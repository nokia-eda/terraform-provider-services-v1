// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_router

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func RouterResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^services\\.eda\\.nokia\\.com/v1$"), ""),
				},
				Default: stringdefault.StaticString("services.eda.nokia.com/v1"),
			},
			"kind": schema.StringAttribute{
				Optional: true,
				Computed: true,
				Validators: []validator.String{
					stringvalidator.RegexMatches(regexp.MustCompile("^Router$"), ""),
				},
				Default: stringdefault.StaticString("Router"),
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Optional:    true,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Required: true,
						Validators: []validator.String{
							stringvalidator.LengthAtMost(253),
							stringvalidator.RegexMatches(regexp.MustCompile("^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"), ""),
						},
					},
					"namespace": schema.StringAttribute{
						Required: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Required: true,
			},
			"name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "name of the Router",
				MarkdownDescription: "name of the Router",
			},
			"namespace": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"bgp": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"autonomous_system": schema.Int64Attribute{
								Optional:            true,
								Description:         "Autonomous System number for BGP.",
								MarkdownDescription: "Autonomous System number for BGP.",
								Validators: []validator.Int64{
									int64validator.Between(1, 4294967295),
								},
							},
							"ebgp_preference": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "Preference to be set for eBGP [default=170].",
								MarkdownDescription: "Preference to be set for eBGP [default=170].",
								Validators: []validator.Int64{
									int64validator.Between(1, 255),
								},
								Default: int64default.StaticInt64(170),
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Enable or disable BGP.",
								MarkdownDescription: "Enable or disable BGP.",
								Default:             booldefault.StaticBool(false),
							},
							"ibgp_preference": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "Preference to be set for iBGP [default=170].",
								MarkdownDescription: "Preference to be set for iBGP [default=170].",
								Validators: []validator.Int64{
									int64validator.Between(1, 255),
								},
								Default: int64default.StaticInt64(170),
							},
							"ip_alias_nexthops": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"esi": schema.StringAttribute{
											Optional:            true,
											Computed:            true,
											Description:         "10 byte Ethernet Segment Identifier, if not set a type 0 ESI is generated.",
											MarkdownDescription: "10 byte Ethernet Segment Identifier, if not set a type 0 ESI is generated.",
											Default:             stringdefault.StaticString("auto"),
										},
										"next_hop": schema.StringAttribute{
											Required:            true,
											Description:         "The nexthop IP address to track for the IP alias.",
											MarkdownDescription: "The nexthop IP address to track for the IP alias.",
										},
										"preferred_active_node": schema.StringAttribute{
											Optional:            true,
											Description:         "When not set the ES is used in an all active mode. This references the ToppNode object and when set, the DF algorithm is configured to type preference and the selected Node is set with a higher preference value. All other Nodes have a lower value configured.",
											MarkdownDescription: "When not set the ES is used in an all active mode. This references the ToppNode object and when set, the DF algorithm is configured to type preference and the selected Node is set with a higher preference value. All other Nodes have a lower value configured.",
										},
									},
									CustomType: IpAliasNexthopsType{
										ObjectType: types.ObjectType{
											AttrTypes: IpAliasNexthopsValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "IP aliasing configuration.",
								MarkdownDescription: "IP aliasing configuration.",
							},
							"ipv4unicast": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"advertise_ipv6next_hops": schema.BoolAttribute{
										Optional:            true,
										Description:         "Enables advertisement of IPv4 Unicast routes with IPv6 next-hops to peers.",
										MarkdownDescription: "Enables advertisement of IPv4 Unicast routes with IPv6 next-hops to peers.",
									},
									"enabled": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Enables the IPv4 unicast AFISAFI.",
										MarkdownDescription: "Enables the IPv4 unicast AFISAFI.",
										Default:             booldefault.StaticBool(false),
									},
									"multipath": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"allow_multiple_as": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "When set to true, BGP is allowed to build a multipath set using BGP routes with different neighbor AS (most recent AS in the AS_PATH), When set to false, BGP is only allowed to use non-best paths for ECMP if they meet the multipath criteria and they have the same neighbor AS as the best path.",
												MarkdownDescription: "When set to true, BGP is allowed to build a multipath set using BGP routes with different neighbor AS (most recent AS in the AS_PATH), When set to false, BGP is only allowed to use non-best paths for ECMP if they meet the multipath criteria and they have the same neighbor AS as the best path.",
												Default:             booldefault.StaticBool(true),
											},
											"max_allowed_paths": schema.Int64Attribute{
												Required:            true,
												Description:         "The maximum number of BGP ECMP next-hops for BGP routes with an NLRI belonging to the address family of this configuration context.",
												MarkdownDescription: "The maximum number of BGP ECMP next-hops for BGP routes with an NLRI belonging to the address family of this configuration context.",
												Validators: []validator.Int64{
													int64validator.Between(1, 256),
												},
											},
										},
										CustomType: MultipathType{
											ObjectType: types.ObjectType{
												AttrTypes: MultipathValue{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Description:         "Enable multipath.",
										MarkdownDescription: "Enable multipath.",
									},
									"receive_ipv6next_hops": schema.BoolAttribute{
										Optional:            true,
										Description:         "Enables the advertisement of the RFC 5549 capability to receive IPv4 routes with IPv6 next-hops.",
										MarkdownDescription: "Enables the advertisement of the RFC 5549 capability to receive IPv4 routes with IPv6 next-hops.",
									},
								},
								CustomType: Ipv4unicastType{
									ObjectType: types.ObjectType{
										AttrTypes: Ipv4unicastValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Parameters relating to the IPv4 unicast AFI/SAFI.",
								MarkdownDescription: "Parameters relating to the IPv4 unicast AFI/SAFI.",
							},
							"ipv6unicast": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"enabled": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Enables the IPv6 unicast AFISAFI",
										MarkdownDescription: "Enables the IPv6 unicast AFISAFI",
										Default:             booldefault.StaticBool(false),
									},
									"multipath_1": schema.SingleNestedAttribute{
										Attributes: map[string]schema.Attribute{
											"allow_multiple_as": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "When set to true, BGP is allowed to build a multipath set using BGP routes with different neighbor AS (most recent AS in the AS_PATH), When set to false, BGP is only allowed to use non-best paths for ECMP if they meet the multipath criteria and they have the same neighbor AS as the best path.",
												MarkdownDescription: "When set to true, BGP is allowed to build a multipath set using BGP routes with different neighbor AS (most recent AS in the AS_PATH), When set to false, BGP is only allowed to use non-best paths for ECMP if they meet the multipath criteria and they have the same neighbor AS as the best path.",
												Default:             booldefault.StaticBool(true),
											},
											"max_allowed_paths": schema.Int64Attribute{
												Required:            true,
												Description:         "The maximum number of BGP ECMP next-hops for BGP routes with an NLRI belonging to the address family of this configuration context.",
												MarkdownDescription: "The maximum number of BGP ECMP next-hops for BGP routes with an NLRI belonging to the address family of this configuration context.",
												Validators: []validator.Int64{
													int64validator.Between(1, 256),
												},
											},
										},
										CustomType: Multipath1Type{
											ObjectType: types.ObjectType{
												AttrTypes: Multipath1Value{}.AttributeTypes(ctx),
											},
										},
										Optional:            true,
										Description:         "Enable multipath",
										MarkdownDescription: "Enable multipath",
									},
								},
								CustomType: Ipv6unicastType{
									ObjectType: types.ObjectType{
										AttrTypes: Ipv6unicastValue{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Parameters relating to the IPv6 unicast AFI/SAFI.",
								MarkdownDescription: "Parameters relating to the IPv6 unicast AFI/SAFI.",
							},
							"keychain": schema.StringAttribute{
								Optional:            true,
								Description:         "Keychain to be used for authentication",
								MarkdownDescription: "Keychain to be used for authentication",
							},
							"min_wait_to_advertise": schema.Int64Attribute{
								Optional:            true,
								Computed:            true,
								Description:         "Minimum wait time before advertising routes post BGP restart.",
								MarkdownDescription: "Minimum wait time before advertising routes post BGP restart.",
								Validators: []validator.Int64{
									int64validator.Between(0, 3600),
								},
								Default: int64default.StaticInt64(0),
							},
							"rapid_withdrawl": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Enable rapid withdrawal in BGP.",
								MarkdownDescription: "Enable rapid withdrawal in BGP.",
								Default:             booldefault.StaticBool(true),
							},
							"wait_for_fibinstall": schema.BoolAttribute{
								Optional:            true,
								Computed:            true,
								Description:         "Wait for FIB installation before advertising routes.",
								MarkdownDescription: "Wait for FIB installation before advertising routes.",
								Default:             booldefault.StaticBool(false),
							},
						},
						CustomType: BgpType{
							ObjectType: types.ObjectType{
								AttrTypes: BgpValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "BGP configuration.",
						MarkdownDescription: "BGP configuration.",
					},
					"description": schema.StringAttribute{
						Optional:            true,
						Description:         "The description of the Router.",
						MarkdownDescription: "The description of the Router.",
					},
					"evi": schema.Int64Attribute{
						Optional:            true,
						Description:         "EVI for the Router; leave blank for auto-allocation from EVI pool.",
						MarkdownDescription: "EVI for the Router; leave blank for auto-allocation from EVI pool.",
						Validators: []validator.Int64{
							int64validator.Between(1, 65535),
						},
					},
					"evi_pool": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Reference to EVI pool for auto-allocation.",
						MarkdownDescription: "Reference to EVI pool for auto-allocation.",
						Default:             stringdefault.StaticString("evi-pool"),
					},
					"export_target": schema.StringAttribute{
						Optional:            true,
						Description:         "Export route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
						MarkdownDescription: "Export route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile("^target.*$"), ""),
						},
					},
					"import_target": schema.StringAttribute{
						Optional:            true,
						Description:         "Import route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
						MarkdownDescription: "Import route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
						Validators: []validator.String{
							stringvalidator.RegexMatches(regexp.MustCompile("^target.*$"), ""),
						},
					},
					"ip_load_balancing": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"prefix": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"hash_buckets_per_path": schema.Int64Attribute{
											Optional:            true,
											Computed:            true,
											Description:         "The number of times each next-hop is repeated in the fill pattern if there are max-paths ECMP next-hops.",
											MarkdownDescription: "The number of times each next-hop is repeated in the fill pattern if there are max-paths ECMP next-hops.",
											Validators: []validator.Int64{
												int64validator.Between(1, 32),
											},
											Default: int64default.StaticInt64(1),
										},
										"max_ecmp": schema.Int64Attribute{
											Optional:            true,
											Computed:            true,
											Description:         "The maximum number of ECMP next-hops per route associated with the resilient-hash prefix.",
											MarkdownDescription: "The maximum number of ECMP next-hops per route associated with the resilient-hash prefix.",
											Validators: []validator.Int64{
												int64validator.Between(1, 64),
											},
											Default: int64default.StaticInt64(1),
										},
										"prefix": schema.StringAttribute{
											Required:            true,
											Description:         "IPv4 or IPv6 prefix. Active routes in the FIB that exactly match this prefix or that are longer matches of this prefix are provided with resilient-hash programming.",
											MarkdownDescription: "IPv4 or IPv6 prefix. Active routes in the FIB that exactly match this prefix or that are longer matches of this prefix are provided with resilient-hash programming.",
										},
									},
									CustomType: PrefixType{
										ObjectType: types.ObjectType{
											AttrTypes: PrefixValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "IPv4 or IPv6 prefix. Active routes in the FIB that exactly match this prefix or that are longer matches of this prefix are provided with resilient-hash programming.",
								MarkdownDescription: "IPv4 or IPv6 prefix. Active routes in the FIB that exactly match this prefix or that are longer matches of this prefix are provided with resilient-hash programming.",
							},
						},
						CustomType: IpLoadBalancingType{
							ObjectType: types.ObjectType{
								AttrTypes: IpLoadBalancingValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "IPv4 or IPv6 prefix. Active routes in the FIB that exactly match this prefix or that are longer matches of this prefix are provided with resilient-hash programming.",
						MarkdownDescription: "IPv4 or IPv6 prefix. Active routes in the FIB that exactly match this prefix or that are longer matches of this prefix are provided with resilient-hash programming.",
					},
					"node_selector": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Description:         "Node selectors for deployment constraints.  If Nodes are selected, the Router will only be deployed on the Nodes selected, if left blank it will be deployed on all Nodes for which there are IRB or RoutedInterfaces referencing this Router.",
						MarkdownDescription: "Node selectors for deployment constraints.  If Nodes are selected, the Router will only be deployed on the Nodes selected, if left blank it will be deployed on all Nodes for which there are IRB or RoutedInterfaces referencing this Router.",
					},
					"route_leaking": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"export_policy": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
								MarkdownDescription: "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
							},
							"import_policy": schema.StringAttribute{
								Optional:            true,
								Description:         "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
								MarkdownDescription: "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
							},
						},
						CustomType: RouteLeakingType{
							ObjectType: types.ObjectType{
								AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Route leaking controlled by routing policies in and out of the DefaultRouter.",
						MarkdownDescription: "Route leaking controlled by routing policies in and out of the DefaultRouter.",
					},
					"router_id": schema.StringAttribute{
						Optional:            true,
						Description:         "Router ID.",
						MarkdownDescription: "Router ID.",
					},
					"tunnel_index_pool": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Reference to tunnel index allocation pool.",
						MarkdownDescription: "Reference to tunnel index allocation pool.",
						Default:             stringdefault.StaticString("tunnel-index-pool"),
					},
					"type": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Select the type of Router.  Simple doesn't include any overlay control plane or dataplane properties (EVPN/VXLAN). EVPNVXLAN includes the properties needed to provision this Router over an IP Fabric.",
						MarkdownDescription: "Select the type of Router.  Simple doesn't include any overlay control plane or dataplane properties (EVPN/VXLAN). EVPNVXLAN includes the properties needed to provision this Router over an IP Fabric.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"SIMPLE",
								"EVPNVXLAN",
							),
						},
						Default: stringdefault.StaticString("EVPNVXLAN"),
					},
					"vni": schema.Int64Attribute{
						Optional:            true,
						Description:         "VNI for the Router; leave blank for auto-allocation from VNI pool.",
						MarkdownDescription: "VNI for the Router; leave blank for auto-allocation from VNI pool.",
						Validators: []validator.Int64{
							int64validator.Between(1, 16777215),
						},
					},
					"vni_pool": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Reference to VNI pool for auto-allocation.",
						MarkdownDescription: "Reference to VNI pool for auto-allocation.",
						Default:             stringdefault.StaticString("vni-pool"),
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Required:            true,
				Description:         "The Router enables the configuration and management of routing functions within a network. This resource allows for setting a unique Router ID, configuring VNIs and EVIs with options for automatic allocation, and defining import and export route targets. It also includes advanced configuration options such as BGP settings, including autonomous system numbers, AFI/SAFI options, and route advertisement preferences. Node selectors can be used to constrain the deployment of the router to specific nodes within the network.",
				MarkdownDescription: "The Router enables the configuration and management of routing functions within a network. This resource allows for setting a unique Router ID, configuring VNIs and EVIs with options for automatic allocation, and defining import and export route targets. It also includes advanced configuration options such as BGP settings, including autonomous system numbers, AFI/SAFI options, and route advertisement preferences. Node selectors can be used to constrain the deployment of the router to specific nodes within the network.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"bgp_peers": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "List of BGPPeers attached to the router.",
						MarkdownDescription: "List of BGPPeers attached to the router.",
					},
					"evi": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "EVI in use for this Router.",
						MarkdownDescription: "EVI in use for this Router.",
					},
					"export_target": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Export route target for this Router.",
						MarkdownDescription: "Export route target for this Router.",
					},
					"health": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Indicates the health score of the Router.",
						MarkdownDescription: "Indicates the health score of the Router.",
					},
					"health_score_reason": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Explains the reason for the health score.",
						MarkdownDescription: "Explains the reason for the health score.",
					},
					"import_target": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Import route target for this Router.",
						MarkdownDescription: "Import route target for this Router.",
					},
					"irb_interfaces": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "List of IRBInterfaces attached to the router.",
						MarkdownDescription: "List of IRBInterfaces attached to the router.",
					},
					"last_change": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Timestamp of the last state change.",
						MarkdownDescription: "Timestamp of the last state change.",
					},
					"nodes": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "List of nodes on which the Router is deployed.",
						MarkdownDescription: "List of nodes on which the Router is deployed.",
					},
					"num_nodes": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Number of nodes on which the Router is configured.",
						MarkdownDescription: "Number of nodes on which the Router is configured.",
					},
					"operational_state": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Operational state of the Router.",
						MarkdownDescription: "Operational state of the Router.",
					},
					"routed_interfaces": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "List of RoutedInterfaces attached to the router.",
						MarkdownDescription: "List of RoutedInterfaces attached to the router.",
					},
					"tunnel_index": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Vxlan tunnel index in use.",
						MarkdownDescription: "Vxlan tunnel index in use.",
					},
					"vni": schema.Int64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "VNI in use for this Router.",
						MarkdownDescription: "VNI in use for this Router.",
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "RouterStatus defines the observed state of Router",
				MarkdownDescription: "RouterStatus defines the observed state of Router",
			},
		},
	}
}

type RouterModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bgpAttribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp is missing from object`)

		return nil, diags
	}

	bgpVal, ok := bgpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp expected to be basetypes.ObjectValue, was: %T`, bgpAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	eviAttribute, ok := attributes["evi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi is missing from object`)

		return nil, diags
	}

	eviVal, ok := eviAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi expected to be basetypes.Int64Value, was: %T`, eviAttribute))
	}

	eviPoolAttribute, ok := attributes["evi_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi_pool is missing from object`)

		return nil, diags
	}

	eviPoolVal, ok := eviPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi_pool expected to be basetypes.StringValue, was: %T`, eviPoolAttribute))
	}

	exportTargetAttribute, ok := attributes["export_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_target is missing from object`)

		return nil, diags
	}

	exportTargetVal, ok := exportTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_target expected to be basetypes.StringValue, was: %T`, exportTargetAttribute))
	}

	importTargetAttribute, ok := attributes["import_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_target is missing from object`)

		return nil, diags
	}

	importTargetVal, ok := importTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_target expected to be basetypes.StringValue, was: %T`, importTargetAttribute))
	}

	ipLoadBalancingAttribute, ok := attributes["ip_load_balancing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_load_balancing is missing from object`)

		return nil, diags
	}

	ipLoadBalancingVal, ok := ipLoadBalancingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_load_balancing expected to be basetypes.ObjectValue, was: %T`, ipLoadBalancingAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return nil, diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.ListValue, was: %T`, nodeSelectorAttribute))
	}

	routeLeakingAttribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking is missing from object`)

		return nil, diags
	}

	routeLeakingVal, ok := routeLeakingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking expected to be basetypes.ObjectValue, was: %T`, routeLeakingAttribute))
	}

	routerIdAttribute, ok := attributes["router_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_id is missing from object`)

		return nil, diags
	}

	routerIdVal, ok := routerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_id expected to be basetypes.StringValue, was: %T`, routerIdAttribute))
	}

	tunnelIndexPoolAttribute, ok := attributes["tunnel_index_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_index_pool is missing from object`)

		return nil, diags
	}

	tunnelIndexPoolVal, ok := tunnelIndexPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_index_pool expected to be basetypes.StringValue, was: %T`, tunnelIndexPoolAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vniAttribute, ok := attributes["vni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni is missing from object`)

		return nil, diags
	}

	vniVal, ok := vniAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni expected to be basetypes.Int64Value, was: %T`, vniAttribute))
	}

	vniPoolAttribute, ok := attributes["vni_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni_pool is missing from object`)

		return nil, diags
	}

	vniPoolVal, ok := vniPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni_pool expected to be basetypes.StringValue, was: %T`, vniPoolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Bgp:             bgpVal,
		Description:     descriptionVal,
		Evi:             eviVal,
		EviPool:         eviPoolVal,
		ExportTarget:    exportTargetVal,
		ImportTarget:    importTargetVal,
		IpLoadBalancing: ipLoadBalancingVal,
		NodeSelector:    nodeSelectorVal,
		RouteLeaking:    routeLeakingVal,
		RouterId:        routerIdVal,
		TunnelIndexPool: tunnelIndexPoolVal,
		SpecType:        typeVal,
		Vni:             vniVal,
		VniPool:         vniPoolVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	bgpAttribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	bgpVal, ok := bgpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp expected to be basetypes.ObjectValue, was: %T`, bgpAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	eviAttribute, ok := attributes["evi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	eviVal, ok := eviAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi expected to be basetypes.Int64Value, was: %T`, eviAttribute))
	}

	eviPoolAttribute, ok := attributes["evi_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi_pool is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	eviPoolVal, ok := eviPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi_pool expected to be basetypes.StringValue, was: %T`, eviPoolAttribute))
	}

	exportTargetAttribute, ok := attributes["export_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_target is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	exportTargetVal, ok := exportTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_target expected to be basetypes.StringValue, was: %T`, exportTargetAttribute))
	}

	importTargetAttribute, ok := attributes["import_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_target is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	importTargetVal, ok := importTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_target expected to be basetypes.StringValue, was: %T`, importTargetAttribute))
	}

	ipLoadBalancingAttribute, ok := attributes["ip_load_balancing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_load_balancing is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipLoadBalancingVal, ok := ipLoadBalancingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_load_balancing expected to be basetypes.ObjectValue, was: %T`, ipLoadBalancingAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.ListValue, was: %T`, nodeSelectorAttribute))
	}

	routeLeakingAttribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	routeLeakingVal, ok := routeLeakingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking expected to be basetypes.ObjectValue, was: %T`, routeLeakingAttribute))
	}

	routerIdAttribute, ok := attributes["router_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_id is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	routerIdVal, ok := routerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_id expected to be basetypes.StringValue, was: %T`, routerIdAttribute))
	}

	tunnelIndexPoolAttribute, ok := attributes["tunnel_index_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_index_pool is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	tunnelIndexPoolVal, ok := tunnelIndexPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_index_pool expected to be basetypes.StringValue, was: %T`, tunnelIndexPoolAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vniAttribute, ok := attributes["vni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	vniVal, ok := vniAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni expected to be basetypes.Int64Value, was: %T`, vniAttribute))
	}

	vniPoolAttribute, ok := attributes["vni_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni_pool is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	vniPoolVal, ok := vniPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni_pool expected to be basetypes.StringValue, was: %T`, vniPoolAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Bgp:             bgpVal,
		Description:     descriptionVal,
		Evi:             eviVal,
		EviPool:         eviPoolVal,
		ExportTarget:    exportTargetVal,
		ImportTarget:    importTargetVal,
		IpLoadBalancing: ipLoadBalancingVal,
		NodeSelector:    nodeSelectorVal,
		RouteLeaking:    routeLeakingVal,
		RouterId:        routerIdVal,
		TunnelIndexPool: tunnelIndexPoolVal,
		SpecType:        typeVal,
		Vni:             vniVal,
		VniPool:         vniPoolVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Bgp             basetypes.ObjectValue `tfsdk:"bgp"`
	Description     basetypes.StringValue `tfsdk:"description"`
	Evi             basetypes.Int64Value  `tfsdk:"evi"`
	EviPool         basetypes.StringValue `tfsdk:"evi_pool"`
	ExportTarget    basetypes.StringValue `tfsdk:"export_target"`
	ImportTarget    basetypes.StringValue `tfsdk:"import_target"`
	IpLoadBalancing basetypes.ObjectValue `tfsdk:"ip_load_balancing"`
	NodeSelector    basetypes.ListValue   `tfsdk:"node_selector"`
	RouteLeaking    basetypes.ObjectValue `tfsdk:"route_leaking"`
	RouterId        basetypes.StringValue `tfsdk:"router_id"`
	TunnelIndexPool basetypes.StringValue `tfsdk:"tunnel_index_pool"`
	SpecType        basetypes.StringValue `tfsdk:"type"`
	Vni             basetypes.Int64Value  `tfsdk:"vni"`
	VniPool         basetypes.StringValue `tfsdk:"vni_pool"`
	state           attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["bgp"] = basetypes.ObjectType{
		AttrTypes: BgpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["evi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["evi_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["export_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_load_balancing"] = basetypes.ObjectType{
		AttrTypes: IpLoadBalancingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["node_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["route_leaking"] = basetypes.ObjectType{
		AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["router_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tunnel_index_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vni"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vni_pool"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.Bgp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Evi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evi"] = val

		val, err = v.EviPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evi_pool"] = val

		val, err = v.ExportTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_target"] = val

		val, err = v.ImportTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_target"] = val

		val, err = v.IpLoadBalancing.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_load_balancing"] = val

		val, err = v.NodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selector"] = val

		val, err = v.RouteLeaking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_leaking"] = val

		val, err = v.RouterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router_id"] = val

		val, err = v.TunnelIndexPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tunnel_index_pool"] = val

		val, err = v.SpecType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Vni.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vni"] = val

		val, err = v.VniPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vni_pool"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bgp basetypes.ObjectValue

	if v.Bgp.IsNull() {
		bgp = types.ObjectNull(
			BgpValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bgp.IsUnknown() {
		bgp = types.ObjectUnknown(
			BgpValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bgp.IsNull() && !v.Bgp.IsUnknown() {
		bgp = types.ObjectValueMust(
			BgpValue{}.AttributeTypes(ctx),
			v.Bgp.Attributes(),
		)
	}

	var ipLoadBalancing basetypes.ObjectValue

	if v.IpLoadBalancing.IsNull() {
		ipLoadBalancing = types.ObjectNull(
			IpLoadBalancingValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpLoadBalancing.IsUnknown() {
		ipLoadBalancing = types.ObjectUnknown(
			IpLoadBalancingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpLoadBalancing.IsNull() && !v.IpLoadBalancing.IsUnknown() {
		ipLoadBalancing = types.ObjectValueMust(
			IpLoadBalancingValue{}.AttributeTypes(ctx),
			v.IpLoadBalancing.Attributes(),
		)
	}

	var routeLeaking basetypes.ObjectValue

	if v.RouteLeaking.IsNull() {
		routeLeaking = types.ObjectNull(
			RouteLeakingValue{}.AttributeTypes(ctx),
		)
	}

	if v.RouteLeaking.IsUnknown() {
		routeLeaking = types.ObjectUnknown(
			RouteLeakingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RouteLeaking.IsNull() && !v.RouteLeaking.IsUnknown() {
		routeLeaking = types.ObjectValueMust(
			RouteLeakingValue{}.AttributeTypes(ctx),
			v.RouteLeaking.Attributes(),
		)
	}

	var nodeSelectorVal basetypes.ListValue
	switch {
	case v.NodeSelector.IsUnknown():
		nodeSelectorVal = types.ListUnknown(types.StringType)
	case v.NodeSelector.IsNull():
		nodeSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeSelectorVal, d = types.ListValue(types.StringType, v.NodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bgp": basetypes.ObjectType{
				AttrTypes: BgpValue{}.AttributeTypes(ctx),
			},
			"description":   basetypes.StringType{},
			"evi":           basetypes.Int64Type{},
			"evi_pool":      basetypes.StringType{},
			"export_target": basetypes.StringType{},
			"import_target": basetypes.StringType{},
			"ip_load_balancing": basetypes.ObjectType{
				AttrTypes: IpLoadBalancingValue{}.AttributeTypes(ctx),
			},
			"node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_leaking": basetypes.ObjectType{
				AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
			},
			"router_id":         basetypes.StringType{},
			"tunnel_index_pool": basetypes.StringType{},
			"type":              basetypes.StringType{},
			"vni":               basetypes.Int64Type{},
			"vni_pool":          basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: BgpValue{}.AttributeTypes(ctx),
		},
		"description":   basetypes.StringType{},
		"evi":           basetypes.Int64Type{},
		"evi_pool":      basetypes.StringType{},
		"export_target": basetypes.StringType{},
		"import_target": basetypes.StringType{},
		"ip_load_balancing": basetypes.ObjectType{
			AttrTypes: IpLoadBalancingValue{}.AttributeTypes(ctx),
		},
		"node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
		},
		"router_id":         basetypes.StringType{},
		"tunnel_index_pool": basetypes.StringType{},
		"type":              basetypes.StringType{},
		"vni":               basetypes.Int64Type{},
		"vni_pool":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bgp":               bgp,
			"description":       v.Description,
			"evi":               v.Evi,
			"evi_pool":          v.EviPool,
			"export_target":     v.ExportTarget,
			"import_target":     v.ImportTarget,
			"ip_load_balancing": ipLoadBalancing,
			"node_selector":     nodeSelectorVal,
			"route_leaking":     routeLeaking,
			"router_id":         v.RouterId,
			"tunnel_index_pool": v.TunnelIndexPool,
			"type":              v.SpecType,
			"vni":               v.Vni,
			"vni_pool":          v.VniPool,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bgp.Equal(other.Bgp) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Evi.Equal(other.Evi) {
		return false
	}

	if !v.EviPool.Equal(other.EviPool) {
		return false
	}

	if !v.ExportTarget.Equal(other.ExportTarget) {
		return false
	}

	if !v.ImportTarget.Equal(other.ImportTarget) {
		return false
	}

	if !v.IpLoadBalancing.Equal(other.IpLoadBalancing) {
		return false
	}

	if !v.NodeSelector.Equal(other.NodeSelector) {
		return false
	}

	if !v.RouteLeaking.Equal(other.RouteLeaking) {
		return false
	}

	if !v.RouterId.Equal(other.RouterId) {
		return false
	}

	if !v.TunnelIndexPool.Equal(other.TunnelIndexPool) {
		return false
	}

	if !v.SpecType.Equal(other.SpecType) {
		return false
	}

	if !v.Vni.Equal(other.Vni) {
		return false
	}

	if !v.VniPool.Equal(other.VniPool) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: BgpValue{}.AttributeTypes(ctx),
		},
		"description":   basetypes.StringType{},
		"evi":           basetypes.Int64Type{},
		"evi_pool":      basetypes.StringType{},
		"export_target": basetypes.StringType{},
		"import_target": basetypes.StringType{},
		"ip_load_balancing": basetypes.ObjectType{
			AttrTypes: IpLoadBalancingValue{}.AttributeTypes(ctx),
		},
		"node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
		},
		"router_id":         basetypes.StringType{},
		"tunnel_index_pool": basetypes.StringType{},
		"type":              basetypes.StringType{},
		"vni":               basetypes.Int64Type{},
		"vni_pool":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BgpType{}

type BgpType struct {
	basetypes.ObjectType
}

func (t BgpType) Equal(o attr.Type) bool {
	other, ok := o.(BgpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BgpType) String() string {
	return "BgpType"
}

func (t BgpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return nil, diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	ebgpPreferenceAttribute, ok := attributes["ebgp_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebgp_preference is missing from object`)

		return nil, diags
	}

	ebgpPreferenceVal, ok := ebgpPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebgp_preference expected to be basetypes.Int64Value, was: %T`, ebgpPreferenceAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ibgpPreferenceAttribute, ok := attributes["ibgp_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibgp_preference is missing from object`)

		return nil, diags
	}

	ibgpPreferenceVal, ok := ibgpPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibgp_preference expected to be basetypes.Int64Value, was: %T`, ibgpPreferenceAttribute))
	}

	ipAliasNexthopsAttribute, ok := attributes["ip_alias_nexthops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_alias_nexthops is missing from object`)

		return nil, diags
	}

	ipAliasNexthopsVal, ok := ipAliasNexthopsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_alias_nexthops expected to be basetypes.ListValue, was: %T`, ipAliasNexthopsAttribute))
	}

	ipv4unicastAttribute, ok := attributes["ipv4unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4unicast is missing from object`)

		return nil, diags
	}

	ipv4unicastVal, ok := ipv4unicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4unicast expected to be basetypes.ObjectValue, was: %T`, ipv4unicastAttribute))
	}

	ipv6unicastAttribute, ok := attributes["ipv6unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6unicast is missing from object`)

		return nil, diags
	}

	ipv6unicastVal, ok := ipv6unicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6unicast expected to be basetypes.ObjectValue, was: %T`, ipv6unicastAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return nil, diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	minWaitToAdvertiseAttribute, ok := attributes["min_wait_to_advertise"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_wait_to_advertise is missing from object`)

		return nil, diags
	}

	minWaitToAdvertiseVal, ok := minWaitToAdvertiseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_wait_to_advertise expected to be basetypes.Int64Value, was: %T`, minWaitToAdvertiseAttribute))
	}

	rapidWithdrawlAttribute, ok := attributes["rapid_withdrawl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rapid_withdrawl is missing from object`)

		return nil, diags
	}

	rapidWithdrawlVal, ok := rapidWithdrawlAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rapid_withdrawl expected to be basetypes.BoolValue, was: %T`, rapidWithdrawlAttribute))
	}

	waitForFibinstallAttribute, ok := attributes["wait_for_fibinstall"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wait_for_fibinstall is missing from object`)

		return nil, diags
	}

	waitForFibinstallVal, ok := waitForFibinstallAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wait_for_fibinstall expected to be basetypes.BoolValue, was: %T`, waitForFibinstallAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BgpValue{
		AutonomousSystem:   autonomousSystemVal,
		EbgpPreference:     ebgpPreferenceVal,
		Enabled:            enabledVal,
		IbgpPreference:     ibgpPreferenceVal,
		IpAliasNexthops:    ipAliasNexthopsVal,
		Ipv4unicast:        ipv4unicastVal,
		Ipv6unicast:        ipv6unicastVal,
		Keychain:           keychainVal,
		MinWaitToAdvertise: minWaitToAdvertiseVal,
		RapidWithdrawl:     rapidWithdrawlVal,
		WaitForFibinstall:  waitForFibinstallVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewBgpValueNull() BgpValue {
	return BgpValue{
		state: attr.ValueStateNull,
	}
}

func NewBgpValueUnknown() BgpValue {
	return BgpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBgpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BgpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BgpValue Attribute Value",
				"While creating a BgpValue value, a missing attribute value was detected. "+
					"A BgpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BgpValue Attribute Type",
				"While creating a BgpValue value, an invalid attribute value was detected. "+
					"A BgpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BgpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BgpValue Attribute Value",
				"While creating a BgpValue value, an extra attribute value was detected. "+
					"A BgpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BgpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgpValueUnknown(), diags
	}

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	ebgpPreferenceAttribute, ok := attributes["ebgp_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebgp_preference is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	ebgpPreferenceVal, ok := ebgpPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebgp_preference expected to be basetypes.Int64Value, was: %T`, ebgpPreferenceAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ibgpPreferenceAttribute, ok := attributes["ibgp_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibgp_preference is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	ibgpPreferenceVal, ok := ibgpPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibgp_preference expected to be basetypes.Int64Value, was: %T`, ibgpPreferenceAttribute))
	}

	ipAliasNexthopsAttribute, ok := attributes["ip_alias_nexthops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_alias_nexthops is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	ipAliasNexthopsVal, ok := ipAliasNexthopsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_alias_nexthops expected to be basetypes.ListValue, was: %T`, ipAliasNexthopsAttribute))
	}

	ipv4unicastAttribute, ok := attributes["ipv4unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4unicast is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	ipv4unicastVal, ok := ipv4unicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4unicast expected to be basetypes.ObjectValue, was: %T`, ipv4unicastAttribute))
	}

	ipv6unicastAttribute, ok := attributes["ipv6unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6unicast is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	ipv6unicastVal, ok := ipv6unicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6unicast expected to be basetypes.ObjectValue, was: %T`, ipv6unicastAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	minWaitToAdvertiseAttribute, ok := attributes["min_wait_to_advertise"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_wait_to_advertise is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	minWaitToAdvertiseVal, ok := minWaitToAdvertiseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_wait_to_advertise expected to be basetypes.Int64Value, was: %T`, minWaitToAdvertiseAttribute))
	}

	rapidWithdrawlAttribute, ok := attributes["rapid_withdrawl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rapid_withdrawl is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	rapidWithdrawlVal, ok := rapidWithdrawlAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rapid_withdrawl expected to be basetypes.BoolValue, was: %T`, rapidWithdrawlAttribute))
	}

	waitForFibinstallAttribute, ok := attributes["wait_for_fibinstall"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wait_for_fibinstall is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	waitForFibinstallVal, ok := waitForFibinstallAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wait_for_fibinstall expected to be basetypes.BoolValue, was: %T`, waitForFibinstallAttribute))
	}

	if diags.HasError() {
		return NewBgpValueUnknown(), diags
	}

	return BgpValue{
		AutonomousSystem:   autonomousSystemVal,
		EbgpPreference:     ebgpPreferenceVal,
		Enabled:            enabledVal,
		IbgpPreference:     ibgpPreferenceVal,
		IpAliasNexthops:    ipAliasNexthopsVal,
		Ipv4unicast:        ipv4unicastVal,
		Ipv6unicast:        ipv6unicastVal,
		Keychain:           keychainVal,
		MinWaitToAdvertise: minWaitToAdvertiseVal,
		RapidWithdrawl:     rapidWithdrawlVal,
		WaitForFibinstall:  waitForFibinstallVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewBgpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BgpValue {
	object, diags := NewBgpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BgpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgpValueMust(BgpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BgpType) ValueType(ctx context.Context) attr.Value {
	return BgpValue{}
}

var _ basetypes.ObjectValuable = BgpValue{}

type BgpValue struct {
	AutonomousSystem   basetypes.Int64Value  `tfsdk:"autonomous_system"`
	EbgpPreference     basetypes.Int64Value  `tfsdk:"ebgp_preference"`
	Enabled            basetypes.BoolValue   `tfsdk:"enabled"`
	IbgpPreference     basetypes.Int64Value  `tfsdk:"ibgp_preference"`
	IpAliasNexthops    basetypes.ListValue   `tfsdk:"ip_alias_nexthops"`
	Ipv4unicast        basetypes.ObjectValue `tfsdk:"ipv4unicast"`
	Ipv6unicast        basetypes.ObjectValue `tfsdk:"ipv6unicast"`
	Keychain           basetypes.StringValue `tfsdk:"keychain"`
	MinWaitToAdvertise basetypes.Int64Value  `tfsdk:"min_wait_to_advertise"`
	RapidWithdrawl     basetypes.BoolValue   `tfsdk:"rapid_withdrawl"`
	WaitForFibinstall  basetypes.BoolValue   `tfsdk:"wait_for_fibinstall"`
	state              attr.ValueState
}

func (v BgpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ebgp_preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ibgp_preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ip_alias_nexthops"] = basetypes.ListType{
		ElemType: IpAliasNexthopsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv4unicast"] = basetypes.ObjectType{
		AttrTypes: Ipv4unicastValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6unicast"] = basetypes.ObjectType{
		AttrTypes: Ipv6unicastValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["keychain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["min_wait_to_advertise"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rapid_withdrawl"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["wait_for_fibinstall"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.AutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_system"] = val

		val, err = v.EbgpPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebgp_preference"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.IbgpPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibgp_preference"] = val

		val, err = v.IpAliasNexthops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_alias_nexthops"] = val

		val, err = v.Ipv4unicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4unicast"] = val

		val, err = v.Ipv6unicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6unicast"] = val

		val, err = v.Keychain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keychain"] = val

		val, err = v.MinWaitToAdvertise.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_wait_to_advertise"] = val

		val, err = v.RapidWithdrawl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rapid_withdrawl"] = val

		val, err = v.WaitForFibinstall.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wait_for_fibinstall"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BgpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BgpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BgpValue) String() string {
	return "BgpValue"
}

func (v BgpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	ipAliasNexthops := types.ListValueMust(
		IpAliasNexthopsType{
			basetypes.ObjectType{
				AttrTypes: IpAliasNexthopsValue{}.AttributeTypes(ctx),
			},
		},
		v.IpAliasNexthops.Elements(),
	)

	if v.IpAliasNexthops.IsNull() {
		ipAliasNexthops = types.ListNull(
			IpAliasNexthopsType{
				basetypes.ObjectType{
					AttrTypes: IpAliasNexthopsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IpAliasNexthops.IsUnknown() {
		ipAliasNexthops = types.ListUnknown(
			IpAliasNexthopsType{
				basetypes.ObjectType{
					AttrTypes: IpAliasNexthopsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var ipv4unicast basetypes.ObjectValue

	if v.Ipv4unicast.IsNull() {
		ipv4unicast = types.ObjectNull(
			Ipv4unicastValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv4unicast.IsUnknown() {
		ipv4unicast = types.ObjectUnknown(
			Ipv4unicastValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv4unicast.IsNull() && !v.Ipv4unicast.IsUnknown() {
		ipv4unicast = types.ObjectValueMust(
			Ipv4unicastValue{}.AttributeTypes(ctx),
			v.Ipv4unicast.Attributes(),
		)
	}

	var ipv6unicast basetypes.ObjectValue

	if v.Ipv6unicast.IsNull() {
		ipv6unicast = types.ObjectNull(
			Ipv6unicastValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv6unicast.IsUnknown() {
		ipv6unicast = types.ObjectUnknown(
			Ipv6unicastValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv6unicast.IsNull() && !v.Ipv6unicast.IsUnknown() {
		ipv6unicast = types.ObjectValueMust(
			Ipv6unicastValue{}.AttributeTypes(ctx),
			v.Ipv6unicast.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"ebgp_preference":   basetypes.Int64Type{},
		"enabled":           basetypes.BoolType{},
		"ibgp_preference":   basetypes.Int64Type{},
		"ip_alias_nexthops": basetypes.ListType{
			ElemType: IpAliasNexthopsValue{}.Type(ctx),
		},
		"ipv4unicast": basetypes.ObjectType{
			AttrTypes: Ipv4unicastValue{}.AttributeTypes(ctx),
		},
		"ipv6unicast": basetypes.ObjectType{
			AttrTypes: Ipv6unicastValue{}.AttributeTypes(ctx),
		},
		"keychain":              basetypes.StringType{},
		"min_wait_to_advertise": basetypes.Int64Type{},
		"rapid_withdrawl":       basetypes.BoolType{},
		"wait_for_fibinstall":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_system":     v.AutonomousSystem,
			"ebgp_preference":       v.EbgpPreference,
			"enabled":               v.Enabled,
			"ibgp_preference":       v.IbgpPreference,
			"ip_alias_nexthops":     ipAliasNexthops,
			"ipv4unicast":           ipv4unicast,
			"ipv6unicast":           ipv6unicast,
			"keychain":              v.Keychain,
			"min_wait_to_advertise": v.MinWaitToAdvertise,
			"rapid_withdrawl":       v.RapidWithdrawl,
			"wait_for_fibinstall":   v.WaitForFibinstall,
		})

	return objVal, diags
}

func (v BgpValue) Equal(o attr.Value) bool {
	other, ok := o.(BgpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousSystem.Equal(other.AutonomousSystem) {
		return false
	}

	if !v.EbgpPreference.Equal(other.EbgpPreference) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.IbgpPreference.Equal(other.IbgpPreference) {
		return false
	}

	if !v.IpAliasNexthops.Equal(other.IpAliasNexthops) {
		return false
	}

	if !v.Ipv4unicast.Equal(other.Ipv4unicast) {
		return false
	}

	if !v.Ipv6unicast.Equal(other.Ipv6unicast) {
		return false
	}

	if !v.Keychain.Equal(other.Keychain) {
		return false
	}

	if !v.MinWaitToAdvertise.Equal(other.MinWaitToAdvertise) {
		return false
	}

	if !v.RapidWithdrawl.Equal(other.RapidWithdrawl) {
		return false
	}

	if !v.WaitForFibinstall.Equal(other.WaitForFibinstall) {
		return false
	}

	return true
}

func (v BgpValue) Type(ctx context.Context) attr.Type {
	return BgpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BgpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"ebgp_preference":   basetypes.Int64Type{},
		"enabled":           basetypes.BoolType{},
		"ibgp_preference":   basetypes.Int64Type{},
		"ip_alias_nexthops": basetypes.ListType{
			ElemType: IpAliasNexthopsValue{}.Type(ctx),
		},
		"ipv4unicast": basetypes.ObjectType{
			AttrTypes: Ipv4unicastValue{}.AttributeTypes(ctx),
		},
		"ipv6unicast": basetypes.ObjectType{
			AttrTypes: Ipv6unicastValue{}.AttributeTypes(ctx),
		},
		"keychain":              basetypes.StringType{},
		"min_wait_to_advertise": basetypes.Int64Type{},
		"rapid_withdrawl":       basetypes.BoolType{},
		"wait_for_fibinstall":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = IpAliasNexthopsType{}

type IpAliasNexthopsType struct {
	basetypes.ObjectType
}

func (t IpAliasNexthopsType) Equal(o attr.Type) bool {
	other, ok := o.(IpAliasNexthopsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpAliasNexthopsType) String() string {
	return "IpAliasNexthopsType"
}

func (t IpAliasNexthopsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	esiAttribute, ok := attributes["esi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esi is missing from object`)

		return nil, diags
	}

	esiVal, ok := esiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esi expected to be basetypes.StringValue, was: %T`, esiAttribute))
	}

	nextHopAttribute, ok := attributes["next_hop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_hop is missing from object`)

		return nil, diags
	}

	nextHopVal, ok := nextHopAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_hop expected to be basetypes.StringValue, was: %T`, nextHopAttribute))
	}

	preferredActiveNodeAttribute, ok := attributes["preferred_active_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_active_node is missing from object`)

		return nil, diags
	}

	preferredActiveNodeVal, ok := preferredActiveNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_active_node expected to be basetypes.StringValue, was: %T`, preferredActiveNodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpAliasNexthopsValue{
		Esi:                 esiVal,
		NextHop:             nextHopVal,
		PreferredActiveNode: preferredActiveNodeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewIpAliasNexthopsValueNull() IpAliasNexthopsValue {
	return IpAliasNexthopsValue{
		state: attr.ValueStateNull,
	}
}

func NewIpAliasNexthopsValueUnknown() IpAliasNexthopsValue {
	return IpAliasNexthopsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpAliasNexthopsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpAliasNexthopsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpAliasNexthopsValue Attribute Value",
				"While creating a IpAliasNexthopsValue value, a missing attribute value was detected. "+
					"A IpAliasNexthopsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpAliasNexthopsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpAliasNexthopsValue Attribute Type",
				"While creating a IpAliasNexthopsValue value, an invalid attribute value was detected. "+
					"A IpAliasNexthopsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpAliasNexthopsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpAliasNexthopsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpAliasNexthopsValue Attribute Value",
				"While creating a IpAliasNexthopsValue value, an extra attribute value was detected. "+
					"A IpAliasNexthopsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpAliasNexthopsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpAliasNexthopsValueUnknown(), diags
	}

	esiAttribute, ok := attributes["esi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esi is missing from object`)

		return NewIpAliasNexthopsValueUnknown(), diags
	}

	esiVal, ok := esiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esi expected to be basetypes.StringValue, was: %T`, esiAttribute))
	}

	nextHopAttribute, ok := attributes["next_hop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_hop is missing from object`)

		return NewIpAliasNexthopsValueUnknown(), diags
	}

	nextHopVal, ok := nextHopAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_hop expected to be basetypes.StringValue, was: %T`, nextHopAttribute))
	}

	preferredActiveNodeAttribute, ok := attributes["preferred_active_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_active_node is missing from object`)

		return NewIpAliasNexthopsValueUnknown(), diags
	}

	preferredActiveNodeVal, ok := preferredActiveNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_active_node expected to be basetypes.StringValue, was: %T`, preferredActiveNodeAttribute))
	}

	if diags.HasError() {
		return NewIpAliasNexthopsValueUnknown(), diags
	}

	return IpAliasNexthopsValue{
		Esi:                 esiVal,
		NextHop:             nextHopVal,
		PreferredActiveNode: preferredActiveNodeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewIpAliasNexthopsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpAliasNexthopsValue {
	object, diags := NewIpAliasNexthopsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpAliasNexthopsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpAliasNexthopsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpAliasNexthopsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpAliasNexthopsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpAliasNexthopsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpAliasNexthopsValueMust(IpAliasNexthopsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpAliasNexthopsType) ValueType(ctx context.Context) attr.Value {
	return IpAliasNexthopsValue{}
}

var _ basetypes.ObjectValuable = IpAliasNexthopsValue{}

type IpAliasNexthopsValue struct {
	Esi                 basetypes.StringValue `tfsdk:"esi"`
	NextHop             basetypes.StringValue `tfsdk:"next_hop"`
	PreferredActiveNode basetypes.StringValue `tfsdk:"preferred_active_node"`
	state               attr.ValueState
}

func (v IpAliasNexthopsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["esi"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["next_hop"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["preferred_active_node"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Esi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["esi"] = val

		val, err = v.NextHop.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_hop"] = val

		val, err = v.PreferredActiveNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preferred_active_node"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpAliasNexthopsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpAliasNexthopsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpAliasNexthopsValue) String() string {
	return "IpAliasNexthopsValue"
}

func (v IpAliasNexthopsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"esi":                   basetypes.StringType{},
		"next_hop":              basetypes.StringType{},
		"preferred_active_node": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"esi":                   v.Esi,
			"next_hop":              v.NextHop,
			"preferred_active_node": v.PreferredActiveNode,
		})

	return objVal, diags
}

func (v IpAliasNexthopsValue) Equal(o attr.Value) bool {
	other, ok := o.(IpAliasNexthopsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Esi.Equal(other.Esi) {
		return false
	}

	if !v.NextHop.Equal(other.NextHop) {
		return false
	}

	if !v.PreferredActiveNode.Equal(other.PreferredActiveNode) {
		return false
	}

	return true
}

func (v IpAliasNexthopsValue) Type(ctx context.Context) attr.Type {
	return IpAliasNexthopsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpAliasNexthopsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"esi":                   basetypes.StringType{},
		"next_hop":              basetypes.StringType{},
		"preferred_active_node": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Ipv4unicastType{}

type Ipv4unicastType struct {
	basetypes.ObjectType
}

func (t Ipv4unicastType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4unicastType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4unicastType) String() string {
	return "Ipv4unicastType"
}

func (t Ipv4unicastType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advertiseIpv6nextHopsAttribute, ok := attributes["advertise_ipv6next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6next_hops is missing from object`)

		return nil, diags
	}

	advertiseIpv6nextHopsVal, ok := advertiseIpv6nextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6nextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	multipathAttribute, ok := attributes["multipath"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multipath is missing from object`)

		return nil, diags
	}

	multipathVal, ok := multipathAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multipath expected to be basetypes.ObjectValue, was: %T`, multipathAttribute))
	}

	receiveIpv6nextHopsAttribute, ok := attributes["receive_ipv6next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receive_ipv6next_hops is missing from object`)

		return nil, diags
	}

	receiveIpv6nextHopsVal, ok := receiveIpv6nextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receive_ipv6next_hops expected to be basetypes.BoolValue, was: %T`, receiveIpv6nextHopsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4unicastValue{
		AdvertiseIpv6nextHops: advertiseIpv6nextHopsVal,
		Enabled:               enabledVal,
		Multipath:             multipathVal,
		ReceiveIpv6nextHops:   receiveIpv6nextHopsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIpv4unicastValueNull() Ipv4unicastValue {
	return Ipv4unicastValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv4unicastValueUnknown() Ipv4unicastValue {
	return Ipv4unicastValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4unicastValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4unicastValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4unicastValue Attribute Value",
				"While creating a Ipv4unicastValue value, a missing attribute value was detected. "+
					"A Ipv4unicastValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4unicastValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4unicastValue Attribute Type",
				"While creating a Ipv4unicastValue value, an invalid attribute value was detected. "+
					"A Ipv4unicastValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4unicastValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4unicastValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4unicastValue Attribute Value",
				"While creating a Ipv4unicastValue value, an extra attribute value was detected. "+
					"A Ipv4unicastValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4unicastValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4unicastValueUnknown(), diags
	}

	advertiseIpv6nextHopsAttribute, ok := attributes["advertise_ipv6next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6next_hops is missing from object`)

		return NewIpv4unicastValueUnknown(), diags
	}

	advertiseIpv6nextHopsVal, ok := advertiseIpv6nextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6nextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv4unicastValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	multipathAttribute, ok := attributes["multipath"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multipath is missing from object`)

		return NewIpv4unicastValueUnknown(), diags
	}

	multipathVal, ok := multipathAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multipath expected to be basetypes.ObjectValue, was: %T`, multipathAttribute))
	}

	receiveIpv6nextHopsAttribute, ok := attributes["receive_ipv6next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receive_ipv6next_hops is missing from object`)

		return NewIpv4unicastValueUnknown(), diags
	}

	receiveIpv6nextHopsVal, ok := receiveIpv6nextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receive_ipv6next_hops expected to be basetypes.BoolValue, was: %T`, receiveIpv6nextHopsAttribute))
	}

	if diags.HasError() {
		return NewIpv4unicastValueUnknown(), diags
	}

	return Ipv4unicastValue{
		AdvertiseIpv6nextHops: advertiseIpv6nextHopsVal,
		Enabled:               enabledVal,
		Multipath:             multipathVal,
		ReceiveIpv6nextHops:   receiveIpv6nextHopsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIpv4unicastValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4unicastValue {
	object, diags := NewIpv4unicastValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4unicastValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4unicastType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4unicastValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4unicastValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4unicastValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4unicastValueMust(Ipv4unicastValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4unicastType) ValueType(ctx context.Context) attr.Value {
	return Ipv4unicastValue{}
}

var _ basetypes.ObjectValuable = Ipv4unicastValue{}

type Ipv4unicastValue struct {
	AdvertiseIpv6nextHops basetypes.BoolValue   `tfsdk:"advertise_ipv6next_hops"`
	Enabled               basetypes.BoolValue   `tfsdk:"enabled"`
	Multipath             basetypes.ObjectValue `tfsdk:"multipath"`
	ReceiveIpv6nextHops   basetypes.BoolValue   `tfsdk:"receive_ipv6next_hops"`
	state                 attr.ValueState
}

func (v Ipv4unicastValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["advertise_ipv6next_hops"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["multipath"] = basetypes.ObjectType{
		AttrTypes: MultipathValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["receive_ipv6next_hops"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AdvertiseIpv6nextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advertise_ipv6next_hops"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Multipath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multipath"] = val

		val, err = v.ReceiveIpv6nextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["receive_ipv6next_hops"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4unicastValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4unicastValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4unicastValue) String() string {
	return "Ipv4unicastValue"
}

func (v Ipv4unicastValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var multipath basetypes.ObjectValue

	if v.Multipath.IsNull() {
		multipath = types.ObjectNull(
			MultipathValue{}.AttributeTypes(ctx),
		)
	}

	if v.Multipath.IsUnknown() {
		multipath = types.ObjectUnknown(
			MultipathValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Multipath.IsNull() && !v.Multipath.IsUnknown() {
		multipath = types.ObjectValueMust(
			MultipathValue{}.AttributeTypes(ctx),
			v.Multipath.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"advertise_ipv6next_hops": basetypes.BoolType{},
		"enabled":                 basetypes.BoolType{},
		"multipath": basetypes.ObjectType{
			AttrTypes: MultipathValue{}.AttributeTypes(ctx),
		},
		"receive_ipv6next_hops": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advertise_ipv6next_hops": v.AdvertiseIpv6nextHops,
			"enabled":                 v.Enabled,
			"multipath":               multipath,
			"receive_ipv6next_hops":   v.ReceiveIpv6nextHops,
		})

	return objVal, diags
}

func (v Ipv4unicastValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4unicastValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvertiseIpv6nextHops.Equal(other.AdvertiseIpv6nextHops) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Multipath.Equal(other.Multipath) {
		return false
	}

	if !v.ReceiveIpv6nextHops.Equal(other.ReceiveIpv6nextHops) {
		return false
	}

	return true
}

func (v Ipv4unicastValue) Type(ctx context.Context) attr.Type {
	return Ipv4unicastType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4unicastValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advertise_ipv6next_hops": basetypes.BoolType{},
		"enabled":                 basetypes.BoolType{},
		"multipath": basetypes.ObjectType{
			AttrTypes: MultipathValue{}.AttributeTypes(ctx),
		},
		"receive_ipv6next_hops": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MultipathType{}

type MultipathType struct {
	basetypes.ObjectType
}

func (t MultipathType) Equal(o attr.Type) bool {
	other, ok := o.(MultipathType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MultipathType) String() string {
	return "MultipathType"
}

func (t MultipathType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowMultipleAsAttribute, ok := attributes["allow_multiple_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_as is missing from object`)

		return nil, diags
	}

	allowMultipleAsVal, ok := allowMultipleAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_as expected to be basetypes.BoolValue, was: %T`, allowMultipleAsAttribute))
	}

	maxAllowedPathsAttribute, ok := attributes["max_allowed_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_allowed_paths is missing from object`)

		return nil, diags
	}

	maxAllowedPathsVal, ok := maxAllowedPathsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_allowed_paths expected to be basetypes.Int64Value, was: %T`, maxAllowedPathsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MultipathValue{
		AllowMultipleAs: allowMultipleAsVal,
		MaxAllowedPaths: maxAllowedPathsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewMultipathValueNull() MultipathValue {
	return MultipathValue{
		state: attr.ValueStateNull,
	}
}

func NewMultipathValueUnknown() MultipathValue {
	return MultipathValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMultipathValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MultipathValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MultipathValue Attribute Value",
				"While creating a MultipathValue value, a missing attribute value was detected. "+
					"A MultipathValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MultipathValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MultipathValue Attribute Type",
				"While creating a MultipathValue value, an invalid attribute value was detected. "+
					"A MultipathValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MultipathValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MultipathValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MultipathValue Attribute Value",
				"While creating a MultipathValue value, an extra attribute value was detected. "+
					"A MultipathValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MultipathValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMultipathValueUnknown(), diags
	}

	allowMultipleAsAttribute, ok := attributes["allow_multiple_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_as is missing from object`)

		return NewMultipathValueUnknown(), diags
	}

	allowMultipleAsVal, ok := allowMultipleAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_as expected to be basetypes.BoolValue, was: %T`, allowMultipleAsAttribute))
	}

	maxAllowedPathsAttribute, ok := attributes["max_allowed_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_allowed_paths is missing from object`)

		return NewMultipathValueUnknown(), diags
	}

	maxAllowedPathsVal, ok := maxAllowedPathsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_allowed_paths expected to be basetypes.Int64Value, was: %T`, maxAllowedPathsAttribute))
	}

	if diags.HasError() {
		return NewMultipathValueUnknown(), diags
	}

	return MultipathValue{
		AllowMultipleAs: allowMultipleAsVal,
		MaxAllowedPaths: maxAllowedPathsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewMultipathValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MultipathValue {
	object, diags := NewMultipathValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMultipathValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MultipathType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMultipathValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMultipathValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMultipathValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMultipathValueMust(MultipathValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MultipathType) ValueType(ctx context.Context) attr.Value {
	return MultipathValue{}
}

var _ basetypes.ObjectValuable = MultipathValue{}

type MultipathValue struct {
	AllowMultipleAs basetypes.BoolValue  `tfsdk:"allow_multiple_as"`
	MaxAllowedPaths basetypes.Int64Value `tfsdk:"max_allowed_paths"`
	state           attr.ValueState
}

func (v MultipathValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["allow_multiple_as"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_allowed_paths"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AllowMultipleAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_multiple_as"] = val

		val, err = v.MaxAllowedPaths.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_allowed_paths"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MultipathValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MultipathValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MultipathValue) String() string {
	return "MultipathValue"
}

func (v MultipathValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"allow_multiple_as": basetypes.BoolType{},
		"max_allowed_paths": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_multiple_as": v.AllowMultipleAs,
			"max_allowed_paths": v.MaxAllowedPaths,
		})

	return objVal, diags
}

func (v MultipathValue) Equal(o attr.Value) bool {
	other, ok := o.(MultipathValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowMultipleAs.Equal(other.AllowMultipleAs) {
		return false
	}

	if !v.MaxAllowedPaths.Equal(other.MaxAllowedPaths) {
		return false
	}

	return true
}

func (v MultipathValue) Type(ctx context.Context) attr.Type {
	return MultipathType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MultipathValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_multiple_as": basetypes.BoolType{},
		"max_allowed_paths": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Ipv6unicastType{}

type Ipv6unicastType struct {
	basetypes.ObjectType
}

func (t Ipv6unicastType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6unicastType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6unicastType) String() string {
	return "Ipv6unicastType"
}

func (t Ipv6unicastType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	multipath1Attribute, ok := attributes["multipath_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multipath_1 is missing from object`)

		return nil, diags
	}

	multipath1Val, ok := multipath1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multipath_1 expected to be basetypes.ObjectValue, was: %T`, multipath1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6unicastValue{
		Enabled:    enabledVal,
		Multipath1: multipath1Val,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpv6unicastValueNull() Ipv6unicastValue {
	return Ipv6unicastValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv6unicastValueUnknown() Ipv6unicastValue {
	return Ipv6unicastValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6unicastValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6unicastValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6unicastValue Attribute Value",
				"While creating a Ipv6unicastValue value, a missing attribute value was detected. "+
					"A Ipv6unicastValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6unicastValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6unicastValue Attribute Type",
				"While creating a Ipv6unicastValue value, an invalid attribute value was detected. "+
					"A Ipv6unicastValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6unicastValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6unicastValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6unicastValue Attribute Value",
				"While creating a Ipv6unicastValue value, an extra attribute value was detected. "+
					"A Ipv6unicastValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6unicastValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6unicastValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv6unicastValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	multipath1Attribute, ok := attributes["multipath_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multipath_1 is missing from object`)

		return NewIpv6unicastValueUnknown(), diags
	}

	multipath1Val, ok := multipath1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multipath_1 expected to be basetypes.ObjectValue, was: %T`, multipath1Attribute))
	}

	if diags.HasError() {
		return NewIpv6unicastValueUnknown(), diags
	}

	return Ipv6unicastValue{
		Enabled:    enabledVal,
		Multipath1: multipath1Val,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpv6unicastValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6unicastValue {
	object, diags := NewIpv6unicastValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6unicastValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6unicastType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6unicastValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6unicastValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6unicastValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6unicastValueMust(Ipv6unicastValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6unicastType) ValueType(ctx context.Context) attr.Value {
	return Ipv6unicastValue{}
}

var _ basetypes.ObjectValuable = Ipv6unicastValue{}

type Ipv6unicastValue struct {
	Enabled    basetypes.BoolValue   `tfsdk:"enabled"`
	Multipath1 basetypes.ObjectValue `tfsdk:"multipath_1"`
	state      attr.ValueState
}

func (v Ipv6unicastValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["multipath_1"] = basetypes.ObjectType{
		AttrTypes: Multipath1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Multipath1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multipath_1"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6unicastValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6unicastValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6unicastValue) String() string {
	return "Ipv6unicastValue"
}

func (v Ipv6unicastValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var multipath1 basetypes.ObjectValue

	if v.Multipath1.IsNull() {
		multipath1 = types.ObjectNull(
			Multipath1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Multipath1.IsUnknown() {
		multipath1 = types.ObjectUnknown(
			Multipath1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Multipath1.IsNull() && !v.Multipath1.IsUnknown() {
		multipath1 = types.ObjectValueMust(
			Multipath1Value{}.AttributeTypes(ctx),
			v.Multipath1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"multipath_1": basetypes.ObjectType{
			AttrTypes: Multipath1Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":     v.Enabled,
			"multipath_1": multipath1,
		})

	return objVal, diags
}

func (v Ipv6unicastValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6unicastValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Multipath1.Equal(other.Multipath1) {
		return false
	}

	return true
}

func (v Ipv6unicastValue) Type(ctx context.Context) attr.Type {
	return Ipv6unicastType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6unicastValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"multipath_1": basetypes.ObjectType{
			AttrTypes: Multipath1Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Multipath1Type{}

type Multipath1Type struct {
	basetypes.ObjectType
}

func (t Multipath1Type) Equal(o attr.Type) bool {
	other, ok := o.(Multipath1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Multipath1Type) String() string {
	return "Multipath1Type"
}

func (t Multipath1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowMultipleAsAttribute, ok := attributes["allow_multiple_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_as is missing from object`)

		return nil, diags
	}

	allowMultipleAsVal, ok := allowMultipleAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_as expected to be basetypes.BoolValue, was: %T`, allowMultipleAsAttribute))
	}

	maxAllowedPathsAttribute, ok := attributes["max_allowed_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_allowed_paths is missing from object`)

		return nil, diags
	}

	maxAllowedPathsVal, ok := maxAllowedPathsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_allowed_paths expected to be basetypes.Int64Value, was: %T`, maxAllowedPathsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Multipath1Value{
		AllowMultipleAs: allowMultipleAsVal,
		MaxAllowedPaths: maxAllowedPathsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewMultipath1ValueNull() Multipath1Value {
	return Multipath1Value{
		state: attr.ValueStateNull,
	}
}

func NewMultipath1ValueUnknown() Multipath1Value {
	return Multipath1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewMultipath1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Multipath1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Multipath1Value Attribute Value",
				"While creating a Multipath1Value value, a missing attribute value was detected. "+
					"A Multipath1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Multipath1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Multipath1Value Attribute Type",
				"While creating a Multipath1Value value, an invalid attribute value was detected. "+
					"A Multipath1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Multipath1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Multipath1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Multipath1Value Attribute Value",
				"While creating a Multipath1Value value, an extra attribute value was detected. "+
					"A Multipath1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Multipath1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMultipath1ValueUnknown(), diags
	}

	allowMultipleAsAttribute, ok := attributes["allow_multiple_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_as is missing from object`)

		return NewMultipath1ValueUnknown(), diags
	}

	allowMultipleAsVal, ok := allowMultipleAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_as expected to be basetypes.BoolValue, was: %T`, allowMultipleAsAttribute))
	}

	maxAllowedPathsAttribute, ok := attributes["max_allowed_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_allowed_paths is missing from object`)

		return NewMultipath1ValueUnknown(), diags
	}

	maxAllowedPathsVal, ok := maxAllowedPathsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_allowed_paths expected to be basetypes.Int64Value, was: %T`, maxAllowedPathsAttribute))
	}

	if diags.HasError() {
		return NewMultipath1ValueUnknown(), diags
	}

	return Multipath1Value{
		AllowMultipleAs: allowMultipleAsVal,
		MaxAllowedPaths: maxAllowedPathsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewMultipath1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Multipath1Value {
	object, diags := NewMultipath1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMultipath1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Multipath1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMultipath1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMultipath1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMultipath1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMultipath1ValueMust(Multipath1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Multipath1Type) ValueType(ctx context.Context) attr.Value {
	return Multipath1Value{}
}

var _ basetypes.ObjectValuable = Multipath1Value{}

type Multipath1Value struct {
	AllowMultipleAs basetypes.BoolValue  `tfsdk:"allow_multiple_as"`
	MaxAllowedPaths basetypes.Int64Value `tfsdk:"max_allowed_paths"`
	state           attr.ValueState
}

func (v Multipath1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["allow_multiple_as"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_allowed_paths"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AllowMultipleAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_multiple_as"] = val

		val, err = v.MaxAllowedPaths.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_allowed_paths"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Multipath1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Multipath1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Multipath1Value) String() string {
	return "Multipath1Value"
}

func (v Multipath1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"allow_multiple_as": basetypes.BoolType{},
		"max_allowed_paths": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_multiple_as": v.AllowMultipleAs,
			"max_allowed_paths": v.MaxAllowedPaths,
		})

	return objVal, diags
}

func (v Multipath1Value) Equal(o attr.Value) bool {
	other, ok := o.(Multipath1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowMultipleAs.Equal(other.AllowMultipleAs) {
		return false
	}

	if !v.MaxAllowedPaths.Equal(other.MaxAllowedPaths) {
		return false
	}

	return true
}

func (v Multipath1Value) Type(ctx context.Context) attr.Type {
	return Multipath1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Multipath1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_multiple_as": basetypes.BoolType{},
		"max_allowed_paths": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = IpLoadBalancingType{}

type IpLoadBalancingType struct {
	basetypes.ObjectType
}

func (t IpLoadBalancingType) Equal(o attr.Type) bool {
	other, ok := o.(IpLoadBalancingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpLoadBalancingType) String() string {
	return "IpLoadBalancingType"
}

func (t IpLoadBalancingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.ListValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpLoadBalancingValue{
		Prefix: prefixVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewIpLoadBalancingValueNull() IpLoadBalancingValue {
	return IpLoadBalancingValue{
		state: attr.ValueStateNull,
	}
}

func NewIpLoadBalancingValueUnknown() IpLoadBalancingValue {
	return IpLoadBalancingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpLoadBalancingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpLoadBalancingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpLoadBalancingValue Attribute Value",
				"While creating a IpLoadBalancingValue value, a missing attribute value was detected. "+
					"A IpLoadBalancingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpLoadBalancingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpLoadBalancingValue Attribute Type",
				"While creating a IpLoadBalancingValue value, an invalid attribute value was detected. "+
					"A IpLoadBalancingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpLoadBalancingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpLoadBalancingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpLoadBalancingValue Attribute Value",
				"While creating a IpLoadBalancingValue value, an extra attribute value was detected. "+
					"A IpLoadBalancingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpLoadBalancingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpLoadBalancingValueUnknown(), diags
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewIpLoadBalancingValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.ListValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return NewIpLoadBalancingValueUnknown(), diags
	}

	return IpLoadBalancingValue{
		Prefix: prefixVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewIpLoadBalancingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpLoadBalancingValue {
	object, diags := NewIpLoadBalancingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpLoadBalancingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpLoadBalancingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpLoadBalancingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpLoadBalancingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpLoadBalancingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpLoadBalancingValueMust(IpLoadBalancingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpLoadBalancingType) ValueType(ctx context.Context) attr.Value {
	return IpLoadBalancingValue{}
}

var _ basetypes.ObjectValuable = IpLoadBalancingValue{}

type IpLoadBalancingValue struct {
	Prefix basetypes.ListValue `tfsdk:"prefix"`
	state  attr.ValueState
}

func (v IpLoadBalancingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["prefix"] = basetypes.ListType{
		ElemType: PrefixValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpLoadBalancingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpLoadBalancingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpLoadBalancingValue) String() string {
	return "IpLoadBalancingValue"
}

func (v IpLoadBalancingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	prefix := types.ListValueMust(
		PrefixType{
			basetypes.ObjectType{
				AttrTypes: PrefixValue{}.AttributeTypes(ctx),
			},
		},
		v.Prefix.Elements(),
	)

	if v.Prefix.IsNull() {
		prefix = types.ListNull(
			PrefixType{
				basetypes.ObjectType{
					AttrTypes: PrefixValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Prefix.IsUnknown() {
		prefix = types.ListUnknown(
			PrefixType{
				basetypes.ObjectType{
					AttrTypes: PrefixValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"prefix": basetypes.ListType{
			ElemType: PrefixValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"prefix": prefix,
		})

	return objVal, diags
}

func (v IpLoadBalancingValue) Equal(o attr.Value) bool {
	other, ok := o.(IpLoadBalancingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	return true
}

func (v IpLoadBalancingValue) Type(ctx context.Context) attr.Type {
	return IpLoadBalancingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpLoadBalancingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"prefix": basetypes.ListType{
			ElemType: PrefixValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixType{}

type PrefixType struct {
	basetypes.ObjectType
}

func (t PrefixType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixType) String() string {
	return "PrefixType"
}

func (t PrefixType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hashBucketsPerPathAttribute, ok := attributes["hash_buckets_per_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hash_buckets_per_path is missing from object`)

		return nil, diags
	}

	hashBucketsPerPathVal, ok := hashBucketsPerPathAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hash_buckets_per_path expected to be basetypes.Int64Value, was: %T`, hashBucketsPerPathAttribute))
	}

	maxEcmpAttribute, ok := attributes["max_ecmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_ecmp is missing from object`)

		return nil, diags
	}

	maxEcmpVal, ok := maxEcmpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_ecmp expected to be basetypes.Int64Value, was: %T`, maxEcmpAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixValue{
		HashBucketsPerPath: hashBucketsPerPathVal,
		MaxEcmp:            maxEcmpVal,
		Prefix:             prefixVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPrefixValueNull() PrefixValue {
	return PrefixValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixValueUnknown() PrefixValue {
	return PrefixValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixValue Attribute Value",
				"While creating a PrefixValue value, a missing attribute value was detected. "+
					"A PrefixValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixValue Attribute Type",
				"While creating a PrefixValue value, an invalid attribute value was detected. "+
					"A PrefixValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixValue Attribute Value",
				"While creating a PrefixValue value, an extra attribute value was detected. "+
					"A PrefixValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixValueUnknown(), diags
	}

	hashBucketsPerPathAttribute, ok := attributes["hash_buckets_per_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hash_buckets_per_path is missing from object`)

		return NewPrefixValueUnknown(), diags
	}

	hashBucketsPerPathVal, ok := hashBucketsPerPathAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hash_buckets_per_path expected to be basetypes.Int64Value, was: %T`, hashBucketsPerPathAttribute))
	}

	maxEcmpAttribute, ok := attributes["max_ecmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_ecmp is missing from object`)

		return NewPrefixValueUnknown(), diags
	}

	maxEcmpVal, ok := maxEcmpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_ecmp expected to be basetypes.Int64Value, was: %T`, maxEcmpAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewPrefixValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return NewPrefixValueUnknown(), diags
	}

	return PrefixValue{
		HashBucketsPerPath: hashBucketsPerPathVal,
		MaxEcmp:            maxEcmpVal,
		Prefix:             prefixVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPrefixValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixValue {
	object, diags := NewPrefixValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixValueMust(PrefixValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixType) ValueType(ctx context.Context) attr.Value {
	return PrefixValue{}
}

var _ basetypes.ObjectValuable = PrefixValue{}

type PrefixValue struct {
	HashBucketsPerPath basetypes.Int64Value  `tfsdk:"hash_buckets_per_path"`
	MaxEcmp            basetypes.Int64Value  `tfsdk:"max_ecmp"`
	Prefix             basetypes.StringValue `tfsdk:"prefix"`
	state              attr.ValueState
}

func (v PrefixValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["hash_buckets_per_path"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_ecmp"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.HashBucketsPerPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hash_buckets_per_path"] = val

		val, err = v.MaxEcmp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_ecmp"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixValue) String() string {
	return "PrefixValue"
}

func (v PrefixValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"hash_buckets_per_path": basetypes.Int64Type{},
		"max_ecmp":              basetypes.Int64Type{},
		"prefix":                basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"hash_buckets_per_path": v.HashBucketsPerPath,
			"max_ecmp":              v.MaxEcmp,
			"prefix":                v.Prefix,
		})

	return objVal, diags
}

func (v PrefixValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.HashBucketsPerPath.Equal(other.HashBucketsPerPath) {
		return false
	}

	if !v.MaxEcmp.Equal(other.MaxEcmp) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	return true
}

func (v PrefixValue) Type(ctx context.Context) attr.Type {
	return PrefixType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"hash_buckets_per_path": basetypes.Int64Type{},
		"max_ecmp":              basetypes.Int64Type{},
		"prefix":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RouteLeakingType{}

type RouteLeakingType struct {
	basetypes.ObjectType
}

func (t RouteLeakingType) Equal(o attr.Type) bool {
	other, ok := o.(RouteLeakingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RouteLeakingType) String() string {
	return "RouteLeakingType"
}

func (t RouteLeakingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RouteLeakingValue{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeakingValueNull() RouteLeakingValue {
	return RouteLeakingValue{
		state: attr.ValueStateNull,
	}
}

func NewRouteLeakingValueUnknown() RouteLeakingValue {
	return RouteLeakingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRouteLeakingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RouteLeakingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RouteLeakingValue Attribute Value",
				"While creating a RouteLeakingValue value, a missing attribute value was detected. "+
					"A RouteLeakingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeakingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RouteLeakingValue Attribute Type",
				"While creating a RouteLeakingValue value, an invalid attribute value was detected. "+
					"A RouteLeakingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeakingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RouteLeakingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RouteLeakingValue Attribute Value",
				"While creating a RouteLeakingValue value, an extra attribute value was detected. "+
					"A RouteLeakingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RouteLeakingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRouteLeakingValueUnknown(), diags
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewRouteLeakingValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewRouteLeakingValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return NewRouteLeakingValueUnknown(), diags
	}

	return RouteLeakingValue{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeakingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RouteLeakingValue {
	object, diags := NewRouteLeakingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRouteLeakingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RouteLeakingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRouteLeakingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRouteLeakingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRouteLeakingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRouteLeakingValueMust(RouteLeakingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RouteLeakingType) ValueType(ctx context.Context) attr.Value {
	return RouteLeakingValue{}
}

var _ basetypes.ObjectValuable = RouteLeakingValue{}

type RouteLeakingValue struct {
	ExportPolicy basetypes.StringValue `tfsdk:"export_policy"`
	ImportPolicy basetypes.StringValue `tfsdk:"import_policy"`
	state        attr.ValueState
}

func (v RouteLeakingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RouteLeakingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RouteLeakingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RouteLeakingValue) String() string {
	return "RouteLeakingValue"
}

func (v RouteLeakingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"export_policy": v.ExportPolicy,
			"import_policy": v.ImportPolicy,
		})

	return objVal, diags
}

func (v RouteLeakingValue) Equal(o attr.Value) bool {
	other, ok := o.(RouteLeakingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	return true
}

func (v RouteLeakingValue) Type(ctx context.Context) attr.Type {
	return RouteLeakingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RouteLeakingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bgpPeersAttribute, ok := attributes["bgp_peers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_peers is missing from object`)

		return nil, diags
	}

	bgpPeersVal, ok := bgpPeersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_peers expected to be basetypes.ListValue, was: %T`, bgpPeersAttribute))
	}

	eviAttribute, ok := attributes["evi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi is missing from object`)

		return nil, diags
	}

	eviVal, ok := eviAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi expected to be basetypes.Int64Value, was: %T`, eviAttribute))
	}

	exportTargetAttribute, ok := attributes["export_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_target is missing from object`)

		return nil, diags
	}

	exportTargetVal, ok := exportTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_target expected to be basetypes.StringValue, was: %T`, exportTargetAttribute))
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return nil, diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return nil, diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	importTargetAttribute, ok := attributes["import_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_target is missing from object`)

		return nil, diags
	}

	importTargetVal, ok := importTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_target expected to be basetypes.StringValue, was: %T`, importTargetAttribute))
	}

	irbInterfacesAttribute, ok := attributes["irb_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`irb_interfaces is missing from object`)

		return nil, diags
	}

	irbInterfacesVal, ok := irbInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`irb_interfaces expected to be basetypes.ListValue, was: %T`, irbInterfacesAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return nil, diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	numNodesAttribute, ok := attributes["num_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_nodes is missing from object`)

		return nil, diags
	}

	numNodesVal, ok := numNodesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_nodes expected to be basetypes.Int64Value, was: %T`, numNodesAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	routedInterfacesAttribute, ok := attributes["routed_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_interfaces is missing from object`)

		return nil, diags
	}

	routedInterfacesVal, ok := routedInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_interfaces expected to be basetypes.ListValue, was: %T`, routedInterfacesAttribute))
	}

	tunnelIndexAttribute, ok := attributes["tunnel_index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_index is missing from object`)

		return nil, diags
	}

	tunnelIndexVal, ok := tunnelIndexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_index expected to be basetypes.Int64Value, was: %T`, tunnelIndexAttribute))
	}

	vniAttribute, ok := attributes["vni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni is missing from object`)

		return nil, diags
	}

	vniVal, ok := vniAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni expected to be basetypes.Int64Value, was: %T`, vniAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		BgpPeers:          bgpPeersVal,
		Evi:               eviVal,
		ExportTarget:      exportTargetVal,
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		ImportTarget:      importTargetVal,
		IrbInterfaces:     irbInterfacesVal,
		LastChange:        lastChangeVal,
		Nodes:             nodesVal,
		NumNodes:          numNodesVal,
		OperationalState:  operationalStateVal,
		RoutedInterfaces:  routedInterfacesVal,
		TunnelIndex:       tunnelIndexVal,
		Vni:               vniVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	bgpPeersAttribute, ok := attributes["bgp_peers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_peers is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	bgpPeersVal, ok := bgpPeersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_peers expected to be basetypes.ListValue, was: %T`, bgpPeersAttribute))
	}

	eviAttribute, ok := attributes["evi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	eviVal, ok := eviAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi expected to be basetypes.Int64Value, was: %T`, eviAttribute))
	}

	exportTargetAttribute, ok := attributes["export_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_target is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	exportTargetVal, ok := exportTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_target expected to be basetypes.StringValue, was: %T`, exportTargetAttribute))
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	importTargetAttribute, ok := attributes["import_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_target is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	importTargetVal, ok := importTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_target expected to be basetypes.StringValue, was: %T`, importTargetAttribute))
	}

	irbInterfacesAttribute, ok := attributes["irb_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`irb_interfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	irbInterfacesVal, ok := irbInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`irb_interfaces expected to be basetypes.ListValue, was: %T`, irbInterfacesAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	numNodesAttribute, ok := attributes["num_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_nodes is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numNodesVal, ok := numNodesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_nodes expected to be basetypes.Int64Value, was: %T`, numNodesAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	routedInterfacesAttribute, ok := attributes["routed_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_interfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	routedInterfacesVal, ok := routedInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_interfaces expected to be basetypes.ListValue, was: %T`, routedInterfacesAttribute))
	}

	tunnelIndexAttribute, ok := attributes["tunnel_index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_index is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	tunnelIndexVal, ok := tunnelIndexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_index expected to be basetypes.Int64Value, was: %T`, tunnelIndexAttribute))
	}

	vniAttribute, ok := attributes["vni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	vniVal, ok := vniAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni expected to be basetypes.Int64Value, was: %T`, vniAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		BgpPeers:          bgpPeersVal,
		Evi:               eviVal,
		ExportTarget:      exportTargetVal,
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		ImportTarget:      importTargetVal,
		IrbInterfaces:     irbInterfacesVal,
		LastChange:        lastChangeVal,
		Nodes:             nodesVal,
		NumNodes:          numNodesVal,
		OperationalState:  operationalStateVal,
		RoutedInterfaces:  routedInterfacesVal,
		TunnelIndex:       tunnelIndexVal,
		Vni:               vniVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	BgpPeers          basetypes.ListValue   `tfsdk:"bgp_peers"`
	Evi               basetypes.Int64Value  `tfsdk:"evi"`
	ExportTarget      basetypes.StringValue `tfsdk:"export_target"`
	Health            basetypes.Int64Value  `tfsdk:"health"`
	HealthScoreReason basetypes.StringValue `tfsdk:"health_score_reason"`
	ImportTarget      basetypes.StringValue `tfsdk:"import_target"`
	IrbInterfaces     basetypes.ListValue   `tfsdk:"irb_interfaces"`
	LastChange        basetypes.StringValue `tfsdk:"last_change"`
	Nodes             basetypes.ListValue   `tfsdk:"nodes"`
	NumNodes          basetypes.Int64Value  `tfsdk:"num_nodes"`
	OperationalState  basetypes.StringValue `tfsdk:"operational_state"`
	RoutedInterfaces  basetypes.ListValue   `tfsdk:"routed_interfaces"`
	TunnelIndex       basetypes.Int64Value  `tfsdk:"tunnel_index"`
	Vni               basetypes.Int64Value  `tfsdk:"vni"`
	state             attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["bgp_peers"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["evi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["export_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["health"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_score_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["irb_interfaces"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["nodes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["num_nodes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["routed_interfaces"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["tunnel_index"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vni"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.BgpPeers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp_peers"] = val

		val, err = v.Evi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evi"] = val

		val, err = v.ExportTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_target"] = val

		val, err = v.Health.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health"] = val

		val, err = v.HealthScoreReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_score_reason"] = val

		val, err = v.ImportTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_target"] = val

		val, err = v.IrbInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["irb_interfaces"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.Nodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nodes"] = val

		val, err = v.NumNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_nodes"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		val, err = v.RoutedInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routed_interfaces"] = val

		val, err = v.TunnelIndex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tunnel_index"] = val

		val, err = v.Vni.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vni"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bgpPeersVal basetypes.ListValue
	switch {
	case v.BgpPeers.IsUnknown():
		bgpPeersVal = types.ListUnknown(types.StringType)
	case v.BgpPeers.IsNull():
		bgpPeersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		bgpPeersVal, d = types.ListValue(types.StringType, v.BgpPeers.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bgp_peers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"evi":                 basetypes.Int64Type{},
			"export_target":       basetypes.StringType{},
			"health":              basetypes.Int64Type{},
			"health_score_reason": basetypes.StringType{},
			"import_target":       basetypes.StringType{},
			"irb_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"last_change": basetypes.StringType{},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"num_nodes":         basetypes.Int64Type{},
			"operational_state": basetypes.StringType{},
			"routed_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tunnel_index": basetypes.Int64Type{},
			"vni":          basetypes.Int64Type{},
		}), diags
	}

	var irbInterfacesVal basetypes.ListValue
	switch {
	case v.IrbInterfaces.IsUnknown():
		irbInterfacesVal = types.ListUnknown(types.StringType)
	case v.IrbInterfaces.IsNull():
		irbInterfacesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		irbInterfacesVal, d = types.ListValue(types.StringType, v.IrbInterfaces.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bgp_peers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"evi":                 basetypes.Int64Type{},
			"export_target":       basetypes.StringType{},
			"health":              basetypes.Int64Type{},
			"health_score_reason": basetypes.StringType{},
			"import_target":       basetypes.StringType{},
			"irb_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"last_change": basetypes.StringType{},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"num_nodes":         basetypes.Int64Type{},
			"operational_state": basetypes.StringType{},
			"routed_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tunnel_index": basetypes.Int64Type{},
			"vni":          basetypes.Int64Type{},
		}), diags
	}

	var nodesVal basetypes.ListValue
	switch {
	case v.Nodes.IsUnknown():
		nodesVal = types.ListUnknown(types.StringType)
	case v.Nodes.IsNull():
		nodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodesVal, d = types.ListValue(types.StringType, v.Nodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bgp_peers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"evi":                 basetypes.Int64Type{},
			"export_target":       basetypes.StringType{},
			"health":              basetypes.Int64Type{},
			"health_score_reason": basetypes.StringType{},
			"import_target":       basetypes.StringType{},
			"irb_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"last_change": basetypes.StringType{},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"num_nodes":         basetypes.Int64Type{},
			"operational_state": basetypes.StringType{},
			"routed_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tunnel_index": basetypes.Int64Type{},
			"vni":          basetypes.Int64Type{},
		}), diags
	}

	var routedInterfacesVal basetypes.ListValue
	switch {
	case v.RoutedInterfaces.IsUnknown():
		routedInterfacesVal = types.ListUnknown(types.StringType)
	case v.RoutedInterfaces.IsNull():
		routedInterfacesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		routedInterfacesVal, d = types.ListValue(types.StringType, v.RoutedInterfaces.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bgp_peers": basetypes.ListType{
				ElemType: types.StringType,
			},
			"evi":                 basetypes.Int64Type{},
			"export_target":       basetypes.StringType{},
			"health":              basetypes.Int64Type{},
			"health_score_reason": basetypes.StringType{},
			"import_target":       basetypes.StringType{},
			"irb_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"last_change": basetypes.StringType{},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"num_nodes":         basetypes.Int64Type{},
			"operational_state": basetypes.StringType{},
			"routed_interfaces": basetypes.ListType{
				ElemType: types.StringType,
			},
			"tunnel_index": basetypes.Int64Type{},
			"vni":          basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"bgp_peers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"evi":                 basetypes.Int64Type{},
		"export_target":       basetypes.StringType{},
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"import_target":       basetypes.StringType{},
		"irb_interfaces": basetypes.ListType{
			ElemType: types.StringType,
		},
		"last_change": basetypes.StringType{},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"num_nodes":         basetypes.Int64Type{},
		"operational_state": basetypes.StringType{},
		"routed_interfaces": basetypes.ListType{
			ElemType: types.StringType,
		},
		"tunnel_index": basetypes.Int64Type{},
		"vni":          basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bgp_peers":           bgpPeersVal,
			"evi":                 v.Evi,
			"export_target":       v.ExportTarget,
			"health":              v.Health,
			"health_score_reason": v.HealthScoreReason,
			"import_target":       v.ImportTarget,
			"irb_interfaces":      irbInterfacesVal,
			"last_change":         v.LastChange,
			"nodes":               nodesVal,
			"num_nodes":           v.NumNodes,
			"operational_state":   v.OperationalState,
			"routed_interfaces":   routedInterfacesVal,
			"tunnel_index":        v.TunnelIndex,
			"vni":                 v.Vni,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BgpPeers.Equal(other.BgpPeers) {
		return false
	}

	if !v.Evi.Equal(other.Evi) {
		return false
	}

	if !v.ExportTarget.Equal(other.ExportTarget) {
		return false
	}

	if !v.Health.Equal(other.Health) {
		return false
	}

	if !v.HealthScoreReason.Equal(other.HealthScoreReason) {
		return false
	}

	if !v.ImportTarget.Equal(other.ImportTarget) {
		return false
	}

	if !v.IrbInterfaces.Equal(other.IrbInterfaces) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.Nodes.Equal(other.Nodes) {
		return false
	}

	if !v.NumNodes.Equal(other.NumNodes) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	if !v.RoutedInterfaces.Equal(other.RoutedInterfaces) {
		return false
	}

	if !v.TunnelIndex.Equal(other.TunnelIndex) {
		return false
	}

	if !v.Vni.Equal(other.Vni) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bgp_peers": basetypes.ListType{
			ElemType: types.StringType,
		},
		"evi":                 basetypes.Int64Type{},
		"export_target":       basetypes.StringType{},
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"import_target":       basetypes.StringType{},
		"irb_interfaces": basetypes.ListType{
			ElemType: types.StringType,
		},
		"last_change": basetypes.StringType{},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"num_nodes":         basetypes.Int64Type{},
		"operational_state": basetypes.StringType{},
		"routed_interfaces": basetypes.ListType{
			ElemType: types.StringType,
		},
		"tunnel_index": basetypes.Int64Type{},
		"vni":          basetypes.Int64Type{},
	}
}
