// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_bridge_interface

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func BridgeInterfaceDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"hash": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "resource content will be returned as it was at the time of this git hash",
				MarkdownDescription: "resource content will be returned as it was at the time of this git hash",
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"namespace": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "name of the BridgeInterface",
				MarkdownDescription: "name of the BridgeInterface",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"bridge_domain": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to a BridgeDomain in which to attach the BridgeInterface.",
						MarkdownDescription: "Reference to a BridgeDomain in which to attach the BridgeInterface.",
					},
					"description": schema.StringAttribute{
						Optional:            true,
						Description:         "The description of the BridgeInterface.",
						MarkdownDescription: "The description of the BridgeInterface.",
					},
					"egress": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"filters": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "List of Filter references to use at egress.",
								MarkdownDescription: "List of Filter references to use at egress.",
							},
							"qos_policy": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "List of QoS Egress policy references to use at egress.",
								MarkdownDescription: "List of QoS Egress policy references to use at egress.",
							},
						},
						CustomType: EgressType{
							ObjectType: types.ObjectType{
								AttrTypes: EgressValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Manages actions on traffic at Egress.",
						MarkdownDescription: "Manages actions on traffic at Egress.",
					},
					"ingress": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"filters": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "List of Filter references to use at ingress.",
								MarkdownDescription: "List of Filter references to use at ingress.",
							},
							"qos_policy": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "List of QoS Ingress policy references to use at ingress.",
								MarkdownDescription: "List of QoS Ingress policy references to use at ingress.",
							},
						},
						CustomType: IngressType{
							ObjectType: types.ObjectType{
								AttrTypes: IngressValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Manages actions on traffic at Ingress.",
						MarkdownDescription: "Manages actions on traffic at Ingress.",
					},
					"interface": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to an Interface resource to attach this BridgeInterface.",
						MarkdownDescription: "Reference to an Interface resource to attach this BridgeInterface.",
					},
					"l2mtu": schema.Int64Attribute{
						Optional:            true,
						Description:         "L2 MTU specifies the maximum sized Ethernet frame that can be transmitted on the subinterface. If a frame exceeds this size it is discarded. If the l2-mtu of the subinterface exceeds the port-mtu of the associated interface, the subinterface will remain operationally down.",
						MarkdownDescription: "L2 MTU specifies the maximum sized Ethernet frame that can be transmitted on the subinterface. If a frame exceeds this size it is discarded. If the l2-mtu of the subinterface exceeds the port-mtu of the associated interface, the subinterface will remain operationally down.",
					},
					"mac_duplication_detection_action": schema.StringAttribute{
						Optional:            true,
						Description:         "Override for Mac Duplication Detection action if enabled in the associated BridgeDomain.",
						MarkdownDescription: "Override for Mac Duplication Detection action if enabled in the associated BridgeDomain.",
					},
					"split_horizon_group": schema.StringAttribute{
						Optional:            true,
						Description:         "Split Horizon Group to be used for this BridgeInterface. The subinterface within this BridgeInterface will be a member of this Split Horizon Group.",
						MarkdownDescription: "Split Horizon Group to be used for this BridgeInterface. The subinterface within this BridgeInterface will be a member of this Split Horizon Group.",
					},
					"uplink": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"egress_1": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"filters": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of Filter references to use at egress.",
										MarkdownDescription: "List of Filter references to use at egress.",
									},
									"qos_policy": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of QoS Egress policy references to use at egress.",
										MarkdownDescription: "List of QoS Egress policy references to use at egress.",
									},
								},
								CustomType: Egress1Type{
									ObjectType: types.ObjectType{
										AttrTypes: Egress1Value{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Manages actions on traffic at Egress of the Local enpoint of the Uplink.",
								MarkdownDescription: "Manages actions on traffic at Egress of the Local enpoint of the Uplink.",
							},
							"ingress_1": schema.SingleNestedAttribute{
								Attributes: map[string]schema.Attribute{
									"filters": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of Filter references to use at ingress.",
										MarkdownDescription: "List of Filter references to use at ingress.",
									},
									"qos_policy": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Description:         "List of QoS Ingress policy references to use at ingress.",
										MarkdownDescription: "List of QoS Ingress policy references to use at ingress.",
									},
								},
								CustomType: Ingress1Type{
									ObjectType: types.ObjectType{
										AttrTypes: Ingress1Value{}.AttributeTypes(ctx),
									},
								},
								Optional:            true,
								Description:         "Manages actions on traffic at Ingress of the Local enpoint of the Uplink.",
								MarkdownDescription: "Manages actions on traffic at Ingress of the Local enpoint of the Uplink.",
							},
							"uplink_selector": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "Selects TopoLinks which connect a leaf switch to a breakout switch. This is the uplink between your access breakout switch and your leaf switch.  There can only be a single TopoLink between the access breakout switch and the leaf switch, if more than one TopoLink is present between two devices the transaction will fail.",
								MarkdownDescription: "Selects TopoLinks which connect a leaf switch to a breakout switch. This is the uplink between your access breakout switch and your leaf switch.  There can only be a single TopoLink between the access breakout switch and the leaf switch, if more than one TopoLink is present between two devices the transaction will fail.",
							},
							"uplink_vlanid": schema.StringAttribute{
								Optional:            true,
								Description:         "The VLAN ID to be utilized to isolate traffic from the VLAN on the access breakout switch to the leaf switch on the selected uplink TopoLink.",
								MarkdownDescription: "The VLAN ID to be utilized to isolate traffic from the VLAN on the access breakout switch to the leaf switch on the selected uplink TopoLink.",
							},
							"uplink_vlanpool": schema.StringAttribute{
								Optional:            true,
								Description:         "A VLAN from this pool will be utilized to isolate traffic from the VLAN on the access breakout switch to the leaf switch on the selected uplink TopoLink.",
								MarkdownDescription: "A VLAN from this pool will be utilized to isolate traffic from the VLAN on the access breakout switch to the leaf switch on the selected uplink TopoLink.",
							},
						},
						CustomType: UplinkType{
							ObjectType: types.ObjectType{
								AttrTypes: UplinkValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "The Uplink between your access breakout switch and your leaf switch.",
						MarkdownDescription: "The Uplink between your access breakout switch and your leaf switch.",
					},
					"vlan_id": schema.StringAttribute{
						Optional:            true,
						Description:         "Single value between 1-4094 support, ranges supported in the format x-y,x-y, or the special keyword null, any, untagged or pool for auto allocation.",
						MarkdownDescription: "Single value between 1-4094 support, ranges supported in the format x-y,x-y, or the special keyword null, any, untagged or pool for auto allocation.",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "The BridgeInterface enables the attachment of network interfaces to a Bridge Domain. It includes settings for VLAN ID allocation, interface attachment, and actions on ingress and egress traffic. The specification supports integration with other network resources, such as Bridge Domains and Interfaces, and provides advanced features like MAC Duplication Detection with configurable actions.",
				MarkdownDescription: "The BridgeInterface enables the attachment of network interfaces to a Bridge Domain. It includes settings for VLAN ID allocation, interface attachment, and actions on ingress and egress traffic. The specification supports integration with other network resources, such as Bridge Domains and Interfaces, and provides advanced features like MAC Duplication Detection with configurable actions.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"health": schema.Int64Attribute{
						Computed:            true,
						Description:         "Indicates the health score of the BridgeInterface.",
						MarkdownDescription: "Indicates the health score of the BridgeInterface.",
					},
					"health_score_reason": schema.StringAttribute{
						Computed:            true,
						Description:         "Indicates the reason for the health score.",
						MarkdownDescription: "Indicates the reason for the health score.",
					},
					"last_change": schema.StringAttribute{
						Computed:            true,
						Description:         "The time when the state of the resource last changed.",
						MarkdownDescription: "The time when the state of the resource last changed.",
					},
					"operational_state": schema.StringAttribute{
						Computed:            true,
						Description:         "Operational state of the BridgeInterface.",
						MarkdownDescription: "Operational state of the BridgeInterface.",
					},
					"sub_interfaces": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "The administrative status of the SubInterface.",
									MarkdownDescription: "The administrative status of the SubInterface.",
								},
								"interface": schema.StringAttribute{
									Computed:            true,
									Description:         "Normalized interface name.",
									MarkdownDescription: "Normalized interface name.",
								},
								"interface_resource": schema.StringAttribute{
									Computed:            true,
									Description:         "Eda interface resource.",
									MarkdownDescription: "Eda interface resource.",
								},
								"last_change": schema.StringAttribute{
									Computed:            true,
									Description:         "Indicates when this SubInterface last changed state.",
									MarkdownDescription: "Indicates when this SubInterface last changed state.",
								},
								"node": schema.StringAttribute{
									Computed:            true,
									Description:         "Reference to Node object.",
									MarkdownDescription: "Reference to Node object.",
								},
								"node_interface": schema.StringAttribute{
									Computed:            true,
									Description:         "Node specific interface name.",
									MarkdownDescription: "Node specific interface name.",
								},
								"operating_system": schema.StringAttribute{
									Computed:            true,
									Description:         "Operating System of the Node.",
									MarkdownDescription: "Operating System of the Node.",
								},
								"operational_state": schema.StringAttribute{
									Computed:            true,
									Description:         "Indicates the current operational state of the SubInterface.",
									MarkdownDescription: "Indicates the current operational state of the SubInterface.",
								},
								"sub_interface_index": schema.Int64Attribute{
									Computed:            true,
									Description:         "Index allocated to the subinterface on the associated interface for the given VLAN.",
									MarkdownDescription: "Index allocated to the subinterface on the associated interface for the given VLAN.",
								},
								"vlan_id": schema.StringAttribute{
									Computed:            true,
									Description:         "vlan assigned to this subinterface.",
									MarkdownDescription: "vlan assigned to this subinterface.",
								},
							},
							CustomType: SubInterfacesType{
								ObjectType: types.ObjectType{
									AttrTypes: SubInterfacesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "Sub-interfaces status within the BridgeInterface.",
						MarkdownDescription: "Sub-interfaces status within the BridgeInterface.",
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
		},
	}
}

type BridgeInterfaceModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Hash       types.String  `tfsdk:"hash"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bridgeDomainAttribute, ok := attributes["bridge_domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_domain is missing from object`)

		return nil, diags
	}

	bridgeDomainVal, ok := bridgeDomainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_domain expected to be basetypes.StringValue, was: %T`, bridgeDomainAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egressAttribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress is missing from object`)

		return nil, diags
	}

	egressVal, ok := egressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress expected to be basetypes.ObjectValue, was: %T`, egressAttribute))
	}

	ingressAttribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress is missing from object`)

		return nil, diags
	}

	ingressVal, ok := ingressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress expected to be basetypes.ObjectValue, was: %T`, ingressAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	l2mtuAttribute, ok := attributes["l2mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2mtu is missing from object`)

		return nil, diags
	}

	l2mtuVal, ok := l2mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2mtu expected to be basetypes.Int64Value, was: %T`, l2mtuAttribute))
	}

	macDuplicationDetectionActionAttribute, ok := attributes["mac_duplication_detection_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_duplication_detection_action is missing from object`)

		return nil, diags
	}

	macDuplicationDetectionActionVal, ok := macDuplicationDetectionActionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_duplication_detection_action expected to be basetypes.StringValue, was: %T`, macDuplicationDetectionActionAttribute))
	}

	splitHorizonGroupAttribute, ok := attributes["split_horizon_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`split_horizon_group is missing from object`)

		return nil, diags
	}

	splitHorizonGroupVal, ok := splitHorizonGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`split_horizon_group expected to be basetypes.StringValue, was: %T`, splitHorizonGroupAttribute))
	}

	uplinkAttribute, ok := attributes["uplink"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink is missing from object`)

		return nil, diags
	}

	uplinkVal, ok := uplinkAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink expected to be basetypes.ObjectValue, was: %T`, uplinkAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		BridgeDomain:                  bridgeDomainVal,
		Description:                   descriptionVal,
		Egress:                        egressVal,
		Ingress:                       ingressVal,
		Interface:                     interfaceVal,
		L2mtu:                         l2mtuVal,
		MacDuplicationDetectionAction: macDuplicationDetectionActionVal,
		SplitHorizonGroup:             splitHorizonGroupVal,
		Uplink:                        uplinkVal,
		VlanId:                        vlanIdVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	bridgeDomainAttribute, ok := attributes["bridge_domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_domain is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	bridgeDomainVal, ok := bridgeDomainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_domain expected to be basetypes.StringValue, was: %T`, bridgeDomainAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egressAttribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	egressVal, ok := egressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress expected to be basetypes.ObjectValue, was: %T`, egressAttribute))
	}

	ingressAttribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ingressVal, ok := ingressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress expected to be basetypes.ObjectValue, was: %T`, ingressAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	l2mtuAttribute, ok := attributes["l2mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2mtu is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	l2mtuVal, ok := l2mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2mtu expected to be basetypes.Int64Value, was: %T`, l2mtuAttribute))
	}

	macDuplicationDetectionActionAttribute, ok := attributes["mac_duplication_detection_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_duplication_detection_action is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	macDuplicationDetectionActionVal, ok := macDuplicationDetectionActionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_duplication_detection_action expected to be basetypes.StringValue, was: %T`, macDuplicationDetectionActionAttribute))
	}

	splitHorizonGroupAttribute, ok := attributes["split_horizon_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`split_horizon_group is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	splitHorizonGroupVal, ok := splitHorizonGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`split_horizon_group expected to be basetypes.StringValue, was: %T`, splitHorizonGroupAttribute))
	}

	uplinkAttribute, ok := attributes["uplink"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	uplinkVal, ok := uplinkAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink expected to be basetypes.ObjectValue, was: %T`, uplinkAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		BridgeDomain:                  bridgeDomainVal,
		Description:                   descriptionVal,
		Egress:                        egressVal,
		Ingress:                       ingressVal,
		Interface:                     interfaceVal,
		L2mtu:                         l2mtuVal,
		MacDuplicationDetectionAction: macDuplicationDetectionActionVal,
		SplitHorizonGroup:             splitHorizonGroupVal,
		Uplink:                        uplinkVal,
		VlanId:                        vlanIdVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	BridgeDomain                  basetypes.StringValue `tfsdk:"bridge_domain"`
	Description                   basetypes.StringValue `tfsdk:"description"`
	Egress                        basetypes.ObjectValue `tfsdk:"egress"`
	Ingress                       basetypes.ObjectValue `tfsdk:"ingress"`
	Interface                     basetypes.StringValue `tfsdk:"interface"`
	L2mtu                         basetypes.Int64Value  `tfsdk:"l2mtu"`
	MacDuplicationDetectionAction basetypes.StringValue `tfsdk:"mac_duplication_detection_action"`
	SplitHorizonGroup             basetypes.StringValue `tfsdk:"split_horizon_group"`
	Uplink                        basetypes.ObjectValue `tfsdk:"uplink"`
	VlanId                        basetypes.StringValue `tfsdk:"vlan_id"`
	state                         attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["bridge_domain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["egress"] = basetypes.ObjectType{
		AttrTypes: EgressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ingress"] = basetypes.ObjectType{
		AttrTypes: IngressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l2mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mac_duplication_detection_action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["split_horizon_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uplink"] = basetypes.ObjectType{
		AttrTypes: UplinkValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.BridgeDomain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bridge_domain"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Egress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress"] = val

		val, err = v.Ingress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.L2mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l2mtu"] = val

		val, err = v.MacDuplicationDetectionAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_duplication_detection_action"] = val

		val, err = v.SplitHorizonGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["split_horizon_group"] = val

		val, err = v.Uplink.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uplink"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var egress basetypes.ObjectValue

	if v.Egress.IsNull() {
		egress = types.ObjectNull(
			EgressValue{}.AttributeTypes(ctx),
		)
	}

	if v.Egress.IsUnknown() {
		egress = types.ObjectUnknown(
			EgressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Egress.IsNull() && !v.Egress.IsUnknown() {
		egress = types.ObjectValueMust(
			EgressValue{}.AttributeTypes(ctx),
			v.Egress.Attributes(),
		)
	}

	var ingress basetypes.ObjectValue

	if v.Ingress.IsNull() {
		ingress = types.ObjectNull(
			IngressValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ingress.IsUnknown() {
		ingress = types.ObjectUnknown(
			IngressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ingress.IsNull() && !v.Ingress.IsUnknown() {
		ingress = types.ObjectValueMust(
			IngressValue{}.AttributeTypes(ctx),
			v.Ingress.Attributes(),
		)
	}

	var uplink basetypes.ObjectValue

	if v.Uplink.IsNull() {
		uplink = types.ObjectNull(
			UplinkValue{}.AttributeTypes(ctx),
		)
	}

	if v.Uplink.IsUnknown() {
		uplink = types.ObjectUnknown(
			UplinkValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Uplink.IsNull() && !v.Uplink.IsUnknown() {
		uplink = types.ObjectValueMust(
			UplinkValue{}.AttributeTypes(ctx),
			v.Uplink.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bridge_domain": basetypes.StringType{},
		"description":   basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: EgressValue{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: IngressValue{}.AttributeTypes(ctx),
		},
		"interface":                        basetypes.StringType{},
		"l2mtu":                            basetypes.Int64Type{},
		"mac_duplication_detection_action": basetypes.StringType{},
		"split_horizon_group":              basetypes.StringType{},
		"uplink": basetypes.ObjectType{
			AttrTypes: UplinkValue{}.AttributeTypes(ctx),
		},
		"vlan_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bridge_domain":                    v.BridgeDomain,
			"description":                      v.Description,
			"egress":                           egress,
			"ingress":                          ingress,
			"interface":                        v.Interface,
			"l2mtu":                            v.L2mtu,
			"mac_duplication_detection_action": v.MacDuplicationDetectionAction,
			"split_horizon_group":              v.SplitHorizonGroup,
			"uplink":                           uplink,
			"vlan_id":                          v.VlanId,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BridgeDomain.Equal(other.BridgeDomain) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Egress.Equal(other.Egress) {
		return false
	}

	if !v.Ingress.Equal(other.Ingress) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.L2mtu.Equal(other.L2mtu) {
		return false
	}

	if !v.MacDuplicationDetectionAction.Equal(other.MacDuplicationDetectionAction) {
		return false
	}

	if !v.SplitHorizonGroup.Equal(other.SplitHorizonGroup) {
		return false
	}

	if !v.Uplink.Equal(other.Uplink) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bridge_domain": basetypes.StringType{},
		"description":   basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: EgressValue{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: IngressValue{}.AttributeTypes(ctx),
		},
		"interface":                        basetypes.StringType{},
		"l2mtu":                            basetypes.Int64Type{},
		"mac_duplication_detection_action": basetypes.StringType{},
		"split_horizon_group":              basetypes.StringType{},
		"uplink": basetypes.ObjectType{
			AttrTypes: UplinkValue{}.AttributeTypes(ctx),
		},
		"vlan_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EgressType{}

type EgressType struct {
	basetypes.ObjectType
}

func (t EgressType) Equal(o attr.Type) bool {
	other, ok := o.(EgressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EgressType) String() string {
	return "EgressType"
}

func (t EgressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EgressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgressValueNull() EgressValue {
	return EgressValue{
		state: attr.ValueStateNull,
	}
}

func NewEgressValueUnknown() EgressValue {
	return EgressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEgressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EgressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EgressValue Attribute Value",
				"While creating a EgressValue value, a missing attribute value was detected. "+
					"A EgressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EgressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EgressValue Attribute Type",
				"While creating a EgressValue value, an invalid attribute value was detected. "+
					"A EgressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EgressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EgressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EgressValue Attribute Value",
				"While creating a EgressValue value, an extra attribute value was detected. "+
					"A EgressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EgressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEgressValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewEgressValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewEgressValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewEgressValueUnknown(), diags
	}

	return EgressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EgressValue {
	object, diags := NewEgressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEgressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EgressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEgressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEgressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEgressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEgressValueMust(EgressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EgressType) ValueType(ctx context.Context) attr.Value {
	return EgressValue{}
}

var _ basetypes.ObjectValuable = EgressValue{}

type EgressValue struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v EgressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EgressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EgressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EgressValue) String() string {
	return "EgressValue"
}

func (v EgressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v EgressValue) Equal(o attr.Value) bool {
	other, ok := o.(EgressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v EgressValue) Type(ctx context.Context) attr.Type {
	return EgressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EgressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = IngressType{}

type IngressType struct {
	basetypes.ObjectType
}

func (t IngressType) Equal(o attr.Type) bool {
	other, ok := o.(IngressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IngressType) String() string {
	return "IngressType"
}

func (t IngressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IngressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngressValueNull() IngressValue {
	return IngressValue{
		state: attr.ValueStateNull,
	}
}

func NewIngressValueUnknown() IngressValue {
	return IngressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIngressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IngressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IngressValue Attribute Value",
				"While creating a IngressValue value, a missing attribute value was detected. "+
					"A IngressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IngressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IngressValue Attribute Type",
				"While creating a IngressValue value, an invalid attribute value was detected. "+
					"A IngressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IngressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IngressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IngressValue Attribute Value",
				"While creating a IngressValue value, an extra attribute value was detected. "+
					"A IngressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IngressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIngressValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewIngressValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewIngressValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewIngressValueUnknown(), diags
	}

	return IngressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IngressValue {
	object, diags := NewIngressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIngressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IngressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIngressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIngressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIngressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIngressValueMust(IngressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IngressType) ValueType(ctx context.Context) attr.Value {
	return IngressValue{}
}

var _ basetypes.ObjectValuable = IngressValue{}

type IngressValue struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v IngressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IngressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IngressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IngressValue) String() string {
	return "IngressValue"
}

func (v IngressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v IngressValue) Equal(o attr.Value) bool {
	other, ok := o.(IngressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v IngressValue) Type(ctx context.Context) attr.Type {
	return IngressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IngressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = UplinkType{}

type UplinkType struct {
	basetypes.ObjectType
}

func (t UplinkType) Equal(o attr.Type) bool {
	other, ok := o.(UplinkType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UplinkType) String() string {
	return "UplinkType"
}

func (t UplinkType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	egress1Attribute, ok := attributes["egress_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_1 is missing from object`)

		return nil, diags
	}

	egress1Val, ok := egress1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_1 expected to be basetypes.ObjectValue, was: %T`, egress1Attribute))
	}

	ingress1Attribute, ok := attributes["ingress_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_1 is missing from object`)

		return nil, diags
	}

	ingress1Val, ok := ingress1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_1 expected to be basetypes.ObjectValue, was: %T`, ingress1Attribute))
	}

	uplinkSelectorAttribute, ok := attributes["uplink_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_selector is missing from object`)

		return nil, diags
	}

	uplinkSelectorVal, ok := uplinkSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_selector expected to be basetypes.ListValue, was: %T`, uplinkSelectorAttribute))
	}

	uplinkVlanidAttribute, ok := attributes["uplink_vlanid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_vlanid is missing from object`)

		return nil, diags
	}

	uplinkVlanidVal, ok := uplinkVlanidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_vlanid expected to be basetypes.StringValue, was: %T`, uplinkVlanidAttribute))
	}

	uplinkVlanpoolAttribute, ok := attributes["uplink_vlanpool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_vlanpool is missing from object`)

		return nil, diags
	}

	uplinkVlanpoolVal, ok := uplinkVlanpoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_vlanpool expected to be basetypes.StringValue, was: %T`, uplinkVlanpoolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UplinkValue{
		Egress1:        egress1Val,
		Ingress1:       ingress1Val,
		UplinkSelector: uplinkSelectorVal,
		UplinkVlanid:   uplinkVlanidVal,
		UplinkVlanpool: uplinkVlanpoolVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewUplinkValueNull() UplinkValue {
	return UplinkValue{
		state: attr.ValueStateNull,
	}
}

func NewUplinkValueUnknown() UplinkValue {
	return UplinkValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUplinkValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UplinkValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UplinkValue Attribute Value",
				"While creating a UplinkValue value, a missing attribute value was detected. "+
					"A UplinkValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UplinkValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UplinkValue Attribute Type",
				"While creating a UplinkValue value, an invalid attribute value was detected. "+
					"A UplinkValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UplinkValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UplinkValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UplinkValue Attribute Value",
				"While creating a UplinkValue value, an extra attribute value was detected. "+
					"A UplinkValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UplinkValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUplinkValueUnknown(), diags
	}

	egress1Attribute, ok := attributes["egress_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_1 is missing from object`)

		return NewUplinkValueUnknown(), diags
	}

	egress1Val, ok := egress1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_1 expected to be basetypes.ObjectValue, was: %T`, egress1Attribute))
	}

	ingress1Attribute, ok := attributes["ingress_1"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_1 is missing from object`)

		return NewUplinkValueUnknown(), diags
	}

	ingress1Val, ok := ingress1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_1 expected to be basetypes.ObjectValue, was: %T`, ingress1Attribute))
	}

	uplinkSelectorAttribute, ok := attributes["uplink_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_selector is missing from object`)

		return NewUplinkValueUnknown(), diags
	}

	uplinkSelectorVal, ok := uplinkSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_selector expected to be basetypes.ListValue, was: %T`, uplinkSelectorAttribute))
	}

	uplinkVlanidAttribute, ok := attributes["uplink_vlanid"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_vlanid is missing from object`)

		return NewUplinkValueUnknown(), diags
	}

	uplinkVlanidVal, ok := uplinkVlanidAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_vlanid expected to be basetypes.StringValue, was: %T`, uplinkVlanidAttribute))
	}

	uplinkVlanpoolAttribute, ok := attributes["uplink_vlanpool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_vlanpool is missing from object`)

		return NewUplinkValueUnknown(), diags
	}

	uplinkVlanpoolVal, ok := uplinkVlanpoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_vlanpool expected to be basetypes.StringValue, was: %T`, uplinkVlanpoolAttribute))
	}

	if diags.HasError() {
		return NewUplinkValueUnknown(), diags
	}

	return UplinkValue{
		Egress1:        egress1Val,
		Ingress1:       ingress1Val,
		UplinkSelector: uplinkSelectorVal,
		UplinkVlanid:   uplinkVlanidVal,
		UplinkVlanpool: uplinkVlanpoolVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewUplinkValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UplinkValue {
	object, diags := NewUplinkValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUplinkValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UplinkType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUplinkValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUplinkValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUplinkValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUplinkValueMust(UplinkValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UplinkType) ValueType(ctx context.Context) attr.Value {
	return UplinkValue{}
}

var _ basetypes.ObjectValuable = UplinkValue{}

type UplinkValue struct {
	Egress1        basetypes.ObjectValue `tfsdk:"egress_1"`
	Ingress1       basetypes.ObjectValue `tfsdk:"ingress_1"`
	UplinkSelector basetypes.ListValue   `tfsdk:"uplink_selector"`
	UplinkVlanid   basetypes.StringValue `tfsdk:"uplink_vlanid"`
	UplinkVlanpool basetypes.StringValue `tfsdk:"uplink_vlanpool"`
	state          attr.ValueState
}

func (v UplinkValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["egress_1"] = basetypes.ObjectType{
		AttrTypes: Egress1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ingress_1"] = basetypes.ObjectType{
		AttrTypes: Ingress1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["uplink_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["uplink_vlanid"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uplink_vlanpool"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Egress1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress_1"] = val

		val, err = v.Ingress1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress_1"] = val

		val, err = v.UplinkSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uplink_selector"] = val

		val, err = v.UplinkVlanid.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uplink_vlanid"] = val

		val, err = v.UplinkVlanpool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uplink_vlanpool"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UplinkValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UplinkValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UplinkValue) String() string {
	return "UplinkValue"
}

func (v UplinkValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var egress1 basetypes.ObjectValue

	if v.Egress1.IsNull() {
		egress1 = types.ObjectNull(
			Egress1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Egress1.IsUnknown() {
		egress1 = types.ObjectUnknown(
			Egress1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Egress1.IsNull() && !v.Egress1.IsUnknown() {
		egress1 = types.ObjectValueMust(
			Egress1Value{}.AttributeTypes(ctx),
			v.Egress1.Attributes(),
		)
	}

	var ingress1 basetypes.ObjectValue

	if v.Ingress1.IsNull() {
		ingress1 = types.ObjectNull(
			Ingress1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ingress1.IsUnknown() {
		ingress1 = types.ObjectUnknown(
			Ingress1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ingress1.IsNull() && !v.Ingress1.IsUnknown() {
		ingress1 = types.ObjectValueMust(
			Ingress1Value{}.AttributeTypes(ctx),
			v.Ingress1.Attributes(),
		)
	}

	var uplinkSelectorVal basetypes.ListValue
	switch {
	case v.UplinkSelector.IsUnknown():
		uplinkSelectorVal = types.ListUnknown(types.StringType)
	case v.UplinkSelector.IsNull():
		uplinkSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		uplinkSelectorVal, d = types.ListValue(types.StringType, v.UplinkSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"egress_1": basetypes.ObjectType{
				AttrTypes: Egress1Value{}.AttributeTypes(ctx),
			},
			"ingress_1": basetypes.ObjectType{
				AttrTypes: Ingress1Value{}.AttributeTypes(ctx),
			},
			"uplink_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"uplink_vlanid":   basetypes.StringType{},
			"uplink_vlanpool": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"egress_1": basetypes.ObjectType{
			AttrTypes: Egress1Value{}.AttributeTypes(ctx),
		},
		"ingress_1": basetypes.ObjectType{
			AttrTypes: Ingress1Value{}.AttributeTypes(ctx),
		},
		"uplink_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"uplink_vlanid":   basetypes.StringType{},
		"uplink_vlanpool": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"egress_1":        egress1,
			"ingress_1":       ingress1,
			"uplink_selector": uplinkSelectorVal,
			"uplink_vlanid":   v.UplinkVlanid,
			"uplink_vlanpool": v.UplinkVlanpool,
		})

	return objVal, diags
}

func (v UplinkValue) Equal(o attr.Value) bool {
	other, ok := o.(UplinkValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Egress1.Equal(other.Egress1) {
		return false
	}

	if !v.Ingress1.Equal(other.Ingress1) {
		return false
	}

	if !v.UplinkSelector.Equal(other.UplinkSelector) {
		return false
	}

	if !v.UplinkVlanid.Equal(other.UplinkVlanid) {
		return false
	}

	if !v.UplinkVlanpool.Equal(other.UplinkVlanpool) {
		return false
	}

	return true
}

func (v UplinkValue) Type(ctx context.Context) attr.Type {
	return UplinkType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UplinkValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"egress_1": basetypes.ObjectType{
			AttrTypes: Egress1Value{}.AttributeTypes(ctx),
		},
		"ingress_1": basetypes.ObjectType{
			AttrTypes: Ingress1Value{}.AttributeTypes(ctx),
		},
		"uplink_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"uplink_vlanid":   basetypes.StringType{},
		"uplink_vlanpool": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Egress1Type{}

type Egress1Type struct {
	basetypes.ObjectType
}

func (t Egress1Type) Equal(o attr.Type) bool {
	other, ok := o.(Egress1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Egress1Type) String() string {
	return "Egress1Type"
}

func (t Egress1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Egress1Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgress1ValueNull() Egress1Value {
	return Egress1Value{
		state: attr.ValueStateNull,
	}
}

func NewEgress1ValueUnknown() Egress1Value {
	return Egress1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewEgress1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Egress1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Egress1Value Attribute Value",
				"While creating a Egress1Value value, a missing attribute value was detected. "+
					"A Egress1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Egress1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Egress1Value Attribute Type",
				"While creating a Egress1Value value, an invalid attribute value was detected. "+
					"A Egress1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Egress1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Egress1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Egress1Value Attribute Value",
				"While creating a Egress1Value value, an extra attribute value was detected. "+
					"A Egress1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Egress1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEgress1ValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewEgress1ValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewEgress1ValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewEgress1ValueUnknown(), diags
	}

	return Egress1Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgress1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Egress1Value {
	object, diags := NewEgress1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEgress1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Egress1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEgress1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEgress1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEgress1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEgress1ValueMust(Egress1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Egress1Type) ValueType(ctx context.Context) attr.Value {
	return Egress1Value{}
}

var _ basetypes.ObjectValuable = Egress1Value{}

type Egress1Value struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v Egress1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Egress1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Egress1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Egress1Value) String() string {
	return "Egress1Value"
}

func (v Egress1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v Egress1Value) Equal(o attr.Value) bool {
	other, ok := o.(Egress1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v Egress1Value) Type(ctx context.Context) attr.Type {
	return Egress1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Egress1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Ingress1Type{}

type Ingress1Type struct {
	basetypes.ObjectType
}

func (t Ingress1Type) Equal(o attr.Type) bool {
	other, ok := o.(Ingress1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ingress1Type) String() string {
	return "Ingress1Type"
}

func (t Ingress1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ingress1Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngress1ValueNull() Ingress1Value {
	return Ingress1Value{
		state: attr.ValueStateNull,
	}
}

func NewIngress1ValueUnknown() Ingress1Value {
	return Ingress1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIngress1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ingress1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ingress1Value Attribute Value",
				"While creating a Ingress1Value value, a missing attribute value was detected. "+
					"A Ingress1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ingress1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ingress1Value Attribute Type",
				"While creating a Ingress1Value value, an invalid attribute value was detected. "+
					"A Ingress1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ingress1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ingress1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ingress1Value Attribute Value",
				"While creating a Ingress1Value value, an extra attribute value was detected. "+
					"A Ingress1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ingress1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIngress1ValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewIngress1ValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewIngress1ValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewIngress1ValueUnknown(), diags
	}

	return Ingress1Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngress1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ingress1Value {
	object, diags := NewIngress1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIngress1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ingress1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIngress1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIngress1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIngress1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIngress1ValueMust(Ingress1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ingress1Type) ValueType(ctx context.Context) attr.Value {
	return Ingress1Value{}
}

var _ basetypes.ObjectValuable = Ingress1Value{}

type Ingress1Value struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v Ingress1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ingress1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ingress1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ingress1Value) String() string {
	return "Ingress1Value"
}

func (v Ingress1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v Ingress1Value) Equal(o attr.Value) bool {
	other, ok := o.(Ingress1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v Ingress1Value) Type(ctx context.Context) attr.Type {
	return Ingress1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ingress1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return nil, diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return nil, diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	subInterfacesAttribute, ok := attributes["sub_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_interfaces is missing from object`)

		return nil, diags
	}

	subInterfacesVal, ok := subInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_interfaces expected to be basetypes.ListValue, was: %T`, subInterfacesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		LastChange:        lastChangeVal,
		OperationalState:  operationalStateVal,
		SubInterfaces:     subInterfacesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	subInterfacesAttribute, ok := attributes["sub_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_interfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	subInterfacesVal, ok := subInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_interfaces expected to be basetypes.ListValue, was: %T`, subInterfacesAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		LastChange:        lastChangeVal,
		OperationalState:  operationalStateVal,
		SubInterfaces:     subInterfacesVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Health            basetypes.Int64Value  `tfsdk:"health"`
	HealthScoreReason basetypes.StringValue `tfsdk:"health_score_reason"`
	LastChange        basetypes.StringValue `tfsdk:"last_change"`
	OperationalState  basetypes.StringValue `tfsdk:"operational_state"`
	SubInterfaces     basetypes.ListValue   `tfsdk:"sub_interfaces"`
	state             attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["health"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_score_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sub_interfaces"] = basetypes.ListType{
		ElemType: SubInterfacesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Health.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health"] = val

		val, err = v.HealthScoreReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_score_reason"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		val, err = v.SubInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sub_interfaces"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	subInterfaces := types.ListValueMust(
		SubInterfacesType{
			basetypes.ObjectType{
				AttrTypes: SubInterfacesValue{}.AttributeTypes(ctx),
			},
		},
		v.SubInterfaces.Elements(),
	)

	if v.SubInterfaces.IsNull() {
		subInterfaces = types.ListNull(
			SubInterfacesType{
				basetypes.ObjectType{
					AttrTypes: SubInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.SubInterfaces.IsUnknown() {
		subInterfaces = types.ListUnknown(
			SubInterfacesType{
				basetypes.ObjectType{
					AttrTypes: SubInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"operational_state":   basetypes.StringType{},
		"sub_interfaces": basetypes.ListType{
			ElemType: SubInterfacesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"health":              v.Health,
			"health_score_reason": v.HealthScoreReason,
			"last_change":         v.LastChange,
			"operational_state":   v.OperationalState,
			"sub_interfaces":      subInterfaces,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Health.Equal(other.Health) {
		return false
	}

	if !v.HealthScoreReason.Equal(other.HealthScoreReason) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	if !v.SubInterfaces.Equal(other.SubInterfaces) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"operational_state":   basetypes.StringType{},
		"sub_interfaces": basetypes.ListType{
			ElemType: SubInterfacesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = SubInterfacesType{}

type SubInterfacesType struct {
	basetypes.ObjectType
}

func (t SubInterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(SubInterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SubInterfacesType) String() string {
	return "SubInterfacesType"
}

func (t SubInterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceResourceAttribute, ok := attributes["interface_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_resource is missing from object`)

		return nil, diags
	}

	interfaceResourceVal, ok := interfaceResourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_resource expected to be basetypes.StringValue, was: %T`, interfaceResourceAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	nodeInterfaceAttribute, ok := attributes["node_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_interface is missing from object`)

		return nil, diags
	}

	nodeInterfaceVal, ok := nodeInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_interface expected to be basetypes.StringValue, was: %T`, nodeInterfaceAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	subInterfaceIndexAttribute, ok := attributes["sub_interface_index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_interface_index is missing from object`)

		return nil, diags
	}

	subInterfaceIndexVal, ok := subInterfaceIndexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_interface_index expected to be basetypes.Int64Value, was: %T`, subInterfaceIndexAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SubInterfacesValue{
		Enabled:           enabledVal,
		Interface:         interfaceVal,
		InterfaceResource: interfaceResourceVal,
		LastChange:        lastChangeVal,
		Node:              nodeVal,
		NodeInterface:     nodeInterfaceVal,
		OperatingSystem:   operatingSystemVal,
		OperationalState:  operationalStateVal,
		SubInterfaceIndex: subInterfaceIndexVal,
		VlanId:            vlanIdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSubInterfacesValueNull() SubInterfacesValue {
	return SubInterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewSubInterfacesValueUnknown() SubInterfacesValue {
	return SubInterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSubInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SubInterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SubInterfacesValue Attribute Value",
				"While creating a SubInterfacesValue value, a missing attribute value was detected. "+
					"A SubInterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubInterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SubInterfacesValue Attribute Type",
				"While creating a SubInterfacesValue value, an invalid attribute value was detected. "+
					"A SubInterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SubInterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SubInterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SubInterfacesValue Attribute Value",
				"While creating a SubInterfacesValue value, an extra attribute value was detected. "+
					"A SubInterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SubInterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSubInterfacesValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSubInterfacesValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewSubInterfacesValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceResourceAttribute, ok := attributes["interface_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_resource is missing from object`)

		return NewSubInterfacesValueUnknown(), diags
	}

	interfaceResourceVal, ok := interfaceResourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_resource expected to be basetypes.StringValue, was: %T`, interfaceResourceAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewSubInterfacesValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewSubInterfacesValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	nodeInterfaceAttribute, ok := attributes["node_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_interface is missing from object`)

		return NewSubInterfacesValueUnknown(), diags
	}

	nodeInterfaceVal, ok := nodeInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_interface expected to be basetypes.StringValue, was: %T`, nodeInterfaceAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewSubInterfacesValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewSubInterfacesValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	subInterfaceIndexAttribute, ok := attributes["sub_interface_index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_interface_index is missing from object`)

		return NewSubInterfacesValueUnknown(), diags
	}

	subInterfaceIndexVal, ok := subInterfaceIndexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_interface_index expected to be basetypes.Int64Value, was: %T`, subInterfaceIndexAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewSubInterfacesValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewSubInterfacesValueUnknown(), diags
	}

	return SubInterfacesValue{
		Enabled:           enabledVal,
		Interface:         interfaceVal,
		InterfaceResource: interfaceResourceVal,
		LastChange:        lastChangeVal,
		Node:              nodeVal,
		NodeInterface:     nodeInterfaceVal,
		OperatingSystem:   operatingSystemVal,
		OperationalState:  operationalStateVal,
		SubInterfaceIndex: subInterfaceIndexVal,
		VlanId:            vlanIdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewSubInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SubInterfacesValue {
	object, diags := NewSubInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSubInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SubInterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSubInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSubInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSubInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSubInterfacesValueMust(SubInterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SubInterfacesType) ValueType(ctx context.Context) attr.Value {
	return SubInterfacesValue{}
}

var _ basetypes.ObjectValuable = SubInterfacesValue{}

type SubInterfacesValue struct {
	Enabled           basetypes.BoolValue   `tfsdk:"enabled"`
	Interface         basetypes.StringValue `tfsdk:"interface"`
	InterfaceResource basetypes.StringValue `tfsdk:"interface_resource"`
	LastChange        basetypes.StringValue `tfsdk:"last_change"`
	Node              basetypes.StringValue `tfsdk:"node"`
	NodeInterface     basetypes.StringValue `tfsdk:"node_interface"`
	OperatingSystem   basetypes.StringValue `tfsdk:"operating_system"`
	OperationalState  basetypes.StringValue `tfsdk:"operational_state"`
	SubInterfaceIndex basetypes.Int64Value  `tfsdk:"sub_interface_index"`
	VlanId            basetypes.StringValue `tfsdk:"vlan_id"`
	state             attr.ValueState
}

func (v SubInterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_resource"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sub_interface_index"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.InterfaceResource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_resource"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.NodeInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_interface"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		val, err = v.SubInterfaceIndex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sub_interface_index"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SubInterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SubInterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SubInterfacesValue) String() string {
	return "SubInterfacesValue"
}

func (v SubInterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":             basetypes.BoolType{},
		"interface":           basetypes.StringType{},
		"interface_resource":  basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"node":                basetypes.StringType{},
		"node_interface":      basetypes.StringType{},
		"operating_system":    basetypes.StringType{},
		"operational_state":   basetypes.StringType{},
		"sub_interface_index": basetypes.Int64Type{},
		"vlan_id":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":             v.Enabled,
			"interface":           v.Interface,
			"interface_resource":  v.InterfaceResource,
			"last_change":         v.LastChange,
			"node":                v.Node,
			"node_interface":      v.NodeInterface,
			"operating_system":    v.OperatingSystem,
			"operational_state":   v.OperationalState,
			"sub_interface_index": v.SubInterfaceIndex,
			"vlan_id":             v.VlanId,
		})

	return objVal, diags
}

func (v SubInterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(SubInterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.InterfaceResource.Equal(other.InterfaceResource) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.NodeInterface.Equal(other.NodeInterface) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	if !v.SubInterfaceIndex.Equal(other.SubInterfaceIndex) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v SubInterfacesValue) Type(ctx context.Context) attr.Type {
	return SubInterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SubInterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":             basetypes.BoolType{},
		"interface":           basetypes.StringType{},
		"interface_resource":  basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"node":                basetypes.StringType{},
		"node_interface":      basetypes.StringType{},
		"operating_system":    basetypes.StringType{},
		"operational_state":   basetypes.StringType{},
		"sub_interface_index": basetypes.Int64Type{},
		"vlan_id":             basetypes.StringType{},
	}
}
