// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_irb_interface

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func IrbInterfaceDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"hash": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "resource content will be returned as it was at the time of this git hash",
				MarkdownDescription: "resource content will be returned as it was at the time of this git hash",
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"metadata": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"annotations": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"labels": schema.MapAttribute{
						ElementType: types.StringType,
						Computed:    true,
					},
					"name": schema.StringAttribute{
						Computed: true,
					},
					"namespace": schema.StringAttribute{
						Computed: true,
					},
				},
				CustomType: MetadataType{
					ObjectType: types.ObjectType{
						AttrTypes: MetadataValue{}.AttributeTypes(ctx),
					},
				},
				Computed: true,
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "name of the IRBInterface",
				MarkdownDescription: "name of the IRBInterface",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
			"spec": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"anycast_gateway_mac": schema.StringAttribute{
						Optional:            true,
						Description:         "The gateway MAC to use on the anycast address, if left empty the node will automatically assign one.",
						MarkdownDescription: "The gateway MAC to use on the anycast address, if left empty the node will automatically assign one.",
					},
					"arp_timeout": schema.Int64Attribute{
						Optional:            true,
						Description:         "Duration of time that dynamic ARP entries remain in the ARP cache before they expire.",
						MarkdownDescription: "Duration of time that dynamic ARP entries remain in the ARP cache before they expire.",
					},
					"bfd": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"desired_min_transmit_int": schema.Int64Attribute{
								Optional:            true,
								Description:         "The minimum interval in microseconds between transmission of BFD control packets.",
								MarkdownDescription: "The minimum interval in microseconds between transmission of BFD control packets.",
							},
							"detection_multiplier": schema.Int64Attribute{
								Optional:            true,
								Description:         "The number of packets that must be missed to declare this session as down.",
								MarkdownDescription: "The number of packets that must be missed to declare this session as down.",
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enables Biforward Detection.",
								MarkdownDescription: "Enables Biforward Detection.",
							},
							"min_echo_receive_interval": schema.Int64Attribute{
								Optional:            true,
								Description:         "The minimum interval between echo packets the local node can receive.",
								MarkdownDescription: "The minimum interval between echo packets the local node can receive.",
							},
							"required_min_receive": schema.Int64Attribute{
								Optional:            true,
								Description:         "The minimum interval in microseconds between received BFD control packets that this system should support.",
								MarkdownDescription: "The minimum interval in microseconds between received BFD control packets that this system should support.",
							},
							"ttl": schema.Int64Attribute{
								Optional:            true,
								Description:         "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not appllicable to single-hop BFD sessions.",
								MarkdownDescription: "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not appllicable to single-hop BFD sessions.",
							},
						},
						CustomType: BfdType{
							ObjectType: types.ObjectType{
								AttrTypes: BfdValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Enable BFD on the IRBInterface.",
						MarkdownDescription: "Enable BFD on the IRBInterface.",
					},
					"bridge_domain": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to a BridgeDomain.",
						MarkdownDescription: "Reference to a BridgeDomain.",
					},
					"description": schema.StringAttribute{
						Optional:            true,
						Description:         "The description of the IRBInterface.",
						MarkdownDescription: "The description of the IRBInterface.",
					},
					"egress": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"filters": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "List of Filter references to use at egress.",
								MarkdownDescription: "List of Filter references to use at egress.",
							},
							"qos_policy": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "List of QoS Egress policy references to use at egress.",
								MarkdownDescription: "List of QoS Egress policy references to use at egress.",
							},
						},
						CustomType: EgressType{
							ObjectType: types.ObjectType{
								AttrTypes: EgressValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Manages actions on traffic at Egress.",
						MarkdownDescription: "Manages actions on traffic at Egress.",
					},
					"evpn_route_advertisement_type": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"arp_dynamic": schema.BoolAttribute{
								Optional:            true,
								Description:         "Advertise dynamic ARP entries.",
								MarkdownDescription: "Advertise dynamic ARP entries.",
							},
							"arp_static": schema.BoolAttribute{
								Optional:            true,
								Description:         "Advertise static ARP entries.",
								MarkdownDescription: "Advertise static ARP entries.",
							},
							"nd_dynamic": schema.BoolAttribute{
								Optional:            true,
								Description:         "Advertise dynamic ND entries.",
								MarkdownDescription: "Advertise dynamic ND entries.",
							},
							"nd_static": schema.BoolAttribute{
								Optional:            true,
								Description:         "Advertise static ND entries.",
								MarkdownDescription: "Advertise static ND entries.",
							},
						},
						CustomType: EvpnRouteAdvertisementTypeType{
							ObjectType: types.ObjectType{
								AttrTypes: EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Controls the type of ARP/ND entries to advertise.",
						MarkdownDescription: "Controls the type of ARP/ND entries to advertise.",
					},
					"host_route_populate": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"dynamic": schema.BoolAttribute{
								Optional:            true,
								Description:         "Create host routes out of dynamic ARP entries.",
								MarkdownDescription: "Create host routes out of dynamic ARP entries.",
							},
							"evpn": schema.BoolAttribute{
								Optional:            true,
								Description:         "Create host routes out of EVPN learned ARP entries.",
								MarkdownDescription: "Create host routes out of EVPN learned ARP entries.",
							},
							"static": schema.BoolAttribute{
								Optional:            true,
								Description:         "Create host routes out of static ARP entries.",
								MarkdownDescription: "Create host routes out of static ARP entries.",
							},
						},
						CustomType: HostRoutePopulateType{
							ObjectType: types.ObjectType{
								AttrTypes: HostRoutePopulateValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Configures host route population based on ARP entries.",
						MarkdownDescription: "Configures host route population based on ARP entries.",
					},
					"ingress": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"filters": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "List of Filter references to use at ingress.",
								MarkdownDescription: "List of Filter references to use at ingress.",
							},
							"qos_policy": schema.ListAttribute{
								ElementType:         types.StringType,
								Optional:            true,
								Description:         "List of QoS Ingress policy references to use at ingress.",
								MarkdownDescription: "List of QoS Ingress policy references to use at ingress.",
							},
						},
						CustomType: IngressType{
							ObjectType: types.ObjectType{
								AttrTypes: IngressValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "Manages actions on traffic at Ingress.",
						MarkdownDescription: "Manages actions on traffic at Ingress.",
					},
					"ip_addresses": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"ipv4address": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"ip_prefix": schema.StringAttribute{
											Optional:            true,
											Description:         "Address and mask to use",
											MarkdownDescription: "Address and mask to use",
										},
										"primary": schema.BoolAttribute{
											Optional:            true,
											Description:         "Indicates which address to use as primary for broadcast",
											MarkdownDescription: "Indicates which address to use as primary for broadcast",
										},
									},
									CustomType: Ipv4addressType{
										ObjectType: types.ObjectType{
											AttrTypes: Ipv4addressValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "IPv4 address in IP/mask form, e.g., 192.168.0.1/24.",
									MarkdownDescription: "IPv4 address in IP/mask form, e.g., 192.168.0.1/24.",
								},
								"ipv6address": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"ip_prefix": schema.StringAttribute{
											Optional:            true,
											Description:         "Address and mask to use",
											MarkdownDescription: "Address and mask to use",
										},
										"primary": schema.BoolAttribute{
											Optional:            true,
											Description:         "Indicates which address to use as primary for broadcast",
											MarkdownDescription: "Indicates which address to use as primary for broadcast",
										},
									},
									CustomType: Ipv6addressType{
										ObjectType: types.ObjectType{
											AttrTypes: Ipv6addressValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "IPv6 address in IP/mask form, e.g., fc00::1/120.",
									MarkdownDescription: "IPv6 address in IP/mask form, e.g., fc00::1/120.",
								},
								"node": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to a TopoNode resource, if not specified the IP address will be assigned to all nodes on which the IRB is deployed.  If specified the IP address will be assigned to the specified node.",
									MarkdownDescription: "Reference to a TopoNode resource, if not specified the IP address will be assigned to all nodes on which the IRB is deployed.  If specified the IP address will be assigned to the specified node.",
								},
							},
							CustomType: IpAddressesType{
								ObjectType: types.ObjectType{
									AttrTypes: IpAddressesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional: true,
					},
					"ip_mtu": schema.Int64Attribute{
						Optional:            true,
						Description:         "IP MTU for the IRBInterface [default=1500].",
						MarkdownDescription: "IP MTU for the IRBInterface [default=1500].",
					},
					"ipv4parameters": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"directed_broadcast": schema.BoolAttribute{
								Optional:            true,
								Description:         "Allow receiving and forwarding of directed broadcast packets. Enabled when set to true.",
								MarkdownDescription: "Allow receiving and forwarding of directed broadcast packets. Enabled when set to true.",
							},
						},
						CustomType: Ipv4parametersType{
							ObjectType: types.ObjectType{
								AttrTypes: Ipv4parametersValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"ipv6router_advertisement": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"current_hop_limit": schema.Int64Attribute{
								Optional:            true,
								Description:         "The current hop limit to advertise in the router advertisement messages.",
								MarkdownDescription: "The current hop limit to advertise in the router advertisement messages.",
							},
							"enabled": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enable or disable IPv6 router advertisements.",
								MarkdownDescription: "Enable or disable IPv6 router advertisements.",
							},
							"ip_mtu": schema.Int64Attribute{
								Optional:            true,
								Description:         "The IP MTU to advertise in the router advertisement messages.",
								MarkdownDescription: "The IP MTU to advertise in the router advertisement messages.",
							},
							"managed_configuration_flag": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enable DHCPv6 for address configuration (M-bit).",
								MarkdownDescription: "Enable DHCPv6 for address configuration (M-bit).",
							},
							"max_advertisement_interval": schema.Int64Attribute{
								Optional:            true,
								Description:         "Maximum time between router advertisements (in seconds).",
								MarkdownDescription: "Maximum time between router advertisements (in seconds).",
							},
							"min_advertisement_interval": schema.Int64Attribute{
								Optional:            true,
								Description:         "Minimum time between router advertisements (in seconds).",
								MarkdownDescription: "Minimum time between router advertisements (in seconds).",
							},
							"other_configuration_flag": schema.BoolAttribute{
								Optional:            true,
								Description:         "Enable DHCPv6 for other configuration (O-bit).",
								MarkdownDescription: "Enable DHCPv6 for other configuration (O-bit).",
							},
							"prefixes": schema.ListNestedAttribute{
								NestedObject: schema.NestedAttributeObject{
									Attributes: map[string]schema.Attribute{
										"autonomous_flag": schema.BoolAttribute{
											Optional:            true,
											Description:         "When this is set in the prefix information option hosts can use the prefix for stateless address autoconfiguration (SLAAC).",
											MarkdownDescription: "When this is set in the prefix information option hosts can use the prefix for stateless address autoconfiguration (SLAAC).",
										},
										"on_link_flag": schema.BoolAttribute{
											Optional:            true,
											Description:         "When this is set in the prefix information option hosts can use the prefix for on-link determination.",
											MarkdownDescription: "When this is set in the prefix information option hosts can use the prefix for on-link determination.",
										},
										"preferred_lifetime": schema.Int64Attribute{
											Optional:            true,
											Description:         "The length of time in seconds (relative to the time the packet is sent) that addresses generated from the prefix via stateless address autoconfiguration remain preferred.",
											MarkdownDescription: "The length of time in seconds (relative to the time the packet is sent) that addresses generated from the prefix via stateless address autoconfiguration remain preferred.",
										},
										"prefix": schema.StringAttribute{
											Optional:            true,
											Description:         "An IPv6 global unicast address prefix.",
											MarkdownDescription: "An IPv6 global unicast address prefix.",
										},
										"valid_lifetime": schema.Int64Attribute{
											Optional:            true,
											Description:         "The length of time in seconds (relative to the time the packet is sent) that the prefix is valid for the purpose of on-link determination.",
											MarkdownDescription: "The length of time in seconds (relative to the time the packet is sent) that the prefix is valid for the purpose of on-link determination.",
										},
									},
									CustomType: PrefixesType{
										ObjectType: types.ObjectType{
											AttrTypes: PrefixesValue{}.AttributeTypes(ctx),
										},
									},
								},
								Optional:            true,
								Description:         "IPv6 prefixes to advertise in router advertisements.",
								MarkdownDescription: "IPv6 prefixes to advertise in router advertisements.",
							},
							"reachable_time": schema.Int64Attribute{
								Optional:            true,
								Description:         "Time in milliseconds for Neighbor Unreachability Detection.",
								MarkdownDescription: "Time in milliseconds for Neighbor Unreachability Detection.",
							},
							"retransmit_time": schema.Int64Attribute{
								Optional:            true,
								Description:         "Time in milliseconds between retransmitted NS messages.",
								MarkdownDescription: "Time in milliseconds between retransmitted NS messages.",
							},
							"router_lifetime": schema.Int64Attribute{
								Optional:            true,
								Description:         "Router lifetime in seconds for default gateway.",
								MarkdownDescription: "Router lifetime in seconds for default gateway.",
							},
						},
						CustomType: Ipv6routerAdvertisementType{
							ObjectType: types.ObjectType{
								AttrTypes: Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
							},
						},
						Optional: true,
					},
					"l3proxy_arpnd": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"proxy_arp": schema.BoolAttribute{
								Optional:            true,
								Description:         "Select whether Proxy ARP should be enabled.",
								MarkdownDescription: "Select whether Proxy ARP should be enabled.",
							},
							"proxy_nd": schema.BoolAttribute{
								Optional:            true,
								Description:         "Select whether Proxy ND should be enabled.",
								MarkdownDescription: "Select whether Proxy ND should be enabled.",
							},
						},
						CustomType: L3proxyArpndType{
							ObjectType: types.ObjectType{
								AttrTypes: L3proxyArpndValue{}.AttributeTypes(ctx),
							},
						},
						Optional:            true,
						Description:         "L3 Proxy ARP and ND configuration.",
						MarkdownDescription: "L3 Proxy ARP and ND configuration.",
					},
					"learn_unsolicited": schema.StringAttribute{
						Optional:            true,
						Description:         "Enable or disable learning of unsolicited ARPs.",
						MarkdownDescription: "Enable or disable learning of unsolicited ARPs.",
					},
					"router": schema.StringAttribute{
						Optional:            true,
						Description:         "Reference to a Router.",
						MarkdownDescription: "Reference to a Router.",
					},
					"unnumbered": schema.StringAttribute{
						Optional:            true,
						Description:         "Enables the use of unnumbered interfaces on the IRBInterface.  If IPv6 is specified, no IP address are configured on the sub-interface and only the link local address will be used.  If any IP addresses are specified for either IPv4 or IPv6 that will take precedence and IPs will be assigned to the interfaces.(Deprecated, Use IPv6RouterAdvertisement)",
						MarkdownDescription: "Enables the use of unnumbered interfaces on the IRBInterface.  If IPv6 is specified, no IP address are configured on the sub-interface and only the link local address will be used.  If any IP addresses are specified for either IPv4 or IPv6 that will take precedence and IPs will be assigned to the interfaces.(Deprecated, Use IPv6RouterAdvertisement)",
					},
					"virtual_ipdiscovery": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"address": schema.StringAttribute{
									Optional:            true,
									Description:         "Virtual IP Address.",
									MarkdownDescription: "Virtual IP Address.",
								},
								"allowed_mac": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "List of allowed MAC addresses for a discovered virtual IP address.",
									MarkdownDescription: "List of allowed MAC addresses for a discovered virtual IP address.",
								},
								"bridge_interface_to_probe": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "List of BridgeInterfaces on the associated MAC-VRF to which the ARP probes are sent. If left blank, the probes are sent on all BridgeInterfaces associated with the BridgeDomain.",
									MarkdownDescription: "List of BridgeInterfaces on the associated MAC-VRF to which the ARP probes are sent. If left blank, the probes are sent on all BridgeInterfaces associated with the BridgeDomain.",
								},
								"probe_interval": schema.Int64Attribute{
									Optional:            true,
									Description:         "ARP probe interval in seconds.",
									MarkdownDescription: "ARP probe interval in seconds.",
								},
								"vlan_to_probe": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Description:         "List of VLANs on the associated BridgeDomain to which the ARP probes are sent.  If left blank, the probes are sent on all VLANs associated with the BridgeDomain.",
									MarkdownDescription: "List of VLANs on the associated BridgeDomain to which the ARP probes are sent.  If left blank, the probes are sent on all VLANs associated with the BridgeDomain.",
								},
							},
							CustomType: VirtualIpdiscoveryType{
								ObjectType: types.ObjectType{
									AttrTypes: VirtualIpdiscoveryValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Description:         "Configuration for Virtual IP discovery on the interface.",
						MarkdownDescription: "Configuration for Virtual IP discovery on the interface.",
					},
				},
				CustomType: SpecType{
					ObjectType: types.ObjectType{
						AttrTypes: SpecValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Description:         "The IRBInterface enables the configuration and management of Layer 3 interfaces associated with a BridgeDomain. This resource allows for the specification of various parameters, including IP MTU, learning of unsolicited ARPs, IPv4 and IPv6 addresses, and unnumbered interface settings. It also supports advanced features such as BFD configuration, Virtual IP discovery, and ARP/ND-related settings like Proxy ARP/ND and EVPN route advertisement.",
				MarkdownDescription: "The IRBInterface enables the configuration and management of Layer 3 interfaces associated with a BridgeDomain. This resource allows for the specification of various parameters, including IP MTU, learning of unsolicited ARPs, IPv4 and IPv6 addresses, and unnumbered interface settings. It also supports advanced features such as BFD configuration, Virtual IP discovery, and ARP/ND-related settings like Proxy ARP/ND and EVPN route advertisement.",
			},
			"status": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"health": schema.Int64Attribute{
						Computed:            true,
						Description:         "Indicates the health score of the VNET.",
						MarkdownDescription: "Indicates the health score of the VNET.",
					},
					"health_score_reason": schema.StringAttribute{
						Computed:            true,
						Description:         "Explains the reason for the health score.",
						MarkdownDescription: "Explains the reason for the health score.",
					},
					"interfaces": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"enabled": schema.BoolAttribute{
									Computed:            true,
									Description:         "Administrative status of the SubInterface.",
									MarkdownDescription: "Administrative status of the SubInterface.",
								},
								"ipv4addresses": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"ip_prefix": schema.StringAttribute{
												Computed:            true,
												Description:         "Address and mask to use",
												MarkdownDescription: "Address and mask to use",
											},
											"primary": schema.BoolAttribute{
												Computed:            true,
												Description:         "Indicates which address to use as primary for broadcast",
												MarkdownDescription: "Indicates which address to use as primary for broadcast",
											},
										},
										CustomType: Ipv4addressesType{
											ObjectType: types.ObjectType{
												AttrTypes: Ipv4addressesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "List of IPv4 addresses",
									MarkdownDescription: "List of IPv4 addresses",
								},
								"ipv6addresses": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"ip_prefix": schema.StringAttribute{
												Computed:            true,
												Description:         "Address and mask to use",
												MarkdownDescription: "Address and mask to use",
											},
											"primary": schema.BoolAttribute{
												Computed:            true,
												Description:         "Indicates which address to use as primary for broadcast",
												MarkdownDescription: "Indicates which address to use as primary for broadcast",
											},
										},
										CustomType: Ipv6addressesType{
											ObjectType: types.ObjectType{
												AttrTypes: Ipv6addressesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "List of IPv6 addresses",
									MarkdownDescription: "List of IPv6 addresses",
								},
								"last_change": schema.StringAttribute{
									Computed:            true,
									Description:         "Timestamp of when this SubInterface last changed state.",
									MarkdownDescription: "Timestamp of when this SubInterface last changed state.",
								},
								"node": schema.StringAttribute{
									Computed:            true,
									Description:         "Reference to Node object.",
									MarkdownDescription: "Reference to Node object.",
								},
								"node_interface": schema.StringAttribute{
									Computed:            true,
									Description:         "Node specific interface name.",
									MarkdownDescription: "Node specific interface name.",
								},
								"operating_system": schema.StringAttribute{
									Computed:            true,
									Description:         "Operating System of the Node.",
									MarkdownDescription: "Operating System of the Node.",
								},
								"operational_state": schema.StringAttribute{
									Computed:            true,
									Description:         "Current operational state of the SubInterface.",
									MarkdownDescription: "Current operational state of the SubInterface.",
								},
							},
							CustomType: InterfacesType{
								ObjectType: types.ObjectType{
									AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed:            true,
						Description:         "Details of the interfaces associated with the IRB.",
						MarkdownDescription: "Details of the interfaces associated with the IRB.",
					},
					"last_change": schema.StringAttribute{
						Computed:            true,
						Description:         "Timestamp of the last state change.",
						MarkdownDescription: "Timestamp of the last state change.",
					},
					"operational_state": schema.StringAttribute{
						Computed:            true,
						Description:         "Operational state of the VNET.",
						MarkdownDescription: "Operational state of the VNET.",
					},
				},
				CustomType: StatusType{
					ObjectType: types.ObjectType{
						AttrTypes: StatusValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "IRBInterfaceStatus defines the observed state of IRBInterface",
				MarkdownDescription: "IRBInterfaceStatus defines the observed state of IRBInterface",
			},
		},
	}
}

type IrbInterfaceModel struct {
	ApiVersion types.String  `tfsdk:"api_version"`
	Hash       types.String  `tfsdk:"hash"`
	Kind       types.String  `tfsdk:"kind"`
	Metadata   MetadataValue `tfsdk:"metadata"`
	Name       types.String  `tfsdk:"name"`
	Namespace  types.String  `tfsdk:"namespace"`
	Spec       SpecValue     `tfsdk:"spec"`
	Status     StatusValue   `tfsdk:"status"`
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	anycastGatewayMacAttribute, ok := attributes["anycast_gateway_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anycast_gateway_mac is missing from object`)

		return nil, diags
	}

	anycastGatewayMacVal, ok := anycastGatewayMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anycast_gateway_mac expected to be basetypes.StringValue, was: %T`, anycastGatewayMacAttribute))
	}

	arpTimeoutAttribute, ok := attributes["arp_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_timeout is missing from object`)

		return nil, diags
	}

	arpTimeoutVal, ok := arpTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_timeout expected to be basetypes.Int64Value, was: %T`, arpTimeoutAttribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return nil, diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	bridgeDomainAttribute, ok := attributes["bridge_domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_domain is missing from object`)

		return nil, diags
	}

	bridgeDomainVal, ok := bridgeDomainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_domain expected to be basetypes.StringValue, was: %T`, bridgeDomainAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egressAttribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress is missing from object`)

		return nil, diags
	}

	egressVal, ok := egressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress expected to be basetypes.ObjectValue, was: %T`, egressAttribute))
	}

	evpnRouteAdvertisementTypeAttribute, ok := attributes["evpn_route_advertisement_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_route_advertisement_type is missing from object`)

		return nil, diags
	}

	evpnRouteAdvertisementTypeVal, ok := evpnRouteAdvertisementTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_route_advertisement_type expected to be basetypes.ObjectValue, was: %T`, evpnRouteAdvertisementTypeAttribute))
	}

	hostRoutePopulateAttribute, ok := attributes["host_route_populate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_route_populate is missing from object`)

		return nil, diags
	}

	hostRoutePopulateVal, ok := hostRoutePopulateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_route_populate expected to be basetypes.ObjectValue, was: %T`, hostRoutePopulateAttribute))
	}

	ingressAttribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress is missing from object`)

		return nil, diags
	}

	ingressVal, ok := ingressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress expected to be basetypes.ObjectValue, was: %T`, ingressAttribute))
	}

	ipAddressesAttribute, ok := attributes["ip_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_addresses is missing from object`)

		return nil, diags
	}

	ipAddressesVal, ok := ipAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_addresses expected to be basetypes.ListValue, was: %T`, ipAddressesAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return nil, diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	ipv4parametersAttribute, ok := attributes["ipv4parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4parameters is missing from object`)

		return nil, diags
	}

	ipv4parametersVal, ok := ipv4parametersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4parameters expected to be basetypes.ObjectValue, was: %T`, ipv4parametersAttribute))
	}

	ipv6routerAdvertisementAttribute, ok := attributes["ipv6router_advertisement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6router_advertisement is missing from object`)

		return nil, diags
	}

	ipv6routerAdvertisementVal, ok := ipv6routerAdvertisementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6router_advertisement expected to be basetypes.ObjectValue, was: %T`, ipv6routerAdvertisementAttribute))
	}

	l3proxyArpndAttribute, ok := attributes["l3proxy_arpnd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3proxy_arpnd is missing from object`)

		return nil, diags
	}

	l3proxyArpndVal, ok := l3proxyArpndAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3proxy_arpnd expected to be basetypes.ObjectValue, was: %T`, l3proxyArpndAttribute))
	}

	learnUnsolicitedAttribute, ok := attributes["learn_unsolicited"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`learn_unsolicited is missing from object`)

		return nil, diags
	}

	learnUnsolicitedVal, ok := learnUnsolicitedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`learn_unsolicited expected to be basetypes.StringValue, was: %T`, learnUnsolicitedAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return nil, diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return nil, diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	virtualIpdiscoveryAttribute, ok := attributes["virtual_ipdiscovery"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`virtual_ipdiscovery is missing from object`)

		return nil, diags
	}

	virtualIpdiscoveryVal, ok := virtualIpdiscoveryAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`virtual_ipdiscovery expected to be basetypes.ListValue, was: %T`, virtualIpdiscoveryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		AnycastGatewayMac:          anycastGatewayMacVal,
		ArpTimeout:                 arpTimeoutVal,
		Bfd:                        bfdVal,
		BridgeDomain:               bridgeDomainVal,
		Description:                descriptionVal,
		Egress:                     egressVal,
		EvpnRouteAdvertisementType: evpnRouteAdvertisementTypeVal,
		HostRoutePopulate:          hostRoutePopulateVal,
		Ingress:                    ingressVal,
		IpAddresses:                ipAddressesVal,
		IpMtu:                      ipMtuVal,
		Ipv4parameters:             ipv4parametersVal,
		Ipv6routerAdvertisement:    ipv6routerAdvertisementVal,
		L3proxyArpnd:               l3proxyArpndVal,
		LearnUnsolicited:           learnUnsolicitedVal,
		Router:                     routerVal,
		Unnumbered:                 unnumberedVal,
		VirtualIpdiscovery:         virtualIpdiscoveryVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	anycastGatewayMacAttribute, ok := attributes["anycast_gateway_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anycast_gateway_mac is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	anycastGatewayMacVal, ok := anycastGatewayMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anycast_gateway_mac expected to be basetypes.StringValue, was: %T`, anycastGatewayMacAttribute))
	}

	arpTimeoutAttribute, ok := attributes["arp_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_timeout is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	arpTimeoutVal, ok := arpTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_timeout expected to be basetypes.Int64Value, was: %T`, arpTimeoutAttribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	bridgeDomainAttribute, ok := attributes["bridge_domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_domain is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	bridgeDomainVal, ok := bridgeDomainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_domain expected to be basetypes.StringValue, was: %T`, bridgeDomainAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egressAttribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	egressVal, ok := egressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress expected to be basetypes.ObjectValue, was: %T`, egressAttribute))
	}

	evpnRouteAdvertisementTypeAttribute, ok := attributes["evpn_route_advertisement_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_route_advertisement_type is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	evpnRouteAdvertisementTypeVal, ok := evpnRouteAdvertisementTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_route_advertisement_type expected to be basetypes.ObjectValue, was: %T`, evpnRouteAdvertisementTypeAttribute))
	}

	hostRoutePopulateAttribute, ok := attributes["host_route_populate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_route_populate is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	hostRoutePopulateVal, ok := hostRoutePopulateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_route_populate expected to be basetypes.ObjectValue, was: %T`, hostRoutePopulateAttribute))
	}

	ingressAttribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ingressVal, ok := ingressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress expected to be basetypes.ObjectValue, was: %T`, ingressAttribute))
	}

	ipAddressesAttribute, ok := attributes["ip_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_addresses is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipAddressesVal, ok := ipAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_addresses expected to be basetypes.ListValue, was: %T`, ipAddressesAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	ipv4parametersAttribute, ok := attributes["ipv4parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4parameters is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipv4parametersVal, ok := ipv4parametersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4parameters expected to be basetypes.ObjectValue, was: %T`, ipv4parametersAttribute))
	}

	ipv6routerAdvertisementAttribute, ok := attributes["ipv6router_advertisement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6router_advertisement is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipv6routerAdvertisementVal, ok := ipv6routerAdvertisementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6router_advertisement expected to be basetypes.ObjectValue, was: %T`, ipv6routerAdvertisementAttribute))
	}

	l3proxyArpndAttribute, ok := attributes["l3proxy_arpnd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3proxy_arpnd is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	l3proxyArpndVal, ok := l3proxyArpndAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3proxy_arpnd expected to be basetypes.ObjectValue, was: %T`, l3proxyArpndAttribute))
	}

	learnUnsolicitedAttribute, ok := attributes["learn_unsolicited"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`learn_unsolicited is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	learnUnsolicitedVal, ok := learnUnsolicitedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`learn_unsolicited expected to be basetypes.StringValue, was: %T`, learnUnsolicitedAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	virtualIpdiscoveryAttribute, ok := attributes["virtual_ipdiscovery"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`virtual_ipdiscovery is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	virtualIpdiscoveryVal, ok := virtualIpdiscoveryAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`virtual_ipdiscovery expected to be basetypes.ListValue, was: %T`, virtualIpdiscoveryAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		AnycastGatewayMac:          anycastGatewayMacVal,
		ArpTimeout:                 arpTimeoutVal,
		Bfd:                        bfdVal,
		BridgeDomain:               bridgeDomainVal,
		Description:                descriptionVal,
		Egress:                     egressVal,
		EvpnRouteAdvertisementType: evpnRouteAdvertisementTypeVal,
		HostRoutePopulate:          hostRoutePopulateVal,
		Ingress:                    ingressVal,
		IpAddresses:                ipAddressesVal,
		IpMtu:                      ipMtuVal,
		Ipv4parameters:             ipv4parametersVal,
		Ipv6routerAdvertisement:    ipv6routerAdvertisementVal,
		L3proxyArpnd:               l3proxyArpndVal,
		LearnUnsolicited:           learnUnsolicitedVal,
		Router:                     routerVal,
		Unnumbered:                 unnumberedVal,
		VirtualIpdiscovery:         virtualIpdiscoveryVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	AnycastGatewayMac          basetypes.StringValue `tfsdk:"anycast_gateway_mac"`
	ArpTimeout                 basetypes.Int64Value  `tfsdk:"arp_timeout"`
	Bfd                        basetypes.ObjectValue `tfsdk:"bfd"`
	BridgeDomain               basetypes.StringValue `tfsdk:"bridge_domain"`
	Description                basetypes.StringValue `tfsdk:"description"`
	Egress                     basetypes.ObjectValue `tfsdk:"egress"`
	EvpnRouteAdvertisementType basetypes.ObjectValue `tfsdk:"evpn_route_advertisement_type"`
	HostRoutePopulate          basetypes.ObjectValue `tfsdk:"host_route_populate"`
	Ingress                    basetypes.ObjectValue `tfsdk:"ingress"`
	IpAddresses                basetypes.ListValue   `tfsdk:"ip_addresses"`
	IpMtu                      basetypes.Int64Value  `tfsdk:"ip_mtu"`
	Ipv4parameters             basetypes.ObjectValue `tfsdk:"ipv4parameters"`
	Ipv6routerAdvertisement    basetypes.ObjectValue `tfsdk:"ipv6router_advertisement"`
	L3proxyArpnd               basetypes.ObjectValue `tfsdk:"l3proxy_arpnd"`
	LearnUnsolicited           basetypes.StringValue `tfsdk:"learn_unsolicited"`
	Router                     basetypes.StringValue `tfsdk:"router"`
	Unnumbered                 basetypes.StringValue `tfsdk:"unnumbered"`
	VirtualIpdiscovery         basetypes.ListValue   `tfsdk:"virtual_ipdiscovery"`
	state                      attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 18)

	var val tftypes.Value
	var err error

	attrTypes["anycast_gateway_mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["arp_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["bfd"] = basetypes.ObjectType{
		AttrTypes: BfdValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["bridge_domain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["egress"] = basetypes.ObjectType{
		AttrTypes: EgressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["evpn_route_advertisement_type"] = basetypes.ObjectType{
		AttrTypes: EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["host_route_populate"] = basetypes.ObjectType{
		AttrTypes: HostRoutePopulateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ingress"] = basetypes.ObjectType{
		AttrTypes: IngressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_addresses"] = basetypes.ListType{
		ElemType: IpAddressesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ipv4parameters"] = basetypes.ObjectType{
		AttrTypes: Ipv4parametersValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6router_advertisement"] = basetypes.ObjectType{
		AttrTypes: Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["l3proxy_arpnd"] = basetypes.ObjectType{
		AttrTypes: L3proxyArpndValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["learn_unsolicited"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["router"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["unnumbered"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["virtual_ipdiscovery"] = basetypes.ListType{
		ElemType: VirtualIpdiscoveryValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 18)

		val, err = v.AnycastGatewayMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["anycast_gateway_mac"] = val

		val, err = v.ArpTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_timeout"] = val

		val, err = v.Bfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.BridgeDomain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bridge_domain"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Egress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress"] = val

		val, err = v.EvpnRouteAdvertisementType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpn_route_advertisement_type"] = val

		val, err = v.HostRoutePopulate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host_route_populate"] = val

		val, err = v.Ingress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress"] = val

		val, err = v.IpAddresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_addresses"] = val

		val, err = v.IpMtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_mtu"] = val

		val, err = v.Ipv4parameters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4parameters"] = val

		val, err = v.Ipv6routerAdvertisement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6router_advertisement"] = val

		val, err = v.L3proxyArpnd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3proxy_arpnd"] = val

		val, err = v.LearnUnsolicited.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["learn_unsolicited"] = val

		val, err = v.Router.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router"] = val

		val, err = v.Unnumbered.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unnumbered"] = val

		val, err = v.VirtualIpdiscovery.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["virtual_ipdiscovery"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bfd basetypes.ObjectValue

	if v.Bfd.IsNull() {
		bfd = types.ObjectNull(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bfd.IsUnknown() {
		bfd = types.ObjectUnknown(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bfd.IsNull() && !v.Bfd.IsUnknown() {
		bfd = types.ObjectValueMust(
			BfdValue{}.AttributeTypes(ctx),
			v.Bfd.Attributes(),
		)
	}

	var egress basetypes.ObjectValue

	if v.Egress.IsNull() {
		egress = types.ObjectNull(
			EgressValue{}.AttributeTypes(ctx),
		)
	}

	if v.Egress.IsUnknown() {
		egress = types.ObjectUnknown(
			EgressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Egress.IsNull() && !v.Egress.IsUnknown() {
		egress = types.ObjectValueMust(
			EgressValue{}.AttributeTypes(ctx),
			v.Egress.Attributes(),
		)
	}

	var evpnRouteAdvertisementType basetypes.ObjectValue

	if v.EvpnRouteAdvertisementType.IsNull() {
		evpnRouteAdvertisementType = types.ObjectNull(
			EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
		)
	}

	if v.EvpnRouteAdvertisementType.IsUnknown() {
		evpnRouteAdvertisementType = types.ObjectUnknown(
			EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.EvpnRouteAdvertisementType.IsNull() && !v.EvpnRouteAdvertisementType.IsUnknown() {
		evpnRouteAdvertisementType = types.ObjectValueMust(
			EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
			v.EvpnRouteAdvertisementType.Attributes(),
		)
	}

	var hostRoutePopulate basetypes.ObjectValue

	if v.HostRoutePopulate.IsNull() {
		hostRoutePopulate = types.ObjectNull(
			HostRoutePopulateValue{}.AttributeTypes(ctx),
		)
	}

	if v.HostRoutePopulate.IsUnknown() {
		hostRoutePopulate = types.ObjectUnknown(
			HostRoutePopulateValue{}.AttributeTypes(ctx),
		)
	}

	if !v.HostRoutePopulate.IsNull() && !v.HostRoutePopulate.IsUnknown() {
		hostRoutePopulate = types.ObjectValueMust(
			HostRoutePopulateValue{}.AttributeTypes(ctx),
			v.HostRoutePopulate.Attributes(),
		)
	}

	var ingress basetypes.ObjectValue

	if v.Ingress.IsNull() {
		ingress = types.ObjectNull(
			IngressValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ingress.IsUnknown() {
		ingress = types.ObjectUnknown(
			IngressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ingress.IsNull() && !v.Ingress.IsUnknown() {
		ingress = types.ObjectValueMust(
			IngressValue{}.AttributeTypes(ctx),
			v.Ingress.Attributes(),
		)
	}

	ipAddresses := types.ListValueMust(
		IpAddressesType{
			basetypes.ObjectType{
				AttrTypes: IpAddressesValue{}.AttributeTypes(ctx),
			},
		},
		v.IpAddresses.Elements(),
	)

	if v.IpAddresses.IsNull() {
		ipAddresses = types.ListNull(
			IpAddressesType{
				basetypes.ObjectType{
					AttrTypes: IpAddressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IpAddresses.IsUnknown() {
		ipAddresses = types.ListUnknown(
			IpAddressesType{
				basetypes.ObjectType{
					AttrTypes: IpAddressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var ipv4parameters basetypes.ObjectValue

	if v.Ipv4parameters.IsNull() {
		ipv4parameters = types.ObjectNull(
			Ipv4parametersValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv4parameters.IsUnknown() {
		ipv4parameters = types.ObjectUnknown(
			Ipv4parametersValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv4parameters.IsNull() && !v.Ipv4parameters.IsUnknown() {
		ipv4parameters = types.ObjectValueMust(
			Ipv4parametersValue{}.AttributeTypes(ctx),
			v.Ipv4parameters.Attributes(),
		)
	}

	var ipv6routerAdvertisement basetypes.ObjectValue

	if v.Ipv6routerAdvertisement.IsNull() {
		ipv6routerAdvertisement = types.ObjectNull(
			Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv6routerAdvertisement.IsUnknown() {
		ipv6routerAdvertisement = types.ObjectUnknown(
			Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv6routerAdvertisement.IsNull() && !v.Ipv6routerAdvertisement.IsUnknown() {
		ipv6routerAdvertisement = types.ObjectValueMust(
			Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
			v.Ipv6routerAdvertisement.Attributes(),
		)
	}

	var l3proxyArpnd basetypes.ObjectValue

	if v.L3proxyArpnd.IsNull() {
		l3proxyArpnd = types.ObjectNull(
			L3proxyArpndValue{}.AttributeTypes(ctx),
		)
	}

	if v.L3proxyArpnd.IsUnknown() {
		l3proxyArpnd = types.ObjectUnknown(
			L3proxyArpndValue{}.AttributeTypes(ctx),
		)
	}

	if !v.L3proxyArpnd.IsNull() && !v.L3proxyArpnd.IsUnknown() {
		l3proxyArpnd = types.ObjectValueMust(
			L3proxyArpndValue{}.AttributeTypes(ctx),
			v.L3proxyArpnd.Attributes(),
		)
	}

	virtualIpdiscovery := types.ListValueMust(
		VirtualIpdiscoveryType{
			basetypes.ObjectType{
				AttrTypes: VirtualIpdiscoveryValue{}.AttributeTypes(ctx),
			},
		},
		v.VirtualIpdiscovery.Elements(),
	)

	if v.VirtualIpdiscovery.IsNull() {
		virtualIpdiscovery = types.ListNull(
			VirtualIpdiscoveryType{
				basetypes.ObjectType{
					AttrTypes: VirtualIpdiscoveryValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VirtualIpdiscovery.IsUnknown() {
		virtualIpdiscovery = types.ListUnknown(
			VirtualIpdiscoveryType{
				basetypes.ObjectType{
					AttrTypes: VirtualIpdiscoveryValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"anycast_gateway_mac": basetypes.StringType{},
		"arp_timeout":         basetypes.Int64Type{},
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"bridge_domain": basetypes.StringType{},
		"description":   basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: EgressValue{}.AttributeTypes(ctx),
		},
		"evpn_route_advertisement_type": basetypes.ObjectType{
			AttrTypes: EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
		},
		"host_route_populate": basetypes.ObjectType{
			AttrTypes: HostRoutePopulateValue{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: IngressValue{}.AttributeTypes(ctx),
		},
		"ip_addresses": basetypes.ListType{
			ElemType: IpAddressesValue{}.Type(ctx),
		},
		"ip_mtu": basetypes.Int64Type{},
		"ipv4parameters": basetypes.ObjectType{
			AttrTypes: Ipv4parametersValue{}.AttributeTypes(ctx),
		},
		"ipv6router_advertisement": basetypes.ObjectType{
			AttrTypes: Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
		},
		"l3proxy_arpnd": basetypes.ObjectType{
			AttrTypes: L3proxyArpndValue{}.AttributeTypes(ctx),
		},
		"learn_unsolicited": basetypes.StringType{},
		"router":            basetypes.StringType{},
		"unnumbered":        basetypes.StringType{},
		"virtual_ipdiscovery": basetypes.ListType{
			ElemType: VirtualIpdiscoveryValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"anycast_gateway_mac":           v.AnycastGatewayMac,
			"arp_timeout":                   v.ArpTimeout,
			"bfd":                           bfd,
			"bridge_domain":                 v.BridgeDomain,
			"description":                   v.Description,
			"egress":                        egress,
			"evpn_route_advertisement_type": evpnRouteAdvertisementType,
			"host_route_populate":           hostRoutePopulate,
			"ingress":                       ingress,
			"ip_addresses":                  ipAddresses,
			"ip_mtu":                        v.IpMtu,
			"ipv4parameters":                ipv4parameters,
			"ipv6router_advertisement":      ipv6routerAdvertisement,
			"l3proxy_arpnd":                 l3proxyArpnd,
			"learn_unsolicited":             v.LearnUnsolicited,
			"router":                        v.Router,
			"unnumbered":                    v.Unnumbered,
			"virtual_ipdiscovery":           virtualIpdiscovery,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AnycastGatewayMac.Equal(other.AnycastGatewayMac) {
		return false
	}

	if !v.ArpTimeout.Equal(other.ArpTimeout) {
		return false
	}

	if !v.Bfd.Equal(other.Bfd) {
		return false
	}

	if !v.BridgeDomain.Equal(other.BridgeDomain) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Egress.Equal(other.Egress) {
		return false
	}

	if !v.EvpnRouteAdvertisementType.Equal(other.EvpnRouteAdvertisementType) {
		return false
	}

	if !v.HostRoutePopulate.Equal(other.HostRoutePopulate) {
		return false
	}

	if !v.Ingress.Equal(other.Ingress) {
		return false
	}

	if !v.IpAddresses.Equal(other.IpAddresses) {
		return false
	}

	if !v.IpMtu.Equal(other.IpMtu) {
		return false
	}

	if !v.Ipv4parameters.Equal(other.Ipv4parameters) {
		return false
	}

	if !v.Ipv6routerAdvertisement.Equal(other.Ipv6routerAdvertisement) {
		return false
	}

	if !v.L3proxyArpnd.Equal(other.L3proxyArpnd) {
		return false
	}

	if !v.LearnUnsolicited.Equal(other.LearnUnsolicited) {
		return false
	}

	if !v.Router.Equal(other.Router) {
		return false
	}

	if !v.Unnumbered.Equal(other.Unnumbered) {
		return false
	}

	if !v.VirtualIpdiscovery.Equal(other.VirtualIpdiscovery) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"anycast_gateway_mac": basetypes.StringType{},
		"arp_timeout":         basetypes.Int64Type{},
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"bridge_domain": basetypes.StringType{},
		"description":   basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: EgressValue{}.AttributeTypes(ctx),
		},
		"evpn_route_advertisement_type": basetypes.ObjectType{
			AttrTypes: EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
		},
		"host_route_populate": basetypes.ObjectType{
			AttrTypes: HostRoutePopulateValue{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: IngressValue{}.AttributeTypes(ctx),
		},
		"ip_addresses": basetypes.ListType{
			ElemType: IpAddressesValue{}.Type(ctx),
		},
		"ip_mtu": basetypes.Int64Type{},
		"ipv4parameters": basetypes.ObjectType{
			AttrTypes: Ipv4parametersValue{}.AttributeTypes(ctx),
		},
		"ipv6router_advertisement": basetypes.ObjectType{
			AttrTypes: Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
		},
		"l3proxy_arpnd": basetypes.ObjectType{
			AttrTypes: L3proxyArpndValue{}.AttributeTypes(ctx),
		},
		"learn_unsolicited": basetypes.StringType{},
		"router":            basetypes.StringType{},
		"unnumbered":        basetypes.StringType{},
		"virtual_ipdiscovery": basetypes.ListType{
			ElemType: VirtualIpdiscoveryValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = BfdType{}

type BfdType struct {
	basetypes.ObjectType
}

func (t BfdType) Equal(o attr.Type) bool {
	other, ok := o.(BfdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BfdType) String() string {
	return "BfdType"
}

func (t BfdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return nil, diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return nil, diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return nil, diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return nil, diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return nil, diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BfdValue{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfdValueNull() BfdValue {
	return BfdValue{
		state: attr.ValueStateNull,
	}
}

func NewBfdValueUnknown() BfdValue {
	return BfdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBfdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BfdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BfdValue Attribute Value",
				"While creating a BfdValue value, a missing attribute value was detected. "+
					"A BfdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BfdValue Attribute Type",
				"While creating a BfdValue value, an invalid attribute value was detected. "+
					"A BfdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BfdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BfdValue Attribute Value",
				"While creating a BfdValue value, an extra attribute value was detected. "+
					"A BfdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BfdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	return BfdValue{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BfdValue {
	object, diags := NewBfdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBfdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BfdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBfdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBfdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBfdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBfdValueMust(BfdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BfdType) ValueType(ctx context.Context) attr.Value {
	return BfdValue{}
}

var _ basetypes.ObjectValuable = BfdValue{}

type BfdValue struct {
	DesiredMinTransmitInt  basetypes.Int64Value `tfsdk:"desired_min_transmit_int"`
	DetectionMultiplier    basetypes.Int64Value `tfsdk:"detection_multiplier"`
	Enabled                basetypes.BoolValue  `tfsdk:"enabled"`
	MinEchoReceiveInterval basetypes.Int64Value `tfsdk:"min_echo_receive_interval"`
	RequiredMinReceive     basetypes.Int64Value `tfsdk:"required_min_receive"`
	Ttl                    basetypes.Int64Value `tfsdk:"ttl"`
	state                  attr.ValueState
}

func (v BfdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["desired_min_transmit_int"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["detection_multiplier"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["min_echo_receive_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["required_min_receive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ttl"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.DesiredMinTransmitInt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_min_transmit_int"] = val

		val, err = v.DetectionMultiplier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["detection_multiplier"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.MinEchoReceiveInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_echo_receive_interval"] = val

		val, err = v.RequiredMinReceive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required_min_receive"] = val

		val, err = v.Ttl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ttl"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BfdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BfdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BfdValue) String() string {
	return "BfdValue"
}

func (v BfdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"desired_min_transmit_int":  v.DesiredMinTransmitInt,
			"detection_multiplier":      v.DetectionMultiplier,
			"enabled":                   v.Enabled,
			"min_echo_receive_interval": v.MinEchoReceiveInterval,
			"required_min_receive":      v.RequiredMinReceive,
			"ttl":                       v.Ttl,
		})

	return objVal, diags
}

func (v BfdValue) Equal(o attr.Value) bool {
	other, ok := o.(BfdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DesiredMinTransmitInt.Equal(other.DesiredMinTransmitInt) {
		return false
	}

	if !v.DetectionMultiplier.Equal(other.DetectionMultiplier) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.MinEchoReceiveInterval.Equal(other.MinEchoReceiveInterval) {
		return false
	}

	if !v.RequiredMinReceive.Equal(other.RequiredMinReceive) {
		return false
	}

	if !v.Ttl.Equal(other.Ttl) {
		return false
	}

	return true
}

func (v BfdValue) Type(ctx context.Context) attr.Type {
	return BfdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BfdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = EgressType{}

type EgressType struct {
	basetypes.ObjectType
}

func (t EgressType) Equal(o attr.Type) bool {
	other, ok := o.(EgressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EgressType) String() string {
	return "EgressType"
}

func (t EgressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EgressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgressValueNull() EgressValue {
	return EgressValue{
		state: attr.ValueStateNull,
	}
}

func NewEgressValueUnknown() EgressValue {
	return EgressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEgressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EgressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EgressValue Attribute Value",
				"While creating a EgressValue value, a missing attribute value was detected. "+
					"A EgressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EgressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EgressValue Attribute Type",
				"While creating a EgressValue value, an invalid attribute value was detected. "+
					"A EgressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EgressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EgressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EgressValue Attribute Value",
				"While creating a EgressValue value, an extra attribute value was detected. "+
					"A EgressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EgressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEgressValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewEgressValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewEgressValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewEgressValueUnknown(), diags
	}

	return EgressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EgressValue {
	object, diags := NewEgressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEgressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EgressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEgressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEgressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEgressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEgressValueMust(EgressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EgressType) ValueType(ctx context.Context) attr.Value {
	return EgressValue{}
}

var _ basetypes.ObjectValuable = EgressValue{}

type EgressValue struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v EgressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EgressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EgressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EgressValue) String() string {
	return "EgressValue"
}

func (v EgressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v EgressValue) Equal(o attr.Value) bool {
	other, ok := o.(EgressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v EgressValue) Type(ctx context.Context) attr.Type {
	return EgressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EgressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = EvpnRouteAdvertisementTypeType{}

type EvpnRouteAdvertisementTypeType struct {
	basetypes.ObjectType
}

func (t EvpnRouteAdvertisementTypeType) Equal(o attr.Type) bool {
	other, ok := o.(EvpnRouteAdvertisementTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EvpnRouteAdvertisementTypeType) String() string {
	return "EvpnRouteAdvertisementTypeType"
}

func (t EvpnRouteAdvertisementTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	arpDynamicAttribute, ok := attributes["arp_dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_dynamic is missing from object`)

		return nil, diags
	}

	arpDynamicVal, ok := arpDynamicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_dynamic expected to be basetypes.BoolValue, was: %T`, arpDynamicAttribute))
	}

	arpStaticAttribute, ok := attributes["arp_static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_static is missing from object`)

		return nil, diags
	}

	arpStaticVal, ok := arpStaticAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_static expected to be basetypes.BoolValue, was: %T`, arpStaticAttribute))
	}

	ndDynamicAttribute, ok := attributes["nd_dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nd_dynamic is missing from object`)

		return nil, diags
	}

	ndDynamicVal, ok := ndDynamicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nd_dynamic expected to be basetypes.BoolValue, was: %T`, ndDynamicAttribute))
	}

	ndStaticAttribute, ok := attributes["nd_static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nd_static is missing from object`)

		return nil, diags
	}

	ndStaticVal, ok := ndStaticAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nd_static expected to be basetypes.BoolValue, was: %T`, ndStaticAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EvpnRouteAdvertisementTypeValue{
		ArpDynamic: arpDynamicVal,
		ArpStatic:  arpStaticVal,
		NdDynamic:  ndDynamicVal,
		NdStatic:   ndStaticVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewEvpnRouteAdvertisementTypeValueNull() EvpnRouteAdvertisementTypeValue {
	return EvpnRouteAdvertisementTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewEvpnRouteAdvertisementTypeValueUnknown() EvpnRouteAdvertisementTypeValue {
	return EvpnRouteAdvertisementTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEvpnRouteAdvertisementTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EvpnRouteAdvertisementTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EvpnRouteAdvertisementTypeValue Attribute Value",
				"While creating a EvpnRouteAdvertisementTypeValue value, a missing attribute value was detected. "+
					"A EvpnRouteAdvertisementTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvpnRouteAdvertisementTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EvpnRouteAdvertisementTypeValue Attribute Type",
				"While creating a EvpnRouteAdvertisementTypeValue value, an invalid attribute value was detected. "+
					"A EvpnRouteAdvertisementTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvpnRouteAdvertisementTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EvpnRouteAdvertisementTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EvpnRouteAdvertisementTypeValue Attribute Value",
				"While creating a EvpnRouteAdvertisementTypeValue value, an extra attribute value was detected. "+
					"A EvpnRouteAdvertisementTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EvpnRouteAdvertisementTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEvpnRouteAdvertisementTypeValueUnknown(), diags
	}

	arpDynamicAttribute, ok := attributes["arp_dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_dynamic is missing from object`)

		return NewEvpnRouteAdvertisementTypeValueUnknown(), diags
	}

	arpDynamicVal, ok := arpDynamicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_dynamic expected to be basetypes.BoolValue, was: %T`, arpDynamicAttribute))
	}

	arpStaticAttribute, ok := attributes["arp_static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_static is missing from object`)

		return NewEvpnRouteAdvertisementTypeValueUnknown(), diags
	}

	arpStaticVal, ok := arpStaticAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_static expected to be basetypes.BoolValue, was: %T`, arpStaticAttribute))
	}

	ndDynamicAttribute, ok := attributes["nd_dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nd_dynamic is missing from object`)

		return NewEvpnRouteAdvertisementTypeValueUnknown(), diags
	}

	ndDynamicVal, ok := ndDynamicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nd_dynamic expected to be basetypes.BoolValue, was: %T`, ndDynamicAttribute))
	}

	ndStaticAttribute, ok := attributes["nd_static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nd_static is missing from object`)

		return NewEvpnRouteAdvertisementTypeValueUnknown(), diags
	}

	ndStaticVal, ok := ndStaticAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nd_static expected to be basetypes.BoolValue, was: %T`, ndStaticAttribute))
	}

	if diags.HasError() {
		return NewEvpnRouteAdvertisementTypeValueUnknown(), diags
	}

	return EvpnRouteAdvertisementTypeValue{
		ArpDynamic: arpDynamicVal,
		ArpStatic:  arpStaticVal,
		NdDynamic:  ndDynamicVal,
		NdStatic:   ndStaticVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewEvpnRouteAdvertisementTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EvpnRouteAdvertisementTypeValue {
	object, diags := NewEvpnRouteAdvertisementTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEvpnRouteAdvertisementTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EvpnRouteAdvertisementTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEvpnRouteAdvertisementTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEvpnRouteAdvertisementTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEvpnRouteAdvertisementTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEvpnRouteAdvertisementTypeValueMust(EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EvpnRouteAdvertisementTypeType) ValueType(ctx context.Context) attr.Value {
	return EvpnRouteAdvertisementTypeValue{}
}

var _ basetypes.ObjectValuable = EvpnRouteAdvertisementTypeValue{}

type EvpnRouteAdvertisementTypeValue struct {
	ArpDynamic basetypes.BoolValue `tfsdk:"arp_dynamic"`
	ArpStatic  basetypes.BoolValue `tfsdk:"arp_static"`
	NdDynamic  basetypes.BoolValue `tfsdk:"nd_dynamic"`
	NdStatic   basetypes.BoolValue `tfsdk:"nd_static"`
	state      attr.ValueState
}

func (v EvpnRouteAdvertisementTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["arp_dynamic"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["arp_static"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["nd_dynamic"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["nd_static"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ArpDynamic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_dynamic"] = val

		val, err = v.ArpStatic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_static"] = val

		val, err = v.NdDynamic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nd_dynamic"] = val

		val, err = v.NdStatic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nd_static"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EvpnRouteAdvertisementTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EvpnRouteAdvertisementTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EvpnRouteAdvertisementTypeValue) String() string {
	return "EvpnRouteAdvertisementTypeValue"
}

func (v EvpnRouteAdvertisementTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"arp_dynamic": basetypes.BoolType{},
		"arp_static":  basetypes.BoolType{},
		"nd_dynamic":  basetypes.BoolType{},
		"nd_static":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"arp_dynamic": v.ArpDynamic,
			"arp_static":  v.ArpStatic,
			"nd_dynamic":  v.NdDynamic,
			"nd_static":   v.NdStatic,
		})

	return objVal, diags
}

func (v EvpnRouteAdvertisementTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(EvpnRouteAdvertisementTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ArpDynamic.Equal(other.ArpDynamic) {
		return false
	}

	if !v.ArpStatic.Equal(other.ArpStatic) {
		return false
	}

	if !v.NdDynamic.Equal(other.NdDynamic) {
		return false
	}

	if !v.NdStatic.Equal(other.NdStatic) {
		return false
	}

	return true
}

func (v EvpnRouteAdvertisementTypeValue) Type(ctx context.Context) attr.Type {
	return EvpnRouteAdvertisementTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EvpnRouteAdvertisementTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"arp_dynamic": basetypes.BoolType{},
		"arp_static":  basetypes.BoolType{},
		"nd_dynamic":  basetypes.BoolType{},
		"nd_static":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = HostRoutePopulateType{}

type HostRoutePopulateType struct {
	basetypes.ObjectType
}

func (t HostRoutePopulateType) Equal(o attr.Type) bool {
	other, ok := o.(HostRoutePopulateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HostRoutePopulateType) String() string {
	return "HostRoutePopulateType"
}

func (t HostRoutePopulateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dynamicAttribute, ok := attributes["dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic is missing from object`)

		return nil, diags
	}

	dynamicVal, ok := dynamicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic expected to be basetypes.BoolValue, was: %T`, dynamicAttribute))
	}

	evpnAttribute, ok := attributes["evpn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn is missing from object`)

		return nil, diags
	}

	evpnVal, ok := evpnAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn expected to be basetypes.BoolValue, was: %T`, evpnAttribute))
	}

	staticAttribute, ok := attributes["static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static is missing from object`)

		return nil, diags
	}

	staticVal, ok := staticAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static expected to be basetypes.BoolValue, was: %T`, staticAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HostRoutePopulateValue{
		Dynamic: dynamicVal,
		Evpn:    evpnVal,
		Static:  staticVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewHostRoutePopulateValueNull() HostRoutePopulateValue {
	return HostRoutePopulateValue{
		state: attr.ValueStateNull,
	}
}

func NewHostRoutePopulateValueUnknown() HostRoutePopulateValue {
	return HostRoutePopulateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHostRoutePopulateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HostRoutePopulateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HostRoutePopulateValue Attribute Value",
				"While creating a HostRoutePopulateValue value, a missing attribute value was detected. "+
					"A HostRoutePopulateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HostRoutePopulateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HostRoutePopulateValue Attribute Type",
				"While creating a HostRoutePopulateValue value, an invalid attribute value was detected. "+
					"A HostRoutePopulateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HostRoutePopulateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HostRoutePopulateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HostRoutePopulateValue Attribute Value",
				"While creating a HostRoutePopulateValue value, an extra attribute value was detected. "+
					"A HostRoutePopulateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HostRoutePopulateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHostRoutePopulateValueUnknown(), diags
	}

	dynamicAttribute, ok := attributes["dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic is missing from object`)

		return NewHostRoutePopulateValueUnknown(), diags
	}

	dynamicVal, ok := dynamicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic expected to be basetypes.BoolValue, was: %T`, dynamicAttribute))
	}

	evpnAttribute, ok := attributes["evpn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn is missing from object`)

		return NewHostRoutePopulateValueUnknown(), diags
	}

	evpnVal, ok := evpnAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn expected to be basetypes.BoolValue, was: %T`, evpnAttribute))
	}

	staticAttribute, ok := attributes["static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static is missing from object`)

		return NewHostRoutePopulateValueUnknown(), diags
	}

	staticVal, ok := staticAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static expected to be basetypes.BoolValue, was: %T`, staticAttribute))
	}

	if diags.HasError() {
		return NewHostRoutePopulateValueUnknown(), diags
	}

	return HostRoutePopulateValue{
		Dynamic: dynamicVal,
		Evpn:    evpnVal,
		Static:  staticVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewHostRoutePopulateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HostRoutePopulateValue {
	object, diags := NewHostRoutePopulateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHostRoutePopulateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HostRoutePopulateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHostRoutePopulateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHostRoutePopulateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHostRoutePopulateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHostRoutePopulateValueMust(HostRoutePopulateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HostRoutePopulateType) ValueType(ctx context.Context) attr.Value {
	return HostRoutePopulateValue{}
}

var _ basetypes.ObjectValuable = HostRoutePopulateValue{}

type HostRoutePopulateValue struct {
	Dynamic basetypes.BoolValue `tfsdk:"dynamic"`
	Evpn    basetypes.BoolValue `tfsdk:"evpn"`
	Static  basetypes.BoolValue `tfsdk:"static"`
	state   attr.ValueState
}

func (v HostRoutePopulateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["dynamic"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["evpn"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["static"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Dynamic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic"] = val

		val, err = v.Evpn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpn"] = val

		val, err = v.Static.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HostRoutePopulateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HostRoutePopulateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HostRoutePopulateValue) String() string {
	return "HostRoutePopulateValue"
}

func (v HostRoutePopulateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"dynamic": basetypes.BoolType{},
		"evpn":    basetypes.BoolType{},
		"static":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dynamic": v.Dynamic,
			"evpn":    v.Evpn,
			"static":  v.Static,
		})

	return objVal, diags
}

func (v HostRoutePopulateValue) Equal(o attr.Value) bool {
	other, ok := o.(HostRoutePopulateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dynamic.Equal(other.Dynamic) {
		return false
	}

	if !v.Evpn.Equal(other.Evpn) {
		return false
	}

	if !v.Static.Equal(other.Static) {
		return false
	}

	return true
}

func (v HostRoutePopulateValue) Type(ctx context.Context) attr.Type {
	return HostRoutePopulateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HostRoutePopulateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dynamic": basetypes.BoolType{},
		"evpn":    basetypes.BoolType{},
		"static":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = IngressType{}

type IngressType struct {
	basetypes.ObjectType
}

func (t IngressType) Equal(o attr.Type) bool {
	other, ok := o.(IngressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IngressType) String() string {
	return "IngressType"
}

func (t IngressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IngressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngressValueNull() IngressValue {
	return IngressValue{
		state: attr.ValueStateNull,
	}
}

func NewIngressValueUnknown() IngressValue {
	return IngressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIngressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IngressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IngressValue Attribute Value",
				"While creating a IngressValue value, a missing attribute value was detected. "+
					"A IngressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IngressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IngressValue Attribute Type",
				"While creating a IngressValue value, an invalid attribute value was detected. "+
					"A IngressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IngressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IngressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IngressValue Attribute Value",
				"While creating a IngressValue value, an extra attribute value was detected. "+
					"A IngressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IngressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIngressValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewIngressValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewIngressValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewIngressValueUnknown(), diags
	}

	return IngressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IngressValue {
	object, diags := NewIngressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIngressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IngressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIngressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIngressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIngressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIngressValueMust(IngressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IngressType) ValueType(ctx context.Context) attr.Value {
	return IngressValue{}
}

var _ basetypes.ObjectValuable = IngressValue{}

type IngressValue struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v IngressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IngressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IngressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IngressValue) String() string {
	return "IngressValue"
}

func (v IngressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v IngressValue) Equal(o attr.Value) bool {
	other, ok := o.(IngressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v IngressValue) Type(ctx context.Context) attr.Type {
	return IngressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IngressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = IpAddressesType{}

type IpAddressesType struct {
	basetypes.ObjectType
}

func (t IpAddressesType) Equal(o attr.Type) bool {
	other, ok := o.(IpAddressesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpAddressesType) String() string {
	return "IpAddressesType"
}

func (t IpAddressesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipv4addressAttribute, ok := attributes["ipv4address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4address is missing from object`)

		return nil, diags
	}

	ipv4addressVal, ok := ipv4addressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4address expected to be basetypes.ObjectValue, was: %T`, ipv4addressAttribute))
	}

	ipv6addressAttribute, ok := attributes["ipv6address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6address is missing from object`)

		return nil, diags
	}

	ipv6addressVal, ok := ipv6addressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6address expected to be basetypes.ObjectValue, was: %T`, ipv6addressAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpAddressesValue{
		Ipv4address: ipv4addressVal,
		Ipv6address: ipv6addressVal,
		Node:        nodeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewIpAddressesValueNull() IpAddressesValue {
	return IpAddressesValue{
		state: attr.ValueStateNull,
	}
}

func NewIpAddressesValueUnknown() IpAddressesValue {
	return IpAddressesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpAddressesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpAddressesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpAddressesValue Attribute Value",
				"While creating a IpAddressesValue value, a missing attribute value was detected. "+
					"A IpAddressesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpAddressesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpAddressesValue Attribute Type",
				"While creating a IpAddressesValue value, an invalid attribute value was detected. "+
					"A IpAddressesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpAddressesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpAddressesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpAddressesValue Attribute Value",
				"While creating a IpAddressesValue value, an extra attribute value was detected. "+
					"A IpAddressesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpAddressesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpAddressesValueUnknown(), diags
	}

	ipv4addressAttribute, ok := attributes["ipv4address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4address is missing from object`)

		return NewIpAddressesValueUnknown(), diags
	}

	ipv4addressVal, ok := ipv4addressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4address expected to be basetypes.ObjectValue, was: %T`, ipv4addressAttribute))
	}

	ipv6addressAttribute, ok := attributes["ipv6address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6address is missing from object`)

		return NewIpAddressesValueUnknown(), diags
	}

	ipv6addressVal, ok := ipv6addressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6address expected to be basetypes.ObjectValue, was: %T`, ipv6addressAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewIpAddressesValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return NewIpAddressesValueUnknown(), diags
	}

	return IpAddressesValue{
		Ipv4address: ipv4addressVal,
		Ipv6address: ipv6addressVal,
		Node:        nodeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewIpAddressesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpAddressesValue {
	object, diags := NewIpAddressesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpAddressesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpAddressesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpAddressesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpAddressesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpAddressesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpAddressesValueMust(IpAddressesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpAddressesType) ValueType(ctx context.Context) attr.Value {
	return IpAddressesValue{}
}

var _ basetypes.ObjectValuable = IpAddressesValue{}

type IpAddressesValue struct {
	Ipv4address basetypes.ObjectValue `tfsdk:"ipv4address"`
	Ipv6address basetypes.ObjectValue `tfsdk:"ipv6address"`
	Node        basetypes.StringValue `tfsdk:"node"`
	state       attr.ValueState
}

func (v IpAddressesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["ipv4address"] = basetypes.ObjectType{
		AttrTypes: Ipv4addressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6address"] = basetypes.ObjectType{
		AttrTypes: Ipv6addressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Ipv4address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4address"] = val

		val, err = v.Ipv6address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6address"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpAddressesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpAddressesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpAddressesValue) String() string {
	return "IpAddressesValue"
}

func (v IpAddressesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ipv4address basetypes.ObjectValue

	if v.Ipv4address.IsNull() {
		ipv4address = types.ObjectNull(
			Ipv4addressValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv4address.IsUnknown() {
		ipv4address = types.ObjectUnknown(
			Ipv4addressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv4address.IsNull() && !v.Ipv4address.IsUnknown() {
		ipv4address = types.ObjectValueMust(
			Ipv4addressValue{}.AttributeTypes(ctx),
			v.Ipv4address.Attributes(),
		)
	}

	var ipv6address basetypes.ObjectValue

	if v.Ipv6address.IsNull() {
		ipv6address = types.ObjectNull(
			Ipv6addressValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv6address.IsUnknown() {
		ipv6address = types.ObjectUnknown(
			Ipv6addressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv6address.IsNull() && !v.Ipv6address.IsUnknown() {
		ipv6address = types.ObjectValueMust(
			Ipv6addressValue{}.AttributeTypes(ctx),
			v.Ipv6address.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"ipv4address": basetypes.ObjectType{
			AttrTypes: Ipv4addressValue{}.AttributeTypes(ctx),
		},
		"ipv6address": basetypes.ObjectType{
			AttrTypes: Ipv6addressValue{}.AttributeTypes(ctx),
		},
		"node": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ipv4address": ipv4address,
			"ipv6address": ipv6address,
			"node":        v.Node,
		})

	return objVal, diags
}

func (v IpAddressesValue) Equal(o attr.Value) bool {
	other, ok := o.(IpAddressesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ipv4address.Equal(other.Ipv4address) {
		return false
	}

	if !v.Ipv6address.Equal(other.Ipv6address) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	return true
}

func (v IpAddressesValue) Type(ctx context.Context) attr.Type {
	return IpAddressesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpAddressesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ipv4address": basetypes.ObjectType{
			AttrTypes: Ipv4addressValue{}.AttributeTypes(ctx),
		},
		"ipv6address": basetypes.ObjectType{
			AttrTypes: Ipv6addressValue{}.AttributeTypes(ctx),
		},
		"node": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Ipv4addressType{}

type Ipv4addressType struct {
	basetypes.ObjectType
}

func (t Ipv4addressType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4addressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4addressType) String() string {
	return "Ipv4addressType"
}

func (t Ipv4addressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return nil, diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4addressValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv4addressValueNull() Ipv4addressValue {
	return Ipv4addressValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv4addressValueUnknown() Ipv4addressValue {
	return Ipv4addressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4addressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4addressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4addressValue Attribute Value",
				"While creating a Ipv4addressValue value, a missing attribute value was detected. "+
					"A Ipv4addressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4addressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4addressValue Attribute Type",
				"While creating a Ipv4addressValue value, an invalid attribute value was detected. "+
					"A Ipv4addressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4addressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4addressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4addressValue Attribute Value",
				"While creating a Ipv4addressValue value, an extra attribute value was detected. "+
					"A Ipv4addressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4addressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4addressValueUnknown(), diags
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return NewIpv4addressValueUnknown(), diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewIpv4addressValueUnknown(), diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return NewIpv4addressValueUnknown(), diags
	}

	return Ipv4addressValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv4addressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4addressValue {
	object, diags := NewIpv4addressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4addressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4addressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4addressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4addressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4addressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4addressValueMust(Ipv4addressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4addressType) ValueType(ctx context.Context) attr.Value {
	return Ipv4addressValue{}
}

var _ basetypes.ObjectValuable = Ipv4addressValue{}

type Ipv4addressValue struct {
	IpPrefix basetypes.StringValue `tfsdk:"ip_prefix"`
	Primary  basetypes.BoolValue   `tfsdk:"primary"`
	state    attr.ValueState
}

func (v Ipv4addressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_prefix"] = val

		val, err = v.Primary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4addressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4addressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4addressValue) String() string {
	return "Ipv4addressValue"
}

func (v Ipv4addressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_prefix": v.IpPrefix,
			"primary":   v.Primary,
		})

	return objVal, diags
}

func (v Ipv4addressValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4addressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpPrefix.Equal(other.IpPrefix) {
		return false
	}

	if !v.Primary.Equal(other.Primary) {
		return false
	}

	return true
}

func (v Ipv4addressValue) Type(ctx context.Context) attr.Type {
	return Ipv4addressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4addressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ipv6addressType{}

type Ipv6addressType struct {
	basetypes.ObjectType
}

func (t Ipv6addressType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6addressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6addressType) String() string {
	return "Ipv6addressType"
}

func (t Ipv6addressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return nil, diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6addressValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv6addressValueNull() Ipv6addressValue {
	return Ipv6addressValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv6addressValueUnknown() Ipv6addressValue {
	return Ipv6addressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6addressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6addressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6addressValue Attribute Value",
				"While creating a Ipv6addressValue value, a missing attribute value was detected. "+
					"A Ipv6addressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6addressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6addressValue Attribute Type",
				"While creating a Ipv6addressValue value, an invalid attribute value was detected. "+
					"A Ipv6addressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6addressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6addressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6addressValue Attribute Value",
				"While creating a Ipv6addressValue value, an extra attribute value was detected. "+
					"A Ipv6addressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6addressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6addressValueUnknown(), diags
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return NewIpv6addressValueUnknown(), diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewIpv6addressValueUnknown(), diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return NewIpv6addressValueUnknown(), diags
	}

	return Ipv6addressValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv6addressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6addressValue {
	object, diags := NewIpv6addressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6addressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6addressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6addressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6addressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6addressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6addressValueMust(Ipv6addressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6addressType) ValueType(ctx context.Context) attr.Value {
	return Ipv6addressValue{}
}

var _ basetypes.ObjectValuable = Ipv6addressValue{}

type Ipv6addressValue struct {
	IpPrefix basetypes.StringValue `tfsdk:"ip_prefix"`
	Primary  basetypes.BoolValue   `tfsdk:"primary"`
	state    attr.ValueState
}

func (v Ipv6addressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_prefix"] = val

		val, err = v.Primary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6addressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6addressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6addressValue) String() string {
	return "Ipv6addressValue"
}

func (v Ipv6addressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_prefix": v.IpPrefix,
			"primary":   v.Primary,
		})

	return objVal, diags
}

func (v Ipv6addressValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6addressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpPrefix.Equal(other.IpPrefix) {
		return false
	}

	if !v.Primary.Equal(other.Primary) {
		return false
	}

	return true
}

func (v Ipv6addressValue) Type(ctx context.Context) attr.Type {
	return Ipv6addressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6addressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ipv4parametersType{}

type Ipv4parametersType struct {
	basetypes.ObjectType
}

func (t Ipv4parametersType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4parametersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4parametersType) String() string {
	return "Ipv4parametersType"
}

func (t Ipv4parametersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	directedBroadcastAttribute, ok := attributes["directed_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`directed_broadcast is missing from object`)

		return nil, diags
	}

	directedBroadcastVal, ok := directedBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`directed_broadcast expected to be basetypes.BoolValue, was: %T`, directedBroadcastAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4parametersValue{
		DirectedBroadcast: directedBroadcastVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewIpv4parametersValueNull() Ipv4parametersValue {
	return Ipv4parametersValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv4parametersValueUnknown() Ipv4parametersValue {
	return Ipv4parametersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4parametersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4parametersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4parametersValue Attribute Value",
				"While creating a Ipv4parametersValue value, a missing attribute value was detected. "+
					"A Ipv4parametersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4parametersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4parametersValue Attribute Type",
				"While creating a Ipv4parametersValue value, an invalid attribute value was detected. "+
					"A Ipv4parametersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4parametersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4parametersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4parametersValue Attribute Value",
				"While creating a Ipv4parametersValue value, an extra attribute value was detected. "+
					"A Ipv4parametersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4parametersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4parametersValueUnknown(), diags
	}

	directedBroadcastAttribute, ok := attributes["directed_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`directed_broadcast is missing from object`)

		return NewIpv4parametersValueUnknown(), diags
	}

	directedBroadcastVal, ok := directedBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`directed_broadcast expected to be basetypes.BoolValue, was: %T`, directedBroadcastAttribute))
	}

	if diags.HasError() {
		return NewIpv4parametersValueUnknown(), diags
	}

	return Ipv4parametersValue{
		DirectedBroadcast: directedBroadcastVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewIpv4parametersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4parametersValue {
	object, diags := NewIpv4parametersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4parametersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4parametersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4parametersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4parametersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4parametersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4parametersValueMust(Ipv4parametersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4parametersType) ValueType(ctx context.Context) attr.Value {
	return Ipv4parametersValue{}
}

var _ basetypes.ObjectValuable = Ipv4parametersValue{}

type Ipv4parametersValue struct {
	DirectedBroadcast basetypes.BoolValue `tfsdk:"directed_broadcast"`
	state             attr.ValueState
}

func (v Ipv4parametersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["directed_broadcast"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.DirectedBroadcast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["directed_broadcast"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4parametersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4parametersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4parametersValue) String() string {
	return "Ipv4parametersValue"
}

func (v Ipv4parametersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"directed_broadcast": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"directed_broadcast": v.DirectedBroadcast,
		})

	return objVal, diags
}

func (v Ipv4parametersValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4parametersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DirectedBroadcast.Equal(other.DirectedBroadcast) {
		return false
	}

	return true
}

func (v Ipv4parametersValue) Type(ctx context.Context) attr.Type {
	return Ipv4parametersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4parametersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"directed_broadcast": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ipv6routerAdvertisementType{}

type Ipv6routerAdvertisementType struct {
	basetypes.ObjectType
}

func (t Ipv6routerAdvertisementType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6routerAdvertisementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6routerAdvertisementType) String() string {
	return "Ipv6routerAdvertisementType"
}

func (t Ipv6routerAdvertisementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	currentHopLimitAttribute, ok := attributes["current_hop_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_hop_limit is missing from object`)

		return nil, diags
	}

	currentHopLimitVal, ok := currentHopLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_hop_limit expected to be basetypes.Int64Value, was: %T`, currentHopLimitAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return nil, diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	managedConfigurationFlagAttribute, ok := attributes["managed_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_configuration_flag is missing from object`)

		return nil, diags
	}

	managedConfigurationFlagVal, ok := managedConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_configuration_flag expected to be basetypes.BoolValue, was: %T`, managedConfigurationFlagAttribute))
	}

	maxAdvertisementIntervalAttribute, ok := attributes["max_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_advertisement_interval is missing from object`)

		return nil, diags
	}

	maxAdvertisementIntervalVal, ok := maxAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_advertisement_interval expected to be basetypes.Int64Value, was: %T`, maxAdvertisementIntervalAttribute))
	}

	minAdvertisementIntervalAttribute, ok := attributes["min_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_advertisement_interval is missing from object`)

		return nil, diags
	}

	minAdvertisementIntervalVal, ok := minAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minAdvertisementIntervalAttribute))
	}

	otherConfigurationFlagAttribute, ok := attributes["other_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_configuration_flag is missing from object`)

		return nil, diags
	}

	otherConfigurationFlagVal, ok := otherConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_configuration_flag expected to be basetypes.BoolValue, was: %T`, otherConfigurationFlagAttribute))
	}

	prefixesAttribute, ok := attributes["prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefixes is missing from object`)

		return nil, diags
	}

	prefixesVal, ok := prefixesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefixes expected to be basetypes.ListValue, was: %T`, prefixesAttribute))
	}

	reachableTimeAttribute, ok := attributes["reachable_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reachable_time is missing from object`)

		return nil, diags
	}

	reachableTimeVal, ok := reachableTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reachable_time expected to be basetypes.Int64Value, was: %T`, reachableTimeAttribute))
	}

	retransmitTimeAttribute, ok := attributes["retransmit_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retransmit_time is missing from object`)

		return nil, diags
	}

	retransmitTimeVal, ok := retransmitTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retransmit_time expected to be basetypes.Int64Value, was: %T`, retransmitTimeAttribute))
	}

	routerLifetimeAttribute, ok := attributes["router_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_lifetime is missing from object`)

		return nil, diags
	}

	routerLifetimeVal, ok := routerLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_lifetime expected to be basetypes.Int64Value, was: %T`, routerLifetimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6routerAdvertisementValue{
		CurrentHopLimit:          currentHopLimitVal,
		Enabled:                  enabledVal,
		IpMtu:                    ipMtuVal,
		ManagedConfigurationFlag: managedConfigurationFlagVal,
		MaxAdvertisementInterval: maxAdvertisementIntervalVal,
		MinAdvertisementInterval: minAdvertisementIntervalVal,
		OtherConfigurationFlag:   otherConfigurationFlagVal,
		Prefixes:                 prefixesVal,
		ReachableTime:            reachableTimeVal,
		RetransmitTime:           retransmitTimeVal,
		RouterLifetime:           routerLifetimeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewIpv6routerAdvertisementValueNull() Ipv6routerAdvertisementValue {
	return Ipv6routerAdvertisementValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv6routerAdvertisementValueUnknown() Ipv6routerAdvertisementValue {
	return Ipv6routerAdvertisementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6routerAdvertisementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6routerAdvertisementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6routerAdvertisementValue Attribute Value",
				"While creating a Ipv6routerAdvertisementValue value, a missing attribute value was detected. "+
					"A Ipv6routerAdvertisementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6routerAdvertisementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6routerAdvertisementValue Attribute Type",
				"While creating a Ipv6routerAdvertisementValue value, an invalid attribute value was detected. "+
					"A Ipv6routerAdvertisementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6routerAdvertisementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6routerAdvertisementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6routerAdvertisementValue Attribute Value",
				"While creating a Ipv6routerAdvertisementValue value, an extra attribute value was detected. "+
					"A Ipv6routerAdvertisementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6routerAdvertisementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	currentHopLimitAttribute, ok := attributes["current_hop_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_hop_limit is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	currentHopLimitVal, ok := currentHopLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_hop_limit expected to be basetypes.Int64Value, was: %T`, currentHopLimitAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	managedConfigurationFlagAttribute, ok := attributes["managed_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_configuration_flag is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	managedConfigurationFlagVal, ok := managedConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_configuration_flag expected to be basetypes.BoolValue, was: %T`, managedConfigurationFlagAttribute))
	}

	maxAdvertisementIntervalAttribute, ok := attributes["max_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_advertisement_interval is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	maxAdvertisementIntervalVal, ok := maxAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_advertisement_interval expected to be basetypes.Int64Value, was: %T`, maxAdvertisementIntervalAttribute))
	}

	minAdvertisementIntervalAttribute, ok := attributes["min_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_advertisement_interval is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	minAdvertisementIntervalVal, ok := minAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minAdvertisementIntervalAttribute))
	}

	otherConfigurationFlagAttribute, ok := attributes["other_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_configuration_flag is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	otherConfigurationFlagVal, ok := otherConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_configuration_flag expected to be basetypes.BoolValue, was: %T`, otherConfigurationFlagAttribute))
	}

	prefixesAttribute, ok := attributes["prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefixes is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	prefixesVal, ok := prefixesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefixes expected to be basetypes.ListValue, was: %T`, prefixesAttribute))
	}

	reachableTimeAttribute, ok := attributes["reachable_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reachable_time is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	reachableTimeVal, ok := reachableTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reachable_time expected to be basetypes.Int64Value, was: %T`, reachableTimeAttribute))
	}

	retransmitTimeAttribute, ok := attributes["retransmit_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retransmit_time is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	retransmitTimeVal, ok := retransmitTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retransmit_time expected to be basetypes.Int64Value, was: %T`, retransmitTimeAttribute))
	}

	routerLifetimeAttribute, ok := attributes["router_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_lifetime is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	routerLifetimeVal, ok := routerLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_lifetime expected to be basetypes.Int64Value, was: %T`, routerLifetimeAttribute))
	}

	if diags.HasError() {
		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	return Ipv6routerAdvertisementValue{
		CurrentHopLimit:          currentHopLimitVal,
		Enabled:                  enabledVal,
		IpMtu:                    ipMtuVal,
		ManagedConfigurationFlag: managedConfigurationFlagVal,
		MaxAdvertisementInterval: maxAdvertisementIntervalVal,
		MinAdvertisementInterval: minAdvertisementIntervalVal,
		OtherConfigurationFlag:   otherConfigurationFlagVal,
		Prefixes:                 prefixesVal,
		ReachableTime:            reachableTimeVal,
		RetransmitTime:           retransmitTimeVal,
		RouterLifetime:           routerLifetimeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewIpv6routerAdvertisementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6routerAdvertisementValue {
	object, diags := NewIpv6routerAdvertisementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6routerAdvertisementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6routerAdvertisementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6routerAdvertisementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6routerAdvertisementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6routerAdvertisementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6routerAdvertisementValueMust(Ipv6routerAdvertisementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6routerAdvertisementType) ValueType(ctx context.Context) attr.Value {
	return Ipv6routerAdvertisementValue{}
}

var _ basetypes.ObjectValuable = Ipv6routerAdvertisementValue{}

type Ipv6routerAdvertisementValue struct {
	CurrentHopLimit          basetypes.Int64Value `tfsdk:"current_hop_limit"`
	Enabled                  basetypes.BoolValue  `tfsdk:"enabled"`
	IpMtu                    basetypes.Int64Value `tfsdk:"ip_mtu"`
	ManagedConfigurationFlag basetypes.BoolValue  `tfsdk:"managed_configuration_flag"`
	MaxAdvertisementInterval basetypes.Int64Value `tfsdk:"max_advertisement_interval"`
	MinAdvertisementInterval basetypes.Int64Value `tfsdk:"min_advertisement_interval"`
	OtherConfigurationFlag   basetypes.BoolValue  `tfsdk:"other_configuration_flag"`
	Prefixes                 basetypes.ListValue  `tfsdk:"prefixes"`
	ReachableTime            basetypes.Int64Value `tfsdk:"reachable_time"`
	RetransmitTime           basetypes.Int64Value `tfsdk:"retransmit_time"`
	RouterLifetime           basetypes.Int64Value `tfsdk:"router_lifetime"`
	state                    attr.ValueState
}

func (v Ipv6routerAdvertisementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["current_hop_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ip_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_configuration_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["other_configuration_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefixes"] = basetypes.ListType{
		ElemType: PrefixesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["reachable_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["retransmit_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["router_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.CurrentHopLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_hop_limit"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.IpMtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_mtu"] = val

		val, err = v.ManagedConfigurationFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_configuration_flag"] = val

		val, err = v.MaxAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_advertisement_interval"] = val

		val, err = v.MinAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_advertisement_interval"] = val

		val, err = v.OtherConfigurationFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["other_configuration_flag"] = val

		val, err = v.Prefixes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefixes"] = val

		val, err = v.ReachableTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reachable_time"] = val

		val, err = v.RetransmitTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["retransmit_time"] = val

		val, err = v.RouterLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router_lifetime"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6routerAdvertisementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6routerAdvertisementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6routerAdvertisementValue) String() string {
	return "Ipv6routerAdvertisementValue"
}

func (v Ipv6routerAdvertisementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	prefixes := types.ListValueMust(
		PrefixesType{
			basetypes.ObjectType{
				AttrTypes: PrefixesValue{}.AttributeTypes(ctx),
			},
		},
		v.Prefixes.Elements(),
	)

	if v.Prefixes.IsNull() {
		prefixes = types.ListNull(
			PrefixesType{
				basetypes.ObjectType{
					AttrTypes: PrefixesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Prefixes.IsUnknown() {
		prefixes = types.ListUnknown(
			PrefixesType{
				basetypes.ObjectType{
					AttrTypes: PrefixesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"current_hop_limit":          basetypes.Int64Type{},
		"enabled":                    basetypes.BoolType{},
		"ip_mtu":                     basetypes.Int64Type{},
		"managed_configuration_flag": basetypes.BoolType{},
		"max_advertisement_interval": basetypes.Int64Type{},
		"min_advertisement_interval": basetypes.Int64Type{},
		"other_configuration_flag":   basetypes.BoolType{},
		"prefixes": basetypes.ListType{
			ElemType: PrefixesValue{}.Type(ctx),
		},
		"reachable_time":  basetypes.Int64Type{},
		"retransmit_time": basetypes.Int64Type{},
		"router_lifetime": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"current_hop_limit":          v.CurrentHopLimit,
			"enabled":                    v.Enabled,
			"ip_mtu":                     v.IpMtu,
			"managed_configuration_flag": v.ManagedConfigurationFlag,
			"max_advertisement_interval": v.MaxAdvertisementInterval,
			"min_advertisement_interval": v.MinAdvertisementInterval,
			"other_configuration_flag":   v.OtherConfigurationFlag,
			"prefixes":                   prefixes,
			"reachable_time":             v.ReachableTime,
			"retransmit_time":            v.RetransmitTime,
			"router_lifetime":            v.RouterLifetime,
		})

	return objVal, diags
}

func (v Ipv6routerAdvertisementValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6routerAdvertisementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CurrentHopLimit.Equal(other.CurrentHopLimit) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.IpMtu.Equal(other.IpMtu) {
		return false
	}

	if !v.ManagedConfigurationFlag.Equal(other.ManagedConfigurationFlag) {
		return false
	}

	if !v.MaxAdvertisementInterval.Equal(other.MaxAdvertisementInterval) {
		return false
	}

	if !v.MinAdvertisementInterval.Equal(other.MinAdvertisementInterval) {
		return false
	}

	if !v.OtherConfigurationFlag.Equal(other.OtherConfigurationFlag) {
		return false
	}

	if !v.Prefixes.Equal(other.Prefixes) {
		return false
	}

	if !v.ReachableTime.Equal(other.ReachableTime) {
		return false
	}

	if !v.RetransmitTime.Equal(other.RetransmitTime) {
		return false
	}

	if !v.RouterLifetime.Equal(other.RouterLifetime) {
		return false
	}

	return true
}

func (v Ipv6routerAdvertisementValue) Type(ctx context.Context) attr.Type {
	return Ipv6routerAdvertisementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6routerAdvertisementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"current_hop_limit":          basetypes.Int64Type{},
		"enabled":                    basetypes.BoolType{},
		"ip_mtu":                     basetypes.Int64Type{},
		"managed_configuration_flag": basetypes.BoolType{},
		"max_advertisement_interval": basetypes.Int64Type{},
		"min_advertisement_interval": basetypes.Int64Type{},
		"other_configuration_flag":   basetypes.BoolType{},
		"prefixes": basetypes.ListType{
			ElemType: PrefixesValue{}.Type(ctx),
		},
		"reachable_time":  basetypes.Int64Type{},
		"retransmit_time": basetypes.Int64Type{},
		"router_lifetime": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrefixesType{}

type PrefixesType struct {
	basetypes.ObjectType
}

func (t PrefixesType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixesType) String() string {
	return "PrefixesType"
}

func (t PrefixesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousFlagAttribute, ok := attributes["autonomous_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_flag is missing from object`)

		return nil, diags
	}

	autonomousFlagVal, ok := autonomousFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_flag expected to be basetypes.BoolValue, was: %T`, autonomousFlagAttribute))
	}

	onLinkFlagAttribute, ok := attributes["on_link_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_link_flag is missing from object`)

		return nil, diags
	}

	onLinkFlagVal, ok := onLinkFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_link_flag expected to be basetypes.BoolValue, was: %T`, onLinkFlagAttribute))
	}

	preferredLifetimeAttribute, ok := attributes["preferred_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_lifetime is missing from object`)

		return nil, diags
	}

	preferredLifetimeVal, ok := preferredLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_lifetime expected to be basetypes.Int64Value, was: %T`, preferredLifetimeAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	validLifetimeAttribute, ok := attributes["valid_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`valid_lifetime is missing from object`)

		return nil, diags
	}

	validLifetimeVal, ok := validLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`valid_lifetime expected to be basetypes.Int64Value, was: %T`, validLifetimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixesValue{
		AutonomousFlag:    autonomousFlagVal,
		OnLinkFlag:        onLinkFlagVal,
		PreferredLifetime: preferredLifetimeVal,
		Prefix:            prefixVal,
		ValidLifetime:     validLifetimeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixesValueNull() PrefixesValue {
	return PrefixesValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixesValueUnknown() PrefixesValue {
	return PrefixesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixesValue Attribute Value",
				"While creating a PrefixesValue value, a missing attribute value was detected. "+
					"A PrefixesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixesValue Attribute Type",
				"While creating a PrefixesValue value, an invalid attribute value was detected. "+
					"A PrefixesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixesValue Attribute Value",
				"While creating a PrefixesValue value, an extra attribute value was detected. "+
					"A PrefixesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixesValueUnknown(), diags
	}

	autonomousFlagAttribute, ok := attributes["autonomous_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_flag is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	autonomousFlagVal, ok := autonomousFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_flag expected to be basetypes.BoolValue, was: %T`, autonomousFlagAttribute))
	}

	onLinkFlagAttribute, ok := attributes["on_link_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_link_flag is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	onLinkFlagVal, ok := onLinkFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_link_flag expected to be basetypes.BoolValue, was: %T`, onLinkFlagAttribute))
	}

	preferredLifetimeAttribute, ok := attributes["preferred_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_lifetime is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	preferredLifetimeVal, ok := preferredLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_lifetime expected to be basetypes.Int64Value, was: %T`, preferredLifetimeAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	validLifetimeAttribute, ok := attributes["valid_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`valid_lifetime is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	validLifetimeVal, ok := validLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`valid_lifetime expected to be basetypes.Int64Value, was: %T`, validLifetimeAttribute))
	}

	if diags.HasError() {
		return NewPrefixesValueUnknown(), diags
	}

	return PrefixesValue{
		AutonomousFlag:    autonomousFlagVal,
		OnLinkFlag:        onLinkFlagVal,
		PreferredLifetime: preferredLifetimeVal,
		Prefix:            prefixVal,
		ValidLifetime:     validLifetimeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixesValue {
	object, diags := NewPrefixesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixesValueMust(PrefixesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixesType) ValueType(ctx context.Context) attr.Value {
	return PrefixesValue{}
}

var _ basetypes.ObjectValuable = PrefixesValue{}

type PrefixesValue struct {
	AutonomousFlag    basetypes.BoolValue   `tfsdk:"autonomous_flag"`
	OnLinkFlag        basetypes.BoolValue   `tfsdk:"on_link_flag"`
	PreferredLifetime basetypes.Int64Value  `tfsdk:"preferred_lifetime"`
	Prefix            basetypes.StringValue `tfsdk:"prefix"`
	ValidLifetime     basetypes.Int64Value  `tfsdk:"valid_lifetime"`
	state             attr.ValueState
}

func (v PrefixesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["on_link_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["preferred_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["valid_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AutonomousFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_flag"] = val

		val, err = v.OnLinkFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["on_link_flag"] = val

		val, err = v.PreferredLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preferred_lifetime"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.ValidLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["valid_lifetime"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixesValue) String() string {
	return "PrefixesValue"
}

func (v PrefixesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"autonomous_flag":    basetypes.BoolType{},
		"on_link_flag":       basetypes.BoolType{},
		"preferred_lifetime": basetypes.Int64Type{},
		"prefix":             basetypes.StringType{},
		"valid_lifetime":     basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_flag":    v.AutonomousFlag,
			"on_link_flag":       v.OnLinkFlag,
			"preferred_lifetime": v.PreferredLifetime,
			"prefix":             v.Prefix,
			"valid_lifetime":     v.ValidLifetime,
		})

	return objVal, diags
}

func (v PrefixesValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousFlag.Equal(other.AutonomousFlag) {
		return false
	}

	if !v.OnLinkFlag.Equal(other.OnLinkFlag) {
		return false
	}

	if !v.PreferredLifetime.Equal(other.PreferredLifetime) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.ValidLifetime.Equal(other.ValidLifetime) {
		return false
	}

	return true
}

func (v PrefixesValue) Type(ctx context.Context) attr.Type {
	return PrefixesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_flag":    basetypes.BoolType{},
		"on_link_flag":       basetypes.BoolType{},
		"preferred_lifetime": basetypes.Int64Type{},
		"prefix":             basetypes.StringType{},
		"valid_lifetime":     basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = L3proxyArpndType{}

type L3proxyArpndType struct {
	basetypes.ObjectType
}

func (t L3proxyArpndType) Equal(o attr.Type) bool {
	other, ok := o.(L3proxyArpndType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t L3proxyArpndType) String() string {
	return "L3proxyArpndType"
}

func (t L3proxyArpndType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return nil, diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.BoolValue, was: %T`, proxyArpAttribute))
	}

	proxyNdAttribute, ok := attributes["proxy_nd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_nd is missing from object`)

		return nil, diags
	}

	proxyNdVal, ok := proxyNdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_nd expected to be basetypes.BoolValue, was: %T`, proxyNdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return L3proxyArpndValue{
		ProxyArp: proxyArpVal,
		ProxyNd:  proxyNdVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewL3proxyArpndValueNull() L3proxyArpndValue {
	return L3proxyArpndValue{
		state: attr.ValueStateNull,
	}
}

func NewL3proxyArpndValueUnknown() L3proxyArpndValue {
	return L3proxyArpndValue{
		state: attr.ValueStateUnknown,
	}
}

func NewL3proxyArpndValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (L3proxyArpndValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing L3proxyArpndValue Attribute Value",
				"While creating a L3proxyArpndValue value, a missing attribute value was detected. "+
					"A L3proxyArpndValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3proxyArpndValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid L3proxyArpndValue Attribute Type",
				"While creating a L3proxyArpndValue value, an invalid attribute value was detected. "+
					"A L3proxyArpndValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3proxyArpndValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("L3proxyArpndValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra L3proxyArpndValue Attribute Value",
				"While creating a L3proxyArpndValue value, an extra attribute value was detected. "+
					"A L3proxyArpndValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra L3proxyArpndValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewL3proxyArpndValueUnknown(), diags
	}

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return NewL3proxyArpndValueUnknown(), diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.BoolValue, was: %T`, proxyArpAttribute))
	}

	proxyNdAttribute, ok := attributes["proxy_nd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_nd is missing from object`)

		return NewL3proxyArpndValueUnknown(), diags
	}

	proxyNdVal, ok := proxyNdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_nd expected to be basetypes.BoolValue, was: %T`, proxyNdAttribute))
	}

	if diags.HasError() {
		return NewL3proxyArpndValueUnknown(), diags
	}

	return L3proxyArpndValue{
		ProxyArp: proxyArpVal,
		ProxyNd:  proxyNdVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewL3proxyArpndValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) L3proxyArpndValue {
	object, diags := NewL3proxyArpndValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewL3proxyArpndValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t L3proxyArpndType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewL3proxyArpndValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewL3proxyArpndValueUnknown(), nil
	}

	if in.IsNull() {
		return NewL3proxyArpndValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewL3proxyArpndValueMust(L3proxyArpndValue{}.AttributeTypes(ctx), attributes), nil
}

func (t L3proxyArpndType) ValueType(ctx context.Context) attr.Value {
	return L3proxyArpndValue{}
}

var _ basetypes.ObjectValuable = L3proxyArpndValue{}

type L3proxyArpndValue struct {
	ProxyArp basetypes.BoolValue `tfsdk:"proxy_arp"`
	ProxyNd  basetypes.BoolValue `tfsdk:"proxy_nd"`
	state    attr.ValueState
}

func (v L3proxyArpndValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["proxy_arp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["proxy_nd"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ProxyArp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_arp"] = val

		val, err = v.ProxyNd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_nd"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v L3proxyArpndValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v L3proxyArpndValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v L3proxyArpndValue) String() string {
	return "L3proxyArpndValue"
}

func (v L3proxyArpndValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"proxy_arp": basetypes.BoolType{},
		"proxy_nd":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"proxy_arp": v.ProxyArp,
			"proxy_nd":  v.ProxyNd,
		})

	return objVal, diags
}

func (v L3proxyArpndValue) Equal(o attr.Value) bool {
	other, ok := o.(L3proxyArpndValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ProxyArp.Equal(other.ProxyArp) {
		return false
	}

	if !v.ProxyNd.Equal(other.ProxyNd) {
		return false
	}

	return true
}

func (v L3proxyArpndValue) Type(ctx context.Context) attr.Type {
	return L3proxyArpndType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v L3proxyArpndValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"proxy_arp": basetypes.BoolType{},
		"proxy_nd":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = VirtualIpdiscoveryType{}

type VirtualIpdiscoveryType struct {
	basetypes.ObjectType
}

func (t VirtualIpdiscoveryType) Equal(o attr.Type) bool {
	other, ok := o.(VirtualIpdiscoveryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VirtualIpdiscoveryType) String() string {
	return "VirtualIpdiscoveryType"
}

func (t VirtualIpdiscoveryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	allowedMacAttribute, ok := attributes["allowed_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_mac is missing from object`)

		return nil, diags
	}

	allowedMacVal, ok := allowedMacAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_mac expected to be basetypes.ListValue, was: %T`, allowedMacAttribute))
	}

	bridgeInterfaceToProbeAttribute, ok := attributes["bridge_interface_to_probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_interface_to_probe is missing from object`)

		return nil, diags
	}

	bridgeInterfaceToProbeVal, ok := bridgeInterfaceToProbeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_interface_to_probe expected to be basetypes.ListValue, was: %T`, bridgeInterfaceToProbeAttribute))
	}

	probeIntervalAttribute, ok := attributes["probe_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_interval is missing from object`)

		return nil, diags
	}

	probeIntervalVal, ok := probeIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_interval expected to be basetypes.Int64Value, was: %T`, probeIntervalAttribute))
	}

	vlanToProbeAttribute, ok := attributes["vlan_to_probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_to_probe is missing from object`)

		return nil, diags
	}

	vlanToProbeVal, ok := vlanToProbeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_to_probe expected to be basetypes.ListValue, was: %T`, vlanToProbeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VirtualIpdiscoveryValue{
		Address:                addressVal,
		AllowedMac:             allowedMacVal,
		BridgeInterfaceToProbe: bridgeInterfaceToProbeVal,
		ProbeInterval:          probeIntervalVal,
		VlanToProbe:            vlanToProbeVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewVirtualIpdiscoveryValueNull() VirtualIpdiscoveryValue {
	return VirtualIpdiscoveryValue{
		state: attr.ValueStateNull,
	}
}

func NewVirtualIpdiscoveryValueUnknown() VirtualIpdiscoveryValue {
	return VirtualIpdiscoveryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVirtualIpdiscoveryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VirtualIpdiscoveryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VirtualIpdiscoveryValue Attribute Value",
				"While creating a VirtualIpdiscoveryValue value, a missing attribute value was detected. "+
					"A VirtualIpdiscoveryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VirtualIpdiscoveryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VirtualIpdiscoveryValue Attribute Type",
				"While creating a VirtualIpdiscoveryValue value, an invalid attribute value was detected. "+
					"A VirtualIpdiscoveryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VirtualIpdiscoveryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VirtualIpdiscoveryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VirtualIpdiscoveryValue Attribute Value",
				"While creating a VirtualIpdiscoveryValue value, an extra attribute value was detected. "+
					"A VirtualIpdiscoveryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VirtualIpdiscoveryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVirtualIpdiscoveryValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewVirtualIpdiscoveryValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	allowedMacAttribute, ok := attributes["allowed_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_mac is missing from object`)

		return NewVirtualIpdiscoveryValueUnknown(), diags
	}

	allowedMacVal, ok := allowedMacAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_mac expected to be basetypes.ListValue, was: %T`, allowedMacAttribute))
	}

	bridgeInterfaceToProbeAttribute, ok := attributes["bridge_interface_to_probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_interface_to_probe is missing from object`)

		return NewVirtualIpdiscoveryValueUnknown(), diags
	}

	bridgeInterfaceToProbeVal, ok := bridgeInterfaceToProbeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_interface_to_probe expected to be basetypes.ListValue, was: %T`, bridgeInterfaceToProbeAttribute))
	}

	probeIntervalAttribute, ok := attributes["probe_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_interval is missing from object`)

		return NewVirtualIpdiscoveryValueUnknown(), diags
	}

	probeIntervalVal, ok := probeIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_interval expected to be basetypes.Int64Value, was: %T`, probeIntervalAttribute))
	}

	vlanToProbeAttribute, ok := attributes["vlan_to_probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_to_probe is missing from object`)

		return NewVirtualIpdiscoveryValueUnknown(), diags
	}

	vlanToProbeVal, ok := vlanToProbeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_to_probe expected to be basetypes.ListValue, was: %T`, vlanToProbeAttribute))
	}

	if diags.HasError() {
		return NewVirtualIpdiscoveryValueUnknown(), diags
	}

	return VirtualIpdiscoveryValue{
		Address:                addressVal,
		AllowedMac:             allowedMacVal,
		BridgeInterfaceToProbe: bridgeInterfaceToProbeVal,
		ProbeInterval:          probeIntervalVal,
		VlanToProbe:            vlanToProbeVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewVirtualIpdiscoveryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VirtualIpdiscoveryValue {
	object, diags := NewVirtualIpdiscoveryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVirtualIpdiscoveryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VirtualIpdiscoveryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVirtualIpdiscoveryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVirtualIpdiscoveryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVirtualIpdiscoveryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVirtualIpdiscoveryValueMust(VirtualIpdiscoveryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VirtualIpdiscoveryType) ValueType(ctx context.Context) attr.Value {
	return VirtualIpdiscoveryValue{}
}

var _ basetypes.ObjectValuable = VirtualIpdiscoveryValue{}

type VirtualIpdiscoveryValue struct {
	Address                basetypes.StringValue `tfsdk:"address"`
	AllowedMac             basetypes.ListValue   `tfsdk:"allowed_mac"`
	BridgeInterfaceToProbe basetypes.ListValue   `tfsdk:"bridge_interface_to_probe"`
	ProbeInterval          basetypes.Int64Value  `tfsdk:"probe_interval"`
	VlanToProbe            basetypes.ListValue   `tfsdk:"vlan_to_probe"`
	state                  attr.ValueState
}

func (v VirtualIpdiscoveryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["allowed_mac"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["bridge_interface_to_probe"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["probe_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vlan_to_probe"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.AllowedMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_mac"] = val

		val, err = v.BridgeInterfaceToProbe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bridge_interface_to_probe"] = val

		val, err = v.ProbeInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probe_interval"] = val

		val, err = v.VlanToProbe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_to_probe"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VirtualIpdiscoveryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VirtualIpdiscoveryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VirtualIpdiscoveryValue) String() string {
	return "VirtualIpdiscoveryValue"
}

func (v VirtualIpdiscoveryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var allowedMacVal basetypes.ListValue
	switch {
	case v.AllowedMac.IsUnknown():
		allowedMacVal = types.ListUnknown(types.StringType)
	case v.AllowedMac.IsNull():
		allowedMacVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		allowedMacVal, d = types.ListValue(types.StringType, v.AllowedMac.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address": basetypes.StringType{},
			"allowed_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bridge_interface_to_probe": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_interval": basetypes.Int64Type{},
			"vlan_to_probe": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var bridgeInterfaceToProbeVal basetypes.ListValue
	switch {
	case v.BridgeInterfaceToProbe.IsUnknown():
		bridgeInterfaceToProbeVal = types.ListUnknown(types.StringType)
	case v.BridgeInterfaceToProbe.IsNull():
		bridgeInterfaceToProbeVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		bridgeInterfaceToProbeVal, d = types.ListValue(types.StringType, v.BridgeInterfaceToProbe.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address": basetypes.StringType{},
			"allowed_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bridge_interface_to_probe": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_interval": basetypes.Int64Type{},
			"vlan_to_probe": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var vlanToProbeVal basetypes.ListValue
	switch {
	case v.VlanToProbe.IsUnknown():
		vlanToProbeVal = types.ListUnknown(types.StringType)
	case v.VlanToProbe.IsNull():
		vlanToProbeVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		vlanToProbeVal, d = types.ListValue(types.StringType, v.VlanToProbe.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address": basetypes.StringType{},
			"allowed_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bridge_interface_to_probe": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_interval": basetypes.Int64Type{},
			"vlan_to_probe": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"address": basetypes.StringType{},
		"allowed_mac": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bridge_interface_to_probe": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_interval": basetypes.Int64Type{},
		"vlan_to_probe": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address":                   v.Address,
			"allowed_mac":               allowedMacVal,
			"bridge_interface_to_probe": bridgeInterfaceToProbeVal,
			"probe_interval":            v.ProbeInterval,
			"vlan_to_probe":             vlanToProbeVal,
		})

	return objVal, diags
}

func (v VirtualIpdiscoveryValue) Equal(o attr.Value) bool {
	other, ok := o.(VirtualIpdiscoveryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.AllowedMac.Equal(other.AllowedMac) {
		return false
	}

	if !v.BridgeInterfaceToProbe.Equal(other.BridgeInterfaceToProbe) {
		return false
	}

	if !v.ProbeInterval.Equal(other.ProbeInterval) {
		return false
	}

	if !v.VlanToProbe.Equal(other.VlanToProbe) {
		return false
	}

	return true
}

func (v VirtualIpdiscoveryValue) Type(ctx context.Context) attr.Type {
	return VirtualIpdiscoveryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VirtualIpdiscoveryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address": basetypes.StringType{},
		"allowed_mac": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bridge_interface_to_probe": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_interval": basetypes.Int64Type{},
		"vlan_to_probe": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return nil, diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return nil, diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	interfacesAttribute, ok := attributes["interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interfaces is missing from object`)

		return nil, diags
	}

	interfacesVal, ok := interfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interfaces expected to be basetypes.ListValue, was: %T`, interfacesAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		Interfaces:        interfacesVal,
		LastChange:        lastChangeVal,
		OperationalState:  operationalStateVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	interfacesAttribute, ok := attributes["interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	interfacesVal, ok := interfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interfaces expected to be basetypes.ListValue, was: %T`, interfacesAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		Interfaces:        interfacesVal,
		LastChange:        lastChangeVal,
		OperationalState:  operationalStateVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Health            basetypes.Int64Value  `tfsdk:"health"`
	HealthScoreReason basetypes.StringValue `tfsdk:"health_score_reason"`
	Interfaces        basetypes.ListValue   `tfsdk:"interfaces"`
	LastChange        basetypes.StringValue `tfsdk:"last_change"`
	OperationalState  basetypes.StringValue `tfsdk:"operational_state"`
	state             attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["health"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_score_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interfaces"] = basetypes.ListType{
		ElemType: InterfacesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Health.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health"] = val

		val, err = v.HealthScoreReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_score_reason"] = val

		val, err = v.Interfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interfaces"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	interfaces := types.ListValueMust(
		InterfacesType{
			basetypes.ObjectType{
				AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
			},
		},
		v.Interfaces.Elements(),
	)

	if v.Interfaces.IsNull() {
		interfaces = types.ListNull(
			InterfacesType{
				basetypes.ObjectType{
					AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Interfaces.IsUnknown() {
		interfaces = types.ListUnknown(
			InterfacesType{
				basetypes.ObjectType{
					AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"interfaces": basetypes.ListType{
			ElemType: InterfacesValue{}.Type(ctx),
		},
		"last_change":       basetypes.StringType{},
		"operational_state": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"health":              v.Health,
			"health_score_reason": v.HealthScoreReason,
			"interfaces":          interfaces,
			"last_change":         v.LastChange,
			"operational_state":   v.OperationalState,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Health.Equal(other.Health) {
		return false
	}

	if !v.HealthScoreReason.Equal(other.HealthScoreReason) {
		return false
	}

	if !v.Interfaces.Equal(other.Interfaces) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"interfaces": basetypes.ListType{
			ElemType: InterfacesValue{}.Type(ctx),
		},
		"last_change":       basetypes.StringType{},
		"operational_state": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfacesType{}

type InterfacesType struct {
	basetypes.ObjectType
}

func (t InterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(InterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfacesType) String() string {
	return "InterfacesType"
}

func (t InterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipv4addressesAttribute, ok := attributes["ipv4addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4addresses is missing from object`)

		return nil, diags
	}

	ipv4addressesVal, ok := ipv4addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4addresses expected to be basetypes.ListValue, was: %T`, ipv4addressesAttribute))
	}

	ipv6addressesAttribute, ok := attributes["ipv6addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6addresses is missing from object`)

		return nil, diags
	}

	ipv6addressesVal, ok := ipv6addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6addresses expected to be basetypes.ListValue, was: %T`, ipv6addressesAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	nodeInterfaceAttribute, ok := attributes["node_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_interface is missing from object`)

		return nil, diags
	}

	nodeInterfaceVal, ok := nodeInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_interface expected to be basetypes.StringValue, was: %T`, nodeInterfaceAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfacesValue{
		Enabled:          enabledVal,
		Ipv4addresses:    ipv4addressesVal,
		Ipv6addresses:    ipv6addressesVal,
		LastChange:       lastChangeVal,
		Node:             nodeVal,
		NodeInterface:    nodeInterfaceVal,
		OperatingSystem:  operatingSystemVal,
		OperationalState: operationalStateVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewInterfacesValueNull() InterfacesValue {
	return InterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfacesValueUnknown() InterfacesValue {
	return InterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfacesValue Attribute Value",
				"While creating a InterfacesValue value, a missing attribute value was detected. "+
					"A InterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfacesValue Attribute Type",
				"While creating a InterfacesValue value, an invalid attribute value was detected. "+
					"A InterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfacesValue Attribute Value",
				"While creating a InterfacesValue value, an extra attribute value was detected. "+
					"A InterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfacesValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipv4addressesAttribute, ok := attributes["ipv4addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4addresses is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	ipv4addressesVal, ok := ipv4addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4addresses expected to be basetypes.ListValue, was: %T`, ipv4addressesAttribute))
	}

	ipv6addressesAttribute, ok := attributes["ipv6addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6addresses is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	ipv6addressesVal, ok := ipv6addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6addresses expected to be basetypes.ListValue, was: %T`, ipv6addressesAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	nodeInterfaceAttribute, ok := attributes["node_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_interface is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	nodeInterfaceVal, ok := nodeInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_interface expected to be basetypes.StringValue, was: %T`, nodeInterfaceAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	if diags.HasError() {
		return NewInterfacesValueUnknown(), diags
	}

	return InterfacesValue{
		Enabled:          enabledVal,
		Ipv4addresses:    ipv4addressesVal,
		Ipv6addresses:    ipv6addressesVal,
		LastChange:       lastChangeVal,
		Node:             nodeVal,
		NodeInterface:    nodeInterfaceVal,
		OperatingSystem:  operatingSystemVal,
		OperationalState: operationalStateVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfacesValue {
	object, diags := NewInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfacesValueMust(InterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfacesType) ValueType(ctx context.Context) attr.Value {
	return InterfacesValue{}
}

var _ basetypes.ObjectValuable = InterfacesValue{}

type InterfacesValue struct {
	Enabled          basetypes.BoolValue   `tfsdk:"enabled"`
	Ipv4addresses    basetypes.ListValue   `tfsdk:"ipv4addresses"`
	Ipv6addresses    basetypes.ListValue   `tfsdk:"ipv6addresses"`
	LastChange       basetypes.StringValue `tfsdk:"last_change"`
	Node             basetypes.StringValue `tfsdk:"node"`
	NodeInterface    basetypes.StringValue `tfsdk:"node_interface"`
	OperatingSystem  basetypes.StringValue `tfsdk:"operating_system"`
	OperationalState basetypes.StringValue `tfsdk:"operational_state"`
	state            attr.ValueState
}

func (v InterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 8)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ipv4addresses"] = basetypes.ListType{
		ElemType: Ipv4addressesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6addresses"] = basetypes.ListType{
		ElemType: Ipv6addressesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 8)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Ipv4addresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4addresses"] = val

		val, err = v.Ipv6addresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6addresses"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.NodeInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_interface"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfacesValue) String() string {
	return "InterfacesValue"
}

func (v InterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	ipv4addresses := types.ListValueMust(
		Ipv4addressesType{
			basetypes.ObjectType{
				AttrTypes: Ipv4addressesValue{}.AttributeTypes(ctx),
			},
		},
		v.Ipv4addresses.Elements(),
	)

	if v.Ipv4addresses.IsNull() {
		ipv4addresses = types.ListNull(
			Ipv4addressesType{
				basetypes.ObjectType{
					AttrTypes: Ipv4addressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ipv4addresses.IsUnknown() {
		ipv4addresses = types.ListUnknown(
			Ipv4addressesType{
				basetypes.ObjectType{
					AttrTypes: Ipv4addressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	ipv6addresses := types.ListValueMust(
		Ipv6addressesType{
			basetypes.ObjectType{
				AttrTypes: Ipv6addressesValue{}.AttributeTypes(ctx),
			},
		},
		v.Ipv6addresses.Elements(),
	)

	if v.Ipv6addresses.IsNull() {
		ipv6addresses = types.ListNull(
			Ipv6addressesType{
				basetypes.ObjectType{
					AttrTypes: Ipv6addressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ipv6addresses.IsUnknown() {
		ipv6addresses = types.ListUnknown(
			Ipv6addressesType{
				basetypes.ObjectType{
					AttrTypes: Ipv6addressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"ipv4addresses": basetypes.ListType{
			ElemType: Ipv4addressesValue{}.Type(ctx),
		},
		"ipv6addresses": basetypes.ListType{
			ElemType: Ipv6addressesValue{}.Type(ctx),
		},
		"last_change":       basetypes.StringType{},
		"node":              basetypes.StringType{},
		"node_interface":    basetypes.StringType{},
		"operating_system":  basetypes.StringType{},
		"operational_state": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":           v.Enabled,
			"ipv4addresses":     ipv4addresses,
			"ipv6addresses":     ipv6addresses,
			"last_change":       v.LastChange,
			"node":              v.Node,
			"node_interface":    v.NodeInterface,
			"operating_system":  v.OperatingSystem,
			"operational_state": v.OperationalState,
		})

	return objVal, diags
}

func (v InterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Ipv4addresses.Equal(other.Ipv4addresses) {
		return false
	}

	if !v.Ipv6addresses.Equal(other.Ipv6addresses) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.NodeInterface.Equal(other.NodeInterface) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	return true
}

func (v InterfacesValue) Type(ctx context.Context) attr.Type {
	return InterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"ipv4addresses": basetypes.ListType{
			ElemType: Ipv4addressesValue{}.Type(ctx),
		},
		"ipv6addresses": basetypes.ListType{
			ElemType: Ipv6addressesValue{}.Type(ctx),
		},
		"last_change":       basetypes.StringType{},
		"node":              basetypes.StringType{},
		"node_interface":    basetypes.StringType{},
		"operating_system":  basetypes.StringType{},
		"operational_state": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Ipv4addressesType{}

type Ipv4addressesType struct {
	basetypes.ObjectType
}

func (t Ipv4addressesType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4addressesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4addressesType) String() string {
	return "Ipv4addressesType"
}

func (t Ipv4addressesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return nil, diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4addressesValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv4addressesValueNull() Ipv4addressesValue {
	return Ipv4addressesValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv4addressesValueUnknown() Ipv4addressesValue {
	return Ipv4addressesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4addressesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4addressesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4addressesValue Attribute Value",
				"While creating a Ipv4addressesValue value, a missing attribute value was detected. "+
					"A Ipv4addressesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4addressesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4addressesValue Attribute Type",
				"While creating a Ipv4addressesValue value, an invalid attribute value was detected. "+
					"A Ipv4addressesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4addressesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4addressesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4addressesValue Attribute Value",
				"While creating a Ipv4addressesValue value, an extra attribute value was detected. "+
					"A Ipv4addressesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4addressesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4addressesValueUnknown(), diags
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return NewIpv4addressesValueUnknown(), diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewIpv4addressesValueUnknown(), diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return NewIpv4addressesValueUnknown(), diags
	}

	return Ipv4addressesValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv4addressesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4addressesValue {
	object, diags := NewIpv4addressesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4addressesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4addressesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4addressesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4addressesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4addressesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4addressesValueMust(Ipv4addressesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4addressesType) ValueType(ctx context.Context) attr.Value {
	return Ipv4addressesValue{}
}

var _ basetypes.ObjectValuable = Ipv4addressesValue{}

type Ipv4addressesValue struct {
	IpPrefix basetypes.StringValue `tfsdk:"ip_prefix"`
	Primary  basetypes.BoolValue   `tfsdk:"primary"`
	state    attr.ValueState
}

func (v Ipv4addressesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_prefix"] = val

		val, err = v.Primary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4addressesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4addressesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4addressesValue) String() string {
	return "Ipv4addressesValue"
}

func (v Ipv4addressesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_prefix": v.IpPrefix,
			"primary":   v.Primary,
		})

	return objVal, diags
}

func (v Ipv4addressesValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4addressesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpPrefix.Equal(other.IpPrefix) {
		return false
	}

	if !v.Primary.Equal(other.Primary) {
		return false
	}

	return true
}

func (v Ipv4addressesValue) Type(ctx context.Context) attr.Type {
	return Ipv4addressesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4addressesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ipv6addressesType{}

type Ipv6addressesType struct {
	basetypes.ObjectType
}

func (t Ipv6addressesType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6addressesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6addressesType) String() string {
	return "Ipv6addressesType"
}

func (t Ipv6addressesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return nil, diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6addressesValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv6addressesValueNull() Ipv6addressesValue {
	return Ipv6addressesValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv6addressesValueUnknown() Ipv6addressesValue {
	return Ipv6addressesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6addressesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6addressesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6addressesValue Attribute Value",
				"While creating a Ipv6addressesValue value, a missing attribute value was detected. "+
					"A Ipv6addressesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6addressesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6addressesValue Attribute Type",
				"While creating a Ipv6addressesValue value, an invalid attribute value was detected. "+
					"A Ipv6addressesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6addressesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6addressesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6addressesValue Attribute Value",
				"While creating a Ipv6addressesValue value, an extra attribute value was detected. "+
					"A Ipv6addressesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6addressesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6addressesValueUnknown(), diags
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return NewIpv6addressesValueUnknown(), diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewIpv6addressesValueUnknown(), diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return NewIpv6addressesValueUnknown(), diags
	}

	return Ipv6addressesValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv6addressesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6addressesValue {
	object, diags := NewIpv6addressesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6addressesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6addressesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6addressesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6addressesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6addressesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6addressesValueMust(Ipv6addressesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6addressesType) ValueType(ctx context.Context) attr.Value {
	return Ipv6addressesValue{}
}

var _ basetypes.ObjectValuable = Ipv6addressesValue{}

type Ipv6addressesValue struct {
	IpPrefix basetypes.StringValue `tfsdk:"ip_prefix"`
	Primary  basetypes.BoolValue   `tfsdk:"primary"`
	state    attr.ValueState
}

func (v Ipv6addressesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_prefix"] = val

		val, err = v.Primary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6addressesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6addressesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6addressesValue) String() string {
	return "Ipv6addressesValue"
}

func (v Ipv6addressesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_prefix": v.IpPrefix,
			"primary":   v.Primary,
		})

	return objVal, diags
}

func (v Ipv6addressesValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6addressesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpPrefix.Equal(other.IpPrefix) {
		return false
	}

	if !v.Primary.Equal(other.Primary) {
		return false
	}

	return true
}

func (v Ipv6addressesValue) Type(ctx context.Context) attr.Type {
	return Ipv6addressesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6addressesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}
}
