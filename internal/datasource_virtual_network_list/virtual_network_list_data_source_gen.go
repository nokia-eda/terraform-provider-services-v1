// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_virtual_network_list

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func VirtualNetworkListDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"fields": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
				MarkdownDescription: "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
			},
			"filter": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "an EQL \"where\" expression that will be used to filter the set of resources returned.",
				MarkdownDescription: "an EQL \"where\" expression that will be used to filter the set of resources returned.",
			},
			"items": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"alarms": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"critical": schema.Int64Attribute{
									Computed: true,
								},
								"major": schema.Int64Attribute{
									Computed: true,
								},
								"minor": schema.Int64Attribute{
									Computed: true,
								},
								"warning": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: AlarmsType{
								ObjectType: types.ObjectType{
									AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"api_version": schema.StringAttribute{
							Computed: true,
						},
						"deviations": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"count": schema.Int64Attribute{
									Computed: true,
								},
							},
							CustomType: DeviationsType{
								ObjectType: types.ObjectType{
									AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"kind": schema.StringAttribute{
							Computed: true,
						},
						"metadata": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"labels": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"namespace": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: MetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: MetadataValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"spec": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"bridge_domains": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Optional:            true,
												Description:         "The name of the BridgeDomain.",
												MarkdownDescription: "The name of the BridgeDomain.",
											},
											"spec": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"configured_name": schema.StringAttribute{
														Optional:            true,
														Description:         "The name of the BridgeDomain to configure on the device.",
														MarkdownDescription: "The name of the BridgeDomain to configure on the device.",
													},
													"description": schema.StringAttribute{
														Optional:            true,
														Description:         "The description of the BridgeDomain.",
														MarkdownDescription: "The description of the BridgeDomain.",
													},
													"evi": schema.Int64Attribute{
														Optional:            true,
														Description:         "EVI to use for this BridgeDomain, can be optionally left blank to have it automatically allocated using the EVI Pool.",
														MarkdownDescription: "EVI to use for this BridgeDomain, can be optionally left blank to have it automatically allocated using the EVI Pool.",
													},
													"evi_pool": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to an EVI pool to use for allocations if EVI is left blank.",
														MarkdownDescription: "Reference to an EVI pool to use for allocations if EVI is left blank.",
													},
													"export_target": schema.StringAttribute{
														Optional:            true,
														Description:         "Export route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
														MarkdownDescription: "Export route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
													},
													"import_target": schema.StringAttribute{
														Optional:            true,
														Description:         "Import route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
														MarkdownDescription: "Import route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
													},
													"l2proxy_arpnd": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"dynamic_learning": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"age_time": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "Aging timer value for the proxy entries in seconds. If not set, this indicates that the entries are never flushed.",
																		MarkdownDescription: "Aging timer value for the proxy entries in seconds. If not set, this indicates that the entries are never flushed.",
																	},
																	"enabled": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enables or disables Dynamic Learning.",
																		MarkdownDescription: "Enables or disables Dynamic Learning.",
																	},
																	"send_refresh": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "The interval determines the frequency at which the system generates three ARP Requests or Neighbor Solicitations with the intent to refresh the proxy entry. The refresh is sent within the age-time window.",
																		MarkdownDescription: "The interval determines the frequency at which the system generates three ARP Requests or Neighbor Solicitations with the intent to refresh the proxy entry. The refresh is sent within the age-time window.",
																	},
																},
																CustomType: DynamicLearningType{
																	ObjectType: types.ObjectType{
																		AttrTypes: DynamicLearningValue{}.AttributeTypes(ctx),
																	},
																},
																Optional: true,
															},
															"ip_duplication": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"enabled": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enables or disables IP Duplication.",
																		MarkdownDescription: "Enables or disables IP Duplication.",
																	},
																	"hold_down_time": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "Time to wait in minutes from the moment an IP is declared duplicate to the time the IP is removed from the proxy ARP/ND table.",
																		MarkdownDescription: "Time to wait in minutes from the moment an IP is declared duplicate to the time the IP is removed from the proxy ARP/ND table.",
																	},
																	"monitoring_window": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "Monitoring window for detecting duplication on a given IP address in the proxy ARP/ND table.",
																		MarkdownDescription: "Monitoring window for detecting duplication on a given IP address in the proxy ARP/ND table.",
																	},
																	"num_moves": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "Number of moves in the proxy ARP/ND table that an IP is allowed within the monitoring-window.",
																		MarkdownDescription: "Number of moves in the proxy ARP/ND table that an IP is allowed within the monitoring-window.",
																	},
																},
																CustomType: IpDuplicationType{
																	ObjectType: types.ObjectType{
																		AttrTypes: IpDuplicationValue{}.AttributeTypes(ctx),
																	},
																},
																Optional: true,
															},
															"proxy_arp": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enables proxy ARP.",
																MarkdownDescription: "Enables proxy ARP.",
															},
															"proxy_nd": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enables proxy ND.",
																MarkdownDescription: "Enables proxy ND.",
															},
															"table_size": schema.Int64Attribute{
																Optional:            true,
																Description:         "Maximum number of entries allowed in the proxy table of the bridge domain.",
																MarkdownDescription: "Maximum number of entries allowed in the proxy table of the bridge domain.",
															},
														},
														CustomType: L2proxyArpndType{
															ObjectType: types.ObjectType{
																AttrTypes: L2proxyArpndValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Enables / Disabled Proxy ARP / Proxy ND.",
														MarkdownDescription: "Enables / Disabled Proxy ARP / Proxy ND.",
													},
													"mac_aging": schema.Int64Attribute{
														Optional:            true,
														Description:         "Configurable aging time for dynamically learned mac addresses.",
														MarkdownDescription: "Configurable aging time for dynamically learned mac addresses.",
													},
													"mac_duplication_detection": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"action": schema.StringAttribute{
																Optional:            true,
																Description:         "Action to take on the subinterface upon detecting at least one mac addresses as duplicate on the subinterface.",
																MarkdownDescription: "Action to take on the subinterface upon detecting at least one mac addresses as duplicate on the subinterface.",
															},
															"enabled": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enables or disables Mac Duplication Detection.",
																MarkdownDescription: "Enables or disables Mac Duplication Detection.",
															},
															"hold_down_time": schema.Int64Attribute{
																Optional:            true,
																Description:         "Time to wait in minutes from the moment a mac is declared duplicate to the mac is flushed from the bridge table.",
																MarkdownDescription: "Time to wait in minutes from the moment a mac is declared duplicate to the mac is flushed from the bridge table.",
															},
															"monitoring_window": schema.Int64Attribute{
																Optional:            true,
																Description:         "Monitoring window in minutes for detecting duplication on a given mac address.",
																MarkdownDescription: "Monitoring window in minutes for detecting duplication on a given mac address.",
															},
															"num_moves": schema.Int64Attribute{
																Optional:            true,
																Description:         "Number of moves a mac is allowed within the monitoring-window, before it is declared duplicate.",
																MarkdownDescription: "Number of moves a mac is allowed within the monitoring-window, before it is declared duplicate.",
															},
														},
														CustomType: MacDuplicationDetectionType{
															ObjectType: types.ObjectType{
																AttrTypes: MacDuplicationDetectionValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Enable or disable MAC duplication detection and resolution mechanisms.",
														MarkdownDescription: "Enable or disable MAC duplication detection and resolution mechanisms.",
													},
													"mac_learning": schema.BoolAttribute{
														Optional:            true,
														Description:         "Enable MAC learning for this BridgeDomain.",
														MarkdownDescription: "Enable MAC learning for this BridgeDomain.",
													},
													"mac_limit": schema.Int64Attribute{
														Optional:            true,
														Description:         "Sets the maximum number of MAC entries accepted in the bridge table.",
														MarkdownDescription: "Sets the maximum number of MAC entries accepted in the bridge table.",
													},
													"tunnel_index_pool": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to a tunnel index pool to use for allocations.",
														MarkdownDescription: "Reference to a tunnel index pool to use for allocations.",
													},
													"type": schema.StringAttribute{
														Optional:            true,
														Description:         "Select the type of BridgeDomain.  Simple doesn't include any overlay control plane or dataplane properties (EVPN/VXLAN). EVPNVXLAN includes the properties needed to provision this BridgeDomain over an IP Fabric.",
														MarkdownDescription: "Select the type of BridgeDomain.  Simple doesn't include any overlay control plane or dataplane properties (EVPN/VXLAN). EVPNVXLAN includes the properties needed to provision this BridgeDomain over an IP Fabric.",
													},
													"vni": schema.Int64Attribute{
														Optional:            true,
														Description:         "VNI to use for this BridgeDomain, can be optionally left blank to have it allocated using the VNI Pool.",
														MarkdownDescription: "VNI to use for this BridgeDomain, can be optionally left blank to have it allocated using the VNI Pool.",
													},
													"vni_pool": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to a VNI pool to use for allocations if VNI is left blank.",
														MarkdownDescription: "Reference to a VNI pool to use for allocations if VNI is left blank.",
													},
												},
												CustomType: Spec1Type{
													ObjectType: types.ObjectType{
														AttrTypes: Spec1Value{}.AttributeTypes(ctx),
													},
												},
												Optional:            true,
												Description:         "Specification of the BridgeDomain",
												MarkdownDescription: "Specification of the BridgeDomain",
											},
										},
										CustomType: BridgeDomainsType{
											ObjectType: types.ObjectType{
												AttrTypes: BridgeDomainsValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "List of Subnets. [emits=BridgeDomain]",
									MarkdownDescription: "List of Subnets. [emits=BridgeDomain]",
								},
								"bridge_interfaces": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Optional:            true,
												Description:         "The name of the BridgeInterface.",
												MarkdownDescription: "The name of the BridgeInterface.",
											},
											"spec": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"bridge_domain": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to a BridgeDomain in which to attach the BridgeInterface.",
														MarkdownDescription: "Reference to a BridgeDomain in which to attach the BridgeInterface.",
													},
													"description": schema.StringAttribute{
														Optional:            true,
														Description:         "The description of the BridgeInterface.",
														MarkdownDescription: "The description of the BridgeInterface.",
													},
													"egress": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"filters": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of Filter references to use at egress.",
																MarkdownDescription: "List of Filter references to use at egress.",
															},
															"qos_policy": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of QoS Egress policy references to use at egress.",
																MarkdownDescription: "List of QoS Egress policy references to use at egress.",
															},
														},
														CustomType: EgressType{
															ObjectType: types.ObjectType{
																AttrTypes: EgressValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Manages actions on traffic at Egress.",
														MarkdownDescription: "Manages actions on traffic at Egress.",
													},
													"ingress": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"filters": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of Filter references to use at ingress.",
																MarkdownDescription: "List of Filter references to use at ingress.",
															},
															"qos_policy": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of QoS Ingress policy references to use at ingress.",
																MarkdownDescription: "List of QoS Ingress policy references to use at ingress.",
															},
														},
														CustomType: IngressType{
															ObjectType: types.ObjectType{
																AttrTypes: IngressValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Manages actions on traffic at Ingress.",
														MarkdownDescription: "Manages actions on traffic at Ingress.",
													},
													"interface": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to an Interface resource to attach this BridgeInterface.",
														MarkdownDescription: "Reference to an Interface resource to attach this BridgeInterface.",
													},
													"l2_mtu": schema.Int64Attribute{
														Optional:            true,
														Description:         "L2 MTU specifies the maximum sized Ethernet frame that can be transmitted on the subinterface. If a frame exceeds this size it is discarded. If the l2-mtu of the subinterface exceeds the port-mtu of the associated interface, the subinterface will remain operationally down.",
														MarkdownDescription: "L2 MTU specifies the maximum sized Ethernet frame that can be transmitted on the subinterface. If a frame exceeds this size it is discarded. If the l2-mtu of the subinterface exceeds the port-mtu of the associated interface, the subinterface will remain operationally down.",
													},
													"mac_duplication_detection_action": schema.StringAttribute{
														Optional:            true,
														Description:         "Override for Mac Duplication Detection action if enabled in the associated BridgeDomain.",
														MarkdownDescription: "Override for Mac Duplication Detection action if enabled in the associated BridgeDomain.",
													},
													"split_horizon_group": schema.StringAttribute{
														Optional:            true,
														Description:         "Split Horizon Group to be used for this BridgeInterface. The subinterface within this BridgeInterface will be a member of this Split Horizon Group.",
														MarkdownDescription: "Split Horizon Group to be used for this BridgeInterface. The subinterface within this BridgeInterface will be a member of this Split Horizon Group.",
													},
													"uplink": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"egress": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"filters": schema.ListAttribute{
																		ElementType:         types.StringType,
																		Optional:            true,
																		Description:         "List of Filter references to use at egress.",
																		MarkdownDescription: "List of Filter references to use at egress.",
																	},
																	"qos_policy": schema.ListAttribute{
																		ElementType:         types.StringType,
																		Optional:            true,
																		Description:         "List of QoS Egress policy references to use at egress.",
																		MarkdownDescription: "List of QoS Egress policy references to use at egress.",
																	},
																},
																CustomType: Egress1Type{
																	ObjectType: types.ObjectType{
																		AttrTypes: Egress1Value{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Manages actions on traffic at Egress of the Local endpoint of the Uplink.",
																MarkdownDescription: "Manages actions on traffic at Egress of the Local endpoint of the Uplink.",
															},
															"ingress": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"filters": schema.ListAttribute{
																		ElementType:         types.StringType,
																		Optional:            true,
																		Description:         "List of Filter references to use at ingress.",
																		MarkdownDescription: "List of Filter references to use at ingress.",
																	},
																	"qos_policy": schema.ListAttribute{
																		ElementType:         types.StringType,
																		Optional:            true,
																		Description:         "List of QoS Ingress policy references to use at ingress.",
																		MarkdownDescription: "List of QoS Ingress policy references to use at ingress.",
																	},
																},
																CustomType: Ingress1Type{
																	ObjectType: types.ObjectType{
																		AttrTypes: Ingress1Value{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Manages actions on traffic at Ingress of the Local endpoint of the Uplink.",
																MarkdownDescription: "Manages actions on traffic at Ingress of the Local endpoint of the Uplink.",
															},
															"uplink_selector": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "Selects TopoLinks which connect a leaf switch to a breakout switch. This is the uplink between your access breakout switch and your leaf switch.  There can only be a single TopoLink between the access breakout switch and the leaf switch, if more than one TopoLink is present between two devices the transaction will fail.",
																MarkdownDescription: "Selects TopoLinks which connect a leaf switch to a breakout switch. This is the uplink between your access breakout switch and your leaf switch.  There can only be a single TopoLink between the access breakout switch and the leaf switch, if more than one TopoLink is present between two devices the transaction will fail.",
															},
															"uplink_vlan_id": schema.StringAttribute{
																Optional:            true,
																Description:         "The VLAN ID to be utilized to isolate traffic from the VLAN on the access breakout switch to the leaf switch on the selected uplink TopoLink.",
																MarkdownDescription: "The VLAN ID to be utilized to isolate traffic from the VLAN on the access breakout switch to the leaf switch on the selected uplink TopoLink.",
															},
															"uplink_vlan_pool": schema.StringAttribute{
																Optional:            true,
																Description:         "A VLAN from this pool will be utilized to isolate traffic from the VLAN on the access breakout switch to the leaf switch on the selected uplink TopoLink.",
																MarkdownDescription: "A VLAN from this pool will be utilized to isolate traffic from the VLAN on the access breakout switch to the leaf switch on the selected uplink TopoLink.",
															},
														},
														CustomType: UplinkType{
															ObjectType: types.ObjectType{
																AttrTypes: UplinkValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "The Uplink between your access breakout switch and your leaf switch.",
														MarkdownDescription: "The Uplink between your access breakout switch and your leaf switch.",
													},
													"vlan_id": schema.StringAttribute{
														Optional:            true,
														Description:         "Single value between 1-4094 support, ranges supported in the format x-y,x-y, or the special keyword null, any, untagged or pool for auto allocation.",
														MarkdownDescription: "Single value between 1-4094 support, ranges supported in the format x-y,x-y, or the special keyword null, any, untagged or pool for auto allocation.",
													},
												},
												CustomType: Spec2Type{
													ObjectType: types.ObjectType{
														AttrTypes: Spec2Value{}.AttributeTypes(ctx),
													},
												},
												Optional:            true,
												Description:         "Specification of the BridgeInterface",
												MarkdownDescription: "Specification of the BridgeInterface",
											},
										},
										CustomType: BridgeInterfacesType{
											ObjectType: types.ObjectType{
												AttrTypes: BridgeInterfacesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "List of BridgeInterfaces. [emits=BridgeInterface]",
									MarkdownDescription: "List of BridgeInterfaces. [emits=BridgeInterface]",
								},
								"irb_interfaces": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Optional:            true,
												Description:         "The name of the IrbInterface.",
												MarkdownDescription: "The name of the IrbInterface.",
											},
											"spec": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"anycast_gateway_mac": schema.StringAttribute{
														Optional:            true,
														Description:         "The gateway MAC to use on the anycast address, if left empty the node will automatically assign one.",
														MarkdownDescription: "The gateway MAC to use on the anycast address, if left empty the node will automatically assign one.",
													},
													"arp_timeout": schema.Int64Attribute{
														Optional:            true,
														Description:         "Duration of time that dynamic ARP entries remain in the ARP cache before they expire.",
														MarkdownDescription: "Duration of time that dynamic ARP entries remain in the ARP cache before they expire.",
													},
													"bfd": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"desired_min_transmit_int": schema.Int64Attribute{
																Optional:            true,
																Description:         "The minimum interval in microseconds between transmission of BFD control packets.",
																MarkdownDescription: "The minimum interval in microseconds between transmission of BFD control packets.",
															},
															"detection_multiplier": schema.Int64Attribute{
																Optional:            true,
																Description:         "The number of packets that must be missed to declare this session as down.",
																MarkdownDescription: "The number of packets that must be missed to declare this session as down.",
															},
															"enabled": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enables Biforward Detection.",
																MarkdownDescription: "Enables Biforward Detection.",
															},
															"min_echo_receive_interval": schema.Int64Attribute{
																Optional:            true,
																Description:         "The minimum interval between echo packets the local node can receive.",
																MarkdownDescription: "The minimum interval between echo packets the local node can receive.",
															},
															"required_min_receive": schema.Int64Attribute{
																Optional:            true,
																Description:         "The minimum interval in microseconds between received BFD control packets that this system should support.",
																MarkdownDescription: "The minimum interval in microseconds between received BFD control packets that this system should support.",
															},
															"ttl": schema.Int64Attribute{
																Optional:            true,
																Description:         "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not applicable to single-hop BFD sessions.",
																MarkdownDescription: "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not applicable to single-hop BFD sessions.",
															},
														},
														CustomType: BfdType{
															ObjectType: types.ObjectType{
																AttrTypes: BfdValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Enable BFD on the IRBInterface.",
														MarkdownDescription: "Enable BFD on the IRBInterface.",
													},
													"bridge_domain": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to a BridgeDomain.",
														MarkdownDescription: "Reference to a BridgeDomain.",
													},
													"description": schema.StringAttribute{
														Optional:            true,
														Description:         "The description of the IRBInterface.",
														MarkdownDescription: "The description of the IRBInterface.",
													},
													"egress": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"filters": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of Filter references to use at egress.",
																MarkdownDescription: "List of Filter references to use at egress.",
															},
															"qos_policy": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of QoS Egress policy references to use at egress.",
																MarkdownDescription: "List of QoS Egress policy references to use at egress.",
															},
														},
														CustomType: Egress2Type{
															ObjectType: types.ObjectType{
																AttrTypes: Egress2Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Manages actions on traffic at Egress.",
														MarkdownDescription: "Manages actions on traffic at Egress.",
													},
													"evpn_route_advertisement_type": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"arp_dynamic": schema.BoolAttribute{
																Optional:            true,
																Description:         "Advertise dynamic ARP entries.",
																MarkdownDescription: "Advertise dynamic ARP entries.",
															},
															"arp_static": schema.BoolAttribute{
																Optional:            true,
																Description:         "Advertise static ARP entries.",
																MarkdownDescription: "Advertise static ARP entries.",
															},
															"nd_dynamic": schema.BoolAttribute{
																Optional:            true,
																Description:         "Advertise dynamic ND entries.",
																MarkdownDescription: "Advertise dynamic ND entries.",
															},
															"nd_static": schema.BoolAttribute{
																Optional:            true,
																Description:         "Advertise static ND entries.",
																MarkdownDescription: "Advertise static ND entries.",
															},
															"rfc9135_symmetric_mode": schema.BoolAttribute{
																Optional:            true,
																Description:         "Use RFC9135-based symmetric mode for ARP/ND host route advertisements.",
																MarkdownDescription: "Use RFC9135-based symmetric mode for ARP/ND host route advertisements.",
															},
														},
														CustomType: EvpnRouteAdvertisementTypeType{
															ObjectType: types.ObjectType{
																AttrTypes: EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Controls the type of ARP/ND entries to advertise.",
														MarkdownDescription: "Controls the type of ARP/ND entries to advertise.",
													},
													"host_route_populate": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"dynamic": schema.BoolAttribute{
																Optional:            true,
																Description:         "Create host routes out of dynamic ARP entries.",
																MarkdownDescription: "Create host routes out of dynamic ARP entries.",
															},
															"evpn": schema.BoolAttribute{
																Optional:            true,
																Description:         "Create host routes out of EVPN learned ARP entries.",
																MarkdownDescription: "Create host routes out of EVPN learned ARP entries.",
															},
															"static": schema.BoolAttribute{
																Optional:            true,
																Description:         "Create host routes out of static ARP entries.",
																MarkdownDescription: "Create host routes out of static ARP entries.",
															},
														},
														CustomType: HostRoutePopulateType{
															ObjectType: types.ObjectType{
																AttrTypes: HostRoutePopulateValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Configures host route population based on ARP entries.",
														MarkdownDescription: "Configures host route population based on ARP entries.",
													},
													"ingress": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"filters": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of Filter references to use at ingress.",
																MarkdownDescription: "List of Filter references to use at ingress.",
															},
															"qos_policy": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of QoS Ingress policy references to use at ingress.",
																MarkdownDescription: "List of QoS Ingress policy references to use at ingress.",
															},
														},
														CustomType: Ingress2Type{
															ObjectType: types.ObjectType{
																AttrTypes: Ingress2Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Manages actions on traffic at Ingress.",
														MarkdownDescription: "Manages actions on traffic at Ingress.",
													},
													"ip_addresses": schema.ListNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"ipv4_address": schema.SingleNestedAttribute{
																	Attributes: map[string]schema.Attribute{
																		"ip_prefix": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Address and mask to use",
																			MarkdownDescription: "Address and mask to use",
																		},
																		"primary": schema.BoolAttribute{
																			Optional:            true,
																			Description:         "Indicates which address to use as primary for broadcast",
																			MarkdownDescription: "Indicates which address to use as primary for broadcast",
																		},
																	},
																	CustomType: Ipv4AddressType{
																		ObjectType: types.ObjectType{
																			AttrTypes: Ipv4AddressValue{}.AttributeTypes(ctx),
																		},
																	},
																	Optional:            true,
																	Description:         "IPv4 address in IP/mask form, e.g., 192.168.0.1/24.",
																	MarkdownDescription: "IPv4 address in IP/mask form, e.g., 192.168.0.1/24.",
																},
																"ipv6_address": schema.SingleNestedAttribute{
																	Attributes: map[string]schema.Attribute{
																		"ip_prefix": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Address and mask to use",
																			MarkdownDescription: "Address and mask to use",
																		},
																		"primary": schema.BoolAttribute{
																			Optional:            true,
																			Description:         "Indicates which address to use as primary for broadcast",
																			MarkdownDescription: "Indicates which address to use as primary for broadcast",
																		},
																	},
																	CustomType: Ipv6AddressType{
																		ObjectType: types.ObjectType{
																			AttrTypes: Ipv6AddressValue{}.AttributeTypes(ctx),
																		},
																	},
																	Optional:            true,
																	Description:         "IPv6 address in IP/mask form, e.g., fc00::1/120.",
																	MarkdownDescription: "IPv6 address in IP/mask form, e.g., fc00::1/120.",
																},
																"node": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Reference to a TopoNode resource, if not specified the IP address will be assigned to all nodes on which the IRB is deployed.  If specified the IP address will be assigned to the specified node.",
																	MarkdownDescription: "Reference to a TopoNode resource, if not specified the IP address will be assigned to all nodes on which the IRB is deployed.  If specified the IP address will be assigned to the specified node.",
																},
															},
															CustomType: IpAddressesType{
																ObjectType: types.ObjectType{
																	AttrTypes: IpAddressesValue{}.AttributeTypes(ctx),
																},
															},
														},
														Optional: true,
													},
													"ip_mtu": schema.Int64Attribute{
														Optional:            true,
														Description:         "IP MTU for the IRBInterface [default=1500].",
														MarkdownDescription: "IP MTU for the IRBInterface [default=1500].",
													},
													"ipv4_parameters": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"directed_broadcast": schema.BoolAttribute{
																Optional:            true,
																Description:         "Allow receiving and forwarding of directed broadcast packets. Enabled when set to true.",
																MarkdownDescription: "Allow receiving and forwarding of directed broadcast packets. Enabled when set to true.",
															},
														},
														CustomType: Ipv4ParametersType{
															ObjectType: types.ObjectType{
																AttrTypes: Ipv4ParametersValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Manages IPv4-specific additional parameters that are not applicable to IPv6.",
														MarkdownDescription: "Manages IPv4-specific additional parameters that are not applicable to IPv6.",
													},
													"ipv6_router_advertisement": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"current_hop_limit": schema.Int64Attribute{
																Optional:            true,
																Description:         "The current hop limit to advertise in the router advertisement messages.",
																MarkdownDescription: "The current hop limit to advertise in the router advertisement messages.",
															},
															"enabled": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enable or disable IPv6 router advertisements.",
																MarkdownDescription: "Enable or disable IPv6 router advertisements.",
															},
															"ip_mtu": schema.Int64Attribute{
																Optional:            true,
																Description:         "The IP MTU to advertise in the router advertisement messages.",
																MarkdownDescription: "The IP MTU to advertise in the router advertisement messages.",
															},
															"managed_configuration_flag": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enable DHCPv6 for address configuration (M-bit).",
																MarkdownDescription: "Enable DHCPv6 for address configuration (M-bit).",
															},
															"max_advertisement_interval": schema.Int64Attribute{
																Optional:            true,
																Description:         "Maximum time between router advertisements (in seconds).",
																MarkdownDescription: "Maximum time between router advertisements (in seconds).",
															},
															"min_advertisement_interval": schema.Int64Attribute{
																Optional:            true,
																Description:         "Minimum time between router advertisements (in seconds).",
																MarkdownDescription: "Minimum time between router advertisements (in seconds).",
															},
															"other_configuration_flag": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enable DHCPv6 for other configuration (O-bit).",
																MarkdownDescription: "Enable DHCPv6 for other configuration (O-bit).",
															},
															"prefixes": schema.ListNestedAttribute{
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"autonomous_flag": schema.BoolAttribute{
																			Optional:            true,
																			Description:         "When this is set in the prefix information option hosts can use the prefix for stateless address autoconfiguration (SLAAC).",
																			MarkdownDescription: "When this is set in the prefix information option hosts can use the prefix for stateless address autoconfiguration (SLAAC).",
																		},
																		"on_link_flag": schema.BoolAttribute{
																			Optional:            true,
																			Description:         "When this is set in the prefix information option hosts can use the prefix for on-link determination.",
																			MarkdownDescription: "When this is set in the prefix information option hosts can use the prefix for on-link determination.",
																		},
																		"preferred_lifetime": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "The length of time in seconds (relative to the time the packet is sent) that addresses generated from the prefix via stateless address autoconfiguration remain preferred.",
																			MarkdownDescription: "The length of time in seconds (relative to the time the packet is sent) that addresses generated from the prefix via stateless address autoconfiguration remain preferred.",
																		},
																		"prefix": schema.StringAttribute{
																			Optional:            true,
																			Description:         "An IPv6 global unicast address prefix.",
																			MarkdownDescription: "An IPv6 global unicast address prefix.",
																		},
																		"valid_lifetime": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "The length of time in seconds (relative to the time the packet is sent) that the prefix is valid for the purpose of on-link determination.",
																			MarkdownDescription: "The length of time in seconds (relative to the time the packet is sent) that the prefix is valid for the purpose of on-link determination.",
																		},
																	},
																	CustomType: PrefixesType{
																		ObjectType: types.ObjectType{
																			AttrTypes: PrefixesValue{}.AttributeTypes(ctx),
																		},
																	},
																},
																Optional:            true,
																Description:         "IPv6 prefixes to advertise in router advertisements.",
																MarkdownDescription: "IPv6 prefixes to advertise in router advertisements.",
															},
															"reachable_time": schema.Int64Attribute{
																Optional:            true,
																Description:         "Time in milliseconds for Neighbor Unreachability Detection.",
																MarkdownDescription: "Time in milliseconds for Neighbor Unreachability Detection.",
															},
															"retransmit_time": schema.Int64Attribute{
																Optional:            true,
																Description:         "Time in milliseconds between retransmitted NS messages.",
																MarkdownDescription: "Time in milliseconds between retransmitted NS messages.",
															},
															"router_lifetime": schema.Int64Attribute{
																Optional:            true,
																Description:         "Router lifetime in seconds for default gateway.",
																MarkdownDescription: "Router lifetime in seconds for default gateway.",
															},
														},
														CustomType: Ipv6RouterAdvertisementType{
															ObjectType: types.ObjectType{
																AttrTypes: Ipv6RouterAdvertisementValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Manages IPV6 Router Advertisement parameters.",
														MarkdownDescription: "Manages IPV6 Router Advertisement parameters.",
													},
													"l3proxy_arpnd": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"proxy_arp": schema.BoolAttribute{
																Optional:            true,
																Description:         "Select whether Proxy ARP should be enabled.",
																MarkdownDescription: "Select whether Proxy ARP should be enabled.",
															},
															"proxy_nd": schema.BoolAttribute{
																Optional:            true,
																Description:         "Select whether Proxy ND should be enabled.",
																MarkdownDescription: "Select whether Proxy ND should be enabled.",
															},
														},
														CustomType: L3proxyArpndType{
															ObjectType: types.ObjectType{
																AttrTypes: L3proxyArpndValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "L3 Proxy ARP and ND configuration.",
														MarkdownDescription: "L3 Proxy ARP and ND configuration.",
													},
													"learn_unsolicited": schema.StringAttribute{
														Optional:            true,
														Description:         "Enable or disable learning of unsolicited ARPs.",
														MarkdownDescription: "Enable or disable learning of unsolicited ARPs.",
													},
													"router": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to a Router.",
														MarkdownDescription: "Reference to a Router.",
													},
													"unnumbered": schema.StringAttribute{
														Optional:            true,
														Description:         "Enables the use of unnumbered interfaces on the IRBInterface.  If IPv6 is specified, no IP address are configured on the sub-interface and only the link local address will be used.  If any IP addresses are specified for either IPv4 or IPv6 that will take precedence and IPs will be assigned to the interfaces.(Deprecated, Use IPv6RouterAdvertisement)",
														MarkdownDescription: "Enables the use of unnumbered interfaces on the IRBInterface.  If IPv6 is specified, no IP address are configured on the sub-interface and only the link local address will be used.  If any IP addresses are specified for either IPv4 or IPv6 that will take precedence and IPs will be assigned to the interfaces.(Deprecated, Use IPv6RouterAdvertisement)",
													},
													"virtual_ip_discovery": schema.ListNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"address": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Virtual IP Address.",
																	MarkdownDescription: "Virtual IP Address.",
																},
																"allowed_mac": schema.ListAttribute{
																	ElementType:         types.StringType,
																	Optional:            true,
																	Description:         "List of allowed MAC addresses for a discovered virtual IP address.",
																	MarkdownDescription: "List of allowed MAC addresses for a discovered virtual IP address.",
																},
																"bridge_interface_to_probe": schema.ListAttribute{
																	ElementType:         types.StringType,
																	Optional:            true,
																	Description:         "List of BridgeInterfaces on the associated MAC-VRF to which the ARP probes are sent. If left blank, the probes are sent on all BridgeInterfaces associated with the BridgeDomain.",
																	MarkdownDescription: "List of BridgeInterfaces on the associated MAC-VRF to which the ARP probes are sent. If left blank, the probes are sent on all BridgeInterfaces associated with the BridgeDomain.",
																},
																"probe_interval": schema.Int64Attribute{
																	Optional:            true,
																	Description:         "ARP probe interval in seconds.",
																	MarkdownDescription: "ARP probe interval in seconds.",
																},
																"vlan_to_probe": schema.ListAttribute{
																	ElementType:         types.StringType,
																	Optional:            true,
																	Description:         "List of VLANs on the associated BridgeDomain to which the ARP probes are sent.  If left blank, the probes are sent on all VLANs associated with the BridgeDomain.",
																	MarkdownDescription: "List of VLANs on the associated BridgeDomain to which the ARP probes are sent.  If left blank, the probes are sent on all VLANs associated with the BridgeDomain.",
																},
															},
															CustomType: VirtualIpDiscoveryType{
																ObjectType: types.ObjectType{
																	AttrTypes: VirtualIpDiscoveryValue{}.AttributeTypes(ctx),
																},
															},
														},
														Optional:            true,
														Description:         "Configuration for Virtual IP discovery on the interface.",
														MarkdownDescription: "Configuration for Virtual IP discovery on the interface.",
													},
												},
												CustomType: Spec3Type{
													ObjectType: types.ObjectType{
														AttrTypes: Spec3Value{}.AttributeTypes(ctx),
													},
												},
												Optional:            true,
												Description:         "Specification of the IrbInterface",
												MarkdownDescription: "Specification of the IrbInterface",
											},
										},
										CustomType: IrbInterfacesType{
											ObjectType: types.ObjectType{
												AttrTypes: IrbInterfacesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "List of IRBInterfaces. [emits=IRBInterface]",
									MarkdownDescription: "List of IRBInterfaces. [emits=IRBInterface]",
								},
								"protocols": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"bgp": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"bgp_groups": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"name": schema.StringAttribute{
																Optional:            true,
																Description:         "The name of the BgpGroup.",
																MarkdownDescription: "The name of the BgpGroup.",
															},
															"spec": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"as_path_options": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"allow_own_as": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "The maximum number of times the global AS number or a local AS number of the BGP instance can appear in any received AS_PATH before it is considered a loop and considered invalid.",
																				MarkdownDescription: "The maximum number of times the global AS number or a local AS number of the BGP instance can appear in any received AS_PATH before it is considered a loop and considered invalid.",
																			},
																			"remove_private_as": schema.SingleNestedAttribute{
																				Attributes: map[string]schema.Attribute{
																					"ignore_peer_as": schema.BoolAttribute{
																						Optional:            true,
																						Description:         "If set to true then do not delete or replace a private AS number that is the same as the peer AS number.",
																						MarkdownDescription: "If set to true then do not delete or replace a private AS number that is the same as the peer AS number.",
																					},
																					"leading_only": schema.BoolAttribute{
																						Optional:            true,
																						Description:         "If set to true then only delete or replace private AS numbers that appear before the first occurrence of a non-private ASN in the sequence of most recent ASNs in the AS path.",
																						MarkdownDescription: "If set to true then only delete or replace private AS numbers that appear before the first occurrence of a non-private ASN in the sequence of most recent ASNs in the AS path.",
																					},
																					"remove_private_as_mode": schema.StringAttribute{
																						Optional:            true,
																						Description:         "The method by which private AS numbers are removed from the advertised AS_PATH attribute.",
																						MarkdownDescription: "The method by which private AS numbers are removed from the advertised AS_PATH attribute.",
																					},
																				},
																				CustomType: RemovePrivateAsType{
																					ObjectType: types.ObjectType{
																						AttrTypes: RemovePrivateAsValue{}.AttributeTypes(ctx),
																					},
																				},
																				Optional:            true,
																				Description:         "Options for removing private AS numbers (2-byte and 4-byte) from the advertised AS path towards all peers.",
																				MarkdownDescription: "Options for removing private AS numbers (2-byte and 4-byte) from the advertised AS path towards all peers.",
																			},
																		},
																		CustomType: AsPathOptionsType{
																			ObjectType: types.ObjectType{
																				AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "AS Path Options",
																		MarkdownDescription: "AS Path Options",
																	},
																	"bfd": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enable or disable Bi-forward Forwarding Detection (BFD) with fast failover.",
																		MarkdownDescription: "Enable or disable Bi-forward Forwarding Detection (BFD) with fast failover.",
																	},
																	"client": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "When set to true, all configured and dynamic BGP peers are considered RR clients.",
																		MarkdownDescription: "When set to true, all configured and dynamic BGP peers are considered RR clients.",
																	},
																	"cluster_id": schema.StringAttribute{
																		Optional:            true,
																		Description:         "Enables route reflect client and sets the cluster ID.",
																		MarkdownDescription: "Enables route reflect client and sets the cluster ID.",
																	},
																	"configured_name": schema.StringAttribute{
																		Optional:            true,
																		Description:         "Configures the group name on the device.",
																		MarkdownDescription: "Configures the group name on the device.",
																	},
																	"description": schema.StringAttribute{
																		Optional:            true,
																		Description:         "Sets the description on the BGP group.",
																		MarkdownDescription: "Sets the description on the BGP group.",
																	},
																	"export_policy": schema.ListAttribute{
																		ElementType:         types.StringType,
																		Optional:            true,
																		Description:         "Reference to a Policy CR that will be used to filter routes advertised to peers.",
																		MarkdownDescription: "Reference to a Policy CR that will be used to filter routes advertised to peers.",
																	},
																	"gr_stale_route_time": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "Enables Graceful Restart on the peer and sets the stale route time.",
																		MarkdownDescription: "Enables Graceful Restart on the peer and sets the stale route time.",
																	},
																	"import_policy": schema.ListAttribute{
																		ElementType:         types.StringType,
																		Optional:            true,
																		Description:         "Reference to a Policy CR that will be used to filter routes received from peers.",
																		MarkdownDescription: "Reference to a Policy CR that will be used to filter routes received from peers.",
																	},
																	"ipv4_unicast": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"advertise_ipv6_next_hops": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "Enables advertisement of IPv4 Unicast routes with IPv6 next-hops to peers.",
																				MarkdownDescription: "Enables advertisement of IPv4 Unicast routes with IPv6 next-hops to peers.",
																			},
																			"enabled": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "Enables the IPv4 unicast AFISAFI.",
																				MarkdownDescription: "Enables the IPv4 unicast AFISAFI.",
																			},
																			"prefix_limit": schema.SingleNestedAttribute{
																				Attributes: map[string]schema.Attribute{
																					"prefix_limit_accepted": schema.SingleNestedAttribute{
																						Attributes: map[string]schema.Attribute{
																							"log_only": schema.BoolAttribute{
																								Optional:            true,
																								Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																								MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																							},
																							"max_received_routes": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
																								MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
																							},
																							"warning_threshold": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
																								MarkdownDescription: "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
																							},
																						},
																						CustomType: PrefixLimitAcceptedType{
																							ObjectType: types.ObjectType{
																								AttrTypes: PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
																							},
																						},
																						Optional: true,
																					},
																					"prefix_limit_received": schema.SingleNestedAttribute{
																						Attributes: map[string]schema.Attribute{
																							"log_only": schema.BoolAttribute{
																								Optional:            true,
																								Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																								MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																							},
																							"max_received_routes": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
																								MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
																							},
																							"warning_threshold": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
																								MarkdownDescription: "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
																							},
																						},
																						CustomType: PrefixLimitReceivedType{
																							ObjectType: types.ObjectType{
																								AttrTypes: PrefixLimitReceivedValue{}.AttributeTypes(ctx),
																							},
																						},
																						Optional: true,
																					},
																				},
																				CustomType: PrefixLimitType{
																					ObjectType: types.ObjectType{
																						AttrTypes: PrefixLimitValue{}.AttributeTypes(ctx),
																					},
																				},
																				Optional: true,
																			},
																			"receive_ipv6_next_hops": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "Enables the advertisement of the RFC 5549 capability to receive IPv4 routes with IPv6 next-hops.",
																				MarkdownDescription: "Enables the advertisement of the RFC 5549 capability to receive IPv4 routes with IPv6 next-hops.",
																			},
																		},
																		CustomType: Ipv4UnicastType{
																			ObjectType: types.ObjectType{
																				AttrTypes: Ipv4UnicastValue{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "Parameters relating to the IPv4 unicast AFI/SAFI.",
																		MarkdownDescription: "Parameters relating to the IPv4 unicast AFI/SAFI.",
																	},
																	"ipv6_unicast": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"enabled": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "Enables the IPv6 unicast AFISAFI",
																				MarkdownDescription: "Enables the IPv6 unicast AFISAFI",
																			},
																			"prefix_limit": schema.SingleNestedAttribute{
																				Attributes: map[string]schema.Attribute{
																					"prefix_limit_accepted": schema.SingleNestedAttribute{
																						Attributes: map[string]schema.Attribute{
																							"log_only": schema.BoolAttribute{
																								Optional:            true,
																								Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																								MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																							},
																							"max_received_routes": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
																								MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
																							},
																							"warning_threshold": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
																								MarkdownDescription: "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
																							},
																						},
																						CustomType: PrefixLimitAccepted1Type{
																							ObjectType: types.ObjectType{
																								AttrTypes: PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
																							},
																						},
																						Optional: true,
																					},
																					"prefix_limit_received": schema.SingleNestedAttribute{
																						Attributes: map[string]schema.Attribute{
																							"log_only": schema.BoolAttribute{
																								Optional:            true,
																								Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																								MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																							},
																							"max_received_routes": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
																								MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
																							},
																							"warning_threshold": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
																								MarkdownDescription: "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
																							},
																						},
																						CustomType: PrefixLimitReceived1Type{
																							ObjectType: types.ObjectType{
																								AttrTypes: PrefixLimitReceived1Value{}.AttributeTypes(ctx),
																							},
																						},
																						Optional: true,
																					},
																				},
																				CustomType: PrefixLimit1Type{
																					ObjectType: types.ObjectType{
																						AttrTypes: PrefixLimit1Value{}.AttributeTypes(ctx),
																					},
																				},
																				Optional: true,
																			},
																		},
																		CustomType: Ipv6UnicastType{
																			ObjectType: types.ObjectType{
																				AttrTypes: Ipv6UnicastValue{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "Parameters relating to the IPv6 unicast AFI/SAFI.",
																		MarkdownDescription: "Parameters relating to the IPv6 unicast AFI/SAFI.",
																	},
																	"keychain": schema.StringAttribute{
																		Optional:            true,
																		Description:         "Reference to a Keychain resource that will be used for authentication with the BGP peer.",
																		MarkdownDescription: "Reference to a Keychain resource that will be used for authentication with the BGP peer.",
																	},
																	"local_as": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"autonomous_system": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "Local Autonomous System number.",
																				MarkdownDescription: "Local Autonomous System number.",
																			},
																			"prepend_global_as": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "When set to true, the global ASN value is prepended to the AS path in outbound routes towards each BGP peer.",
																				MarkdownDescription: "When set to true, the global ASN value is prepended to the AS path in outbound routes towards each BGP peer.",
																			},
																			"prepend_local_as": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "When set to true, the local AS value is prepended to the AS path of inbound routes from each EBGP peer.",
																				MarkdownDescription: "When set to true, the local AS value is prepended to the AS path of inbound routes from each EBGP peer.",
																			},
																		},
																		CustomType: LocalAsType{
																			ObjectType: types.ObjectType{
																				AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "The local autonomous system number advertised to peers.",
																		MarkdownDescription: "The local autonomous system number advertised to peers.",
																	},
																	"local_preference": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "Local Preference attribute added to received routes from the BGP peers, also sets local preference for generated routes.",
																		MarkdownDescription: "Local Preference attribute added to received routes from the BGP peers, also sets local preference for generated routes.",
																	},
																	"multi_hop_max_hop": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "Enable multihop for eBGP peers and sets the maximum number of hops allowed.",
																		MarkdownDescription: "Enable multihop for eBGP peers and sets the maximum number of hops allowed.",
																	},
																	"next_hop_self": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "When set to true, the next-hop in all IPv4-unicast, IPv6-unicast and EVPN BGP routes advertised to the peer is set to the local-address.",
																		MarkdownDescription: "When set to true, the next-hop in all IPv4-unicast, IPv6-unicast and EVPN BGP routes advertised to the peer is set to the local-address.",
																	},
																	"peer_as": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"autonomous_system": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "Local Autonomous System number.",
																				MarkdownDescription: "Local Autonomous System number.",
																			},
																		},
																		CustomType: PeerAsType{
																			ObjectType: types.ObjectType{
																				AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "The autonomous system number expected from peers.",
																		MarkdownDescription: "The autonomous system number expected from peers.",
																	},
																	"send_community_large": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "When false, all large (12 byte) BGP communities from all outbound routes advertised to the peer are stripped.",
																		MarkdownDescription: "When false, all large (12 byte) BGP communities from all outbound routes advertised to the peer are stripped.",
																	},
																	"send_community_standard": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "When false, all standard (4 byte) communities from all outbound routes advertised to the peer are stripped.",
																		MarkdownDescription: "When false, all standard (4 byte) communities from all outbound routes advertised to the peer are stripped.",
																	},
																	"send_default_route": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"address_family": schema.ListAttribute{
																				ElementType:         types.StringType,
																				Optional:            true,
																				Description:         "Enables the sending of a synthetically generated default IPv4 or IPV6 route to each peer.",
																				MarkdownDescription: "Enables the sending of a synthetically generated default IPv4 or IPV6 route to each peer.",
																			},
																			"export_policy": schema.StringAttribute{
																				Optional:            true,
																				Description:         "Reference to a Policy that should be applied to the advertised default routes, in order to set their attributes to non-default values.",
																				MarkdownDescription: "Reference to a Policy that should be applied to the advertised default routes, in order to set their attributes to non-default values.",
																			},
																		},
																		CustomType: SendDefaultRouteType{
																			ObjectType: types.ObjectType{
																				AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "Options for controlling the generation of default routes towards BGP peers.",
																		MarkdownDescription: "Options for controlling the generation of default routes towards BGP peers.",
																	},
																	"timers": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"connect_retry": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "The time interval in seconds between successive attempts to establish a session with a peer.",
																				MarkdownDescription: "The time interval in seconds between successive attempts to establish a session with a peer.",
																			},
																			"hold_time": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "The hold-time interval in seconds that the router proposes to the peer in its OPEN message.",
																				MarkdownDescription: "The hold-time interval in seconds that the router proposes to the peer in its OPEN message.",
																			},
																			"keep_alive": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "The interval in seconds between successive keepalive messages sent to the peer.",
																				MarkdownDescription: "The interval in seconds between successive keepalive messages sent to the peer.",
																			},
																			"minimum_advertisement_interval": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions.",
																				MarkdownDescription: "The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions.",
																			},
																		},
																		CustomType: TimersType{
																			ObjectType: types.ObjectType{
																				AttrTypes: TimersValue{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "Timer configurations",
																		MarkdownDescription: "Timer configurations",
																	},
																},
																CustomType: Spec4Type{
																	ObjectType: types.ObjectType{
																		AttrTypes: Spec4Value{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Specification of the BgpGroup",
																MarkdownDescription: "Specification of the BgpGroup",
															},
														},
														CustomType: BgpGroupsType{
															ObjectType: types.ObjectType{
																AttrTypes: BgpGroupsValue{}.AttributeTypes(ctx),
															},
														},
													},
													Optional:            true,
													Description:         "List of BgpGroups. [emits=BGPGroup]",
													MarkdownDescription: "List of BgpGroups. [emits=BGPGroup]",
												},
												"bgp_peers": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"name": schema.StringAttribute{
																Optional:            true,
																Description:         "The name of the BgpPeer.",
																MarkdownDescription: "The name of the BgpPeer.",
															},
															"spec": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"as_path_options": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"allow_own_as": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "The maximum number of times the global AS number or a local AS number of the BGP instance can appear in any received AS_PATH before it is considered a loop and considered invalid.",
																				MarkdownDescription: "The maximum number of times the global AS number or a local AS number of the BGP instance can appear in any received AS_PATH before it is considered a loop and considered invalid.",
																			},
																			"remove_private_as": schema.SingleNestedAttribute{
																				Attributes: map[string]schema.Attribute{
																					"ignore_peer_as": schema.BoolAttribute{
																						Optional:            true,
																						Description:         "If set to true then do not delete or replace a private AS number that is the same as the peer AS number.",
																						MarkdownDescription: "If set to true then do not delete or replace a private AS number that is the same as the peer AS number.",
																					},
																					"leading_only": schema.BoolAttribute{
																						Optional:            true,
																						Description:         "If set to true then only delete or replace private AS numbers that appear before the first occurrence of a non-private ASN in the sequence of most recent ASNs in the AS path.",
																						MarkdownDescription: "If set to true then only delete or replace private AS numbers that appear before the first occurrence of a non-private ASN in the sequence of most recent ASNs in the AS path.",
																					},
																					"remove_private_as_mode": schema.StringAttribute{
																						Optional:            true,
																						Description:         "The method by which private AS numbers are removed from the advertised AS_PATH attribute.",
																						MarkdownDescription: "The method by which private AS numbers are removed from the advertised AS_PATH attribute.",
																					},
																				},
																				CustomType: RemovePrivateAs1Type{
																					ObjectType: types.ObjectType{
																						AttrTypes: RemovePrivateAs1Value{}.AttributeTypes(ctx),
																					},
																				},
																				Optional:            true,
																				Description:         "Options for removing private AS numbers (2-byte and 4-byte) from the advertised AS path towards all peers.",
																				MarkdownDescription: "Options for removing private AS numbers (2-byte and 4-byte) from the advertised AS path towards all peers.",
																			},
																		},
																		CustomType: AsPathOptions1Type{
																			ObjectType: types.ObjectType{
																				AttrTypes: AsPathOptions1Value{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "AS Path Options",
																		MarkdownDescription: "AS Path Options",
																	},
																	"bfd": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enable or disable Bi-forward Forwarding Detection (BFD) with fast failover.",
																		MarkdownDescription: "Enable or disable Bi-forward Forwarding Detection (BFD) with fast failover.",
																	},
																	"client": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "When set to true, all configured and dynamic BGP peers are considered RR clients.",
																		MarkdownDescription: "When set to true, all configured and dynamic BGP peers are considered RR clients.",
																	},
																	"cluster_id": schema.StringAttribute{
																		Optional:            true,
																		Description:         "Enables route reflect client and sets the cluster ID.",
																		MarkdownDescription: "Enables route reflect client and sets the cluster ID.",
																	},
																	"description": schema.StringAttribute{
																		Optional:            true,
																		Description:         "Sets the description on the BGP peer",
																		MarkdownDescription: "Sets the description on the BGP peer",
																	},
																	"dynamic_neighbor": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "When set to true the Interface is added to the dynamic-neighbor list for dynamic peering.",
																		MarkdownDescription: "When set to true the Interface is added to the dynamic-neighbor list for dynamic peering.",
																	},
																	"dynamic_neighbor_allowed_peer_as": schema.ListAttribute{
																		ElementType:         types.Int64Type,
																		Optional:            true,
																		Description:         "The autonomous system numbers allowed from peers if dynamic peering is enabled.",
																		MarkdownDescription: "The autonomous system numbers allowed from peers if dynamic peering is enabled.",
																	},
																	"export_policy": schema.ListAttribute{
																		ElementType:         types.StringType,
																		Optional:            true,
																		Description:         "Reference to a Policy CR that will be used to filter routes advertised to peers.",
																		MarkdownDescription: "Reference to a Policy CR that will be used to filter routes advertised to peers.",
																	},
																	"gr_stale_route_time": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "Enables Graceful Restart on the peer and sets the stale route time.",
																		MarkdownDescription: "Enables Graceful Restart on the peer and sets the stale route time.",
																	},
																	"group": schema.StringAttribute{
																		Optional:            true,
																		Description:         "Reference to a BGPGroup. When present this BGP peer will be added to the BGP group",
																		MarkdownDescription: "Reference to a BGPGroup. When present this BGP peer will be added to the BGP group",
																	},
																	"import_policy": schema.ListAttribute{
																		ElementType:         types.StringType,
																		Optional:            true,
																		Description:         "Reference to a Policy CR that will be used to filter routes received from peers.",
																		MarkdownDescription: "Reference to a Policy CR that will be used to filter routes received from peers.",
																	},
																	"interface": schema.StringAttribute{
																		Optional:            true,
																		Description:         "Reference to a RoutedInterface or IrbInterface resource whose IP will be used as a source IP for the BGP session.",
																		MarkdownDescription: "Reference to a RoutedInterface or IrbInterface resource whose IP will be used as a source IP for the BGP session.",
																	},
																	"interface_kind": schema.StringAttribute{
																		Optional:            true,
																		Description:         "InterfaceReference type defines whether the provided Reference is a RoutedInterface or IrbInterface.",
																		MarkdownDescription: "InterfaceReference type defines whether the provided Reference is a RoutedInterface or IrbInterface.",
																	},
																	"ipv4_unicast": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"advertise_ipv6_next_hops": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "Enables advertisement of IPv4 Unicast routes with IPv6 next-hops to peers.",
																				MarkdownDescription: "Enables advertisement of IPv4 Unicast routes with IPv6 next-hops to peers.",
																			},
																			"enabled": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "Enables the IPv4 unicast AFISAFI.",
																				MarkdownDescription: "Enables the IPv4 unicast AFISAFI.",
																			},
																			"prefix_limit": schema.SingleNestedAttribute{
																				Attributes: map[string]schema.Attribute{
																					"prefix_limit_accepted": schema.SingleNestedAttribute{
																						Attributes: map[string]schema.Attribute{
																							"log_only": schema.BoolAttribute{
																								Optional:            true,
																								Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																								MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																							},
																							"max_received_routes": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
																								MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
																							},
																							"warning_threshold": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
																								MarkdownDescription: "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
																							},
																						},
																						CustomType: PrefixLimitAccepted2Type{
																							ObjectType: types.ObjectType{
																								AttrTypes: PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
																							},
																						},
																						Optional: true,
																					},
																					"prefix_limit_received": schema.SingleNestedAttribute{
																						Attributes: map[string]schema.Attribute{
																							"log_only": schema.BoolAttribute{
																								Optional:            true,
																								Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																								MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																							},
																							"max_received_routes": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
																								MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
																							},
																							"warning_threshold": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
																								MarkdownDescription: "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
																							},
																						},
																						CustomType: PrefixLimitReceived2Type{
																							ObjectType: types.ObjectType{
																								AttrTypes: PrefixLimitReceived2Value{}.AttributeTypes(ctx),
																							},
																						},
																						Optional: true,
																					},
																				},
																				CustomType: PrefixLimit2Type{
																					ObjectType: types.ObjectType{
																						AttrTypes: PrefixLimit2Value{}.AttributeTypes(ctx),
																					},
																				},
																				Optional: true,
																			},
																			"receive_ipv6_next_hops": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "Enables the advertisement of the RFC 5549 capability to receive IPv4 routes with IPv6 next-hops.",
																				MarkdownDescription: "Enables the advertisement of the RFC 5549 capability to receive IPv4 routes with IPv6 next-hops.",
																			},
																		},
																		CustomType: Ipv4Unicast1Type{
																			ObjectType: types.ObjectType{
																				AttrTypes: Ipv4Unicast1Value{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "Parameters relating to the IPv4 unicast AFI/SAFI.",
																		MarkdownDescription: "Parameters relating to the IPv4 unicast AFI/SAFI.",
																	},
																	"ipv6_unicast": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"enabled": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "Enables the IPv6 unicast AFISAFI",
																				MarkdownDescription: "Enables the IPv6 unicast AFISAFI",
																			},
																			"prefix_limit": schema.SingleNestedAttribute{
																				Attributes: map[string]schema.Attribute{
																					"prefix_limit_accepted": schema.SingleNestedAttribute{
																						Attributes: map[string]schema.Attribute{
																							"log_only": schema.BoolAttribute{
																								Optional:            true,
																								Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																								MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																							},
																							"max_received_routes": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
																								MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting only accepted routes.",
																							},
																							"warning_threshold": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
																								MarkdownDescription: "A percentage of the maximum number of prefixes that can be accepted before a warning is logged.",
																							},
																						},
																						CustomType: PrefixLimitAccepted3Type{
																							ObjectType: types.ObjectType{
																								AttrTypes: PrefixLimitAccepted3Value{}.AttributeTypes(ctx),
																							},
																						},
																						Optional: true,
																					},
																					"prefix_limit_received": schema.SingleNestedAttribute{
																						Attributes: map[string]schema.Attribute{
																							"log_only": schema.BoolAttribute{
																								Optional:            true,
																								Description:         "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																								MarkdownDescription: "Defines the action to take when the maximum number of prefixes is exceeded. Session is reset if set to false, otherwise only a warning is logged.",
																							},
																							"max_received_routes": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
																								MarkdownDescription: "Maximum number of prefixes allowed to be received from the neighbor, counting all routes (accepted and rejected by import policies).",
																							},
																							"warning_threshold": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
																								MarkdownDescription: "A percentage of the maximum number of prefixes that can be received before a warning is logged.",
																							},
																						},
																						CustomType: PrefixLimitReceived3Type{
																							ObjectType: types.ObjectType{
																								AttrTypes: PrefixLimitReceived3Value{}.AttributeTypes(ctx),
																							},
																						},
																						Optional: true,
																					},
																				},
																				CustomType: PrefixLimit3Type{
																					ObjectType: types.ObjectType{
																						AttrTypes: PrefixLimit3Value{}.AttributeTypes(ctx),
																					},
																				},
																				Optional: true,
																			},
																		},
																		CustomType: Ipv6Unicast1Type{
																			ObjectType: types.ObjectType{
																				AttrTypes: Ipv6Unicast1Value{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "Parameters relating to the IPv6 unicast AFI/SAFI.",
																		MarkdownDescription: "Parameters relating to the IPv6 unicast AFI/SAFI.",
																	},
																	"keychain": schema.StringAttribute{
																		Optional:            true,
																		Description:         "Reference to a Keychain resource that will be used for authentication with the BGP peer.",
																		MarkdownDescription: "Reference to a Keychain resource that will be used for authentication with the BGP peer.",
																	},
																	"local_as": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"autonomous_system": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "Local Autonomous System number.",
																				MarkdownDescription: "Local Autonomous System number.",
																			},
																			"prepend_global_as": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "When set to true, the global ASN value is prepended to the AS path in outbound routes towards each BGP peer.",
																				MarkdownDescription: "When set to true, the global ASN value is prepended to the AS path in outbound routes towards each BGP peer.",
																			},
																			"prepend_local_as": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "When set to true, the local AS value is prepended to the AS path of inbound routes from each EBGP peer.",
																				MarkdownDescription: "When set to true, the local AS value is prepended to the AS path of inbound routes from each EBGP peer.",
																			},
																		},
																		CustomType: LocalAs1Type{
																			ObjectType: types.ObjectType{
																				AttrTypes: LocalAs1Value{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "The local autonomous system number advertised to peers.",
																		MarkdownDescription: "The local autonomous system number advertised to peers.",
																	},
																	"local_preference": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "Local Preference attribute added to received routes from the BGP peers, also sets local preference for generated routes.",
																		MarkdownDescription: "Local Preference attribute added to received routes from the BGP peers, also sets local preference for generated routes.",
																	},
																	"multi_hop_max_hop": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "Enable multihop for eBGP peers and sets the maximum number of hops allowed.",
																		MarkdownDescription: "Enable multihop for eBGP peers and sets the maximum number of hops allowed.",
																	},
																	"next_hop_self": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "When set to true, the next-hop in all IPv4-unicast, IPv6-unicast and EVPN BGP routes advertised to the peer is set to the local-address.",
																		MarkdownDescription: "When set to true, the next-hop in all IPv4-unicast, IPv6-unicast and EVPN BGP routes advertised to the peer is set to the local-address.",
																	},
																	"node": schema.StringAttribute{
																		Optional:            true,
																		Description:         "Node on which to configure the BGP peer. This node must be one of the nodes on which the IRBInterface is configured.  When left blank or if the node is not part of the IRBInterface, the peer will not be deployed. Ignored for RoutedInterfaces.",
																		MarkdownDescription: "Node on which to configure the BGP peer. This node must be one of the nodes on which the IRBInterface is configured.  When left blank or if the node is not part of the IRBInterface, the peer will not be deployed. Ignored for RoutedInterfaces.",
																	},
																	"peer_as": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"autonomous_system": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "Local Autonomous System number.",
																				MarkdownDescription: "Local Autonomous System number.",
																			},
																		},
																		CustomType: PeerAs1Type{
																			ObjectType: types.ObjectType{
																				AttrTypes: PeerAs1Value{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "The autonomous system number expected from peers.",
																		MarkdownDescription: "The autonomous system number expected from peers.",
																	},
																	"peer_ip": schema.StringAttribute{
																		Optional:            true,
																		Description:         "Peer IP to which the peering session will be established.",
																		MarkdownDescription: "Peer IP to which the peering session will be established.",
																	},
																	"send_community_large": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "When false, all large (12 byte) BGP communities from all outbound routes advertised to the peer are stripped.",
																		MarkdownDescription: "When false, all large (12 byte) BGP communities from all outbound routes advertised to the peer are stripped.",
																	},
																	"send_community_standard": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "When false, all standard (4 byte) communities from all outbound routes advertised to the peer are stripped.",
																		MarkdownDescription: "When false, all standard (4 byte) communities from all outbound routes advertised to the peer are stripped.",
																	},
																	"send_default_route": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"address_family": schema.ListAttribute{
																				ElementType:         types.StringType,
																				Optional:            true,
																				Description:         "Enables the sending of a synthetically generated default IPv4 or IPV6 route to each peer.",
																				MarkdownDescription: "Enables the sending of a synthetically generated default IPv4 or IPV6 route to each peer.",
																			},
																			"export_policy": schema.StringAttribute{
																				Optional:            true,
																				Description:         "Reference to a Policy that should be applied to the advertised default routes, in order to set their attributes to non-default values.",
																				MarkdownDescription: "Reference to a Policy that should be applied to the advertised default routes, in order to set their attributes to non-default values.",
																			},
																		},
																		CustomType: SendDefaultRoute1Type{
																			ObjectType: types.ObjectType{
																				AttrTypes: SendDefaultRoute1Value{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "Options for controlling the generation of default routes towards BGP peers.",
																		MarkdownDescription: "Options for controlling the generation of default routes towards BGP peers.",
																	},
																	"timers": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"connect_retry": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "The time interval in seconds between successive attempts to establish a session with a peer.",
																				MarkdownDescription: "The time interval in seconds between successive attempts to establish a session with a peer.",
																			},
																			"hold_time": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "The hold-time interval in seconds that the router proposes to the peer in its OPEN message.",
																				MarkdownDescription: "The hold-time interval in seconds that the router proposes to the peer in its OPEN message.",
																			},
																			"keep_alive": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "The interval in seconds between successive keepalive messages sent to the peer.",
																				MarkdownDescription: "The interval in seconds between successive keepalive messages sent to the peer.",
																			},
																			"minimum_advertisement_interval": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions.",
																				MarkdownDescription: "The value assigned to the MinRouteAdvertisementIntervalTimer of RFC 4271, for both EBGP and IBGP sessions.",
																			},
																		},
																		CustomType: Timers1Type{
																			ObjectType: types.ObjectType{
																				AttrTypes: Timers1Value{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "Timer configurations",
																		MarkdownDescription: "Timer configurations",
																	},
																},
																CustomType: Spec5Type{
																	ObjectType: types.ObjectType{
																		AttrTypes: Spec5Value{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Specification of the BgpPeer",
																MarkdownDescription: "Specification of the BgpPeer",
															},
														},
														CustomType: BgpPeersType{
															ObjectType: types.ObjectType{
																AttrTypes: BgpPeersValue{}.AttributeTypes(ctx),
															},
														},
													},
													Optional:            true,
													Description:         "List of BgpPeers [emits=BGPPeer]",
													MarkdownDescription: "List of BgpPeers [emits=BGPPeer]",
												},
											},
											CustomType: BgpType{
												ObjectType: types.ObjectType{
													AttrTypes: BgpValue{}.AttributeTypes(ctx),
												},
											},
											Optional:            true,
											Description:         "BGP Protocol.",
											MarkdownDescription: "BGP Protocol.",
										},
										"ospf": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														Optional:            true,
														Description:         "The name of the OSPFInstance.",
														MarkdownDescription: "The name of the OSPFInstance.",
													},
													"ospf_areas": schema.ListNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	Optional:            true,
																	Description:         "The name of the OSPFArea.",
																	MarkdownDescription: "The name of the OSPFArea.",
																},
																"spec": schema.SingleNestedAttribute{
																	Attributes: map[string]schema.Attribute{
																		"area_id": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Area ID. 32-bit in the dotted-quad notation (e.g., \"0.0.0.0\").",
																			MarkdownDescription: "Area ID. 32-bit in the dotted-quad notation (e.g., \"0.0.0.0\").",
																		},
																		"area_type": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Area type. Normal is assumed if not specified.",
																			MarkdownDescription: "Area type. Normal is assumed if not specified.",
																		},
																	},
																	CustomType: Spec6Type{
																		ObjectType: types.ObjectType{
																			AttrTypes: Spec6Value{}.AttributeTypes(ctx),
																		},
																	},
																	Optional:            true,
																	Description:         "Specification of the OSPFArea.",
																	MarkdownDescription: "Specification of the OSPFArea.",
																},
															},
															CustomType: OspfAreasType{
																ObjectType: types.ObjectType{
																	AttrTypes: OspfAreasValue{}.AttributeTypes(ctx),
																},
															},
														},
														Optional:            true,
														Description:         "List of OSPFAreas. [emits=OSPFArea]",
														MarkdownDescription: "List of OSPFAreas. [emits=OSPFArea]",
													},
													"ospf_interfaces": schema.ListNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"name": schema.StringAttribute{
																	Optional:            true,
																	Description:         "The name of the OSPFInterface.",
																	MarkdownDescription: "The name of the OSPFInterface.",
																},
																"spec": schema.SingleNestedAttribute{
																	Attributes: map[string]schema.Attribute{
																		"dead_interval_sec": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "Dead Interval in seconds.",
																			MarkdownDescription: "Dead Interval in seconds.",
																		},
																		"hello_interval_sec": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "Hello Interval in seconds.",
																			MarkdownDescription: "Hello Interval in seconds.",
																		},
																		"interface": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Reference to a RoutedInterface.",
																			MarkdownDescription: "Reference to a RoutedInterface.",
																		},
																		"interface_kind": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Reference to the Kind of interface to enable OSPF on.",
																			MarkdownDescription: "Reference to the Kind of interface to enable OSPF on.",
																		},
																		"metric": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "Interface metric.",
																			MarkdownDescription: "Interface metric.",
																		},
																		"mtu": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "OSPF interface MTU",
																			MarkdownDescription: "OSPF interface MTU",
																		},
																		"ospf_area": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Reference to a OSPFArea.",
																			MarkdownDescription: "Reference to a OSPFArea.",
																		},
																		"ospf_bfd": schema.SingleNestedAttribute{
																			Attributes: map[string]schema.Attribute{
																				"enabled": schema.BoolAttribute{
																					Optional:            true,
																					Description:         "Enables BFD on the OSPF interface.",
																					MarkdownDescription: "Enables BFD on the OSPF interface.",
																				},
																				"strict_mode": schema.BoolAttribute{
																					Optional:            true,
																					Description:         "Enables BFD Strict Mode on the OSPF interface.",
																					MarkdownDescription: "Enables BFD Strict Mode on the OSPF interface.",
																				},
																				"strict_mode_hold_down_sec": schema.Int64Attribute{
																					Optional:            true,
																					Description:         "Enables Hold Down Timer for BFD Strict Mode, in seconds.",
																					MarkdownDescription: "Enables Hold Down Timer for BFD Strict Mode, in seconds.",
																				},
																			},
																			CustomType: OspfBfdType{
																				ObjectType: types.ObjectType{
																					AttrTypes: OspfBfdValue{}.AttributeTypes(ctx),
																				},
																			},
																			Optional:            true,
																			Description:         "Configure BFD on the OSPF interface.",
																			MarkdownDescription: "Configure BFD on the OSPF interface.",
																		},
																		"ospf_instance": schema.StringAttribute{
																			Optional:            true,
																			Description:         "Reference to a OSPF Instance on which the OSPF area is configured.",
																			MarkdownDescription: "Reference to a OSPF Instance on which the OSPF area is configured.",
																		},
																		"passive": schema.BoolAttribute{
																			Optional:            true,
																			Description:         "Configure the OSPF interface as passive.",
																			MarkdownDescription: "Configure the OSPF interface as passive.",
																		},
																		"type": schema.StringAttribute{
																			Optional:            true,
																			Description:         "OSPF interface type.",
																			MarkdownDescription: "OSPF interface type.",
																		},
																	},
																	CustomType: Spec7Type{
																		ObjectType: types.ObjectType{
																			AttrTypes: Spec7Value{}.AttributeTypes(ctx),
																		},
																	},
																	Optional:            true,
																	Description:         "Specification of the OSPFInterface.",
																	MarkdownDescription: "Specification of the OSPFInterface.",
																},
															},
															CustomType: OspfInterfacesType{
																ObjectType: types.ObjectType{
																	AttrTypes: OspfInterfacesValue{}.AttributeTypes(ctx),
																},
															},
														},
														Optional:            true,
														Description:         "List of OSPFInterfaces. [emits=OSPFInterface]",
														MarkdownDescription: "List of OSPFInterfaces. [emits=OSPFInterface]",
													},
													"spec": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"address_family": schema.StringAttribute{
																Optional:            true,
																Description:         "Selects an address family for OSPFv3. It is mandatory to specify at least one address family when OSPFv3 is selected.",
																MarkdownDescription: "Selects an address family for OSPFv3. It is mandatory to specify at least one address family when OSPFv3 is selected.",
															},
															"enabled": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enables OSPF instance.",
																MarkdownDescription: "Enables OSPF instance.",
															},
															"max_ecmp": schema.Int64Attribute{
																Optional:            true,
																Description:         "The maximum number of ECMP paths (next-hops).",
																MarkdownDescription: "The maximum number of ECMP paths (next-hops).",
															},
															"max_metric": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"on_boot": schema.Int64Attribute{
																		Optional:            true,
																		Description:         "Set Max Metric on boot for the fixed period of time (in seconds).",
																		MarkdownDescription: "Set Max Metric on boot for the fixed period of time (in seconds).",
																	},
																	"overload": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enable Max Link Metric on all interfaces.",
																		MarkdownDescription: "Enable Max Link Metric on all interfaces.",
																	},
																},
																CustomType: MaxMetricType{
																	ObjectType: types.ObjectType{
																		AttrTypes: MaxMetricValue{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Configuration related to OSPF Max Metric / Overload.",
																MarkdownDescription: "Configuration related to OSPF Max Metric / Overload.",
															},
															"ref_bw_gbps": schema.Int64Attribute{
																Optional:            true,
																Description:         "Reference bandwidth (in Gbps) for automatic metric calculation.",
																MarkdownDescription: "Reference bandwidth (in Gbps) for automatic metric calculation.",
															},
															"timers": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"lsa_timers": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"accumulate_ms": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "Delay (in milliseconds) to gather LSAs before advertising to neighbors",
																				MarkdownDescription: "Delay (in milliseconds) to gather LSAs before advertising to neighbors",
																			},
																			"arrival_ms": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "Minimum interval (in milliseconds) to accept an identical LSA.",
																				MarkdownDescription: "Minimum interval (in milliseconds) to accept an identical LSA.",
																			},
																			"gen_hold_interval_ms": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "Hold interval (in milliseconds) for subsequent LSA regeneration.",
																				MarkdownDescription: "Hold interval (in milliseconds) for subsequent LSA regeneration.",
																			},
																			"gen_initial_delay_ms": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "Initial delay (in milliseconds) to generate the first instance of LSAs.",
																				MarkdownDescription: "Initial delay (in milliseconds) to generate the first instance of LSAs.",
																			},
																			"gen_max_delay_ms": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "Maximum interval (in milliseconds) between two consecutive regenerations (of the same LSA).",
																				MarkdownDescription: "Maximum interval (in milliseconds) between two consecutive regenerations (of the same LSA).",
																			},
																		},
																		CustomType: LsaTimersType{
																			ObjectType: types.ObjectType{
																				AttrTypes: LsaTimersValue{}.AttributeTypes(ctx),
																			},
																		},
																		Optional: true,
																	},
																	"spf_timers": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"hold_interval_ms": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "Hold interval for subsequent SPF calculations.",
																				MarkdownDescription: "Hold interval for subsequent SPF calculations.",
																			},
																			"incremental_spf_delay_ms": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "Delay (in milliseconds) before an incremental SPF calculation starts.",
																				MarkdownDescription: "Delay (in milliseconds) before an incremental SPF calculation starts.",
																			},
																			"initial_delay_ms": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "Initial SPF calculation delay (in milliseconds).",
																				MarkdownDescription: "Initial SPF calculation delay (in milliseconds).",
																			},
																			"max_delay_ms": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "Maximum interval (in milliseconds) between two consecutive SPF calculations.",
																				MarkdownDescription: "Maximum interval (in milliseconds) between two consecutive SPF calculations.",
																			},
																		},
																		CustomType: SpfTimersType{
																			ObjectType: types.ObjectType{
																				AttrTypes: SpfTimersValue{}.AttributeTypes(ctx),
																			},
																		},
																		Optional: true,
																	},
																},
																CustomType: Timers2Type{
																	ObjectType: types.ObjectType{
																		AttrTypes: Timers2Value{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Configures OSPF timers.",
																MarkdownDescription: "Configures OSPF timers.",
															},
															"version": schema.StringAttribute{
																Optional:            true,
																Description:         "OSPF version to use. OSPFv2 is supported over IPv4-enabled interfaces, OSPFv3 over IPv6-enabled interfaces.",
																MarkdownDescription: "OSPF version to use. OSPFv2 is supported over IPv4-enabled interfaces, OSPFv3 over IPv6-enabled interfaces.",
															},
														},
														CustomType: Spec8Type{
															ObjectType: types.ObjectType{
																AttrTypes: Spec8Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Specification of the OSPFInstance.",
														MarkdownDescription: "Specification of the OSPFInstance.",
													},
												},
												CustomType: OspfType{
													ObjectType: types.ObjectType{
														AttrTypes: OspfValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Description:         "OSPF Protocol Instanes.",
											MarkdownDescription: "OSPF Protocol Instanes.",
										},
										"routing_policies": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"policies": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"name": schema.StringAttribute{
																Optional:            true,
																Description:         "Name of the Policy.",
																MarkdownDescription: "Name of the Policy.",
															},
															"spec": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"configured_name": schema.StringAttribute{
																		Optional:            true,
																		Description:         "The name of the policy to configure on the device.",
																		MarkdownDescription: "The name of the policy to configure on the device.",
																	},
																	"default_action": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"bgp": schema.SingleNestedAttribute{
																				Attributes: map[string]schema.Attribute{
																					"as_path_prepend": schema.Int64Attribute{
																						Optional:            true,
																						Description:         "AS number to prepend to the AS Path attributes.",
																						MarkdownDescription: "AS number to prepend to the AS Path attributes.",
																					},
																					"as_path_remove": schema.BoolAttribute{
																						Optional:            true,
																						Description:         "Clear the AS path to make it empty.",
																						MarkdownDescription: "Clear the AS path to make it empty.",
																					},
																					"as_path_replace": schema.ListAttribute{
																						ElementType:         types.Int64Type,
																						Optional:            true,
																						Description:         "Replace the existing AS path with a new AS_SEQUENCE containing the listed AS numbers.",
																						MarkdownDescription: "Replace the existing AS path with a new AS_SEQUENCE containing the listed AS numbers.",
																					},
																					"community_set": schema.SingleNestedAttribute{
																						Attributes: map[string]schema.Attribute{
																							"add": schema.ListAttribute{
																								ElementType:         types.StringType,
																								Optional:            true,
																								Description:         "List of community sets to add to the route.",
																								MarkdownDescription: "List of community sets to add to the route.",
																							},
																							"remove": schema.ListAttribute{
																								ElementType:         types.StringType,
																								Optional:            true,
																								Description:         "List of community sets to remove from the route.",
																								MarkdownDescription: "List of community sets to remove from the route.",
																							},
																							"replace": schema.ListAttribute{
																								ElementType:         types.StringType,
																								Optional:            true,
																								Description:         "List of community sets to replace the existing communities with. Cannot be combined with Add or Remove.",
																								MarkdownDescription: "List of community sets to replace the existing communities with. Cannot be combined with Add or Remove.",
																							},
																						},
																						CustomType: CommunitySetType{
																							ObjectType: types.ObjectType{
																								AttrTypes: CommunitySetValue{}.AttributeTypes(ctx),
																							},
																						},
																						Optional:            true,
																						Description:         "Modify BGP communities associated with the route using hybrid Community Sets.",
																						MarkdownDescription: "Modify BGP communities associated with the route using hybrid Community Sets.",
																					},
																					"local_preference": schema.Int64Attribute{
																						Optional:            true,
																						Description:         "Set a new LOCAL_PREF value for matching BGP routes.",
																						MarkdownDescription: "Set a new LOCAL_PREF value for matching BGP routes.",
																					},
																					"med": schema.SingleNestedAttribute{
																						Attributes: map[string]schema.Attribute{
																							"numerical_value": schema.Int64Attribute{
																								Optional:            true,
																								Description:         "Fixed numerical value to set or add/subtract.",
																								MarkdownDescription: "Fixed numerical value to set or add/subtract.",
																							},
																							"operation": schema.StringAttribute{
																								Optional:            true,
																								Description:         "The operation to perform on the MED value.",
																								MarkdownDescription: "The operation to perform on the MED value.",
																							},
																							"value_type": schema.StringAttribute{
																								Optional:            true,
																								Description:         "Use a fixed value or an IGP metric to adjust the MED.",
																								MarkdownDescription: "Use a fixed value or an IGP metric to adjust the MED.",
																							},
																						},
																						CustomType: MedType{
																							ObjectType: types.ObjectType{
																								AttrTypes: MedValue{}.AttributeTypes(ctx),
																							},
																						},
																						Optional:            true,
																						Description:         "Set a new MED value.",
																						MarkdownDescription: "Set a new MED value.",
																					},
																					"set_origin": schema.StringAttribute{
																						Optional:            true,
																						Description:         "Set a new ORIGIN attribute for matching BGP routes.",
																						MarkdownDescription: "Set a new ORIGIN attribute for matching BGP routes.",
																					},
																				},
																				CustomType: Bgp1Type{
																					ObjectType: types.ObjectType{
																						AttrTypes: Bgp1Value{}.AttributeTypes(ctx),
																					},
																				},
																				Optional:            true,
																				Description:         "Actions related to the BGP protocol.",
																				MarkdownDescription: "Actions related to the BGP protocol.",
																			},
																			"policy_result": schema.StringAttribute{
																				Optional:            true,
																				Description:         "Final disposition for the route.",
																				MarkdownDescription: "Final disposition for the route.",
																			},
																			"tags": schema.SingleNestedAttribute{
																				Attributes: map[string]schema.Attribute{
																					"tag_set": schema.StringAttribute{
																						Optional:            true,
																						Description:         "Add tags to the route from the referenced Tag Set.",
																						MarkdownDescription: "Add tags to the route from the referenced Tag Set.",
																					},
																				},
																				CustomType: TagsType{
																					ObjectType: types.ObjectType{
																						AttrTypes: TagsValue{}.AttributeTypes(ctx),
																					},
																				},
																				Optional:            true,
																				Description:         "Manipulate internal route tags associated with the route.",
																				MarkdownDescription: "Manipulate internal route tags associated with the route.",
																			},
																		},
																		CustomType: DefaultActionType{
																			ObjectType: types.ObjectType{
																				AttrTypes: DefaultActionValue{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "The default action to apply if no other actions are defined.",
																		MarkdownDescription: "The default action to apply if no other actions are defined.",
																	},
																	"statement": schema.ListNestedAttribute{
																		NestedObject: schema.NestedAttributeObject{
																			Attributes: map[string]schema.Attribute{
																				"action": schema.SingleNestedAttribute{
																					Attributes: map[string]schema.Attribute{
																						"bgp": schema.SingleNestedAttribute{
																							Attributes: map[string]schema.Attribute{
																								"as_path_prepend": schema.Int64Attribute{
																									Optional:            true,
																									Description:         "AS number to prepend to the AS Path attributes.",
																									MarkdownDescription: "AS number to prepend to the AS Path attributes.",
																								},
																								"as_path_remove": schema.BoolAttribute{
																									Optional:            true,
																									Description:         "Clear the AS path to make it empty.",
																									MarkdownDescription: "Clear the AS path to make it empty.",
																								},
																								"as_path_replace": schema.ListAttribute{
																									ElementType:         types.Int64Type,
																									Optional:            true,
																									Description:         "Replace the existing AS path with a new AS_SEQUENCE containing the listed AS numbers.",
																									MarkdownDescription: "Replace the existing AS path with a new AS_SEQUENCE containing the listed AS numbers.",
																								},
																								"community_set": schema.SingleNestedAttribute{
																									Attributes: map[string]schema.Attribute{
																										"add": schema.ListAttribute{
																											ElementType:         types.StringType,
																											Optional:            true,
																											Description:         "List of community sets to add to the route.",
																											MarkdownDescription: "List of community sets to add to the route.",
																										},
																										"remove": schema.ListAttribute{
																											ElementType:         types.StringType,
																											Optional:            true,
																											Description:         "List of community sets to remove from the route.",
																											MarkdownDescription: "List of community sets to remove from the route.",
																										},
																										"replace": schema.ListAttribute{
																											ElementType:         types.StringType,
																											Optional:            true,
																											Description:         "List of community sets to replace the existing communities with. Cannot be combined with Add or Remove.",
																											MarkdownDescription: "List of community sets to replace the existing communities with. Cannot be combined with Add or Remove.",
																										},
																									},
																									CustomType: CommunitySet1Type{
																										ObjectType: types.ObjectType{
																											AttrTypes: CommunitySet1Value{}.AttributeTypes(ctx),
																										},
																									},
																									Optional:            true,
																									Description:         "Modify BGP communities associated with the route using hybrid Community Sets.",
																									MarkdownDescription: "Modify BGP communities associated with the route using hybrid Community Sets.",
																								},
																								"local_preference": schema.Int64Attribute{
																									Optional:            true,
																									Description:         "Set a new LOCAL_PREF value for matching BGP routes.",
																									MarkdownDescription: "Set a new LOCAL_PREF value for matching BGP routes.",
																								},
																								"med": schema.SingleNestedAttribute{
																									Attributes: map[string]schema.Attribute{
																										"numerical_value": schema.Int64Attribute{
																											Optional:            true,
																											Description:         "Fixed numerical value to set or add/subtract.",
																											MarkdownDescription: "Fixed numerical value to set or add/subtract.",
																										},
																										"operation": schema.StringAttribute{
																											Optional:            true,
																											Description:         "The operation to perform on the MED value.",
																											MarkdownDescription: "The operation to perform on the MED value.",
																										},
																										"value_type": schema.StringAttribute{
																											Optional:            true,
																											Description:         "Use a fixed value or an IGP metric to adjust the MED.",
																											MarkdownDescription: "Use a fixed value or an IGP metric to adjust the MED.",
																										},
																									},
																									CustomType: Med1Type{
																										ObjectType: types.ObjectType{
																											AttrTypes: Med1Value{}.AttributeTypes(ctx),
																										},
																									},
																									Optional:            true,
																									Description:         "Set a new MED value.",
																									MarkdownDescription: "Set a new MED value.",
																								},
																								"set_origin": schema.StringAttribute{
																									Optional:            true,
																									Description:         "Set a new ORIGIN attribute for matching BGP routes.",
																									MarkdownDescription: "Set a new ORIGIN attribute for matching BGP routes.",
																								},
																							},
																							CustomType: Bgp2Type{
																								ObjectType: types.ObjectType{
																									AttrTypes: Bgp2Value{}.AttributeTypes(ctx),
																								},
																							},
																							Optional:            true,
																							Description:         "Actions related to the BGP protocol.",
																							MarkdownDescription: "Actions related to the BGP protocol.",
																						},
																						"policy_result": schema.StringAttribute{
																							Optional:            true,
																							Description:         "Final disposition for the route.",
																							MarkdownDescription: "Final disposition for the route.",
																						},
																						"tags": schema.SingleNestedAttribute{
																							Attributes: map[string]schema.Attribute{
																								"tag_set": schema.StringAttribute{
																									Optional:            true,
																									Description:         "Add tags to the route from the referenced Tag Set.",
																									MarkdownDescription: "Add tags to the route from the referenced Tag Set.",
																								},
																							},
																							CustomType: Tags1Type{
																								ObjectType: types.ObjectType{
																									AttrTypes: Tags1Value{}.AttributeTypes(ctx),
																								},
																							},
																							Optional:            true,
																							Description:         "Manipulate internal route tags associated with the route.",
																							MarkdownDescription: "Manipulate internal route tags associated with the route.",
																						},
																					},
																					CustomType: ActionType{
																						ObjectType: types.ObjectType{
																							AttrTypes: ActionValue{}.AttributeTypes(ctx),
																						},
																					},
																					Optional:            true,
																					Description:         "Actions for routes that match the policy statement.",
																					MarkdownDescription: "Actions for routes that match the policy statement.",
																				},
																				"match": schema.SingleNestedAttribute{
																					Attributes: map[string]schema.Attribute{
																						"bgp": schema.SingleNestedAttribute{
																							Attributes: map[string]schema.Attribute{
																								"as_path_match": schema.SingleNestedAttribute{
																									Attributes: map[string]schema.Attribute{
																										"as_path_expression": schema.StringAttribute{
																											Optional:            true,
																											Description:         "A singular regular expression string to match against AS_PATH objects. Mutually exclusive with the ASPathSet reference.",
																											MarkdownDescription: "A singular regular expression string to match against AS_PATH objects. Mutually exclusive with the ASPathSet reference.",
																										},
																										"as_path_set": schema.StringAttribute{
																											Optional:            true,
																											Description:         "Reference to an ASPathSet resource. Mutually exclusive with the ASPathExpression.",
																											MarkdownDescription: "Reference to an ASPathSet resource. Mutually exclusive with the ASPathExpression.",
																										},
																										"match_set_options": schema.StringAttribute{
																											Optional:            true,
																											Description:         "The matching criteria that applies to the members in the referenced set.",
																											MarkdownDescription: "The matching criteria that applies to the members in the referenced set.",
																										},
																									},
																									CustomType: AsPathMatchType{
																										ObjectType: types.ObjectType{
																											AttrTypes: AsPathMatchValue{}.AttributeTypes(ctx),
																										},
																									},
																									Optional:            true,
																									Description:         "AS Path match criteria.",
																									MarkdownDescription: "AS Path match criteria.",
																								},
																								"community_set": schema.StringAttribute{
																									Optional:            true,
																									Description:         "Match conditions for BGP communities.",
																									MarkdownDescription: "Match conditions for BGP communities.",
																								},
																								"evpn_route_type": schema.ListAttribute{
																									ElementType:         types.Int64Type,
																									Optional:            true,
																									Description:         "Match conditions for EVPN route types.",
																									MarkdownDescription: "Match conditions for EVPN route types.",
																								},
																							},
																							CustomType: Bgp3Type{
																								ObjectType: types.ObjectType{
																									AttrTypes: Bgp3Value{}.AttributeTypes(ctx),
																								},
																							},
																							Optional:            true,
																							Description:         "Configuration for BGP-specific policy match criteria.",
																							MarkdownDescription: "Configuration for BGP-specific policy match criteria.",
																						},
																						"family": schema.ListAttribute{
																							ElementType:         types.StringType,
																							Optional:            true,
																							Description:         "Address families that the route belongs to.",
																							MarkdownDescription: "Address families that the route belongs to.",
																						},
																						"prefix_set": schema.StringAttribute{
																							Optional:            true,
																							Description:         "Reference to a PrefixSet resource.",
																							MarkdownDescription: "Reference to a PrefixSet resource.",
																						},
																						"protocol": schema.StringAttribute{
																							Optional:            true,
																							Description:         "The route protocol type to match.",
																							MarkdownDescription: "The route protocol type to match.",
																						},
																						"tags": schema.SingleNestedAttribute{
																							Attributes: map[string]schema.Attribute{
																								"tag_set": schema.StringAttribute{
																									Optional:            true,
																									Description:         "Reference to a TagSet resource.",
																									MarkdownDescription: "Reference to a TagSet resource.",
																								},
																							},
																							CustomType: Tags2Type{
																								ObjectType: types.ObjectType{
																									AttrTypes: Tags2Value{}.AttributeTypes(ctx),
																								},
																							},
																							Optional:            true,
																							Description:         "Match based on the internal route tags associated with the route.",
																							MarkdownDescription: "Match based on the internal route tags associated with the route.",
																						},
																					},
																					CustomType: MatchType{
																						ObjectType: types.ObjectType{
																							AttrTypes: MatchValue{}.AttributeTypes(ctx),
																						},
																					},
																					Optional:            true,
																					Description:         "Match conditions of the policy statement.",
																					MarkdownDescription: "Match conditions of the policy statement.",
																				},
																				"name": schema.StringAttribute{
																					Optional:            true,
																					Description:         "Name of the policy statement.",
																					MarkdownDescription: "Name of the policy statement.",
																				},
																			},
																			CustomType: StatementType{
																				ObjectType: types.ObjectType{
																					AttrTypes: StatementValue{}.AttributeTypes(ctx),
																				},
																			},
																		},
																		Optional:            true,
																		Description:         "List of policy statements.",
																		MarkdownDescription: "List of policy statements.",
																	},
																},
																CustomType: Spec9Type{
																	ObjectType: types.ObjectType{
																		AttrTypes: Spec9Value{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "A policy",
																MarkdownDescription: "A policy",
															},
														},
														CustomType: PoliciesType{
															ObjectType: types.ObjectType{
																AttrTypes: PoliciesValue{}.AttributeTypes(ctx),
															},
														},
													},
													Optional:            true,
													Description:         "List of Policies.  [emits=Policy]",
													MarkdownDescription: "List of Policies.  [emits=Policy]",
												},
												"prefix_sets": schema.ListNestedAttribute{
													NestedObject: schema.NestedAttributeObject{
														Attributes: map[string]schema.Attribute{
															"name": schema.StringAttribute{
																Optional:            true,
																Description:         "Name of the PrefixSet.",
																MarkdownDescription: "Name of the PrefixSet.",
															},
															"spec": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"configured_name": schema.StringAttribute{
																		Optional:            true,
																		Description:         "The name of the prefixset to configure on the device.",
																		MarkdownDescription: "The name of the prefixset to configure on the device.",
																	},
																	"prefix": schema.ListNestedAttribute{
																		NestedObject: schema.NestedAttributeObject{
																			Attributes: map[string]schema.Attribute{
																				"end_range": schema.Int64Attribute{
																					Optional:            true,
																					Description:         "The end range when using a range to match prefixes.",
																					MarkdownDescription: "The end range when using a range to match prefixes.",
																				},
																				"exact": schema.BoolAttribute{
																					Optional:            true,
																					Description:         "Indicates if it is an exact match. Ignores the StartRange and EndRange if this param is set.",
																					MarkdownDescription: "Indicates if it is an exact match. Ignores the StartRange and EndRange if this param is set.",
																				},
																				"prefix": schema.StringAttribute{
																					Optional:            true,
																					Description:         "The IPv4 or IPv6 prefix in CIDR notation with mask.",
																					MarkdownDescription: "The IPv4 or IPv6 prefix in CIDR notation with mask.",
																				},
																				"start_range": schema.Int64Attribute{
																					Optional:            true,
																					Description:         "If specifying a range, this is the start of the range.",
																					MarkdownDescription: "If specifying a range, this is the start of the range.",
																				},
																			},
																			CustomType: PrefixType{
																				ObjectType: types.ObjectType{
																					AttrTypes: PrefixValue{}.AttributeTypes(ctx),
																				},
																			},
																		},
																		Optional:            true,
																		Description:         "List of IPv4 or IPv6 prefixes in CIDR notation.",
																		MarkdownDescription: "List of IPv4 or IPv6 prefixes in CIDR notation.",
																	},
																},
																CustomType: Spec10Type{
																	ObjectType: types.ObjectType{
																		AttrTypes: Spec10Value{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "A PrefixSets",
																MarkdownDescription: "A PrefixSets",
															},
														},
														CustomType: PrefixSetsType{
															ObjectType: types.ObjectType{
																AttrTypes: PrefixSetsValue{}.AttributeTypes(ctx),
															},
														},
													},
													Optional:            true,
													Description:         "List of PrefixSet [emits=PrefixSet]",
													MarkdownDescription: "List of PrefixSet [emits=PrefixSet]",
												},
											},
											CustomType: RoutingPoliciesType{
												ObjectType: types.ObjectType{
													AttrTypes: RoutingPoliciesValue{}.AttributeTypes(ctx),
												},
											},
											Optional:            true,
											Description:         "Routing Policies.",
											MarkdownDescription: "Routing Policies.",
										},
										"static_routes": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"name": schema.StringAttribute{
														Optional:            true,
														Description:         "Name of the StaticRoute.",
														MarkdownDescription: "Name of the StaticRoute.",
													},
													"spec": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"configured_name": schema.StringAttribute{
																Optional:            true,
																Description:         "The name of the static route to configure on the device.",
																MarkdownDescription: "The name of the static route to configure on the device.",
															},
															"nexthop_group": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"bfd": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"enabled": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "Defines whether BFD should be enabled towards the nexthops.",
																				MarkdownDescription: "Defines whether BFD should be enabled towards the nexthops.",
																			},
																			"local_address": schema.StringAttribute{
																				Optional:            true,
																				Description:         "Defines the local address to use when establishing the BFD session with the nexthop.",
																				MarkdownDescription: "Defines the local address to use when establishing the BFD session with the nexthop.",
																			},
																		},
																		CustomType: Bfd1Type{
																			ObjectType: types.ObjectType{
																				AttrTypes: Bfd1Value{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "Enables BFD to the next-hops in the group. Local and Remote discriminator parameters have been deprecated at this level. Use Nexthop to set these parameters.",
																		MarkdownDescription: "Enables BFD to the next-hops in the group. Local and Remote discriminator parameters have been deprecated at this level. Use Nexthop to set these parameters.",
																	},
																	"blackhole": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "If set to true all traffic destined to the prefixes will be blackholed.  If enabled, next-hops are ignored and this takes precedence.",
																		MarkdownDescription: "If set to true all traffic destined to the prefixes will be blackholed.  If enabled, next-hops are ignored and this takes precedence.",
																	},
																	"blackhole_send_icmp": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "When enabled, the router will generate ICMP Unreachable messages for packets destined to the blackhole route.",
																		MarkdownDescription: "When enabled, the router will generate ICMP Unreachable messages for packets destined to the blackhole route.",
																	},
																	"nexthops": schema.ListNestedAttribute{
																		NestedObject: schema.NestedAttributeObject{
																			Attributes: map[string]schema.Attribute{
																				"bfd": schema.SingleNestedAttribute{
																					Attributes: map[string]schema.Attribute{
																						"enabled": schema.BoolAttribute{
																							Optional:            true,
																							Description:         "Defines whether BFD should be enabled towards the nexthops.",
																							MarkdownDescription: "Defines whether BFD should be enabled towards the nexthops.",
																						},
																						"local_address": schema.StringAttribute{
																							Optional:            true,
																							Description:         "Defines the local address to use when establishing the BFD session with the nexthop.",
																							MarkdownDescription: "Defines the local address to use when establishing the BFD session with the nexthop.",
																						},
																						"local_discriminator": schema.Int64Attribute{
																							Optional:            true,
																							Description:         "Defines the local discriminator.",
																							MarkdownDescription: "Defines the local discriminator.",
																						},
																						"remote_discriminator": schema.Int64Attribute{
																							Optional:            true,
																							Description:         "Defines the remote discriminator.",
																							MarkdownDescription: "Defines the remote discriminator.",
																						},
																					},
																					CustomType: Bfd2Type{
																						ObjectType: types.ObjectType{
																							AttrTypes: Bfd2Value{}.AttributeTypes(ctx),
																						},
																					},
																					Optional:            true,
																					Description:         "Enables BFD to the next-hops in the group. This overrides the configuration at the group.",
																					MarkdownDescription: "Enables BFD to the next-hops in the group. This overrides the configuration at the group.",
																				},
																				"ip_prefix": schema.StringAttribute{
																					Optional:            true,
																					Description:         "Address to use.",
																					MarkdownDescription: "Address to use.",
																				},
																				"resolve": schema.BoolAttribute{
																					Optional:            true,
																					Description:         "If set to true the next-hops can be destinations which are resolved in the route table. This overrides the configuration at the group.",
																					MarkdownDescription: "If set to true the next-hops can be destinations which are resolved in the route table. This overrides the configuration at the group.",
																				},
																			},
																			CustomType: NexthopsType{
																				ObjectType: types.ObjectType{
																					AttrTypes: NexthopsValue{}.AttributeTypes(ctx),
																				},
																			},
																		},
																		Optional:            true,
																		Description:         "Ordered list of nexthops.",
																		MarkdownDescription: "Ordered list of nexthops.",
																	},
																	"resolve": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "If set to true the next-hops can be destinations which are resolved in the route table.",
																		MarkdownDescription: "If set to true the next-hops can be destinations which are resolved in the route table.",
																	},
																},
																CustomType: NexthopGroupType{
																	ObjectType: types.ObjectType{
																		AttrTypes: NexthopGroupValue{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Group of nexthops for the list of prefixes.",
																MarkdownDescription: "Group of nexthops for the list of prefixes.",
															},
															"nodes": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of nodes on which to configure the static routes. An AND operation is executed against the nodes in this list and the nodes on which the Router is configured to determine the Nodes on which to configure the static routes.",
																MarkdownDescription: "List of nodes on which to configure the static routes. An AND operation is executed against the nodes in this list and the nodes on which the Router is configured to determine the Nodes on which to configure the static routes.",
															},
															"preference": schema.Int64Attribute{
																Optional:            true,
																Description:         "Defines the route preference.",
																MarkdownDescription: "Defines the route preference.",
															},
															"prefixes": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of destination prefixes and mask to use for the static routes.",
																MarkdownDescription: "List of destination prefixes and mask to use for the static routes.",
															},
															"router": schema.StringAttribute{
																Optional:            true,
																Description:         "Reference to a Router on which to configure the static routes.  If no Nodes are provided then the static routes will be provisioned on all Nodes on which the Router is provisioned.",
																MarkdownDescription: "Reference to a Router on which to configure the static routes.  If no Nodes are provided then the static routes will be provisioned on all Nodes on which the Router is provisioned.",
															},
														},
														CustomType: Spec11Type{
															ObjectType: types.ObjectType{
																AttrTypes: Spec11Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "A StaticRoutes",
														MarkdownDescription: "A StaticRoutes",
													},
												},
												CustomType: StaticRoutesType{
													ObjectType: types.ObjectType{
														AttrTypes: StaticRoutesValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Description:         "List of Static Routes within this VirtualNetwork. [emits=StaticRoute]",
											MarkdownDescription: "List of Static Routes within this VirtualNetwork. [emits=StaticRoute]",
										},
									},
									CustomType: ProtocolsType{
										ObjectType: types.ObjectType{
											AttrTypes: ProtocolsValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Protocols to configure.",
									MarkdownDescription: "Protocols to configure.",
								},
								"routed_interfaces": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Optional:            true,
												Description:         "The name of the RoutedInterface.",
												MarkdownDescription: "The name of the RoutedInterface.",
											},
											"spec": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"arp_timeout": schema.Int64Attribute{
														Optional:            true,
														Description:         "Duration of time that dynamic ARP entries remain in the ARP cache before they expire.",
														MarkdownDescription: "Duration of time that dynamic ARP entries remain in the ARP cache before they expire.",
													},
													"bfd": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"desired_min_transmit_int": schema.Int64Attribute{
																Optional:            true,
																Description:         "The minimum interval in microseconds between transmission of BFD control packets.",
																MarkdownDescription: "The minimum interval in microseconds between transmission of BFD control packets.",
															},
															"detection_multiplier": schema.Int64Attribute{
																Optional:            true,
																Description:         "The number of packets that must be missed to declare this session as down.",
																MarkdownDescription: "The number of packets that must be missed to declare this session as down.",
															},
															"enabled": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enables Biforward Detection.",
																MarkdownDescription: "Enables Biforward Detection.",
															},
															"min_echo_receive_interval": schema.Int64Attribute{
																Optional:            true,
																Description:         "The minimum interval between echo packets the local node can receive.",
																MarkdownDescription: "The minimum interval between echo packets the local node can receive.",
															},
															"required_min_receive": schema.Int64Attribute{
																Optional:            true,
																Description:         "The minimum interval in microseconds between received BFD control packets that this system should support.",
																MarkdownDescription: "The minimum interval in microseconds between received BFD control packets that this system should support.",
															},
															"ttl": schema.Int64Attribute{
																Optional:            true,
																Description:         "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not applicable to single-hop BFD sessions.",
																MarkdownDescription: "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not applicable to single-hop BFD sessions.",
															},
														},
														CustomType: Bfd3Type{
															ObjectType: types.ObjectType{
																AttrTypes: Bfd3Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Enables BFD on the RoutedInterface.",
														MarkdownDescription: "Enables BFD on the RoutedInterface.",
													},
													"description": schema.StringAttribute{
														Optional:            true,
														Description:         "The description of the RoutedInterface.",
														MarkdownDescription: "The description of the RoutedInterface.",
													},
													"egress": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"filters": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of Filter references to use at egress.",
																MarkdownDescription: "List of Filter references to use at egress.",
															},
															"qos_policy": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of QoS Egress policy references to use at egress.",
																MarkdownDescription: "List of QoS Egress policy references to use at egress.",
															},
														},
														CustomType: Egress3Type{
															ObjectType: types.ObjectType{
																AttrTypes: Egress3Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Manages actions on traffic at Egress.",
														MarkdownDescription: "Manages actions on traffic at Egress.",
													},
													"host_route_populate": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"dynamic": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"datapath_programming": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enable datapath programming for host routes.",
																		MarkdownDescription: "Enable datapath programming for host routes.",
																	},
																	"populate": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enable population of host routes based on ARP/ND entries.",
																		MarkdownDescription: "Enable population of host routes based on ARP/ND entries.",
																	},
																},
																CustomType: DynamicType{
																	ObjectType: types.ObjectType{
																		AttrTypes: DynamicValue{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Create host routes out of dynamic ARP/ND entries.",
																MarkdownDescription: "Create host routes out of dynamic ARP/ND entries.",
															},
															"evpn": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"datapath_programming": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enable datapath programming for host routes.",
																		MarkdownDescription: "Enable datapath programming for host routes.",
																	},
																	"populate": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enable population of host routes based on ARP/ND entries.",
																		MarkdownDescription: "Enable population of host routes based on ARP/ND entries.",
																	},
																},
																CustomType: EvpnType{
																	ObjectType: types.ObjectType{
																		AttrTypes: EvpnValue{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Create host routes out of EVPN learned ARP/ND entries.",
																MarkdownDescription: "Create host routes out of EVPN learned ARP/ND entries.",
															},
															"static": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"datapath_programming": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enable datapath programming for host routes.",
																		MarkdownDescription: "Enable datapath programming for host routes.",
																	},
																	"populate": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enable population of host routes based on ARP/ND entries.",
																		MarkdownDescription: "Enable population of host routes based on ARP/ND entries.",
																	},
																},
																CustomType: StaticType{
																	ObjectType: types.ObjectType{
																		AttrTypes: StaticValue{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Create host routes out of static ARP/ND entries.",
																MarkdownDescription: "Create host routes out of static ARP/ND entries.",
															},
														},
														CustomType: HostRoutePopulate1Type{
															ObjectType: types.ObjectType{
																AttrTypes: HostRoutePopulate1Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Configures host route population based on ARP/ND entries.",
														MarkdownDescription: "Configures host route population based on ARP/ND entries.",
													},
													"ingress": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"filters": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of Filter references to use at ingress.",
																MarkdownDescription: "List of Filter references to use at ingress.",
															},
															"qos_policy": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of QoS Ingress policy references to use at ingress.",
																MarkdownDescription: "List of QoS Ingress policy references to use at ingress.",
															},
														},
														CustomType: Ingress3Type{
															ObjectType: types.ObjectType{
																AttrTypes: Ingress3Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Manages actions on traffic at Ingress.",
														MarkdownDescription: "Manages actions on traffic at Ingress.",
													},
													"interface": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to an Interface to use for attachment.",
														MarkdownDescription: "Reference to an Interface to use for attachment.",
													},
													"ip_mtu": schema.Int64Attribute{
														Optional:            true,
														Description:         "IP MTU for the RoutedInterface.",
														MarkdownDescription: "IP MTU for the RoutedInterface.",
													},
													"ipv4_addresses": schema.ListNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"ip_prefix": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Address and mask to use",
																	MarkdownDescription: "Address and mask to use",
																},
																"primary": schema.BoolAttribute{
																	Optional:            true,
																	Description:         "Indicates which address to use as primary for broadcast",
																	MarkdownDescription: "Indicates which address to use as primary for broadcast",
																},
															},
															CustomType: Ipv4AddressesType{
																ObjectType: types.ObjectType{
																	AttrTypes: Ipv4AddressesValue{}.AttributeTypes(ctx),
																},
															},
														},
														Optional:            true,
														Description:         "List of IPv4 addresses in IP/mask form, e.g., 192.168.0.1/24.",
														MarkdownDescription: "List of IPv4 addresses in IP/mask form, e.g., 192.168.0.1/24.",
													},
													"ipv4_parameters": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"directed_broadcast": schema.BoolAttribute{
																Optional:            true,
																Description:         "Allow receiving and forwarding of directed broadcast packets. Enabled when set to true.",
																MarkdownDescription: "Allow receiving and forwarding of directed broadcast packets. Enabled when set to true.",
															},
														},
														CustomType: Ipv4Parameters1Type{
															ObjectType: types.ObjectType{
																AttrTypes: Ipv4Parameters1Value{}.AttributeTypes(ctx),
															},
														},
														Optional: true,
													},
													"ipv6_addresses": schema.ListNestedAttribute{
														NestedObject: schema.NestedAttributeObject{
															Attributes: map[string]schema.Attribute{
																"ip_prefix": schema.StringAttribute{
																	Optional:            true,
																	Description:         "Address and mask to use",
																	MarkdownDescription: "Address and mask to use",
																},
																"primary": schema.BoolAttribute{
																	Optional:            true,
																	Description:         "Indicates which address to use as primary for broadcast",
																	MarkdownDescription: "Indicates which address to use as primary for broadcast",
																},
															},
															CustomType: Ipv6AddressesType{
																ObjectType: types.ObjectType{
																	AttrTypes: Ipv6AddressesValue{}.AttributeTypes(ctx),
																},
															},
														},
														Optional:            true,
														Description:         "List of IPv6 addresses in IP/mask form, e.g., fc00::1/120.",
														MarkdownDescription: "List of IPv6 addresses in IP/mask form, e.g., fc00::1/120.",
													},
													"ipv6_router_advertisement": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"current_hop_limit": schema.Int64Attribute{
																Optional:            true,
																Description:         "The current hop limit to advertise in the router advertisement messages.",
																MarkdownDescription: "The current hop limit to advertise in the router advertisement messages.",
															},
															"enabled": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enable or disable IPv6 router advertisements.",
																MarkdownDescription: "Enable or disable IPv6 router advertisements.",
															},
															"ip_mtu": schema.Int64Attribute{
																Optional:            true,
																Description:         "The IP MTU to advertise in the router advertisement messages.",
																MarkdownDescription: "The IP MTU to advertise in the router advertisement messages.",
															},
															"managed_configuration_flag": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enable DHCPv6 for address configuration (M-bit).",
																MarkdownDescription: "Enable DHCPv6 for address configuration (M-bit).",
															},
															"max_advertisement_interval": schema.Int64Attribute{
																Optional:            true,
																Description:         "Maximum time between router advertisements (in seconds).",
																MarkdownDescription: "Maximum time between router advertisements (in seconds).",
															},
															"min_advertisement_interval": schema.Int64Attribute{
																Optional:            true,
																Description:         "Minimum time between router advertisements (in seconds).",
																MarkdownDescription: "Minimum time between router advertisements (in seconds).",
															},
															"other_configuration_flag": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enable DHCPv6 for other configuration (O-bit).",
																MarkdownDescription: "Enable DHCPv6 for other configuration (O-bit).",
															},
															"prefixes": schema.ListNestedAttribute{
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"autonomous_flag": schema.BoolAttribute{
																			Optional:            true,
																			Description:         "When this is set in the prefix information option hosts can use the prefix for stateless address autoconfiguration (SLAAC).",
																			MarkdownDescription: "When this is set in the prefix information option hosts can use the prefix for stateless address autoconfiguration (SLAAC).",
																		},
																		"on_link_flag": schema.BoolAttribute{
																			Optional:            true,
																			Description:         "When this is set in the prefix information option hosts can use the prefix for on-link determination.",
																			MarkdownDescription: "When this is set in the prefix information option hosts can use the prefix for on-link determination.",
																		},
																		"preferred_lifetime": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "The length of time in seconds (relative to the time the packet is sent) that addresses generated from the prefix via stateless address autoconfiguration remain preferred.",
																			MarkdownDescription: "The length of time in seconds (relative to the time the packet is sent) that addresses generated from the prefix via stateless address autoconfiguration remain preferred.",
																		},
																		"prefix": schema.StringAttribute{
																			Optional:            true,
																			Description:         "An IPv6 global unicast address prefix.",
																			MarkdownDescription: "An IPv6 global unicast address prefix.",
																		},
																		"valid_lifetime": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "The length of time in seconds (relative to the time the packet is sent) that the prefix is valid for the purpose of on-link determination.",
																			MarkdownDescription: "The length of time in seconds (relative to the time the packet is sent) that the prefix is valid for the purpose of on-link determination.",
																		},
																	},
																	CustomType: Prefixes1Type{
																		ObjectType: types.ObjectType{
																			AttrTypes: Prefixes1Value{}.AttributeTypes(ctx),
																		},
																	},
																},
																Optional:            true,
																Description:         "IPv6 prefixes to advertise in router advertisements.",
																MarkdownDescription: "IPv6 prefixes to advertise in router advertisements.",
															},
															"reachable_time": schema.Int64Attribute{
																Optional:            true,
																Description:         "Time in milliseconds for Neighbor Unreachability Detection.",
																MarkdownDescription: "Time in milliseconds for Neighbor Unreachability Detection.",
															},
															"retransmit_time": schema.Int64Attribute{
																Optional:            true,
																Description:         "Time in milliseconds between retransmitted NS messages.",
																MarkdownDescription: "Time in milliseconds between retransmitted NS messages.",
															},
															"router_lifetime": schema.Int64Attribute{
																Optional:            true,
																Description:         "Router lifetime in seconds for default gateway.",
																MarkdownDescription: "Router lifetime in seconds for default gateway.",
															},
														},
														CustomType: Ipv6RouterAdvertisement1Type{
															ObjectType: types.ObjectType{
																AttrTypes: Ipv6RouterAdvertisement1Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Manages IPV6 Router Advertisement parameters.",
														MarkdownDescription: "Manages IPV6 Router Advertisement parameters.",
													},
													"l3proxy_arpnd": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"proxy_arp": schema.BoolAttribute{
																Optional:            true,
																Description:         "Select whether Proxy ARP should be enabled.",
																MarkdownDescription: "Select whether Proxy ARP should be enabled.",
															},
															"proxy_nd": schema.BoolAttribute{
																Optional:            true,
																Description:         "Select whether Proxy ND should be enabled.",
																MarkdownDescription: "Select whether Proxy ND should be enabled.",
															},
														},
														CustomType: L3proxyArpnd1Type{
															ObjectType: types.ObjectType{
																AttrTypes: L3proxyArpnd1Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "L3 Proxy ARP and ND configuration.",
														MarkdownDescription: "L3 Proxy ARP and ND configuration.",
													},
													"learn_unsolicited": schema.StringAttribute{
														Optional:            true,
														Description:         "Enable or disable learning of unsolicited ARPs.",
														MarkdownDescription: "Enable or disable learning of unsolicited ARPs.",
													},
													"router": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to a Router.",
														MarkdownDescription: "Reference to a Router.",
													},
													"unnumbered": schema.StringAttribute{
														Optional:            true,
														Description:         "Enables the use of unnumbered interfaces on the IRBInterface.  If IPv6 is specified, no IP address are configured on the sub-interface and only the link local address will be used.  If any IP addresses are specified for either IPv4 or IPv6 that will take precedence and IPs will be assigned to the interfaces. (Deprecated, Use IPv6RouterAdvertisement)",
														MarkdownDescription: "Enables the use of unnumbered interfaces on the IRBInterface.  If IPv6 is specified, no IP address are configured on the sub-interface and only the link local address will be used.  If any IP addresses are specified for either IPv4 or IPv6 that will take precedence and IPs will be assigned to the interfaces. (Deprecated, Use IPv6RouterAdvertisement)",
													},
													"vlan_id": schema.StringAttribute{
														Optional:            true,
														Description:         "Single value between 1-4094 support, ranges supported in the format x-y,x-y, or the special keyword null, any, untagged or pool for auto allocation.",
														MarkdownDescription: "Single value between 1-4094 support, ranges supported in the format x-y,x-y, or the special keyword null, any, untagged or pool for auto allocation.",
													},
													"vlan_pool": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to a VLAN pool to use for allocations.",
														MarkdownDescription: "Reference to a VLAN pool to use for allocations.",
													},
												},
												CustomType: Spec12Type{
													ObjectType: types.ObjectType{
														AttrTypes: Spec12Value{}.AttributeTypes(ctx),
													},
												},
												Optional:            true,
												Description:         "Specification of the RoutedInterface",
												MarkdownDescription: "Specification of the RoutedInterface",
											},
										},
										CustomType: RoutedInterfacesType{
											ObjectType: types.ObjectType{
												AttrTypes: RoutedInterfacesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "List of RoutedInterface. [emits=RoutedInterface]",
									MarkdownDescription: "List of RoutedInterface. [emits=RoutedInterface]",
								},
								"routers": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Optional:            true,
												Description:         "The name of the Router.",
												MarkdownDescription: "The name of the Router.",
											},
											"spec": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"bgp": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"autonomous_system": schema.Int64Attribute{
																Optional:            true,
																Description:         "Autonomous System number for BGP.",
																MarkdownDescription: "Autonomous System number for BGP.",
															},
															"ebgp_preference": schema.Int64Attribute{
																Optional:            true,
																Description:         "Preference to be set for eBGP [default=170].",
																MarkdownDescription: "Preference to be set for eBGP [default=170].",
															},
															"enabled": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enable or disable BGP.",
																MarkdownDescription: "Enable or disable BGP.",
															},
															"export_policy": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "Reference to a Policy CR that will be used to filter routes advertised to peers.",
																MarkdownDescription: "Reference to a Policy CR that will be used to filter routes advertised to peers.",
															},
															"ibgp_preference": schema.Int64Attribute{
																Optional:            true,
																Description:         "Preference to be set for iBGP [default=170].",
																MarkdownDescription: "Preference to be set for iBGP [default=170].",
															},
															"import_policy": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "Reference to a Policy CR that will be used to filter routes received from peers.",
																MarkdownDescription: "Reference to a Policy CR that will be used to filter routes received from peers.",
															},
															"ip_alias_nexthops": schema.ListNestedAttribute{
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"esi": schema.StringAttribute{
																			Optional:            true,
																			Description:         "10 byte Ethernet Segment Identifier, if not set a type 0 ESI is generated.",
																			MarkdownDescription: "10 byte Ethernet Segment Identifier, if not set a type 0 ESI is generated.",
																		},
																		"next_hop": schema.StringAttribute{
																			Optional:            true,
																			Description:         "The nexthop IP address to track for the IP alias.",
																			MarkdownDescription: "The nexthop IP address to track for the IP alias.",
																		},
																		"preferred_active_node": schema.StringAttribute{
																			Optional:            true,
																			Description:         "When not set the ES is used in an all active mode. This references the TopoNode object and when set, the DF algorithm is configured to type preference and the selected Node is set with a higher preference value. All other Nodes have a lower value configured.",
																			MarkdownDescription: "When not set the ES is used in an all active mode. This references the TopoNode object and when set, the DF algorithm is configured to type preference and the selected Node is set with a higher preference value. All other Nodes have a lower value configured.",
																		},
																	},
																	CustomType: IpAliasNexthopsType{
																		ObjectType: types.ObjectType{
																			AttrTypes: IpAliasNexthopsValue{}.AttributeTypes(ctx),
																		},
																	},
																},
																Optional:            true,
																Description:         "IP aliasing configuration.",
																MarkdownDescription: "IP aliasing configuration.",
															},
															"ipv4_unicast": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"advertise_ipv6_next_hops": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enables advertisement of IPv4 Unicast routes with IPv6 next-hops to peers.",
																		MarkdownDescription: "Enables advertisement of IPv4 Unicast routes with IPv6 next-hops to peers.",
																	},
																	"enabled": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enables the IPv4 unicast AFISAFI.",
																		MarkdownDescription: "Enables the IPv4 unicast AFISAFI.",
																	},
																	"multipath": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"allow_multiple_as": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "When set to true, BGP is allowed to build a multipath set using BGP routes with different neighbor AS (most recent AS in the AS_PATH), When set to false, BGP is only allowed to use non-best paths for ECMP if they meet the multipath criteria and they have the same neighbor AS as the best path.",
																				MarkdownDescription: "When set to true, BGP is allowed to build a multipath set using BGP routes with different neighbor AS (most recent AS in the AS_PATH), When set to false, BGP is only allowed to use non-best paths for ECMP if they meet the multipath criteria and they have the same neighbor AS as the best path.",
																			},
																			"max_allowed_paths": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "The maximum number of BGP ECMP next-hops for BGP routes with an NLRI belonging to the address family of this configuration context.",
																				MarkdownDescription: "The maximum number of BGP ECMP next-hops for BGP routes with an NLRI belonging to the address family of this configuration context.",
																			},
																		},
																		CustomType: MultipathType{
																			ObjectType: types.ObjectType{
																				AttrTypes: MultipathValue{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "Enable multipath.",
																		MarkdownDescription: "Enable multipath.",
																	},
																	"receive_ipv6_next_hops": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enables the advertisement of the RFC 5549 capability to receive IPv4 routes with IPv6 next-hops.",
																		MarkdownDescription: "Enables the advertisement of the RFC 5549 capability to receive IPv4 routes with IPv6 next-hops.",
																	},
																},
																CustomType: Ipv4Unicast2Type{
																	ObjectType: types.ObjectType{
																		AttrTypes: Ipv4Unicast2Value{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Parameters relating to the IPv4 unicast AFI/SAFI.",
																MarkdownDescription: "Parameters relating to the IPv4 unicast AFI/SAFI.",
															},
															"ipv6_unicast": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"enabled": schema.BoolAttribute{
																		Optional:            true,
																		Description:         "Enables the IPv6 unicast AFISAFI",
																		MarkdownDescription: "Enables the IPv6 unicast AFISAFI",
																	},
																	"multipath": schema.SingleNestedAttribute{
																		Attributes: map[string]schema.Attribute{
																			"allow_multiple_as": schema.BoolAttribute{
																				Optional:            true,
																				Description:         "When set to true, BGP is allowed to build a multipath set using BGP routes with different neighbor AS (most recent AS in the AS_PATH), When set to false, BGP is only allowed to use non-best paths for ECMP if they meet the multipath criteria and they have the same neighbor AS as the best path.",
																				MarkdownDescription: "When set to true, BGP is allowed to build a multipath set using BGP routes with different neighbor AS (most recent AS in the AS_PATH), When set to false, BGP is only allowed to use non-best paths for ECMP if they meet the multipath criteria and they have the same neighbor AS as the best path.",
																			},
																			"max_allowed_paths": schema.Int64Attribute{
																				Optional:            true,
																				Description:         "The maximum number of BGP ECMP next-hops for BGP routes with an NLRI belonging to the address family of this configuration context.",
																				MarkdownDescription: "The maximum number of BGP ECMP next-hops for BGP routes with an NLRI belonging to the address family of this configuration context.",
																			},
																		},
																		CustomType: Multipath1Type{
																			ObjectType: types.ObjectType{
																				AttrTypes: Multipath1Value{}.AttributeTypes(ctx),
																			},
																		},
																		Optional:            true,
																		Description:         "Enable multipath",
																		MarkdownDescription: "Enable multipath",
																	},
																},
																CustomType: Ipv6Unicast2Type{
																	ObjectType: types.ObjectType{
																		AttrTypes: Ipv6Unicast2Value{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Parameters relating to the IPv6 unicast AFI/SAFI.",
																MarkdownDescription: "Parameters relating to the IPv6 unicast AFI/SAFI.",
															},
															"keychain": schema.StringAttribute{
																Optional:            true,
																Description:         "Keychain to be used for authentication",
																MarkdownDescription: "Keychain to be used for authentication",
															},
															"min_wait_to_advertise": schema.Int64Attribute{
																Optional:            true,
																Description:         "Minimum wait time before advertising routes post BGP restart.",
																MarkdownDescription: "Minimum wait time before advertising routes post BGP restart.",
															},
															"rapid_withdrawl": schema.BoolAttribute{
																Optional:            true,
																Description:         "Enable rapid withdrawal in BGP.",
																MarkdownDescription: "Enable rapid withdrawal in BGP.",
															},
															"wait_for_fib_install": schema.BoolAttribute{
																Optional:            true,
																Description:         "Wait for FIB installation before advertising routes.",
																MarkdownDescription: "Wait for FIB installation before advertising routes.",
															},
														},
														CustomType: Bgp4Type{
															ObjectType: types.ObjectType{
																AttrTypes: Bgp4Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "BGP configuration.",
														MarkdownDescription: "BGP configuration.",
													},
													"configured_name": schema.StringAttribute{
														Optional:            true,
														Description:         "The name of the Router to configure on the device.",
														MarkdownDescription: "The name of the Router to configure on the device.",
													},
													"description": schema.StringAttribute{
														Optional:            true,
														Description:         "The description of the Router.",
														MarkdownDescription: "The description of the Router.",
													},
													"ecmp": schema.Int64Attribute{
														Optional:            true,
														Description:         "Set the maximum number of ECMP paths for the Router. This is supported only by some platforms, and will be ignored for others.",
														MarkdownDescription: "Set the maximum number of ECMP paths for the Router. This is supported only by some platforms, and will be ignored for others.",
													},
													"evi": schema.Int64Attribute{
														Optional:            true,
														Description:         "EVI for the Router; leave blank for auto-allocation from EVI pool.",
														MarkdownDescription: "EVI for the Router; leave blank for auto-allocation from EVI pool.",
													},
													"evi_pool": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to EVI pool for auto-allocation.",
														MarkdownDescription: "Reference to EVI pool for auto-allocation.",
													},
													"export_target": schema.StringAttribute{
														Optional:            true,
														Description:         "Export route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
														MarkdownDescription: "Export route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
													},
													"import_target": schema.StringAttribute{
														Optional:            true,
														Description:         "Import route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
														MarkdownDescription: "Import route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
													},
													"ip_load_balancing": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"prefix": schema.ListNestedAttribute{
																NestedObject: schema.NestedAttributeObject{
																	Attributes: map[string]schema.Attribute{
																		"hash_buckets_per_path": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "The number of times each next-hop is repeated in the fill pattern if there are max-paths ECMP next-hops.",
																			MarkdownDescription: "The number of times each next-hop is repeated in the fill pattern if there are max-paths ECMP next-hops.",
																		},
																		"max_ecmp": schema.Int64Attribute{
																			Optional:            true,
																			Description:         "The maximum number of ECMP next-hops per route associated with the resilient-hash prefix.",
																			MarkdownDescription: "The maximum number of ECMP next-hops per route associated with the resilient-hash prefix.",
																		},
																		"prefix": schema.StringAttribute{
																			Optional:            true,
																			Description:         "IPv4 or IPv6 prefix. Active routes in the FIB that exactly match this prefix or that are longer matches of this prefix are provided with resilient-hash programming.",
																			MarkdownDescription: "IPv4 or IPv6 prefix. Active routes in the FIB that exactly match this prefix or that are longer matches of this prefix are provided with resilient-hash programming.",
																		},
																	},
																	CustomType: Prefix1Type{
																		ObjectType: types.ObjectType{
																			AttrTypes: Prefix1Value{}.AttributeTypes(ctx),
																		},
																	},
																},
																Optional:            true,
																Description:         "IPv4 or IPv6 prefix. Active routes in the FIB that exactly match this prefix or that are longer matches of this prefix are provided with resilient-hash programming.",
																MarkdownDescription: "IPv4 or IPv6 prefix. Active routes in the FIB that exactly match this prefix or that are longer matches of this prefix are provided with resilient-hash programming.",
															},
														},
														CustomType: IpLoadBalancingType{
															ObjectType: types.ObjectType{
																AttrTypes: IpLoadBalancingValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Resilient Hashing configuration.",
														MarkdownDescription: "Resilient Hashing configuration.",
													},
													"node_selector": schema.ListAttribute{
														ElementType:         types.StringType,
														Optional:            true,
														Description:         "Node selectors for deployment constraints.  If Nodes are selected, the Router will only be deployed on the Nodes selected, if left blank it will be deployed on all Nodes for which there are IRB or RoutedInterfaces referencing this Router.",
														MarkdownDescription: "Node selectors for deployment constraints.  If Nodes are selected, the Router will only be deployed on the Nodes selected, if left blank it will be deployed on all Nodes for which there are IRB or RoutedInterfaces referencing this Router.",
													},
													"route_leaking": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"export_policy": schema.StringAttribute{
																Optional:            true,
																Description:         "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
																MarkdownDescription: "Reference to a Policy resource to use when evaluating route exports from the DefaultRouter.",
															},
															"import_policy": schema.StringAttribute{
																Optional:            true,
																Description:         "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
																MarkdownDescription: "Reference to a Policy resource to use when evaluating route imports into the DefaultRouter.",
															},
														},
														CustomType: RouteLeakingType{
															ObjectType: types.ObjectType{
																AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Route leaking controlled by routing policies in and out of the DefaultRouter.",
														MarkdownDescription: "Route leaking controlled by routing policies in and out of the DefaultRouter.",
													},
													"router_id": schema.StringAttribute{
														Optional:            true,
														Description:         "Router ID.",
														MarkdownDescription: "Router ID.",
													},
													"tunnel_index_pool": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to tunnel index allocation pool.",
														MarkdownDescription: "Reference to tunnel index allocation pool.",
													},
													"type": schema.StringAttribute{
														Optional:            true,
														Description:         "Select the type of Router.  Simple doesn't include any overlay control plane or dataplane properties (EVPN/VXLAN). EVPNVXLAN includes the properties needed to provision this Router over an IP Fabric.",
														MarkdownDescription: "Select the type of Router.  Simple doesn't include any overlay control plane or dataplane properties (EVPN/VXLAN). EVPNVXLAN includes the properties needed to provision this Router over an IP Fabric.",
													},
													"vni": schema.Int64Attribute{
														Optional:            true,
														Description:         "VNI for the Router; leave blank for auto-allocation from VNI pool.",
														MarkdownDescription: "VNI for the Router; leave blank for auto-allocation from VNI pool.",
													},
													"vni_pool": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to VNI pool for auto-allocation.",
														MarkdownDescription: "Reference to VNI pool for auto-allocation.",
													},
												},
												CustomType: Spec13Type{
													ObjectType: types.ObjectType{
														AttrTypes: Spec13Value{}.AttributeTypes(ctx),
													},
												},
												Optional:            true,
												Description:         "Specification of the Router",
												MarkdownDescription: "Specification of the Router",
											},
										},
										CustomType: RoutersType{
											ObjectType: types.ObjectType{
												AttrTypes: RoutersValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "List of Routers.[emits=Router]",
									MarkdownDescription: "List of Routers.[emits=Router]",
								},
								"vlans": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"name": schema.StringAttribute{
												Optional:            true,
												Description:         "The name of the VLAN.",
												MarkdownDescription: "The name of the VLAN.",
											},
											"spec": schema.SingleNestedAttribute{
												Attributes: map[string]schema.Attribute{
													"bridge_domain": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to a BridgeDomain or SimpleBridgeDomain.",
														MarkdownDescription: "Reference to a BridgeDomain or SimpleBridgeDomain.",
													},
													"description": schema.StringAttribute{
														Optional:            true,
														Description:         "The description of the VLAN.",
														MarkdownDescription: "The description of the VLAN.",
													},
													"egress": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"filters": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of Filter references to use at egress.",
																MarkdownDescription: "List of Filter references to use at egress.",
															},
															"qos_policy": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of QoS Egress policy references to use at egress.",
																MarkdownDescription: "List of QoS Egress policy references to use at egress.",
															},
														},
														CustomType: Egress4Type{
															ObjectType: types.ObjectType{
																AttrTypes: Egress4Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Manages actions on traffic at Egress.",
														MarkdownDescription: "Manages actions on traffic at Egress.",
													},
													"ingress": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"filters": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of Filter references to use at ingress.",
																MarkdownDescription: "List of Filter references to use at ingress.",
															},
															"qos_policy": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "List of QoS Ingress policy references to use at ingress.",
																MarkdownDescription: "List of QoS Ingress policy references to use at ingress.",
															},
														},
														CustomType: Ingress4Type{
															ObjectType: types.ObjectType{
																AttrTypes: Ingress4Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "Manages actions on traffic at Ingress.",
														MarkdownDescription: "Manages actions on traffic at Ingress.",
													},
													"interface_selector": schema.ListAttribute{
														ElementType:         types.StringType,
														Optional:            true,
														Description:         "Interfaces to use for attachment to this VLAN based on the label selector.  Selects Interfaces based on their associated labels.",
														MarkdownDescription: "Interfaces to use for attachment to this VLAN based on the label selector.  Selects Interfaces based on their associated labels.",
													},
													"l2_mtu": schema.Int64Attribute{
														Optional:            true,
														Description:         "L2 MTU specifies the maximum sized Ethernet frame that can be transmitted on the subinterface. If a frame exceeds this size it is discarded. If the l2-mtu of the subinterface exceeds the port-mtu of the associated interface, the subinterface will remain operationally down.",
														MarkdownDescription: "L2 MTU specifies the maximum sized Ethernet frame that can be transmitted on the subinterface. If a frame exceeds this size it is discarded. If the l2-mtu of the subinterface exceeds the port-mtu of the associated interface, the subinterface will remain operationally down.",
													},
													"mac_duplication_detection_action": schema.StringAttribute{
														Optional:            true,
														Description:         "If Mac Duplication Detection is enabled on the associated Bridge Domain, this property will override the MDD action set in the BridgeDomain.",
														MarkdownDescription: "If Mac Duplication Detection is enabled on the associated Bridge Domain, this property will override the MDD action set in the BridgeDomain.",
													},
													"split_horizon_group": schema.StringAttribute{
														Optional:            true,
														Description:         "Name of the Split Horizon Group to be used for this VLAN.  All subinterfaces within this VLAN will be members of this Split Horizon Group.",
														MarkdownDescription: "Name of the Split Horizon Group to be used for this VLAN.  All subinterfaces within this VLAN will be members of this Split Horizon Group.",
													},
													"uplink": schema.SingleNestedAttribute{
														Attributes: map[string]schema.Attribute{
															"egress": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"filters": schema.ListAttribute{
																		ElementType:         types.StringType,
																		Optional:            true,
																		Description:         "List of Filter references to use at egress.",
																		MarkdownDescription: "List of Filter references to use at egress.",
																	},
																	"qos_policy": schema.ListAttribute{
																		ElementType:         types.StringType,
																		Optional:            true,
																		Description:         "List of QoS Egress policy references to use at egress.",
																		MarkdownDescription: "List of QoS Egress policy references to use at egress.",
																	},
																},
																CustomType: Egress5Type{
																	ObjectType: types.ObjectType{
																		AttrTypes: Egress5Value{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Manages actions on traffic at Egress of the Local endpoint of the Uplink.",
																MarkdownDescription: "Manages actions on traffic at Egress of the Local endpoint of the Uplink.",
															},
															"ingress": schema.SingleNestedAttribute{
																Attributes: map[string]schema.Attribute{
																	"filters": schema.ListAttribute{
																		ElementType:         types.StringType,
																		Optional:            true,
																		Description:         "List of Filter references to use at ingress.",
																		MarkdownDescription: "List of Filter references to use at ingress.",
																	},
																	"qos_policy": schema.ListAttribute{
																		ElementType:         types.StringType,
																		Optional:            true,
																		Description:         "List of QoS Ingress policy references to use at ingress.",
																		MarkdownDescription: "List of QoS Ingress policy references to use at ingress.",
																	},
																},
																CustomType: Ingress5Type{
																	ObjectType: types.ObjectType{
																		AttrTypes: Ingress5Value{}.AttributeTypes(ctx),
																	},
																},
																Optional:            true,
																Description:         "Manages actions on traffic at Ingress of the Local endpoint of the Uplink.",
																MarkdownDescription: "Manages actions on traffic at Ingress of the Local endpoint of the Uplink.",
															},
															"uplink_selector": schema.ListAttribute{
																ElementType:         types.StringType,
																Optional:            true,
																Description:         "Selects TopoLinks which connect a leaf switch to a breakout switch. This is the uplink between your access breakout switch and your leaf switch.  There can only be a single TopoLink between the access breakout switch and the leaf switch, if more than one TopoLink is present between two devices the transaction will fail.",
																MarkdownDescription: "Selects TopoLinks which connect a leaf switch to a breakout switch. This is the uplink between your access breakout switch and your leaf switch.  There can only be a single TopoLink between the access breakout switch and the leaf switch, if more than one TopoLink is present between two devices the transaction will fail.",
															},
															"uplink_vlan_id": schema.StringAttribute{
																Optional:            true,
																Description:         "The VLAN ID to be utilized to isolate traffic from the VLAN on the access breakout switch to the leaf switch on the selected uplink TopoLink.",
																MarkdownDescription: "The VLAN ID to be utilized to isolate traffic from the VLAN on the access breakout switch to the leaf switch on the selected uplink TopoLink.",
															},
															"uplink_vlan_pool": schema.StringAttribute{
																Optional:            true,
																Description:         "A VLAN from this pool will be utilized to isolate traffic from the VLAN on the access breakout switch to the leaf switch on the selected uplink TopoLink.",
																MarkdownDescription: "A VLAN from this pool will be utilized to isolate traffic from the VLAN on the access breakout switch to the leaf switch on the selected uplink TopoLink.",
															},
														},
														CustomType: Uplink1Type{
															ObjectType: types.ObjectType{
																AttrTypes: Uplink1Value{}.AttributeTypes(ctx),
															},
														},
														Optional:            true,
														Description:         "The Uplink between your access breakout switch and your leaf switch.",
														MarkdownDescription: "The Uplink between your access breakout switch and your leaf switch.",
													},
													"vlan_id": schema.StringAttribute{
														Optional:            true,
														Description:         "Single value between 1-4094 support, ranges supported in the format x-y,x-y, or the special keyword null, any, untagged or pool for auto allocation.",
														MarkdownDescription: "Single value between 1-4094 support, ranges supported in the format x-y,x-y, or the special keyword null, any, untagged or pool for auto allocation.",
													},
													"vlan_pool": schema.StringAttribute{
														Optional:            true,
														Description:         "Reference to a VLAN pool to use for allocations. [default=\"vlan-pool\"]",
														MarkdownDescription: "Reference to a VLAN pool to use for allocations. [default=\"vlan-pool\"]",
													},
												},
												CustomType: Spec14Type{
													ObjectType: types.ObjectType{
														AttrTypes: Spec14Value{}.AttributeTypes(ctx),
													},
												},
												Optional:            true,
												Description:         "Specification of the Vlan",
												MarkdownDescription: "Specification of the Vlan",
											},
										},
										CustomType: VlansType{
											ObjectType: types.ObjectType{
												AttrTypes: VlansValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "List of VLANs. [emits=VLAN]",
									MarkdownDescription: "List of VLANs. [emits=VLAN]",
								},
							},
							CustomType: SpecType{
								ObjectType: types.ObjectType{
									AttrTypes: SpecValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "VirtualNetworkSpec defines the desired state of VirtualNetwork",
							MarkdownDescription: "VirtualNetworkSpec defines the desired state of VirtualNetwork",
						},
						"status": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"health": schema.Int64Attribute{
									Computed:            true,
									Description:         "Indicates the health score of the VNET.",
									MarkdownDescription: "Indicates the health score of the VNET.",
								},
								"health_score_reason": schema.StringAttribute{
									Computed:            true,
									Description:         "Indicates the reason for the health score.",
									MarkdownDescription: "Indicates the reason for the health score.",
								},
								"last_change": schema.StringAttribute{
									Computed:            true,
									Description:         "The time when the state of the resource last changed.",
									MarkdownDescription: "The time when the state of the resource last changed.",
								},
								"nodes": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "List of Nodes on which the VNET is configured.",
									MarkdownDescription: "List of Nodes on which the VNET is configured.",
								},
								"num_bgp_peers": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of configured BGP Peers.",
									MarkdownDescription: "Total number of configured BGP Peers.",
								},
								"num_bgp_peers_oper_down": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total Number of BGP Peer operationally down.",
									MarkdownDescription: "Total Number of BGP Peer operationally down.",
								},
								"num_irb_interfaces": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of irb-interfaces configured by the VNET.",
									MarkdownDescription: "Total number of irb-interfaces configured by the VNET.",
								},
								"num_irb_interfaces_oper_down": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of irb-interfaces configured by the VNET which are oper-down.",
									MarkdownDescription: "Total number of irb-interfaces configured by the VNET which are oper-down.",
								},
								"num_nodes": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of Nodes on which the VNET is configured.",
									MarkdownDescription: "Total number of Nodes on which the VNET is configured.",
								},
								"num_ospf_interfaces": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of configured OSPF Interfaces.",
									MarkdownDescription: "Total number of configured OSPF Interfaces.",
								},
								"num_ospf_interfaces_oper_down": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total Number of OSPF Interface operationally down.",
									MarkdownDescription: "Total Number of OSPF Interface operationally down.",
								},
								"num_routed_interfaces": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of routed-interfaces configured by the VNET.",
									MarkdownDescription: "Total number of routed-interfaces configured by the VNET.",
								},
								"num_routed_interfaces_oper_down": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of routed-interfaces configured by the VNET which are oper-down.",
									MarkdownDescription: "Total number of routed-interfaces configured by the VNET which are oper-down.",
								},
								"num_sub_interfaces": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of sub-interfaces configured by the VNET.",
									MarkdownDescription: "Total number of sub-interfaces configured by the VNET.",
								},
								"num_sub_interfaces_oper_down": schema.Int64Attribute{
									Computed:            true,
									Description:         "Total number of sub-interfaces configured by the VNET which are oper-down.",
									MarkdownDescription: "Total number of sub-interfaces configured by the VNET which are oper-down.",
								},
								"operational_state": schema.StringAttribute{
									Computed:            true,
									Description:         "Operational state of the VNET.",
									MarkdownDescription: "Operational state of the VNET.",
								},
							},
							CustomType: StatusType{
								ObjectType: types.ObjectType{
									AttrTypes: StatusValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
					},
					CustomType: ItemsType{
						ObjectType: types.ObjectType{
							AttrTypes: ItemsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"label_selector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a label selector string to filter the results based on CR labels",
				MarkdownDescription: "a label selector string to filter the results based on CR labels",
			},
			"labelselector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Deprecated: a label selector string to filter the results based on CR labels",
				MarkdownDescription: "Deprecated: a label selector string to filter the results based on CR labels",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
		},
	}
}

type VirtualNetworkListModel struct {
	ApiVersion    types.String `tfsdk:"api_version"`
	Fields        types.String `tfsdk:"fields"`
	Filter        types.String `tfsdk:"filter"`
	Items         types.List   `tfsdk:"items"`
	Kind          types.String `tfsdk:"kind"`
	LabelSelector types.String `tfsdk:"label_selector"`
	Labelselector types.String `tfsdk:"labelselector"`
	Namespace     types.String `tfsdk:"namespace"`
}

var _ basetypes.ObjectTypable = ItemsType{}

type ItemsType struct {
	basetypes.ObjectType
}

func (t ItemsType) Equal(o attr.Type) bool {
	other, ok := o.(ItemsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ItemsType) String() string {
	return "ItemsType"
}

func (t ItemsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	alarmsAttribute, ok := attributes["alarms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alarms is missing from object`)

		return nil, diags
	}

	alarmsVal, ok := alarmsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alarms expected to be basetypes.ObjectValue, was: %T`, alarmsAttribute))
	}

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return nil, diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	deviationsAttribute, ok := attributes["deviations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviations is missing from object`)

		return nil, diags
	}

	deviationsVal, ok := deviationsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviations expected to be basetypes.ObjectValue, was: %T`, deviationsAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return nil, diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ItemsValue{
		Alarms:     alarmsVal,
		ApiVersion: apiVersionVal,
		Deviations: deviationsVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueNull() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateNull,
	}
}

func NewItemsValueUnknown() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewItemsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ItemsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ItemsValue Attribute Value",
				"While creating a ItemsValue value, a missing attribute value was detected. "+
					"A ItemsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ItemsValue Attribute Type",
				"While creating a ItemsValue value, an invalid attribute value was detected. "+
					"A ItemsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ItemsValue Attribute Value",
				"While creating a ItemsValue value, an extra attribute value was detected. "+
					"A ItemsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ItemsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	alarmsAttribute, ok := attributes["alarms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`alarms is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	alarmsVal, ok := alarmsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`alarms expected to be basetypes.ObjectValue, was: %T`, alarmsAttribute))
	}

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	deviationsAttribute, ok := attributes["deviations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`deviations is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	deviationsVal, ok := deviationsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`deviations expected to be basetypes.ObjectValue, was: %T`, deviationsAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	return ItemsValue{
		Alarms:     alarmsVal,
		ApiVersion: apiVersionVal,
		Deviations: deviationsVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ItemsValue {
	object, diags := NewItemsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewItemsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ItemsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewItemsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewItemsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewItemsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewItemsValueMust(ItemsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ItemsType) ValueType(ctx context.Context) attr.Value {
	return ItemsValue{}
}

var _ basetypes.ObjectValuable = ItemsValue{}

type ItemsValue struct {
	Alarms     basetypes.ObjectValue `tfsdk:"alarms"`
	ApiVersion basetypes.StringValue `tfsdk:"api_version"`
	Deviations basetypes.ObjectValue `tfsdk:"deviations"`
	Kind       basetypes.StringValue `tfsdk:"kind"`
	Metadata   basetypes.ObjectValue `tfsdk:"metadata"`
	Spec       basetypes.ObjectValue `tfsdk:"spec"`
	Status     basetypes.ObjectValue `tfsdk:"status"`
	state      attr.ValueState
}

func (v ItemsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["alarms"] = basetypes.ObjectType{
		AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["api_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["deviations"] = basetypes.ObjectType{
		AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ObjectType{
		AttrTypes: MetadataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: SpecValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.ObjectType{
		AttrTypes: StatusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.Alarms.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["alarms"] = val

		val, err = v.ApiVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_version"] = val

		val, err = v.Deviations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["deviations"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Spec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ItemsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ItemsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ItemsValue) String() string {
	return "ItemsValue"
}

func (v ItemsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var alarms basetypes.ObjectValue

	if v.Alarms.IsNull() {
		alarms = types.ObjectNull(
			AlarmsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Alarms.IsUnknown() {
		alarms = types.ObjectUnknown(
			AlarmsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Alarms.IsNull() && !v.Alarms.IsUnknown() {
		alarms = types.ObjectValueMust(
			AlarmsValue{}.AttributeTypes(ctx),
			v.Alarms.Attributes(),
		)
	}

	var deviations basetypes.ObjectValue

	if v.Deviations.IsNull() {
		deviations = types.ObjectNull(
			DeviationsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Deviations.IsUnknown() {
		deviations = types.ObjectUnknown(
			DeviationsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Deviations.IsNull() && !v.Deviations.IsUnknown() {
		deviations = types.ObjectValueMust(
			DeviationsValue{}.AttributeTypes(ctx),
			v.Deviations.Attributes(),
		)
	}

	var metadata basetypes.ObjectValue

	if v.Metadata.IsNull() {
		metadata = types.ObjectNull(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ObjectUnknown(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Metadata.IsNull() && !v.Metadata.IsUnknown() {
		metadata = types.ObjectValueMust(
			MetadataValue{}.AttributeTypes(ctx),
			v.Metadata.Attributes(),
		)
	}

	var spec basetypes.ObjectValue

	if v.Spec.IsNull() {
		spec = types.ObjectNull(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if v.Spec.IsUnknown() {
		spec = types.ObjectUnknown(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec.IsNull() && !v.Spec.IsUnknown() {
		spec = types.ObjectValueMust(
			SpecValue{}.AttributeTypes(ctx),
			v.Spec.Attributes(),
		)
	}

	var status basetypes.ObjectValue

	if v.Status.IsNull() {
		status = types.ObjectNull(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if v.Status.IsUnknown() {
		status = types.ObjectUnknown(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Status.IsNull() && !v.Status.IsUnknown() {
		status = types.ObjectValueMust(
			StatusValue{}.AttributeTypes(ctx),
			v.Status.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"alarms": basetypes.ObjectType{
			AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
		},
		"api_version": basetypes.StringType{},
		"deviations": basetypes.ObjectType{
			AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
		},
		"kind": basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"alarms":      alarms,
			"api_version": v.ApiVersion,
			"deviations":  deviations,
			"kind":        v.Kind,
			"metadata":    metadata,
			"spec":        spec,
			"status":      status,
		})

	return objVal, diags
}

func (v ItemsValue) Equal(o attr.Value) bool {
	other, ok := o.(ItemsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Alarms.Equal(other.Alarms) {
		return false
	}

	if !v.ApiVersion.Equal(other.ApiVersion) {
		return false
	}

	if !v.Deviations.Equal(other.Deviations) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Spec.Equal(other.Spec) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ItemsValue) Type(ctx context.Context) attr.Type {
	return ItemsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ItemsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"alarms": basetypes.ObjectType{
			AttrTypes: AlarmsValue{}.AttributeTypes(ctx),
		},
		"api_version": basetypes.StringType{},
		"deviations": basetypes.ObjectType{
			AttrTypes: DeviationsValue{}.AttributeTypes(ctx),
		},
		"kind": basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AlarmsType{}

type AlarmsType struct {
	basetypes.ObjectType
}

func (t AlarmsType) Equal(o attr.Type) bool {
	other, ok := o.(AlarmsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AlarmsType) String() string {
	return "AlarmsType"
}

func (t AlarmsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return nil, diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return nil, diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return nil, diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return nil, diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueNull() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateNull,
	}
}

func NewAlarmsValueUnknown() AlarmsValue {
	return AlarmsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAlarmsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AlarmsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, a missing attribute value was detected. "+
					"A AlarmsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AlarmsValue Attribute Type",
				"While creating a AlarmsValue value, an invalid attribute value was detected. "+
					"A AlarmsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AlarmsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AlarmsValue Attribute Value",
				"While creating a AlarmsValue value, an extra attribute value was detected. "+
					"A AlarmsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AlarmsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	criticalAttribute, ok := attributes["critical"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`critical is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	criticalVal, ok := criticalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`critical expected to be basetypes.Int64Value, was: %T`, criticalAttribute))
	}

	majorAttribute, ok := attributes["major"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`major is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	majorVal, ok := majorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`major expected to be basetypes.Int64Value, was: %T`, majorAttribute))
	}

	minorAttribute, ok := attributes["minor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minor is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	minorVal, ok := minorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minor expected to be basetypes.Int64Value, was: %T`, minorAttribute))
	}

	warningAttribute, ok := attributes["warning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning is missing from object`)

		return NewAlarmsValueUnknown(), diags
	}

	warningVal, ok := warningAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning expected to be basetypes.Int64Value, was: %T`, warningAttribute))
	}

	if diags.HasError() {
		return NewAlarmsValueUnknown(), diags
	}

	return AlarmsValue{
		Critical: criticalVal,
		Major:    majorVal,
		Minor:    minorVal,
		Warning:  warningVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewAlarmsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AlarmsValue {
	object, diags := NewAlarmsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAlarmsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AlarmsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAlarmsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAlarmsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAlarmsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAlarmsValueMust(AlarmsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AlarmsType) ValueType(ctx context.Context) attr.Value {
	return AlarmsValue{}
}

var _ basetypes.ObjectValuable = AlarmsValue{}

type AlarmsValue struct {
	Critical basetypes.Int64Value `tfsdk:"critical"`
	Major    basetypes.Int64Value `tfsdk:"major"`
	Minor    basetypes.Int64Value `tfsdk:"minor"`
	Warning  basetypes.Int64Value `tfsdk:"warning"`
	state    attr.ValueState
}

func (v AlarmsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["critical"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["major"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minor"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Critical.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["critical"] = val

		val, err = v.Major.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["major"] = val

		val, err = v.Minor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minor"] = val

		val, err = v.Warning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AlarmsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AlarmsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AlarmsValue) String() string {
	return "AlarmsValue"
}

func (v AlarmsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"critical": v.Critical,
			"major":    v.Major,
			"minor":    v.Minor,
			"warning":  v.Warning,
		})

	return objVal, diags
}

func (v AlarmsValue) Equal(o attr.Value) bool {
	other, ok := o.(AlarmsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Critical.Equal(other.Critical) {
		return false
	}

	if !v.Major.Equal(other.Major) {
		return false
	}

	if !v.Minor.Equal(other.Minor) {
		return false
	}

	if !v.Warning.Equal(other.Warning) {
		return false
	}

	return true
}

func (v AlarmsValue) Type(ctx context.Context) attr.Type {
	return AlarmsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AlarmsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"critical": basetypes.Int64Type{},
		"major":    basetypes.Int64Type{},
		"minor":    basetypes.Int64Type{},
		"warning":  basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DeviationsType{}

type DeviationsType struct {
	basetypes.ObjectType
}

func (t DeviationsType) Equal(o attr.Type) bool {
	other, ok := o.(DeviationsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DeviationsType) String() string {
	return "DeviationsType"
}

func (t DeviationsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return nil, diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueNull() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateNull,
	}
}

func NewDeviationsValueUnknown() DeviationsValue {
	return DeviationsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDeviationsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DeviationsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, a missing attribute value was detected. "+
					"A DeviationsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DeviationsValue Attribute Type",
				"While creating a DeviationsValue value, an invalid attribute value was detected. "+
					"A DeviationsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DeviationsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DeviationsValue Attribute Value",
				"While creating a DeviationsValue value, an extra attribute value was detected. "+
					"A DeviationsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DeviationsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	countAttribute, ok := attributes["count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`count is missing from object`)

		return NewDeviationsValueUnknown(), diags
	}

	countVal, ok := countAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`count expected to be basetypes.Int64Value, was: %T`, countAttribute))
	}

	if diags.HasError() {
		return NewDeviationsValueUnknown(), diags
	}

	return DeviationsValue{
		Count: countVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewDeviationsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DeviationsValue {
	object, diags := NewDeviationsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDeviationsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DeviationsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDeviationsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDeviationsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDeviationsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDeviationsValueMust(DeviationsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DeviationsType) ValueType(ctx context.Context) attr.Value {
	return DeviationsValue{}
}

var _ basetypes.ObjectValuable = DeviationsValue{}

type DeviationsValue struct {
	Count basetypes.Int64Value `tfsdk:"count"`
	state attr.ValueState
}

func (v DeviationsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["count"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Count.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["count"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DeviationsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DeviationsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DeviationsValue) String() string {
	return "DeviationsValue"
}

func (v DeviationsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"count": v.Count,
		})

	return objVal, diags
}

func (v DeviationsValue) Equal(o attr.Value) bool {
	other, ok := o.(DeviationsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Count.Equal(other.Count) {
		return false
	}

	return true
}

func (v DeviationsValue) Type(ctx context.Context) attr.Type {
	return DeviationsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DeviationsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"count": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bridgeDomainsAttribute, ok := attributes["bridge_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_domains is missing from object`)

		return nil, diags
	}

	bridgeDomainsVal, ok := bridgeDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_domains expected to be basetypes.ListValue, was: %T`, bridgeDomainsAttribute))
	}

	bridgeInterfacesAttribute, ok := attributes["bridge_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_interfaces is missing from object`)

		return nil, diags
	}

	bridgeInterfacesVal, ok := bridgeInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_interfaces expected to be basetypes.ListValue, was: %T`, bridgeInterfacesAttribute))
	}

	irbInterfacesAttribute, ok := attributes["irb_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`irb_interfaces is missing from object`)

		return nil, diags
	}

	irbInterfacesVal, ok := irbInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`irb_interfaces expected to be basetypes.ListValue, was: %T`, irbInterfacesAttribute))
	}

	protocolsAttribute, ok := attributes["protocols"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocols is missing from object`)

		return nil, diags
	}

	protocolsVal, ok := protocolsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocols expected to be basetypes.ObjectValue, was: %T`, protocolsAttribute))
	}

	routedInterfacesAttribute, ok := attributes["routed_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_interfaces is missing from object`)

		return nil, diags
	}

	routedInterfacesVal, ok := routedInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_interfaces expected to be basetypes.ListValue, was: %T`, routedInterfacesAttribute))
	}

	routersAttribute, ok := attributes["routers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routers is missing from object`)

		return nil, diags
	}

	routersVal, ok := routersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routers expected to be basetypes.ListValue, was: %T`, routersAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return nil, diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.ListValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		BridgeDomains:    bridgeDomainsVal,
		BridgeInterfaces: bridgeInterfacesVal,
		IrbInterfaces:    irbInterfacesVal,
		Protocols:        protocolsVal,
		RoutedInterfaces: routedInterfacesVal,
		Routers:          routersVal,
		Vlans:            vlansVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	bridgeDomainsAttribute, ok := attributes["bridge_domains"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_domains is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	bridgeDomainsVal, ok := bridgeDomainsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_domains expected to be basetypes.ListValue, was: %T`, bridgeDomainsAttribute))
	}

	bridgeInterfacesAttribute, ok := attributes["bridge_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_interfaces is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	bridgeInterfacesVal, ok := bridgeInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_interfaces expected to be basetypes.ListValue, was: %T`, bridgeInterfacesAttribute))
	}

	irbInterfacesAttribute, ok := attributes["irb_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`irb_interfaces is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	irbInterfacesVal, ok := irbInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`irb_interfaces expected to be basetypes.ListValue, was: %T`, irbInterfacesAttribute))
	}

	protocolsAttribute, ok := attributes["protocols"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocols is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	protocolsVal, ok := protocolsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocols expected to be basetypes.ObjectValue, was: %T`, protocolsAttribute))
	}

	routedInterfacesAttribute, ok := attributes["routed_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routed_interfaces is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	routedInterfacesVal, ok := routedInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routed_interfaces expected to be basetypes.ListValue, was: %T`, routedInterfacesAttribute))
	}

	routersAttribute, ok := attributes["routers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routers is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	routersVal, ok := routersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routers expected to be basetypes.ListValue, was: %T`, routersAttribute))
	}

	vlansAttribute, ok := attributes["vlans"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlans is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	vlansVal, ok := vlansAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlans expected to be basetypes.ListValue, was: %T`, vlansAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		BridgeDomains:    bridgeDomainsVal,
		BridgeInterfaces: bridgeInterfacesVal,
		IrbInterfaces:    irbInterfacesVal,
		Protocols:        protocolsVal,
		RoutedInterfaces: routedInterfacesVal,
		Routers:          routersVal,
		Vlans:            vlansVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	BridgeDomains    basetypes.ListValue   `tfsdk:"bridge_domains"`
	BridgeInterfaces basetypes.ListValue   `tfsdk:"bridge_interfaces"`
	IrbInterfaces    basetypes.ListValue   `tfsdk:"irb_interfaces"`
	Protocols        basetypes.ObjectValue `tfsdk:"protocols"`
	RoutedInterfaces basetypes.ListValue   `tfsdk:"routed_interfaces"`
	Routers          basetypes.ListValue   `tfsdk:"routers"`
	Vlans            basetypes.ListValue   `tfsdk:"vlans"`
	state            attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["bridge_domains"] = basetypes.ListType{
		ElemType: BridgeDomainsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["bridge_interfaces"] = basetypes.ListType{
		ElemType: BridgeInterfacesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["irb_interfaces"] = basetypes.ListType{
		ElemType: IrbInterfacesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["protocols"] = basetypes.ObjectType{
		AttrTypes: ProtocolsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["routed_interfaces"] = basetypes.ListType{
		ElemType: RoutedInterfacesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["routers"] = basetypes.ListType{
		ElemType: RoutersValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["vlans"] = basetypes.ListType{
		ElemType: VlansValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.BridgeDomains.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bridge_domains"] = val

		val, err = v.BridgeInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bridge_interfaces"] = val

		val, err = v.IrbInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["irb_interfaces"] = val

		val, err = v.Protocols.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocols"] = val

		val, err = v.RoutedInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routed_interfaces"] = val

		val, err = v.Routers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routers"] = val

		val, err = v.Vlans.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlans"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	bridgeDomains := types.ListValueMust(
		BridgeDomainsType{
			basetypes.ObjectType{
				AttrTypes: BridgeDomainsValue{}.AttributeTypes(ctx),
			},
		},
		v.BridgeDomains.Elements(),
	)

	if v.BridgeDomains.IsNull() {
		bridgeDomains = types.ListNull(
			BridgeDomainsType{
				basetypes.ObjectType{
					AttrTypes: BridgeDomainsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.BridgeDomains.IsUnknown() {
		bridgeDomains = types.ListUnknown(
			BridgeDomainsType{
				basetypes.ObjectType{
					AttrTypes: BridgeDomainsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	bridgeInterfaces := types.ListValueMust(
		BridgeInterfacesType{
			basetypes.ObjectType{
				AttrTypes: BridgeInterfacesValue{}.AttributeTypes(ctx),
			},
		},
		v.BridgeInterfaces.Elements(),
	)

	if v.BridgeInterfaces.IsNull() {
		bridgeInterfaces = types.ListNull(
			BridgeInterfacesType{
				basetypes.ObjectType{
					AttrTypes: BridgeInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.BridgeInterfaces.IsUnknown() {
		bridgeInterfaces = types.ListUnknown(
			BridgeInterfacesType{
				basetypes.ObjectType{
					AttrTypes: BridgeInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	irbInterfaces := types.ListValueMust(
		IrbInterfacesType{
			basetypes.ObjectType{
				AttrTypes: IrbInterfacesValue{}.AttributeTypes(ctx),
			},
		},
		v.IrbInterfaces.Elements(),
	)

	if v.IrbInterfaces.IsNull() {
		irbInterfaces = types.ListNull(
			IrbInterfacesType{
				basetypes.ObjectType{
					AttrTypes: IrbInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IrbInterfaces.IsUnknown() {
		irbInterfaces = types.ListUnknown(
			IrbInterfacesType{
				basetypes.ObjectType{
					AttrTypes: IrbInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var protocols basetypes.ObjectValue

	if v.Protocols.IsNull() {
		protocols = types.ObjectNull(
			ProtocolsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Protocols.IsUnknown() {
		protocols = types.ObjectUnknown(
			ProtocolsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Protocols.IsNull() && !v.Protocols.IsUnknown() {
		protocols = types.ObjectValueMust(
			ProtocolsValue{}.AttributeTypes(ctx),
			v.Protocols.Attributes(),
		)
	}

	routedInterfaces := types.ListValueMust(
		RoutedInterfacesType{
			basetypes.ObjectType{
				AttrTypes: RoutedInterfacesValue{}.AttributeTypes(ctx),
			},
		},
		v.RoutedInterfaces.Elements(),
	)

	if v.RoutedInterfaces.IsNull() {
		routedInterfaces = types.ListNull(
			RoutedInterfacesType{
				basetypes.ObjectType{
					AttrTypes: RoutedInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.RoutedInterfaces.IsUnknown() {
		routedInterfaces = types.ListUnknown(
			RoutedInterfacesType{
				basetypes.ObjectType{
					AttrTypes: RoutedInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	routers := types.ListValueMust(
		RoutersType{
			basetypes.ObjectType{
				AttrTypes: RoutersValue{}.AttributeTypes(ctx),
			},
		},
		v.Routers.Elements(),
	)

	if v.Routers.IsNull() {
		routers = types.ListNull(
			RoutersType{
				basetypes.ObjectType{
					AttrTypes: RoutersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Routers.IsUnknown() {
		routers = types.ListUnknown(
			RoutersType{
				basetypes.ObjectType{
					AttrTypes: RoutersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	vlans := types.ListValueMust(
		VlansType{
			basetypes.ObjectType{
				AttrTypes: VlansValue{}.AttributeTypes(ctx),
			},
		},
		v.Vlans.Elements(),
	)

	if v.Vlans.IsNull() {
		vlans = types.ListNull(
			VlansType{
				basetypes.ObjectType{
					AttrTypes: VlansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Vlans.IsUnknown() {
		vlans = types.ListUnknown(
			VlansType{
				basetypes.ObjectType{
					AttrTypes: VlansValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"bridge_domains": basetypes.ListType{
			ElemType: BridgeDomainsValue{}.Type(ctx),
		},
		"bridge_interfaces": basetypes.ListType{
			ElemType: BridgeInterfacesValue{}.Type(ctx),
		},
		"irb_interfaces": basetypes.ListType{
			ElemType: IrbInterfacesValue{}.Type(ctx),
		},
		"protocols": basetypes.ObjectType{
			AttrTypes: ProtocolsValue{}.AttributeTypes(ctx),
		},
		"routed_interfaces": basetypes.ListType{
			ElemType: RoutedInterfacesValue{}.Type(ctx),
		},
		"routers": basetypes.ListType{
			ElemType: RoutersValue{}.Type(ctx),
		},
		"vlans": basetypes.ListType{
			ElemType: VlansValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bridge_domains":    bridgeDomains,
			"bridge_interfaces": bridgeInterfaces,
			"irb_interfaces":    irbInterfaces,
			"protocols":         protocols,
			"routed_interfaces": routedInterfaces,
			"routers":           routers,
			"vlans":             vlans,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BridgeDomains.Equal(other.BridgeDomains) {
		return false
	}

	if !v.BridgeInterfaces.Equal(other.BridgeInterfaces) {
		return false
	}

	if !v.IrbInterfaces.Equal(other.IrbInterfaces) {
		return false
	}

	if !v.Protocols.Equal(other.Protocols) {
		return false
	}

	if !v.RoutedInterfaces.Equal(other.RoutedInterfaces) {
		return false
	}

	if !v.Routers.Equal(other.Routers) {
		return false
	}

	if !v.Vlans.Equal(other.Vlans) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bridge_domains": basetypes.ListType{
			ElemType: BridgeDomainsValue{}.Type(ctx),
		},
		"bridge_interfaces": basetypes.ListType{
			ElemType: BridgeInterfacesValue{}.Type(ctx),
		},
		"irb_interfaces": basetypes.ListType{
			ElemType: IrbInterfacesValue{}.Type(ctx),
		},
		"protocols": basetypes.ObjectType{
			AttrTypes: ProtocolsValue{}.AttributeTypes(ctx),
		},
		"routed_interfaces": basetypes.ListType{
			ElemType: RoutedInterfacesValue{}.Type(ctx),
		},
		"routers": basetypes.ListType{
			ElemType: RoutersValue{}.Type(ctx),
		},
		"vlans": basetypes.ListType{
			ElemType: VlansValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = BridgeDomainsType{}

type BridgeDomainsType struct {
	basetypes.ObjectType
}

func (t BridgeDomainsType) Equal(o attr.Type) bool {
	other, ok := o.(BridgeDomainsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BridgeDomainsType) String() string {
	return "BridgeDomainsType"
}

func (t BridgeDomainsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec1Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_1 is missing from object`)

		return nil, diags
	}

	spec1Val, ok := spec1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_1 expected to be basetypes.ObjectValue, was: %T`, spec1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BridgeDomainsValue{
		Name:  nameVal,
		Spec1: spec1Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBridgeDomainsValueNull() BridgeDomainsValue {
	return BridgeDomainsValue{
		state: attr.ValueStateNull,
	}
}

func NewBridgeDomainsValueUnknown() BridgeDomainsValue {
	return BridgeDomainsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBridgeDomainsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BridgeDomainsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BridgeDomainsValue Attribute Value",
				"While creating a BridgeDomainsValue value, a missing attribute value was detected. "+
					"A BridgeDomainsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BridgeDomainsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BridgeDomainsValue Attribute Type",
				"While creating a BridgeDomainsValue value, an invalid attribute value was detected. "+
					"A BridgeDomainsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BridgeDomainsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BridgeDomainsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BridgeDomainsValue Attribute Value",
				"While creating a BridgeDomainsValue value, an extra attribute value was detected. "+
					"A BridgeDomainsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BridgeDomainsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBridgeDomainsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewBridgeDomainsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec1Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_1 is missing from object`)

		return NewBridgeDomainsValueUnknown(), diags
	}

	spec1Val, ok := spec1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_1 expected to be basetypes.ObjectValue, was: %T`, spec1Attribute))
	}

	if diags.HasError() {
		return NewBridgeDomainsValueUnknown(), diags
	}

	return BridgeDomainsValue{
		Name:  nameVal,
		Spec1: spec1Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBridgeDomainsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BridgeDomainsValue {
	object, diags := NewBridgeDomainsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBridgeDomainsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BridgeDomainsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBridgeDomainsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBridgeDomainsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBridgeDomainsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBridgeDomainsValueMust(BridgeDomainsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BridgeDomainsType) ValueType(ctx context.Context) attr.Value {
	return BridgeDomainsValue{}
}

var _ basetypes.ObjectValuable = BridgeDomainsValue{}

type BridgeDomainsValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Spec1 basetypes.ObjectValue `tfsdk:"spec"`
	state attr.ValueState
}

func (v BridgeDomainsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Spec1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BridgeDomainsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BridgeDomainsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BridgeDomainsValue) String() string {
	return "BridgeDomainsValue"
}

func (v BridgeDomainsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spec1 basetypes.ObjectValue

	if v.Spec1.IsNull() {
		spec1 = types.ObjectNull(
			Spec1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec1.IsUnknown() {
		spec1 = types.ObjectUnknown(
			Spec1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec1.IsNull() && !v.Spec1.IsUnknown() {
		spec1 = types.ObjectValueMust(
			Spec1Value{}.AttributeTypes(ctx),
			v.Spec1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec1Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"spec": spec1,
		})

	return objVal, diags
}

func (v BridgeDomainsValue) Equal(o attr.Value) bool {
	other, ok := o.(BridgeDomainsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Spec1.Equal(other.Spec1) {
		return false
	}

	return true
}

func (v BridgeDomainsValue) Type(ctx context.Context) attr.Type {
	return BridgeDomainsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BridgeDomainsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec1Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Spec1Type{}

type Spec1Type struct {
	basetypes.ObjectType
}

func (t Spec1Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec1Type) String() string {
	return "Spec1Type"
}

func (t Spec1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configuredNameAttribute, ok := attributes["configured_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_name is missing from object`)

		return nil, diags
	}

	configuredNameVal, ok := configuredNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_name expected to be basetypes.StringValue, was: %T`, configuredNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	eviAttribute, ok := attributes["evi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi is missing from object`)

		return nil, diags
	}

	eviVal, ok := eviAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi expected to be basetypes.Int64Value, was: %T`, eviAttribute))
	}

	eviPoolAttribute, ok := attributes["evi_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi_pool is missing from object`)

		return nil, diags
	}

	eviPoolVal, ok := eviPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi_pool expected to be basetypes.StringValue, was: %T`, eviPoolAttribute))
	}

	exportTargetAttribute, ok := attributes["export_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_target is missing from object`)

		return nil, diags
	}

	exportTargetVal, ok := exportTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_target expected to be basetypes.StringValue, was: %T`, exportTargetAttribute))
	}

	importTargetAttribute, ok := attributes["import_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_target is missing from object`)

		return nil, diags
	}

	importTargetVal, ok := importTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_target expected to be basetypes.StringValue, was: %T`, importTargetAttribute))
	}

	l2proxyArpndAttribute, ok := attributes["l2proxy_arpnd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2proxy_arpnd is missing from object`)

		return nil, diags
	}

	l2proxyArpndVal, ok := l2proxyArpndAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2proxy_arpnd expected to be basetypes.ObjectValue, was: %T`, l2proxyArpndAttribute))
	}

	macAgingAttribute, ok := attributes["mac_aging"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_aging is missing from object`)

		return nil, diags
	}

	macAgingVal, ok := macAgingAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_aging expected to be basetypes.Int64Value, was: %T`, macAgingAttribute))
	}

	macDuplicationDetectionAttribute, ok := attributes["mac_duplication_detection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_duplication_detection is missing from object`)

		return nil, diags
	}

	macDuplicationDetectionVal, ok := macDuplicationDetectionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_duplication_detection expected to be basetypes.ObjectValue, was: %T`, macDuplicationDetectionAttribute))
	}

	macLearningAttribute, ok := attributes["mac_learning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_learning is missing from object`)

		return nil, diags
	}

	macLearningVal, ok := macLearningAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_learning expected to be basetypes.BoolValue, was: %T`, macLearningAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return nil, diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	tunnelIndexPoolAttribute, ok := attributes["tunnel_index_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_index_pool is missing from object`)

		return nil, diags
	}

	tunnelIndexPoolVal, ok := tunnelIndexPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_index_pool expected to be basetypes.StringValue, was: %T`, tunnelIndexPoolAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vniAttribute, ok := attributes["vni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni is missing from object`)

		return nil, diags
	}

	vniVal, ok := vniAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni expected to be basetypes.Int64Value, was: %T`, vniAttribute))
	}

	vniPoolAttribute, ok := attributes["vni_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni_pool is missing from object`)

		return nil, diags
	}

	vniPoolVal, ok := vniPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni_pool expected to be basetypes.StringValue, was: %T`, vniPoolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec1Value{
		ConfiguredName:          configuredNameVal,
		Description:             descriptionVal,
		Evi:                     eviVal,
		EviPool:                 eviPoolVal,
		ExportTarget:            exportTargetVal,
		ImportTarget:            importTargetVal,
		L2proxyArpnd:            l2proxyArpndVal,
		MacAging:                macAgingVal,
		MacDuplicationDetection: macDuplicationDetectionVal,
		MacLearning:             macLearningVal,
		MacLimit:                macLimitVal,
		TunnelIndexPool:         tunnelIndexPoolVal,
		Spec1Type:               typeVal,
		Vni:                     vniVal,
		VniPool:                 vniPoolVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewSpec1ValueNull() Spec1Value {
	return Spec1Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec1ValueUnknown() Spec1Value {
	return Spec1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec1Value Attribute Value",
				"While creating a Spec1Value value, a missing attribute value was detected. "+
					"A Spec1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec1Value Attribute Type",
				"While creating a Spec1Value value, an invalid attribute value was detected. "+
					"A Spec1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec1Value Attribute Value",
				"While creating a Spec1Value value, an extra attribute value was detected. "+
					"A Spec1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec1ValueUnknown(), diags
	}

	configuredNameAttribute, ok := attributes["configured_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_name is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	configuredNameVal, ok := configuredNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_name expected to be basetypes.StringValue, was: %T`, configuredNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	eviAttribute, ok := attributes["evi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	eviVal, ok := eviAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi expected to be basetypes.Int64Value, was: %T`, eviAttribute))
	}

	eviPoolAttribute, ok := attributes["evi_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi_pool is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	eviPoolVal, ok := eviPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi_pool expected to be basetypes.StringValue, was: %T`, eviPoolAttribute))
	}

	exportTargetAttribute, ok := attributes["export_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_target is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	exportTargetVal, ok := exportTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_target expected to be basetypes.StringValue, was: %T`, exportTargetAttribute))
	}

	importTargetAttribute, ok := attributes["import_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_target is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	importTargetVal, ok := importTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_target expected to be basetypes.StringValue, was: %T`, importTargetAttribute))
	}

	l2proxyArpndAttribute, ok := attributes["l2proxy_arpnd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2proxy_arpnd is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	l2proxyArpndVal, ok := l2proxyArpndAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2proxy_arpnd expected to be basetypes.ObjectValue, was: %T`, l2proxyArpndAttribute))
	}

	macAgingAttribute, ok := attributes["mac_aging"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_aging is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	macAgingVal, ok := macAgingAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_aging expected to be basetypes.Int64Value, was: %T`, macAgingAttribute))
	}

	macDuplicationDetectionAttribute, ok := attributes["mac_duplication_detection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_duplication_detection is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	macDuplicationDetectionVal, ok := macDuplicationDetectionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_duplication_detection expected to be basetypes.ObjectValue, was: %T`, macDuplicationDetectionAttribute))
	}

	macLearningAttribute, ok := attributes["mac_learning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_learning is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	macLearningVal, ok := macLearningAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_learning expected to be basetypes.BoolValue, was: %T`, macLearningAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	tunnelIndexPoolAttribute, ok := attributes["tunnel_index_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_index_pool is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	tunnelIndexPoolVal, ok := tunnelIndexPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_index_pool expected to be basetypes.StringValue, was: %T`, tunnelIndexPoolAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vniAttribute, ok := attributes["vni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	vniVal, ok := vniAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni expected to be basetypes.Int64Value, was: %T`, vniAttribute))
	}

	vniPoolAttribute, ok := attributes["vni_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni_pool is missing from object`)

		return NewSpec1ValueUnknown(), diags
	}

	vniPoolVal, ok := vniPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni_pool expected to be basetypes.StringValue, was: %T`, vniPoolAttribute))
	}

	if diags.HasError() {
		return NewSpec1ValueUnknown(), diags
	}

	return Spec1Value{
		ConfiguredName:          configuredNameVal,
		Description:             descriptionVal,
		Evi:                     eviVal,
		EviPool:                 eviPoolVal,
		ExportTarget:            exportTargetVal,
		ImportTarget:            importTargetVal,
		L2proxyArpnd:            l2proxyArpndVal,
		MacAging:                macAgingVal,
		MacDuplicationDetection: macDuplicationDetectionVal,
		MacLearning:             macLearningVal,
		MacLimit:                macLimitVal,
		TunnelIndexPool:         tunnelIndexPoolVal,
		Spec1Type:               typeVal,
		Vni:                     vniVal,
		VniPool:                 vniPoolVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewSpec1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec1Value {
	object, diags := NewSpec1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec1ValueMust(Spec1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec1Type) ValueType(ctx context.Context) attr.Value {
	return Spec1Value{}
}

var _ basetypes.ObjectValuable = Spec1Value{}

type Spec1Value struct {
	ConfiguredName          basetypes.StringValue `tfsdk:"configured_name"`
	Description             basetypes.StringValue `tfsdk:"description"`
	Evi                     basetypes.Int64Value  `tfsdk:"evi"`
	EviPool                 basetypes.StringValue `tfsdk:"evi_pool"`
	ExportTarget            basetypes.StringValue `tfsdk:"export_target"`
	ImportTarget            basetypes.StringValue `tfsdk:"import_target"`
	L2proxyArpnd            basetypes.ObjectValue `tfsdk:"l2proxy_arpnd"`
	MacAging                basetypes.Int64Value  `tfsdk:"mac_aging"`
	MacDuplicationDetection basetypes.ObjectValue `tfsdk:"mac_duplication_detection"`
	MacLearning             basetypes.BoolValue   `tfsdk:"mac_learning"`
	MacLimit                basetypes.Int64Value  `tfsdk:"mac_limit"`
	TunnelIndexPool         basetypes.StringValue `tfsdk:"tunnel_index_pool"`
	Spec1Type               basetypes.StringValue `tfsdk:"type"`
	Vni                     basetypes.Int64Value  `tfsdk:"vni"`
	VniPool                 basetypes.StringValue `tfsdk:"vni_pool"`
	state                   attr.ValueState
}

func (v Spec1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 15)

	var val tftypes.Value
	var err error

	attrTypes["configured_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["evi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["evi_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["export_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l2proxy_arpnd"] = basetypes.ObjectType{
		AttrTypes: L2proxyArpndValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["mac_aging"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mac_duplication_detection"] = basetypes.ObjectType{
		AttrTypes: MacDuplicationDetectionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["mac_learning"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tunnel_index_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vni"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vni_pool"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 15)

		val, err = v.ConfiguredName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configured_name"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Evi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evi"] = val

		val, err = v.EviPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evi_pool"] = val

		val, err = v.ExportTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_target"] = val

		val, err = v.ImportTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_target"] = val

		val, err = v.L2proxyArpnd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l2proxy_arpnd"] = val

		val, err = v.MacAging.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_aging"] = val

		val, err = v.MacDuplicationDetection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_duplication_detection"] = val

		val, err = v.MacLearning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_learning"] = val

		val, err = v.MacLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_limit"] = val

		val, err = v.TunnelIndexPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tunnel_index_pool"] = val

		val, err = v.Spec1Type.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Vni.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vni"] = val

		val, err = v.VniPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vni_pool"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec1Value) String() string {
	return "Spec1Value"
}

func (v Spec1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var l2proxyArpnd basetypes.ObjectValue

	if v.L2proxyArpnd.IsNull() {
		l2proxyArpnd = types.ObjectNull(
			L2proxyArpndValue{}.AttributeTypes(ctx),
		)
	}

	if v.L2proxyArpnd.IsUnknown() {
		l2proxyArpnd = types.ObjectUnknown(
			L2proxyArpndValue{}.AttributeTypes(ctx),
		)
	}

	if !v.L2proxyArpnd.IsNull() && !v.L2proxyArpnd.IsUnknown() {
		l2proxyArpnd = types.ObjectValueMust(
			L2proxyArpndValue{}.AttributeTypes(ctx),
			v.L2proxyArpnd.Attributes(),
		)
	}

	var macDuplicationDetection basetypes.ObjectValue

	if v.MacDuplicationDetection.IsNull() {
		macDuplicationDetection = types.ObjectNull(
			MacDuplicationDetectionValue{}.AttributeTypes(ctx),
		)
	}

	if v.MacDuplicationDetection.IsUnknown() {
		macDuplicationDetection = types.ObjectUnknown(
			MacDuplicationDetectionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MacDuplicationDetection.IsNull() && !v.MacDuplicationDetection.IsUnknown() {
		macDuplicationDetection = types.ObjectValueMust(
			MacDuplicationDetectionValue{}.AttributeTypes(ctx),
			v.MacDuplicationDetection.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"configured_name": basetypes.StringType{},
		"description":     basetypes.StringType{},
		"evi":             basetypes.Int64Type{},
		"evi_pool":        basetypes.StringType{},
		"export_target":   basetypes.StringType{},
		"import_target":   basetypes.StringType{},
		"l2proxy_arpnd": basetypes.ObjectType{
			AttrTypes: L2proxyArpndValue{}.AttributeTypes(ctx),
		},
		"mac_aging": basetypes.Int64Type{},
		"mac_duplication_detection": basetypes.ObjectType{
			AttrTypes: MacDuplicationDetectionValue{}.AttributeTypes(ctx),
		},
		"mac_learning":      basetypes.BoolType{},
		"mac_limit":         basetypes.Int64Type{},
		"tunnel_index_pool": basetypes.StringType{},
		"type":              basetypes.StringType{},
		"vni":               basetypes.Int64Type{},
		"vni_pool":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"configured_name":           v.ConfiguredName,
			"description":               v.Description,
			"evi":                       v.Evi,
			"evi_pool":                  v.EviPool,
			"export_target":             v.ExportTarget,
			"import_target":             v.ImportTarget,
			"l2proxy_arpnd":             l2proxyArpnd,
			"mac_aging":                 v.MacAging,
			"mac_duplication_detection": macDuplicationDetection,
			"mac_learning":              v.MacLearning,
			"mac_limit":                 v.MacLimit,
			"tunnel_index_pool":         v.TunnelIndexPool,
			"type":                      v.Spec1Type,
			"vni":                       v.Vni,
			"vni_pool":                  v.VniPool,
		})

	return objVal, diags
}

func (v Spec1Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConfiguredName.Equal(other.ConfiguredName) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Evi.Equal(other.Evi) {
		return false
	}

	if !v.EviPool.Equal(other.EviPool) {
		return false
	}

	if !v.ExportTarget.Equal(other.ExportTarget) {
		return false
	}

	if !v.ImportTarget.Equal(other.ImportTarget) {
		return false
	}

	if !v.L2proxyArpnd.Equal(other.L2proxyArpnd) {
		return false
	}

	if !v.MacAging.Equal(other.MacAging) {
		return false
	}

	if !v.MacDuplicationDetection.Equal(other.MacDuplicationDetection) {
		return false
	}

	if !v.MacLearning.Equal(other.MacLearning) {
		return false
	}

	if !v.MacLimit.Equal(other.MacLimit) {
		return false
	}

	if !v.TunnelIndexPool.Equal(other.TunnelIndexPool) {
		return false
	}

	if !v.Spec1Type.Equal(other.Spec1Type) {
		return false
	}

	if !v.Vni.Equal(other.Vni) {
		return false
	}

	if !v.VniPool.Equal(other.VniPool) {
		return false
	}

	return true
}

func (v Spec1Value) Type(ctx context.Context) attr.Type {
	return Spec1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"configured_name": basetypes.StringType{},
		"description":     basetypes.StringType{},
		"evi":             basetypes.Int64Type{},
		"evi_pool":        basetypes.StringType{},
		"export_target":   basetypes.StringType{},
		"import_target":   basetypes.StringType{},
		"l2proxy_arpnd": basetypes.ObjectType{
			AttrTypes: L2proxyArpndValue{}.AttributeTypes(ctx),
		},
		"mac_aging": basetypes.Int64Type{},
		"mac_duplication_detection": basetypes.ObjectType{
			AttrTypes: MacDuplicationDetectionValue{}.AttributeTypes(ctx),
		},
		"mac_learning":      basetypes.BoolType{},
		"mac_limit":         basetypes.Int64Type{},
		"tunnel_index_pool": basetypes.StringType{},
		"type":              basetypes.StringType{},
		"vni":               basetypes.Int64Type{},
		"vni_pool":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = L2proxyArpndType{}

type L2proxyArpndType struct {
	basetypes.ObjectType
}

func (t L2proxyArpndType) Equal(o attr.Type) bool {
	other, ok := o.(L2proxyArpndType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t L2proxyArpndType) String() string {
	return "L2proxyArpndType"
}

func (t L2proxyArpndType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dynamicLearningAttribute, ok := attributes["dynamic_learning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_learning is missing from object`)

		return nil, diags
	}

	dynamicLearningVal, ok := dynamicLearningAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_learning expected to be basetypes.ObjectValue, was: %T`, dynamicLearningAttribute))
	}

	ipDuplicationAttribute, ok := attributes["ip_duplication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_duplication is missing from object`)

		return nil, diags
	}

	ipDuplicationVal, ok := ipDuplicationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_duplication expected to be basetypes.ObjectValue, was: %T`, ipDuplicationAttribute))
	}

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return nil, diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.BoolValue, was: %T`, proxyArpAttribute))
	}

	proxyNdAttribute, ok := attributes["proxy_nd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_nd is missing from object`)

		return nil, diags
	}

	proxyNdVal, ok := proxyNdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_nd expected to be basetypes.BoolValue, was: %T`, proxyNdAttribute))
	}

	tableSizeAttribute, ok := attributes["table_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_size is missing from object`)

		return nil, diags
	}

	tableSizeVal, ok := tableSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_size expected to be basetypes.Int64Value, was: %T`, tableSizeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return L2proxyArpndValue{
		DynamicLearning: dynamicLearningVal,
		IpDuplication:   ipDuplicationVal,
		ProxyArp:        proxyArpVal,
		ProxyNd:         proxyNdVal,
		TableSize:       tableSizeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewL2proxyArpndValueNull() L2proxyArpndValue {
	return L2proxyArpndValue{
		state: attr.ValueStateNull,
	}
}

func NewL2proxyArpndValueUnknown() L2proxyArpndValue {
	return L2proxyArpndValue{
		state: attr.ValueStateUnknown,
	}
}

func NewL2proxyArpndValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (L2proxyArpndValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing L2proxyArpndValue Attribute Value",
				"While creating a L2proxyArpndValue value, a missing attribute value was detected. "+
					"A L2proxyArpndValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L2proxyArpndValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid L2proxyArpndValue Attribute Type",
				"While creating a L2proxyArpndValue value, an invalid attribute value was detected. "+
					"A L2proxyArpndValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L2proxyArpndValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("L2proxyArpndValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra L2proxyArpndValue Attribute Value",
				"While creating a L2proxyArpndValue value, an extra attribute value was detected. "+
					"A L2proxyArpndValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra L2proxyArpndValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewL2proxyArpndValueUnknown(), diags
	}

	dynamicLearningAttribute, ok := attributes["dynamic_learning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_learning is missing from object`)

		return NewL2proxyArpndValueUnknown(), diags
	}

	dynamicLearningVal, ok := dynamicLearningAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_learning expected to be basetypes.ObjectValue, was: %T`, dynamicLearningAttribute))
	}

	ipDuplicationAttribute, ok := attributes["ip_duplication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_duplication is missing from object`)

		return NewL2proxyArpndValueUnknown(), diags
	}

	ipDuplicationVal, ok := ipDuplicationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_duplication expected to be basetypes.ObjectValue, was: %T`, ipDuplicationAttribute))
	}

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return NewL2proxyArpndValueUnknown(), diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.BoolValue, was: %T`, proxyArpAttribute))
	}

	proxyNdAttribute, ok := attributes["proxy_nd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_nd is missing from object`)

		return NewL2proxyArpndValueUnknown(), diags
	}

	proxyNdVal, ok := proxyNdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_nd expected to be basetypes.BoolValue, was: %T`, proxyNdAttribute))
	}

	tableSizeAttribute, ok := attributes["table_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_size is missing from object`)

		return NewL2proxyArpndValueUnknown(), diags
	}

	tableSizeVal, ok := tableSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_size expected to be basetypes.Int64Value, was: %T`, tableSizeAttribute))
	}

	if diags.HasError() {
		return NewL2proxyArpndValueUnknown(), diags
	}

	return L2proxyArpndValue{
		DynamicLearning: dynamicLearningVal,
		IpDuplication:   ipDuplicationVal,
		ProxyArp:        proxyArpVal,
		ProxyNd:         proxyNdVal,
		TableSize:       tableSizeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewL2proxyArpndValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) L2proxyArpndValue {
	object, diags := NewL2proxyArpndValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewL2proxyArpndValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t L2proxyArpndType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewL2proxyArpndValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewL2proxyArpndValueUnknown(), nil
	}

	if in.IsNull() {
		return NewL2proxyArpndValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewL2proxyArpndValueMust(L2proxyArpndValue{}.AttributeTypes(ctx), attributes), nil
}

func (t L2proxyArpndType) ValueType(ctx context.Context) attr.Value {
	return L2proxyArpndValue{}
}

var _ basetypes.ObjectValuable = L2proxyArpndValue{}

type L2proxyArpndValue struct {
	DynamicLearning basetypes.ObjectValue `tfsdk:"dynamic_learning"`
	IpDuplication   basetypes.ObjectValue `tfsdk:"ip_duplication"`
	ProxyArp        basetypes.BoolValue   `tfsdk:"proxy_arp"`
	ProxyNd         basetypes.BoolValue   `tfsdk:"proxy_nd"`
	TableSize       basetypes.Int64Value  `tfsdk:"table_size"`
	state           attr.ValueState
}

func (v L2proxyArpndValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["dynamic_learning"] = basetypes.ObjectType{
		AttrTypes: DynamicLearningValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_duplication"] = basetypes.ObjectType{
		AttrTypes: IpDuplicationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["proxy_arp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["proxy_nd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["table_size"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DynamicLearning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_learning"] = val

		val, err = v.IpDuplication.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_duplication"] = val

		val, err = v.ProxyArp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_arp"] = val

		val, err = v.ProxyNd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_nd"] = val

		val, err = v.TableSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["table_size"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v L2proxyArpndValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v L2proxyArpndValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v L2proxyArpndValue) String() string {
	return "L2proxyArpndValue"
}

func (v L2proxyArpndValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var dynamicLearning basetypes.ObjectValue

	if v.DynamicLearning.IsNull() {
		dynamicLearning = types.ObjectNull(
			DynamicLearningValue{}.AttributeTypes(ctx),
		)
	}

	if v.DynamicLearning.IsUnknown() {
		dynamicLearning = types.ObjectUnknown(
			DynamicLearningValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DynamicLearning.IsNull() && !v.DynamicLearning.IsUnknown() {
		dynamicLearning = types.ObjectValueMust(
			DynamicLearningValue{}.AttributeTypes(ctx),
			v.DynamicLearning.Attributes(),
		)
	}

	var ipDuplication basetypes.ObjectValue

	if v.IpDuplication.IsNull() {
		ipDuplication = types.ObjectNull(
			IpDuplicationValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpDuplication.IsUnknown() {
		ipDuplication = types.ObjectUnknown(
			IpDuplicationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpDuplication.IsNull() && !v.IpDuplication.IsUnknown() {
		ipDuplication = types.ObjectValueMust(
			IpDuplicationValue{}.AttributeTypes(ctx),
			v.IpDuplication.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"dynamic_learning": basetypes.ObjectType{
			AttrTypes: DynamicLearningValue{}.AttributeTypes(ctx),
		},
		"ip_duplication": basetypes.ObjectType{
			AttrTypes: IpDuplicationValue{}.AttributeTypes(ctx),
		},
		"proxy_arp":  basetypes.BoolType{},
		"proxy_nd":   basetypes.BoolType{},
		"table_size": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dynamic_learning": dynamicLearning,
			"ip_duplication":   ipDuplication,
			"proxy_arp":        v.ProxyArp,
			"proxy_nd":         v.ProxyNd,
			"table_size":       v.TableSize,
		})

	return objVal, diags
}

func (v L2proxyArpndValue) Equal(o attr.Value) bool {
	other, ok := o.(L2proxyArpndValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DynamicLearning.Equal(other.DynamicLearning) {
		return false
	}

	if !v.IpDuplication.Equal(other.IpDuplication) {
		return false
	}

	if !v.ProxyArp.Equal(other.ProxyArp) {
		return false
	}

	if !v.ProxyNd.Equal(other.ProxyNd) {
		return false
	}

	if !v.TableSize.Equal(other.TableSize) {
		return false
	}

	return true
}

func (v L2proxyArpndValue) Type(ctx context.Context) attr.Type {
	return L2proxyArpndType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v L2proxyArpndValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dynamic_learning": basetypes.ObjectType{
			AttrTypes: DynamicLearningValue{}.AttributeTypes(ctx),
		},
		"ip_duplication": basetypes.ObjectType{
			AttrTypes: IpDuplicationValue{}.AttributeTypes(ctx),
		},
		"proxy_arp":  basetypes.BoolType{},
		"proxy_nd":   basetypes.BoolType{},
		"table_size": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DynamicLearningType{}

type DynamicLearningType struct {
	basetypes.ObjectType
}

func (t DynamicLearningType) Equal(o attr.Type) bool {
	other, ok := o.(DynamicLearningType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DynamicLearningType) String() string {
	return "DynamicLearningType"
}

func (t DynamicLearningType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ageTimeAttribute, ok := attributes["age_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`age_time is missing from object`)

		return nil, diags
	}

	ageTimeVal, ok := ageTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`age_time expected to be basetypes.Int64Value, was: %T`, ageTimeAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	sendRefreshAttribute, ok := attributes["send_refresh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_refresh is missing from object`)

		return nil, diags
	}

	sendRefreshVal, ok := sendRefreshAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_refresh expected to be basetypes.Int64Value, was: %T`, sendRefreshAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DynamicLearningValue{
		AgeTime:     ageTimeVal,
		Enabled:     enabledVal,
		SendRefresh: sendRefreshVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDynamicLearningValueNull() DynamicLearningValue {
	return DynamicLearningValue{
		state: attr.ValueStateNull,
	}
}

func NewDynamicLearningValueUnknown() DynamicLearningValue {
	return DynamicLearningValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDynamicLearningValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DynamicLearningValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DynamicLearningValue Attribute Value",
				"While creating a DynamicLearningValue value, a missing attribute value was detected. "+
					"A DynamicLearningValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicLearningValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DynamicLearningValue Attribute Type",
				"While creating a DynamicLearningValue value, an invalid attribute value was detected. "+
					"A DynamicLearningValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicLearningValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DynamicLearningValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DynamicLearningValue Attribute Value",
				"While creating a DynamicLearningValue value, an extra attribute value was detected. "+
					"A DynamicLearningValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DynamicLearningValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDynamicLearningValueUnknown(), diags
	}

	ageTimeAttribute, ok := attributes["age_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`age_time is missing from object`)

		return NewDynamicLearningValueUnknown(), diags
	}

	ageTimeVal, ok := ageTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`age_time expected to be basetypes.Int64Value, was: %T`, ageTimeAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDynamicLearningValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	sendRefreshAttribute, ok := attributes["send_refresh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_refresh is missing from object`)

		return NewDynamicLearningValueUnknown(), diags
	}

	sendRefreshVal, ok := sendRefreshAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_refresh expected to be basetypes.Int64Value, was: %T`, sendRefreshAttribute))
	}

	if diags.HasError() {
		return NewDynamicLearningValueUnknown(), diags
	}

	return DynamicLearningValue{
		AgeTime:     ageTimeVal,
		Enabled:     enabledVal,
		SendRefresh: sendRefreshVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDynamicLearningValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DynamicLearningValue {
	object, diags := NewDynamicLearningValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDynamicLearningValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DynamicLearningType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDynamicLearningValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDynamicLearningValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDynamicLearningValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDynamicLearningValueMust(DynamicLearningValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DynamicLearningType) ValueType(ctx context.Context) attr.Value {
	return DynamicLearningValue{}
}

var _ basetypes.ObjectValuable = DynamicLearningValue{}

type DynamicLearningValue struct {
	AgeTime     basetypes.Int64Value `tfsdk:"age_time"`
	Enabled     basetypes.BoolValue  `tfsdk:"enabled"`
	SendRefresh basetypes.Int64Value `tfsdk:"send_refresh"`
	state       attr.ValueState
}

func (v DynamicLearningValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["age_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["send_refresh"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AgeTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["age_time"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.SendRefresh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_refresh"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DynamicLearningValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DynamicLearningValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DynamicLearningValue) String() string {
	return "DynamicLearningValue"
}

func (v DynamicLearningValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"age_time":     basetypes.Int64Type{},
		"enabled":      basetypes.BoolType{},
		"send_refresh": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"age_time":     v.AgeTime,
			"enabled":      v.Enabled,
			"send_refresh": v.SendRefresh,
		})

	return objVal, diags
}

func (v DynamicLearningValue) Equal(o attr.Value) bool {
	other, ok := o.(DynamicLearningValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AgeTime.Equal(other.AgeTime) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.SendRefresh.Equal(other.SendRefresh) {
		return false
	}

	return true
}

func (v DynamicLearningValue) Type(ctx context.Context) attr.Type {
	return DynamicLearningType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DynamicLearningValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"age_time":     basetypes.Int64Type{},
		"enabled":      basetypes.BoolType{},
		"send_refresh": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = IpDuplicationType{}

type IpDuplicationType struct {
	basetypes.ObjectType
}

func (t IpDuplicationType) Equal(o attr.Type) bool {
	other, ok := o.(IpDuplicationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpDuplicationType) String() string {
	return "IpDuplicationType"
}

func (t IpDuplicationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	holdDownTimeAttribute, ok := attributes["hold_down_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_down_time is missing from object`)

		return nil, diags
	}

	holdDownTimeVal, ok := holdDownTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_down_time expected to be basetypes.Int64Value, was: %T`, holdDownTimeAttribute))
	}

	monitoringWindowAttribute, ok := attributes["monitoring_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_window is missing from object`)

		return nil, diags
	}

	monitoringWindowVal, ok := monitoringWindowAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_window expected to be basetypes.Int64Value, was: %T`, monitoringWindowAttribute))
	}

	numMovesAttribute, ok := attributes["num_moves"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_moves is missing from object`)

		return nil, diags
	}

	numMovesVal, ok := numMovesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_moves expected to be basetypes.Int64Value, was: %T`, numMovesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpDuplicationValue{
		Enabled:          enabledVal,
		HoldDownTime:     holdDownTimeVal,
		MonitoringWindow: monitoringWindowVal,
		NumMoves:         numMovesVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewIpDuplicationValueNull() IpDuplicationValue {
	return IpDuplicationValue{
		state: attr.ValueStateNull,
	}
}

func NewIpDuplicationValueUnknown() IpDuplicationValue {
	return IpDuplicationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpDuplicationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpDuplicationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpDuplicationValue Attribute Value",
				"While creating a IpDuplicationValue value, a missing attribute value was detected. "+
					"A IpDuplicationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpDuplicationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpDuplicationValue Attribute Type",
				"While creating a IpDuplicationValue value, an invalid attribute value was detected. "+
					"A IpDuplicationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpDuplicationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpDuplicationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpDuplicationValue Attribute Value",
				"While creating a IpDuplicationValue value, an extra attribute value was detected. "+
					"A IpDuplicationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpDuplicationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpDuplicationValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpDuplicationValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	holdDownTimeAttribute, ok := attributes["hold_down_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_down_time is missing from object`)

		return NewIpDuplicationValueUnknown(), diags
	}

	holdDownTimeVal, ok := holdDownTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_down_time expected to be basetypes.Int64Value, was: %T`, holdDownTimeAttribute))
	}

	monitoringWindowAttribute, ok := attributes["monitoring_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_window is missing from object`)

		return NewIpDuplicationValueUnknown(), diags
	}

	monitoringWindowVal, ok := monitoringWindowAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_window expected to be basetypes.Int64Value, was: %T`, monitoringWindowAttribute))
	}

	numMovesAttribute, ok := attributes["num_moves"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_moves is missing from object`)

		return NewIpDuplicationValueUnknown(), diags
	}

	numMovesVal, ok := numMovesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_moves expected to be basetypes.Int64Value, was: %T`, numMovesAttribute))
	}

	if diags.HasError() {
		return NewIpDuplicationValueUnknown(), diags
	}

	return IpDuplicationValue{
		Enabled:          enabledVal,
		HoldDownTime:     holdDownTimeVal,
		MonitoringWindow: monitoringWindowVal,
		NumMoves:         numMovesVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewIpDuplicationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpDuplicationValue {
	object, diags := NewIpDuplicationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpDuplicationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpDuplicationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpDuplicationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpDuplicationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpDuplicationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpDuplicationValueMust(IpDuplicationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpDuplicationType) ValueType(ctx context.Context) attr.Value {
	return IpDuplicationValue{}
}

var _ basetypes.ObjectValuable = IpDuplicationValue{}

type IpDuplicationValue struct {
	Enabled          basetypes.BoolValue  `tfsdk:"enabled"`
	HoldDownTime     basetypes.Int64Value `tfsdk:"hold_down_time"`
	MonitoringWindow basetypes.Int64Value `tfsdk:"monitoring_window"`
	NumMoves         basetypes.Int64Value `tfsdk:"num_moves"`
	state            attr.ValueState
}

func (v IpDuplicationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hold_down_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["monitoring_window"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_moves"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.HoldDownTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_down_time"] = val

		val, err = v.MonitoringWindow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monitoring_window"] = val

		val, err = v.NumMoves.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_moves"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpDuplicationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpDuplicationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpDuplicationValue) String() string {
	return "IpDuplicationValue"
}

func (v IpDuplicationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":           basetypes.BoolType{},
		"hold_down_time":    basetypes.Int64Type{},
		"monitoring_window": basetypes.Int64Type{},
		"num_moves":         basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":           v.Enabled,
			"hold_down_time":    v.HoldDownTime,
			"monitoring_window": v.MonitoringWindow,
			"num_moves":         v.NumMoves,
		})

	return objVal, diags
}

func (v IpDuplicationValue) Equal(o attr.Value) bool {
	other, ok := o.(IpDuplicationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.HoldDownTime.Equal(other.HoldDownTime) {
		return false
	}

	if !v.MonitoringWindow.Equal(other.MonitoringWindow) {
		return false
	}

	if !v.NumMoves.Equal(other.NumMoves) {
		return false
	}

	return true
}

func (v IpDuplicationValue) Type(ctx context.Context) attr.Type {
	return IpDuplicationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpDuplicationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":           basetypes.BoolType{},
		"hold_down_time":    basetypes.Int64Type{},
		"monitoring_window": basetypes.Int64Type{},
		"num_moves":         basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MacDuplicationDetectionType{}

type MacDuplicationDetectionType struct {
	basetypes.ObjectType
}

func (t MacDuplicationDetectionType) Equal(o attr.Type) bool {
	other, ok := o.(MacDuplicationDetectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MacDuplicationDetectionType) String() string {
	return "MacDuplicationDetectionType"
}

func (t MacDuplicationDetectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	holdDownTimeAttribute, ok := attributes["hold_down_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_down_time is missing from object`)

		return nil, diags
	}

	holdDownTimeVal, ok := holdDownTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_down_time expected to be basetypes.Int64Value, was: %T`, holdDownTimeAttribute))
	}

	monitoringWindowAttribute, ok := attributes["monitoring_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_window is missing from object`)

		return nil, diags
	}

	monitoringWindowVal, ok := monitoringWindowAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_window expected to be basetypes.Int64Value, was: %T`, monitoringWindowAttribute))
	}

	numMovesAttribute, ok := attributes["num_moves"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_moves is missing from object`)

		return nil, diags
	}

	numMovesVal, ok := numMovesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_moves expected to be basetypes.Int64Value, was: %T`, numMovesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MacDuplicationDetectionValue{
		Action:           actionVal,
		Enabled:          enabledVal,
		HoldDownTime:     holdDownTimeVal,
		MonitoringWindow: monitoringWindowVal,
		NumMoves:         numMovesVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMacDuplicationDetectionValueNull() MacDuplicationDetectionValue {
	return MacDuplicationDetectionValue{
		state: attr.ValueStateNull,
	}
}

func NewMacDuplicationDetectionValueUnknown() MacDuplicationDetectionValue {
	return MacDuplicationDetectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMacDuplicationDetectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MacDuplicationDetectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MacDuplicationDetectionValue Attribute Value",
				"While creating a MacDuplicationDetectionValue value, a missing attribute value was detected. "+
					"A MacDuplicationDetectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MacDuplicationDetectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MacDuplicationDetectionValue Attribute Type",
				"While creating a MacDuplicationDetectionValue value, an invalid attribute value was detected. "+
					"A MacDuplicationDetectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MacDuplicationDetectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MacDuplicationDetectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MacDuplicationDetectionValue Attribute Value",
				"While creating a MacDuplicationDetectionValue value, an extra attribute value was detected. "+
					"A MacDuplicationDetectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MacDuplicationDetectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	holdDownTimeAttribute, ok := attributes["hold_down_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_down_time is missing from object`)

		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	holdDownTimeVal, ok := holdDownTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_down_time expected to be basetypes.Int64Value, was: %T`, holdDownTimeAttribute))
	}

	monitoringWindowAttribute, ok := attributes["monitoring_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_window is missing from object`)

		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	monitoringWindowVal, ok := monitoringWindowAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_window expected to be basetypes.Int64Value, was: %T`, monitoringWindowAttribute))
	}

	numMovesAttribute, ok := attributes["num_moves"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_moves is missing from object`)

		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	numMovesVal, ok := numMovesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_moves expected to be basetypes.Int64Value, was: %T`, numMovesAttribute))
	}

	if diags.HasError() {
		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	return MacDuplicationDetectionValue{
		Action:           actionVal,
		Enabled:          enabledVal,
		HoldDownTime:     holdDownTimeVal,
		MonitoringWindow: monitoringWindowVal,
		NumMoves:         numMovesVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMacDuplicationDetectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MacDuplicationDetectionValue {
	object, diags := NewMacDuplicationDetectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMacDuplicationDetectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MacDuplicationDetectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMacDuplicationDetectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMacDuplicationDetectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMacDuplicationDetectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMacDuplicationDetectionValueMust(MacDuplicationDetectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MacDuplicationDetectionType) ValueType(ctx context.Context) attr.Value {
	return MacDuplicationDetectionValue{}
}

var _ basetypes.ObjectValuable = MacDuplicationDetectionValue{}

type MacDuplicationDetectionValue struct {
	Action           basetypes.StringValue `tfsdk:"action"`
	Enabled          basetypes.BoolValue   `tfsdk:"enabled"`
	HoldDownTime     basetypes.Int64Value  `tfsdk:"hold_down_time"`
	MonitoringWindow basetypes.Int64Value  `tfsdk:"monitoring_window"`
	NumMoves         basetypes.Int64Value  `tfsdk:"num_moves"`
	state            attr.ValueState
}

func (v MacDuplicationDetectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hold_down_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["monitoring_window"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_moves"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.HoldDownTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_down_time"] = val

		val, err = v.MonitoringWindow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monitoring_window"] = val

		val, err = v.NumMoves.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_moves"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MacDuplicationDetectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MacDuplicationDetectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MacDuplicationDetectionValue) String() string {
	return "MacDuplicationDetectionValue"
}

func (v MacDuplicationDetectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"action":            basetypes.StringType{},
		"enabled":           basetypes.BoolType{},
		"hold_down_time":    basetypes.Int64Type{},
		"monitoring_window": basetypes.Int64Type{},
		"num_moves":         basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":            v.Action,
			"enabled":           v.Enabled,
			"hold_down_time":    v.HoldDownTime,
			"monitoring_window": v.MonitoringWindow,
			"num_moves":         v.NumMoves,
		})

	return objVal, diags
}

func (v MacDuplicationDetectionValue) Equal(o attr.Value) bool {
	other, ok := o.(MacDuplicationDetectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.HoldDownTime.Equal(other.HoldDownTime) {
		return false
	}

	if !v.MonitoringWindow.Equal(other.MonitoringWindow) {
		return false
	}

	if !v.NumMoves.Equal(other.NumMoves) {
		return false
	}

	return true
}

func (v MacDuplicationDetectionValue) Type(ctx context.Context) attr.Type {
	return MacDuplicationDetectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MacDuplicationDetectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action":            basetypes.StringType{},
		"enabled":           basetypes.BoolType{},
		"hold_down_time":    basetypes.Int64Type{},
		"monitoring_window": basetypes.Int64Type{},
		"num_moves":         basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = BridgeInterfacesType{}

type BridgeInterfacesType struct {
	basetypes.ObjectType
}

func (t BridgeInterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(BridgeInterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BridgeInterfacesType) String() string {
	return "BridgeInterfacesType"
}

func (t BridgeInterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec2Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_2 is missing from object`)

		return nil, diags
	}

	spec2Val, ok := spec2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_2 expected to be basetypes.ObjectValue, was: %T`, spec2Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BridgeInterfacesValue{
		Name:  nameVal,
		Spec2: spec2Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBridgeInterfacesValueNull() BridgeInterfacesValue {
	return BridgeInterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewBridgeInterfacesValueUnknown() BridgeInterfacesValue {
	return BridgeInterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBridgeInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BridgeInterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BridgeInterfacesValue Attribute Value",
				"While creating a BridgeInterfacesValue value, a missing attribute value was detected. "+
					"A BridgeInterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BridgeInterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BridgeInterfacesValue Attribute Type",
				"While creating a BridgeInterfacesValue value, an invalid attribute value was detected. "+
					"A BridgeInterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BridgeInterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BridgeInterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BridgeInterfacesValue Attribute Value",
				"While creating a BridgeInterfacesValue value, an extra attribute value was detected. "+
					"A BridgeInterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BridgeInterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBridgeInterfacesValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewBridgeInterfacesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec2Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_2 is missing from object`)

		return NewBridgeInterfacesValueUnknown(), diags
	}

	spec2Val, ok := spec2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_2 expected to be basetypes.ObjectValue, was: %T`, spec2Attribute))
	}

	if diags.HasError() {
		return NewBridgeInterfacesValueUnknown(), diags
	}

	return BridgeInterfacesValue{
		Name:  nameVal,
		Spec2: spec2Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBridgeInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BridgeInterfacesValue {
	object, diags := NewBridgeInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBridgeInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BridgeInterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBridgeInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBridgeInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBridgeInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBridgeInterfacesValueMust(BridgeInterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BridgeInterfacesType) ValueType(ctx context.Context) attr.Value {
	return BridgeInterfacesValue{}
}

var _ basetypes.ObjectValuable = BridgeInterfacesValue{}

type BridgeInterfacesValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Spec2 basetypes.ObjectValue `tfsdk:"spec"`
	state attr.ValueState
}

func (v BridgeInterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Spec2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BridgeInterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BridgeInterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BridgeInterfacesValue) String() string {
	return "BridgeInterfacesValue"
}

func (v BridgeInterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spec2 basetypes.ObjectValue

	if v.Spec2.IsNull() {
		spec2 = types.ObjectNull(
			Spec2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec2.IsUnknown() {
		spec2 = types.ObjectUnknown(
			Spec2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec2.IsNull() && !v.Spec2.IsUnknown() {
		spec2 = types.ObjectValueMust(
			Spec2Value{}.AttributeTypes(ctx),
			v.Spec2.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec2Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"spec": spec2,
		})

	return objVal, diags
}

func (v BridgeInterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(BridgeInterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Spec2.Equal(other.Spec2) {
		return false
	}

	return true
}

func (v BridgeInterfacesValue) Type(ctx context.Context) attr.Type {
	return BridgeInterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BridgeInterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec2Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Spec2Type{}

type Spec2Type struct {
	basetypes.ObjectType
}

func (t Spec2Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec2Type) String() string {
	return "Spec2Type"
}

func (t Spec2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bridgeDomainAttribute, ok := attributes["bridge_domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_domain is missing from object`)

		return nil, diags
	}

	bridgeDomainVal, ok := bridgeDomainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_domain expected to be basetypes.StringValue, was: %T`, bridgeDomainAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egressAttribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress is missing from object`)

		return nil, diags
	}

	egressVal, ok := egressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress expected to be basetypes.ObjectValue, was: %T`, egressAttribute))
	}

	ingressAttribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress is missing from object`)

		return nil, diags
	}

	ingressVal, ok := ingressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress expected to be basetypes.ObjectValue, was: %T`, ingressAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	l2MtuAttribute, ok := attributes["l2_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2_mtu is missing from object`)

		return nil, diags
	}

	l2MtuVal, ok := l2MtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2_mtu expected to be basetypes.Int64Value, was: %T`, l2MtuAttribute))
	}

	macDuplicationDetectionActionAttribute, ok := attributes["mac_duplication_detection_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_duplication_detection_action is missing from object`)

		return nil, diags
	}

	macDuplicationDetectionActionVal, ok := macDuplicationDetectionActionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_duplication_detection_action expected to be basetypes.StringValue, was: %T`, macDuplicationDetectionActionAttribute))
	}

	splitHorizonGroupAttribute, ok := attributes["split_horizon_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`split_horizon_group is missing from object`)

		return nil, diags
	}

	splitHorizonGroupVal, ok := splitHorizonGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`split_horizon_group expected to be basetypes.StringValue, was: %T`, splitHorizonGroupAttribute))
	}

	uplinkAttribute, ok := attributes["uplink"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink is missing from object`)

		return nil, diags
	}

	uplinkVal, ok := uplinkAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink expected to be basetypes.ObjectValue, was: %T`, uplinkAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec2Value{
		BridgeDomain:                  bridgeDomainVal,
		Description:                   descriptionVal,
		Egress:                        egressVal,
		Ingress:                       ingressVal,
		Interface:                     interfaceVal,
		L2Mtu:                         l2MtuVal,
		MacDuplicationDetectionAction: macDuplicationDetectionActionVal,
		SplitHorizonGroup:             splitHorizonGroupVal,
		Uplink:                        uplinkVal,
		VlanId:                        vlanIdVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSpec2ValueNull() Spec2Value {
	return Spec2Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec2ValueUnknown() Spec2Value {
	return Spec2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec2Value Attribute Value",
				"While creating a Spec2Value value, a missing attribute value was detected. "+
					"A Spec2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec2Value Attribute Type",
				"While creating a Spec2Value value, an invalid attribute value was detected. "+
					"A Spec2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec2Value Attribute Value",
				"While creating a Spec2Value value, an extra attribute value was detected. "+
					"A Spec2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec2ValueUnknown(), diags
	}

	bridgeDomainAttribute, ok := attributes["bridge_domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_domain is missing from object`)

		return NewSpec2ValueUnknown(), diags
	}

	bridgeDomainVal, ok := bridgeDomainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_domain expected to be basetypes.StringValue, was: %T`, bridgeDomainAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpec2ValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egressAttribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress is missing from object`)

		return NewSpec2ValueUnknown(), diags
	}

	egressVal, ok := egressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress expected to be basetypes.ObjectValue, was: %T`, egressAttribute))
	}

	ingressAttribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress is missing from object`)

		return NewSpec2ValueUnknown(), diags
	}

	ingressVal, ok := ingressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress expected to be basetypes.ObjectValue, was: %T`, ingressAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewSpec2ValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	l2MtuAttribute, ok := attributes["l2_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2_mtu is missing from object`)

		return NewSpec2ValueUnknown(), diags
	}

	l2MtuVal, ok := l2MtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2_mtu expected to be basetypes.Int64Value, was: %T`, l2MtuAttribute))
	}

	macDuplicationDetectionActionAttribute, ok := attributes["mac_duplication_detection_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_duplication_detection_action is missing from object`)

		return NewSpec2ValueUnknown(), diags
	}

	macDuplicationDetectionActionVal, ok := macDuplicationDetectionActionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_duplication_detection_action expected to be basetypes.StringValue, was: %T`, macDuplicationDetectionActionAttribute))
	}

	splitHorizonGroupAttribute, ok := attributes["split_horizon_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`split_horizon_group is missing from object`)

		return NewSpec2ValueUnknown(), diags
	}

	splitHorizonGroupVal, ok := splitHorizonGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`split_horizon_group expected to be basetypes.StringValue, was: %T`, splitHorizonGroupAttribute))
	}

	uplinkAttribute, ok := attributes["uplink"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink is missing from object`)

		return NewSpec2ValueUnknown(), diags
	}

	uplinkVal, ok := uplinkAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink expected to be basetypes.ObjectValue, was: %T`, uplinkAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewSpec2ValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewSpec2ValueUnknown(), diags
	}

	return Spec2Value{
		BridgeDomain:                  bridgeDomainVal,
		Description:                   descriptionVal,
		Egress:                        egressVal,
		Ingress:                       ingressVal,
		Interface:                     interfaceVal,
		L2Mtu:                         l2MtuVal,
		MacDuplicationDetectionAction: macDuplicationDetectionActionVal,
		SplitHorizonGroup:             splitHorizonGroupVal,
		Uplink:                        uplinkVal,
		VlanId:                        vlanIdVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSpec2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec2Value {
	object, diags := NewSpec2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec2ValueMust(Spec2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec2Type) ValueType(ctx context.Context) attr.Value {
	return Spec2Value{}
}

var _ basetypes.ObjectValuable = Spec2Value{}

type Spec2Value struct {
	BridgeDomain                  basetypes.StringValue `tfsdk:"bridge_domain"`
	Description                   basetypes.StringValue `tfsdk:"description"`
	Egress                        basetypes.ObjectValue `tfsdk:"egress"`
	Ingress                       basetypes.ObjectValue `tfsdk:"ingress"`
	Interface                     basetypes.StringValue `tfsdk:"interface"`
	L2Mtu                         basetypes.Int64Value  `tfsdk:"l2_mtu"`
	MacDuplicationDetectionAction basetypes.StringValue `tfsdk:"mac_duplication_detection_action"`
	SplitHorizonGroup             basetypes.StringValue `tfsdk:"split_horizon_group"`
	Uplink                        basetypes.ObjectValue `tfsdk:"uplink"`
	VlanId                        basetypes.StringValue `tfsdk:"vlan_id"`
	state                         attr.ValueState
}

func (v Spec2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["bridge_domain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["egress"] = basetypes.ObjectType{
		AttrTypes: EgressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ingress"] = basetypes.ObjectType{
		AttrTypes: IngressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l2_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mac_duplication_detection_action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["split_horizon_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uplink"] = basetypes.ObjectType{
		AttrTypes: UplinkValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.BridgeDomain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bridge_domain"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Egress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress"] = val

		val, err = v.Ingress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.L2Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l2_mtu"] = val

		val, err = v.MacDuplicationDetectionAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_duplication_detection_action"] = val

		val, err = v.SplitHorizonGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["split_horizon_group"] = val

		val, err = v.Uplink.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uplink"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec2Value) String() string {
	return "Spec2Value"
}

func (v Spec2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var egress basetypes.ObjectValue

	if v.Egress.IsNull() {
		egress = types.ObjectNull(
			EgressValue{}.AttributeTypes(ctx),
		)
	}

	if v.Egress.IsUnknown() {
		egress = types.ObjectUnknown(
			EgressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Egress.IsNull() && !v.Egress.IsUnknown() {
		egress = types.ObjectValueMust(
			EgressValue{}.AttributeTypes(ctx),
			v.Egress.Attributes(),
		)
	}

	var ingress basetypes.ObjectValue

	if v.Ingress.IsNull() {
		ingress = types.ObjectNull(
			IngressValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ingress.IsUnknown() {
		ingress = types.ObjectUnknown(
			IngressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ingress.IsNull() && !v.Ingress.IsUnknown() {
		ingress = types.ObjectValueMust(
			IngressValue{}.AttributeTypes(ctx),
			v.Ingress.Attributes(),
		)
	}

	var uplink basetypes.ObjectValue

	if v.Uplink.IsNull() {
		uplink = types.ObjectNull(
			UplinkValue{}.AttributeTypes(ctx),
		)
	}

	if v.Uplink.IsUnknown() {
		uplink = types.ObjectUnknown(
			UplinkValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Uplink.IsNull() && !v.Uplink.IsUnknown() {
		uplink = types.ObjectValueMust(
			UplinkValue{}.AttributeTypes(ctx),
			v.Uplink.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bridge_domain": basetypes.StringType{},
		"description":   basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: EgressValue{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: IngressValue{}.AttributeTypes(ctx),
		},
		"interface":                        basetypes.StringType{},
		"l2_mtu":                           basetypes.Int64Type{},
		"mac_duplication_detection_action": basetypes.StringType{},
		"split_horizon_group":              basetypes.StringType{},
		"uplink": basetypes.ObjectType{
			AttrTypes: UplinkValue{}.AttributeTypes(ctx),
		},
		"vlan_id": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bridge_domain":                    v.BridgeDomain,
			"description":                      v.Description,
			"egress":                           egress,
			"ingress":                          ingress,
			"interface":                        v.Interface,
			"l2_mtu":                           v.L2Mtu,
			"mac_duplication_detection_action": v.MacDuplicationDetectionAction,
			"split_horizon_group":              v.SplitHorizonGroup,
			"uplink":                           uplink,
			"vlan_id":                          v.VlanId,
		})

	return objVal, diags
}

func (v Spec2Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BridgeDomain.Equal(other.BridgeDomain) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Egress.Equal(other.Egress) {
		return false
	}

	if !v.Ingress.Equal(other.Ingress) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.L2Mtu.Equal(other.L2Mtu) {
		return false
	}

	if !v.MacDuplicationDetectionAction.Equal(other.MacDuplicationDetectionAction) {
		return false
	}

	if !v.SplitHorizonGroup.Equal(other.SplitHorizonGroup) {
		return false
	}

	if !v.Uplink.Equal(other.Uplink) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v Spec2Value) Type(ctx context.Context) attr.Type {
	return Spec2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bridge_domain": basetypes.StringType{},
		"description":   basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: EgressValue{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: IngressValue{}.AttributeTypes(ctx),
		},
		"interface":                        basetypes.StringType{},
		"l2_mtu":                           basetypes.Int64Type{},
		"mac_duplication_detection_action": basetypes.StringType{},
		"split_horizon_group":              basetypes.StringType{},
		"uplink": basetypes.ObjectType{
			AttrTypes: UplinkValue{}.AttributeTypes(ctx),
		},
		"vlan_id": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = EgressType{}

type EgressType struct {
	basetypes.ObjectType
}

func (t EgressType) Equal(o attr.Type) bool {
	other, ok := o.(EgressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EgressType) String() string {
	return "EgressType"
}

func (t EgressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EgressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgressValueNull() EgressValue {
	return EgressValue{
		state: attr.ValueStateNull,
	}
}

func NewEgressValueUnknown() EgressValue {
	return EgressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEgressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EgressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EgressValue Attribute Value",
				"While creating a EgressValue value, a missing attribute value was detected. "+
					"A EgressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EgressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EgressValue Attribute Type",
				"While creating a EgressValue value, an invalid attribute value was detected. "+
					"A EgressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EgressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EgressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EgressValue Attribute Value",
				"While creating a EgressValue value, an extra attribute value was detected. "+
					"A EgressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EgressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEgressValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewEgressValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewEgressValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewEgressValueUnknown(), diags
	}

	return EgressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EgressValue {
	object, diags := NewEgressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEgressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EgressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEgressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEgressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEgressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEgressValueMust(EgressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EgressType) ValueType(ctx context.Context) attr.Value {
	return EgressValue{}
}

var _ basetypes.ObjectValuable = EgressValue{}

type EgressValue struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v EgressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EgressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EgressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EgressValue) String() string {
	return "EgressValue"
}

func (v EgressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v EgressValue) Equal(o attr.Value) bool {
	other, ok := o.(EgressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v EgressValue) Type(ctx context.Context) attr.Type {
	return EgressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EgressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = IngressType{}

type IngressType struct {
	basetypes.ObjectType
}

func (t IngressType) Equal(o attr.Type) bool {
	other, ok := o.(IngressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IngressType) String() string {
	return "IngressType"
}

func (t IngressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IngressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngressValueNull() IngressValue {
	return IngressValue{
		state: attr.ValueStateNull,
	}
}

func NewIngressValueUnknown() IngressValue {
	return IngressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIngressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IngressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IngressValue Attribute Value",
				"While creating a IngressValue value, a missing attribute value was detected. "+
					"A IngressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IngressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IngressValue Attribute Type",
				"While creating a IngressValue value, an invalid attribute value was detected. "+
					"A IngressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IngressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IngressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IngressValue Attribute Value",
				"While creating a IngressValue value, an extra attribute value was detected. "+
					"A IngressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IngressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIngressValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewIngressValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewIngressValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewIngressValueUnknown(), diags
	}

	return IngressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IngressValue {
	object, diags := NewIngressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIngressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IngressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIngressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIngressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIngressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIngressValueMust(IngressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IngressType) ValueType(ctx context.Context) attr.Value {
	return IngressValue{}
}

var _ basetypes.ObjectValuable = IngressValue{}

type IngressValue struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v IngressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IngressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IngressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IngressValue) String() string {
	return "IngressValue"
}

func (v IngressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v IngressValue) Equal(o attr.Value) bool {
	other, ok := o.(IngressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v IngressValue) Type(ctx context.Context) attr.Type {
	return IngressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IngressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = UplinkType{}

type UplinkType struct {
	basetypes.ObjectType
}

func (t UplinkType) Equal(o attr.Type) bool {
	other, ok := o.(UplinkType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t UplinkType) String() string {
	return "UplinkType"
}

func (t UplinkType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	egress1Attribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_1 is missing from object`)

		return nil, diags
	}

	egress1Val, ok := egress1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_1 expected to be basetypes.ObjectValue, was: %T`, egress1Attribute))
	}

	ingress1Attribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_1 is missing from object`)

		return nil, diags
	}

	ingress1Val, ok := ingress1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_1 expected to be basetypes.ObjectValue, was: %T`, ingress1Attribute))
	}

	uplinkSelectorAttribute, ok := attributes["uplink_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_selector is missing from object`)

		return nil, diags
	}

	uplinkSelectorVal, ok := uplinkSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_selector expected to be basetypes.ListValue, was: %T`, uplinkSelectorAttribute))
	}

	uplinkVlanIdAttribute, ok := attributes["uplink_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_vlan_id is missing from object`)

		return nil, diags
	}

	uplinkVlanIdVal, ok := uplinkVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_vlan_id expected to be basetypes.StringValue, was: %T`, uplinkVlanIdAttribute))
	}

	uplinkVlanPoolAttribute, ok := attributes["uplink_vlan_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_vlan_pool is missing from object`)

		return nil, diags
	}

	uplinkVlanPoolVal, ok := uplinkVlanPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_vlan_pool expected to be basetypes.StringValue, was: %T`, uplinkVlanPoolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return UplinkValue{
		Egress1:        egress1Val,
		Ingress1:       ingress1Val,
		UplinkSelector: uplinkSelectorVal,
		UplinkVlanId:   uplinkVlanIdVal,
		UplinkVlanPool: uplinkVlanPoolVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewUplinkValueNull() UplinkValue {
	return UplinkValue{
		state: attr.ValueStateNull,
	}
}

func NewUplinkValueUnknown() UplinkValue {
	return UplinkValue{
		state: attr.ValueStateUnknown,
	}
}

func NewUplinkValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (UplinkValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing UplinkValue Attribute Value",
				"While creating a UplinkValue value, a missing attribute value was detected. "+
					"A UplinkValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UplinkValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid UplinkValue Attribute Type",
				"While creating a UplinkValue value, an invalid attribute value was detected. "+
					"A UplinkValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("UplinkValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("UplinkValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra UplinkValue Attribute Value",
				"While creating a UplinkValue value, an extra attribute value was detected. "+
					"A UplinkValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra UplinkValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUplinkValueUnknown(), diags
	}

	egress1Attribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_1 is missing from object`)

		return NewUplinkValueUnknown(), diags
	}

	egress1Val, ok := egress1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_1 expected to be basetypes.ObjectValue, was: %T`, egress1Attribute))
	}

	ingress1Attribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_1 is missing from object`)

		return NewUplinkValueUnknown(), diags
	}

	ingress1Val, ok := ingress1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_1 expected to be basetypes.ObjectValue, was: %T`, ingress1Attribute))
	}

	uplinkSelectorAttribute, ok := attributes["uplink_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_selector is missing from object`)

		return NewUplinkValueUnknown(), diags
	}

	uplinkSelectorVal, ok := uplinkSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_selector expected to be basetypes.ListValue, was: %T`, uplinkSelectorAttribute))
	}

	uplinkVlanIdAttribute, ok := attributes["uplink_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_vlan_id is missing from object`)

		return NewUplinkValueUnknown(), diags
	}

	uplinkVlanIdVal, ok := uplinkVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_vlan_id expected to be basetypes.StringValue, was: %T`, uplinkVlanIdAttribute))
	}

	uplinkVlanPoolAttribute, ok := attributes["uplink_vlan_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_vlan_pool is missing from object`)

		return NewUplinkValueUnknown(), diags
	}

	uplinkVlanPoolVal, ok := uplinkVlanPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_vlan_pool expected to be basetypes.StringValue, was: %T`, uplinkVlanPoolAttribute))
	}

	if diags.HasError() {
		return NewUplinkValueUnknown(), diags
	}

	return UplinkValue{
		Egress1:        egress1Val,
		Ingress1:       ingress1Val,
		UplinkSelector: uplinkSelectorVal,
		UplinkVlanId:   uplinkVlanIdVal,
		UplinkVlanPool: uplinkVlanPoolVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewUplinkValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) UplinkValue {
	object, diags := NewUplinkValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUplinkValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t UplinkType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUplinkValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUplinkValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUplinkValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUplinkValueMust(UplinkValue{}.AttributeTypes(ctx), attributes), nil
}

func (t UplinkType) ValueType(ctx context.Context) attr.Value {
	return UplinkValue{}
}

var _ basetypes.ObjectValuable = UplinkValue{}

type UplinkValue struct {
	Egress1        basetypes.ObjectValue `tfsdk:"egress"`
	Ingress1       basetypes.ObjectValue `tfsdk:"ingress"`
	UplinkSelector basetypes.ListValue   `tfsdk:"uplink_selector"`
	UplinkVlanId   basetypes.StringValue `tfsdk:"uplink_vlan_id"`
	UplinkVlanPool basetypes.StringValue `tfsdk:"uplink_vlan_pool"`
	state          attr.ValueState
}

func (v UplinkValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["egress"] = basetypes.ObjectType{
		AttrTypes: Egress1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ingress"] = basetypes.ObjectType{
		AttrTypes: Ingress1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["uplink_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["uplink_vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uplink_vlan_pool"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Egress1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress"] = val

		val, err = v.Ingress1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress"] = val

		val, err = v.UplinkSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uplink_selector"] = val

		val, err = v.UplinkVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uplink_vlan_id"] = val

		val, err = v.UplinkVlanPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uplink_vlan_pool"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v UplinkValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v UplinkValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v UplinkValue) String() string {
	return "UplinkValue"
}

func (v UplinkValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var egress1 basetypes.ObjectValue

	if v.Egress1.IsNull() {
		egress1 = types.ObjectNull(
			Egress1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Egress1.IsUnknown() {
		egress1 = types.ObjectUnknown(
			Egress1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Egress1.IsNull() && !v.Egress1.IsUnknown() {
		egress1 = types.ObjectValueMust(
			Egress1Value{}.AttributeTypes(ctx),
			v.Egress1.Attributes(),
		)
	}

	var ingress1 basetypes.ObjectValue

	if v.Ingress1.IsNull() {
		ingress1 = types.ObjectNull(
			Ingress1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ingress1.IsUnknown() {
		ingress1 = types.ObjectUnknown(
			Ingress1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ingress1.IsNull() && !v.Ingress1.IsUnknown() {
		ingress1 = types.ObjectValueMust(
			Ingress1Value{}.AttributeTypes(ctx),
			v.Ingress1.Attributes(),
		)
	}

	var uplinkSelectorVal basetypes.ListValue
	switch {
	case v.UplinkSelector.IsUnknown():
		uplinkSelectorVal = types.ListUnknown(types.StringType)
	case v.UplinkSelector.IsNull():
		uplinkSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		uplinkSelectorVal, d = types.ListValue(types.StringType, v.UplinkSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"egress": basetypes.ObjectType{
				AttrTypes: Egress1Value{}.AttributeTypes(ctx),
			},
			"ingress": basetypes.ObjectType{
				AttrTypes: Ingress1Value{}.AttributeTypes(ctx),
			},
			"uplink_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"uplink_vlan_id":   basetypes.StringType{},
			"uplink_vlan_pool": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"egress": basetypes.ObjectType{
			AttrTypes: Egress1Value{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: Ingress1Value{}.AttributeTypes(ctx),
		},
		"uplink_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"uplink_vlan_id":   basetypes.StringType{},
		"uplink_vlan_pool": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"egress":           egress1,
			"ingress":          ingress1,
			"uplink_selector":  uplinkSelectorVal,
			"uplink_vlan_id":   v.UplinkVlanId,
			"uplink_vlan_pool": v.UplinkVlanPool,
		})

	return objVal, diags
}

func (v UplinkValue) Equal(o attr.Value) bool {
	other, ok := o.(UplinkValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Egress1.Equal(other.Egress1) {
		return false
	}

	if !v.Ingress1.Equal(other.Ingress1) {
		return false
	}

	if !v.UplinkSelector.Equal(other.UplinkSelector) {
		return false
	}

	if !v.UplinkVlanId.Equal(other.UplinkVlanId) {
		return false
	}

	if !v.UplinkVlanPool.Equal(other.UplinkVlanPool) {
		return false
	}

	return true
}

func (v UplinkValue) Type(ctx context.Context) attr.Type {
	return UplinkType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v UplinkValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"egress": basetypes.ObjectType{
			AttrTypes: Egress1Value{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: Ingress1Value{}.AttributeTypes(ctx),
		},
		"uplink_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"uplink_vlan_id":   basetypes.StringType{},
		"uplink_vlan_pool": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Egress1Type{}

type Egress1Type struct {
	basetypes.ObjectType
}

func (t Egress1Type) Equal(o attr.Type) bool {
	other, ok := o.(Egress1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Egress1Type) String() string {
	return "Egress1Type"
}

func (t Egress1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Egress1Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgress1ValueNull() Egress1Value {
	return Egress1Value{
		state: attr.ValueStateNull,
	}
}

func NewEgress1ValueUnknown() Egress1Value {
	return Egress1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewEgress1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Egress1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Egress1Value Attribute Value",
				"While creating a Egress1Value value, a missing attribute value was detected. "+
					"A Egress1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Egress1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Egress1Value Attribute Type",
				"While creating a Egress1Value value, an invalid attribute value was detected. "+
					"A Egress1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Egress1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Egress1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Egress1Value Attribute Value",
				"While creating a Egress1Value value, an extra attribute value was detected. "+
					"A Egress1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Egress1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEgress1ValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewEgress1ValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewEgress1ValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewEgress1ValueUnknown(), diags
	}

	return Egress1Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgress1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Egress1Value {
	object, diags := NewEgress1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEgress1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Egress1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEgress1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEgress1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEgress1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEgress1ValueMust(Egress1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Egress1Type) ValueType(ctx context.Context) attr.Value {
	return Egress1Value{}
}

var _ basetypes.ObjectValuable = Egress1Value{}

type Egress1Value struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v Egress1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Egress1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Egress1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Egress1Value) String() string {
	return "Egress1Value"
}

func (v Egress1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v Egress1Value) Equal(o attr.Value) bool {
	other, ok := o.(Egress1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v Egress1Value) Type(ctx context.Context) attr.Type {
	return Egress1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Egress1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Ingress1Type{}

type Ingress1Type struct {
	basetypes.ObjectType
}

func (t Ingress1Type) Equal(o attr.Type) bool {
	other, ok := o.(Ingress1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ingress1Type) String() string {
	return "Ingress1Type"
}

func (t Ingress1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ingress1Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngress1ValueNull() Ingress1Value {
	return Ingress1Value{
		state: attr.ValueStateNull,
	}
}

func NewIngress1ValueUnknown() Ingress1Value {
	return Ingress1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIngress1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ingress1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ingress1Value Attribute Value",
				"While creating a Ingress1Value value, a missing attribute value was detected. "+
					"A Ingress1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ingress1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ingress1Value Attribute Type",
				"While creating a Ingress1Value value, an invalid attribute value was detected. "+
					"A Ingress1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ingress1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ingress1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ingress1Value Attribute Value",
				"While creating a Ingress1Value value, an extra attribute value was detected. "+
					"A Ingress1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ingress1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIngress1ValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewIngress1ValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewIngress1ValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewIngress1ValueUnknown(), diags
	}

	return Ingress1Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngress1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ingress1Value {
	object, diags := NewIngress1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIngress1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ingress1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIngress1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIngress1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIngress1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIngress1ValueMust(Ingress1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ingress1Type) ValueType(ctx context.Context) attr.Value {
	return Ingress1Value{}
}

var _ basetypes.ObjectValuable = Ingress1Value{}

type Ingress1Value struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v Ingress1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ingress1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ingress1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ingress1Value) String() string {
	return "Ingress1Value"
}

func (v Ingress1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v Ingress1Value) Equal(o attr.Value) bool {
	other, ok := o.(Ingress1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v Ingress1Value) Type(ctx context.Context) attr.Type {
	return Ingress1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ingress1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = IrbInterfacesType{}

type IrbInterfacesType struct {
	basetypes.ObjectType
}

func (t IrbInterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(IrbInterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IrbInterfacesType) String() string {
	return "IrbInterfacesType"
}

func (t IrbInterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec3Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_3 is missing from object`)

		return nil, diags
	}

	spec3Val, ok := spec3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_3 expected to be basetypes.ObjectValue, was: %T`, spec3Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IrbInterfacesValue{
		Name:  nameVal,
		Spec3: spec3Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewIrbInterfacesValueNull() IrbInterfacesValue {
	return IrbInterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewIrbInterfacesValueUnknown() IrbInterfacesValue {
	return IrbInterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIrbInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IrbInterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IrbInterfacesValue Attribute Value",
				"While creating a IrbInterfacesValue value, a missing attribute value was detected. "+
					"A IrbInterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IrbInterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IrbInterfacesValue Attribute Type",
				"While creating a IrbInterfacesValue value, an invalid attribute value was detected. "+
					"A IrbInterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IrbInterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IrbInterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IrbInterfacesValue Attribute Value",
				"While creating a IrbInterfacesValue value, an extra attribute value was detected. "+
					"A IrbInterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IrbInterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIrbInterfacesValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewIrbInterfacesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec3Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_3 is missing from object`)

		return NewIrbInterfacesValueUnknown(), diags
	}

	spec3Val, ok := spec3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_3 expected to be basetypes.ObjectValue, was: %T`, spec3Attribute))
	}

	if diags.HasError() {
		return NewIrbInterfacesValueUnknown(), diags
	}

	return IrbInterfacesValue{
		Name:  nameVal,
		Spec3: spec3Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewIrbInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IrbInterfacesValue {
	object, diags := NewIrbInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIrbInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IrbInterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIrbInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIrbInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIrbInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIrbInterfacesValueMust(IrbInterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IrbInterfacesType) ValueType(ctx context.Context) attr.Value {
	return IrbInterfacesValue{}
}

var _ basetypes.ObjectValuable = IrbInterfacesValue{}

type IrbInterfacesValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Spec3 basetypes.ObjectValue `tfsdk:"spec"`
	state attr.ValueState
}

func (v IrbInterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec3Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Spec3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IrbInterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IrbInterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IrbInterfacesValue) String() string {
	return "IrbInterfacesValue"
}

func (v IrbInterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spec3 basetypes.ObjectValue

	if v.Spec3.IsNull() {
		spec3 = types.ObjectNull(
			Spec3Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec3.IsUnknown() {
		spec3 = types.ObjectUnknown(
			Spec3Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec3.IsNull() && !v.Spec3.IsUnknown() {
		spec3 = types.ObjectValueMust(
			Spec3Value{}.AttributeTypes(ctx),
			v.Spec3.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec3Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"spec": spec3,
		})

	return objVal, diags
}

func (v IrbInterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(IrbInterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Spec3.Equal(other.Spec3) {
		return false
	}

	return true
}

func (v IrbInterfacesValue) Type(ctx context.Context) attr.Type {
	return IrbInterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IrbInterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec3Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Spec3Type{}

type Spec3Type struct {
	basetypes.ObjectType
}

func (t Spec3Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec3Type) String() string {
	return "Spec3Type"
}

func (t Spec3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	anycastGatewayMacAttribute, ok := attributes["anycast_gateway_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anycast_gateway_mac is missing from object`)

		return nil, diags
	}

	anycastGatewayMacVal, ok := anycastGatewayMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anycast_gateway_mac expected to be basetypes.StringValue, was: %T`, anycastGatewayMacAttribute))
	}

	arpTimeoutAttribute, ok := attributes["arp_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_timeout is missing from object`)

		return nil, diags
	}

	arpTimeoutVal, ok := arpTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_timeout expected to be basetypes.Int64Value, was: %T`, arpTimeoutAttribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return nil, diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	bridgeDomainAttribute, ok := attributes["bridge_domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_domain is missing from object`)

		return nil, diags
	}

	bridgeDomainVal, ok := bridgeDomainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_domain expected to be basetypes.StringValue, was: %T`, bridgeDomainAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egress2Attribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_2 is missing from object`)

		return nil, diags
	}

	egress2Val, ok := egress2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_2 expected to be basetypes.ObjectValue, was: %T`, egress2Attribute))
	}

	evpnRouteAdvertisementTypeAttribute, ok := attributes["evpn_route_advertisement_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_route_advertisement_type is missing from object`)

		return nil, diags
	}

	evpnRouteAdvertisementTypeVal, ok := evpnRouteAdvertisementTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_route_advertisement_type expected to be basetypes.ObjectValue, was: %T`, evpnRouteAdvertisementTypeAttribute))
	}

	hostRoutePopulateAttribute, ok := attributes["host_route_populate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_route_populate is missing from object`)

		return nil, diags
	}

	hostRoutePopulateVal, ok := hostRoutePopulateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_route_populate expected to be basetypes.ObjectValue, was: %T`, hostRoutePopulateAttribute))
	}

	ingress2Attribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_2 is missing from object`)

		return nil, diags
	}

	ingress2Val, ok := ingress2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_2 expected to be basetypes.ObjectValue, was: %T`, ingress2Attribute))
	}

	ipAddressesAttribute, ok := attributes["ip_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_addresses is missing from object`)

		return nil, diags
	}

	ipAddressesVal, ok := ipAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_addresses expected to be basetypes.ListValue, was: %T`, ipAddressesAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return nil, diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	ipv4ParametersAttribute, ok := attributes["ipv4_parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_parameters is missing from object`)

		return nil, diags
	}

	ipv4ParametersVal, ok := ipv4ParametersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_parameters expected to be basetypes.ObjectValue, was: %T`, ipv4ParametersAttribute))
	}

	ipv6RouterAdvertisementAttribute, ok := attributes["ipv6_router_advertisement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_router_advertisement is missing from object`)

		return nil, diags
	}

	ipv6RouterAdvertisementVal, ok := ipv6RouterAdvertisementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_router_advertisement expected to be basetypes.ObjectValue, was: %T`, ipv6RouterAdvertisementAttribute))
	}

	l3proxyArpndAttribute, ok := attributes["l3proxy_arpnd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3proxy_arpnd is missing from object`)

		return nil, diags
	}

	l3proxyArpndVal, ok := l3proxyArpndAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3proxy_arpnd expected to be basetypes.ObjectValue, was: %T`, l3proxyArpndAttribute))
	}

	learnUnsolicitedAttribute, ok := attributes["learn_unsolicited"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`learn_unsolicited is missing from object`)

		return nil, diags
	}

	learnUnsolicitedVal, ok := learnUnsolicitedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`learn_unsolicited expected to be basetypes.StringValue, was: %T`, learnUnsolicitedAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return nil, diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return nil, diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	virtualIpDiscoveryAttribute, ok := attributes["virtual_ip_discovery"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`virtual_ip_discovery is missing from object`)

		return nil, diags
	}

	virtualIpDiscoveryVal, ok := virtualIpDiscoveryAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`virtual_ip_discovery expected to be basetypes.ListValue, was: %T`, virtualIpDiscoveryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec3Value{
		AnycastGatewayMac:          anycastGatewayMacVal,
		ArpTimeout:                 arpTimeoutVal,
		Bfd:                        bfdVal,
		BridgeDomain:               bridgeDomainVal,
		Description:                descriptionVal,
		Egress2:                    egress2Val,
		EvpnRouteAdvertisementType: evpnRouteAdvertisementTypeVal,
		HostRoutePopulate:          hostRoutePopulateVal,
		Ingress2:                   ingress2Val,
		IpAddresses:                ipAddressesVal,
		IpMtu:                      ipMtuVal,
		Ipv4Parameters:             ipv4ParametersVal,
		Ipv6RouterAdvertisement:    ipv6RouterAdvertisementVal,
		L3proxyArpnd:               l3proxyArpndVal,
		LearnUnsolicited:           learnUnsolicitedVal,
		Router:                     routerVal,
		Unnumbered:                 unnumberedVal,
		VirtualIpDiscovery:         virtualIpDiscoveryVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewSpec3ValueNull() Spec3Value {
	return Spec3Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec3ValueUnknown() Spec3Value {
	return Spec3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec3Value Attribute Value",
				"While creating a Spec3Value value, a missing attribute value was detected. "+
					"A Spec3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec3Value Attribute Type",
				"While creating a Spec3Value value, an invalid attribute value was detected. "+
					"A Spec3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec3Value Attribute Value",
				"While creating a Spec3Value value, an extra attribute value was detected. "+
					"A Spec3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec3ValueUnknown(), diags
	}

	anycastGatewayMacAttribute, ok := attributes["anycast_gateway_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`anycast_gateway_mac is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	anycastGatewayMacVal, ok := anycastGatewayMacAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`anycast_gateway_mac expected to be basetypes.StringValue, was: %T`, anycastGatewayMacAttribute))
	}

	arpTimeoutAttribute, ok := attributes["arp_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_timeout is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	arpTimeoutVal, ok := arpTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_timeout expected to be basetypes.Int64Value, was: %T`, arpTimeoutAttribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	bridgeDomainAttribute, ok := attributes["bridge_domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_domain is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	bridgeDomainVal, ok := bridgeDomainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_domain expected to be basetypes.StringValue, was: %T`, bridgeDomainAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egress2Attribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_2 is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	egress2Val, ok := egress2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_2 expected to be basetypes.ObjectValue, was: %T`, egress2Attribute))
	}

	evpnRouteAdvertisementTypeAttribute, ok := attributes["evpn_route_advertisement_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_route_advertisement_type is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	evpnRouteAdvertisementTypeVal, ok := evpnRouteAdvertisementTypeAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_route_advertisement_type expected to be basetypes.ObjectValue, was: %T`, evpnRouteAdvertisementTypeAttribute))
	}

	hostRoutePopulateAttribute, ok := attributes["host_route_populate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_route_populate is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	hostRoutePopulateVal, ok := hostRoutePopulateAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_route_populate expected to be basetypes.ObjectValue, was: %T`, hostRoutePopulateAttribute))
	}

	ingress2Attribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_2 is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	ingress2Val, ok := ingress2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_2 expected to be basetypes.ObjectValue, was: %T`, ingress2Attribute))
	}

	ipAddressesAttribute, ok := attributes["ip_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_addresses is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	ipAddressesVal, ok := ipAddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_addresses expected to be basetypes.ListValue, was: %T`, ipAddressesAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	ipv4ParametersAttribute, ok := attributes["ipv4_parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_parameters is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	ipv4ParametersVal, ok := ipv4ParametersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_parameters expected to be basetypes.ObjectValue, was: %T`, ipv4ParametersAttribute))
	}

	ipv6RouterAdvertisementAttribute, ok := attributes["ipv6_router_advertisement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_router_advertisement is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	ipv6RouterAdvertisementVal, ok := ipv6RouterAdvertisementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_router_advertisement expected to be basetypes.ObjectValue, was: %T`, ipv6RouterAdvertisementAttribute))
	}

	l3proxyArpndAttribute, ok := attributes["l3proxy_arpnd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3proxy_arpnd is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	l3proxyArpndVal, ok := l3proxyArpndAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3proxy_arpnd expected to be basetypes.ObjectValue, was: %T`, l3proxyArpndAttribute))
	}

	learnUnsolicitedAttribute, ok := attributes["learn_unsolicited"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`learn_unsolicited is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	learnUnsolicitedVal, ok := learnUnsolicitedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`learn_unsolicited expected to be basetypes.StringValue, was: %T`, learnUnsolicitedAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	virtualIpDiscoveryAttribute, ok := attributes["virtual_ip_discovery"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`virtual_ip_discovery is missing from object`)

		return NewSpec3ValueUnknown(), diags
	}

	virtualIpDiscoveryVal, ok := virtualIpDiscoveryAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`virtual_ip_discovery expected to be basetypes.ListValue, was: %T`, virtualIpDiscoveryAttribute))
	}

	if diags.HasError() {
		return NewSpec3ValueUnknown(), diags
	}

	return Spec3Value{
		AnycastGatewayMac:          anycastGatewayMacVal,
		ArpTimeout:                 arpTimeoutVal,
		Bfd:                        bfdVal,
		BridgeDomain:               bridgeDomainVal,
		Description:                descriptionVal,
		Egress2:                    egress2Val,
		EvpnRouteAdvertisementType: evpnRouteAdvertisementTypeVal,
		HostRoutePopulate:          hostRoutePopulateVal,
		Ingress2:                   ingress2Val,
		IpAddresses:                ipAddressesVal,
		IpMtu:                      ipMtuVal,
		Ipv4Parameters:             ipv4ParametersVal,
		Ipv6RouterAdvertisement:    ipv6RouterAdvertisementVal,
		L3proxyArpnd:               l3proxyArpndVal,
		LearnUnsolicited:           learnUnsolicitedVal,
		Router:                     routerVal,
		Unnumbered:                 unnumberedVal,
		VirtualIpDiscovery:         virtualIpDiscoveryVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewSpec3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec3Value {
	object, diags := NewSpec3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec3ValueMust(Spec3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec3Type) ValueType(ctx context.Context) attr.Value {
	return Spec3Value{}
}

var _ basetypes.ObjectValuable = Spec3Value{}

type Spec3Value struct {
	AnycastGatewayMac          basetypes.StringValue `tfsdk:"anycast_gateway_mac"`
	ArpTimeout                 basetypes.Int64Value  `tfsdk:"arp_timeout"`
	Bfd                        basetypes.ObjectValue `tfsdk:"bfd"`
	BridgeDomain               basetypes.StringValue `tfsdk:"bridge_domain"`
	Description                basetypes.StringValue `tfsdk:"description"`
	Egress2                    basetypes.ObjectValue `tfsdk:"egress"`
	EvpnRouteAdvertisementType basetypes.ObjectValue `tfsdk:"evpn_route_advertisement_type"`
	HostRoutePopulate          basetypes.ObjectValue `tfsdk:"host_route_populate"`
	Ingress2                   basetypes.ObjectValue `tfsdk:"ingress"`
	IpAddresses                basetypes.ListValue   `tfsdk:"ip_addresses"`
	IpMtu                      basetypes.Int64Value  `tfsdk:"ip_mtu"`
	Ipv4Parameters             basetypes.ObjectValue `tfsdk:"ipv4_parameters"`
	Ipv6RouterAdvertisement    basetypes.ObjectValue `tfsdk:"ipv6_router_advertisement"`
	L3proxyArpnd               basetypes.ObjectValue `tfsdk:"l3proxy_arpnd"`
	LearnUnsolicited           basetypes.StringValue `tfsdk:"learn_unsolicited"`
	Router                     basetypes.StringValue `tfsdk:"router"`
	Unnumbered                 basetypes.StringValue `tfsdk:"unnumbered"`
	VirtualIpDiscovery         basetypes.ListValue   `tfsdk:"virtual_ip_discovery"`
	state                      attr.ValueState
}

func (v Spec3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 18)

	var val tftypes.Value
	var err error

	attrTypes["anycast_gateway_mac"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["arp_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["bfd"] = basetypes.ObjectType{
		AttrTypes: BfdValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["bridge_domain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["egress"] = basetypes.ObjectType{
		AttrTypes: Egress2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["evpn_route_advertisement_type"] = basetypes.ObjectType{
		AttrTypes: EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["host_route_populate"] = basetypes.ObjectType{
		AttrTypes: HostRoutePopulateValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ingress"] = basetypes.ObjectType{
		AttrTypes: Ingress2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_addresses"] = basetypes.ListType{
		ElemType: IpAddressesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ipv4_parameters"] = basetypes.ObjectType{
		AttrTypes: Ipv4ParametersValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6_router_advertisement"] = basetypes.ObjectType{
		AttrTypes: Ipv6RouterAdvertisementValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["l3proxy_arpnd"] = basetypes.ObjectType{
		AttrTypes: L3proxyArpndValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["learn_unsolicited"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["router"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["unnumbered"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["virtual_ip_discovery"] = basetypes.ListType{
		ElemType: VirtualIpDiscoveryValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 18)

		val, err = v.AnycastGatewayMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["anycast_gateway_mac"] = val

		val, err = v.ArpTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_timeout"] = val

		val, err = v.Bfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.BridgeDomain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bridge_domain"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Egress2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress"] = val

		val, err = v.EvpnRouteAdvertisementType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpn_route_advertisement_type"] = val

		val, err = v.HostRoutePopulate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host_route_populate"] = val

		val, err = v.Ingress2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress"] = val

		val, err = v.IpAddresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_addresses"] = val

		val, err = v.IpMtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_mtu"] = val

		val, err = v.Ipv4Parameters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_parameters"] = val

		val, err = v.Ipv6RouterAdvertisement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_router_advertisement"] = val

		val, err = v.L3proxyArpnd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3proxy_arpnd"] = val

		val, err = v.LearnUnsolicited.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["learn_unsolicited"] = val

		val, err = v.Router.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router"] = val

		val, err = v.Unnumbered.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unnumbered"] = val

		val, err = v.VirtualIpDiscovery.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["virtual_ip_discovery"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec3Value) String() string {
	return "Spec3Value"
}

func (v Spec3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bfd basetypes.ObjectValue

	if v.Bfd.IsNull() {
		bfd = types.ObjectNull(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bfd.IsUnknown() {
		bfd = types.ObjectUnknown(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bfd.IsNull() && !v.Bfd.IsUnknown() {
		bfd = types.ObjectValueMust(
			BfdValue{}.AttributeTypes(ctx),
			v.Bfd.Attributes(),
		)
	}

	var egress2 basetypes.ObjectValue

	if v.Egress2.IsNull() {
		egress2 = types.ObjectNull(
			Egress2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Egress2.IsUnknown() {
		egress2 = types.ObjectUnknown(
			Egress2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Egress2.IsNull() && !v.Egress2.IsUnknown() {
		egress2 = types.ObjectValueMust(
			Egress2Value{}.AttributeTypes(ctx),
			v.Egress2.Attributes(),
		)
	}

	var evpnRouteAdvertisementType basetypes.ObjectValue

	if v.EvpnRouteAdvertisementType.IsNull() {
		evpnRouteAdvertisementType = types.ObjectNull(
			EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
		)
	}

	if v.EvpnRouteAdvertisementType.IsUnknown() {
		evpnRouteAdvertisementType = types.ObjectUnknown(
			EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
		)
	}

	if !v.EvpnRouteAdvertisementType.IsNull() && !v.EvpnRouteAdvertisementType.IsUnknown() {
		evpnRouteAdvertisementType = types.ObjectValueMust(
			EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
			v.EvpnRouteAdvertisementType.Attributes(),
		)
	}

	var hostRoutePopulate basetypes.ObjectValue

	if v.HostRoutePopulate.IsNull() {
		hostRoutePopulate = types.ObjectNull(
			HostRoutePopulateValue{}.AttributeTypes(ctx),
		)
	}

	if v.HostRoutePopulate.IsUnknown() {
		hostRoutePopulate = types.ObjectUnknown(
			HostRoutePopulateValue{}.AttributeTypes(ctx),
		)
	}

	if !v.HostRoutePopulate.IsNull() && !v.HostRoutePopulate.IsUnknown() {
		hostRoutePopulate = types.ObjectValueMust(
			HostRoutePopulateValue{}.AttributeTypes(ctx),
			v.HostRoutePopulate.Attributes(),
		)
	}

	var ingress2 basetypes.ObjectValue

	if v.Ingress2.IsNull() {
		ingress2 = types.ObjectNull(
			Ingress2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ingress2.IsUnknown() {
		ingress2 = types.ObjectUnknown(
			Ingress2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ingress2.IsNull() && !v.Ingress2.IsUnknown() {
		ingress2 = types.ObjectValueMust(
			Ingress2Value{}.AttributeTypes(ctx),
			v.Ingress2.Attributes(),
		)
	}

	ipAddresses := types.ListValueMust(
		IpAddressesType{
			basetypes.ObjectType{
				AttrTypes: IpAddressesValue{}.AttributeTypes(ctx),
			},
		},
		v.IpAddresses.Elements(),
	)

	if v.IpAddresses.IsNull() {
		ipAddresses = types.ListNull(
			IpAddressesType{
				basetypes.ObjectType{
					AttrTypes: IpAddressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IpAddresses.IsUnknown() {
		ipAddresses = types.ListUnknown(
			IpAddressesType{
				basetypes.ObjectType{
					AttrTypes: IpAddressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var ipv4Parameters basetypes.ObjectValue

	if v.Ipv4Parameters.IsNull() {
		ipv4Parameters = types.ObjectNull(
			Ipv4ParametersValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv4Parameters.IsUnknown() {
		ipv4Parameters = types.ObjectUnknown(
			Ipv4ParametersValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv4Parameters.IsNull() && !v.Ipv4Parameters.IsUnknown() {
		ipv4Parameters = types.ObjectValueMust(
			Ipv4ParametersValue{}.AttributeTypes(ctx),
			v.Ipv4Parameters.Attributes(),
		)
	}

	var ipv6RouterAdvertisement basetypes.ObjectValue

	if v.Ipv6RouterAdvertisement.IsNull() {
		ipv6RouterAdvertisement = types.ObjectNull(
			Ipv6RouterAdvertisementValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv6RouterAdvertisement.IsUnknown() {
		ipv6RouterAdvertisement = types.ObjectUnknown(
			Ipv6RouterAdvertisementValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv6RouterAdvertisement.IsNull() && !v.Ipv6RouterAdvertisement.IsUnknown() {
		ipv6RouterAdvertisement = types.ObjectValueMust(
			Ipv6RouterAdvertisementValue{}.AttributeTypes(ctx),
			v.Ipv6RouterAdvertisement.Attributes(),
		)
	}

	var l3proxyArpnd basetypes.ObjectValue

	if v.L3proxyArpnd.IsNull() {
		l3proxyArpnd = types.ObjectNull(
			L3proxyArpndValue{}.AttributeTypes(ctx),
		)
	}

	if v.L3proxyArpnd.IsUnknown() {
		l3proxyArpnd = types.ObjectUnknown(
			L3proxyArpndValue{}.AttributeTypes(ctx),
		)
	}

	if !v.L3proxyArpnd.IsNull() && !v.L3proxyArpnd.IsUnknown() {
		l3proxyArpnd = types.ObjectValueMust(
			L3proxyArpndValue{}.AttributeTypes(ctx),
			v.L3proxyArpnd.Attributes(),
		)
	}

	virtualIpDiscovery := types.ListValueMust(
		VirtualIpDiscoveryType{
			basetypes.ObjectType{
				AttrTypes: VirtualIpDiscoveryValue{}.AttributeTypes(ctx),
			},
		},
		v.VirtualIpDiscovery.Elements(),
	)

	if v.VirtualIpDiscovery.IsNull() {
		virtualIpDiscovery = types.ListNull(
			VirtualIpDiscoveryType{
				basetypes.ObjectType{
					AttrTypes: VirtualIpDiscoveryValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.VirtualIpDiscovery.IsUnknown() {
		virtualIpDiscovery = types.ListUnknown(
			VirtualIpDiscoveryType{
				basetypes.ObjectType{
					AttrTypes: VirtualIpDiscoveryValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"anycast_gateway_mac": basetypes.StringType{},
		"arp_timeout":         basetypes.Int64Type{},
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"bridge_domain": basetypes.StringType{},
		"description":   basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: Egress2Value{}.AttributeTypes(ctx),
		},
		"evpn_route_advertisement_type": basetypes.ObjectType{
			AttrTypes: EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
		},
		"host_route_populate": basetypes.ObjectType{
			AttrTypes: HostRoutePopulateValue{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: Ingress2Value{}.AttributeTypes(ctx),
		},
		"ip_addresses": basetypes.ListType{
			ElemType: IpAddressesValue{}.Type(ctx),
		},
		"ip_mtu": basetypes.Int64Type{},
		"ipv4_parameters": basetypes.ObjectType{
			AttrTypes: Ipv4ParametersValue{}.AttributeTypes(ctx),
		},
		"ipv6_router_advertisement": basetypes.ObjectType{
			AttrTypes: Ipv6RouterAdvertisementValue{}.AttributeTypes(ctx),
		},
		"l3proxy_arpnd": basetypes.ObjectType{
			AttrTypes: L3proxyArpndValue{}.AttributeTypes(ctx),
		},
		"learn_unsolicited": basetypes.StringType{},
		"router":            basetypes.StringType{},
		"unnumbered":        basetypes.StringType{},
		"virtual_ip_discovery": basetypes.ListType{
			ElemType: VirtualIpDiscoveryValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"anycast_gateway_mac":           v.AnycastGatewayMac,
			"arp_timeout":                   v.ArpTimeout,
			"bfd":                           bfd,
			"bridge_domain":                 v.BridgeDomain,
			"description":                   v.Description,
			"egress":                        egress2,
			"evpn_route_advertisement_type": evpnRouteAdvertisementType,
			"host_route_populate":           hostRoutePopulate,
			"ingress":                       ingress2,
			"ip_addresses":                  ipAddresses,
			"ip_mtu":                        v.IpMtu,
			"ipv4_parameters":               ipv4Parameters,
			"ipv6_router_advertisement":     ipv6RouterAdvertisement,
			"l3proxy_arpnd":                 l3proxyArpnd,
			"learn_unsolicited":             v.LearnUnsolicited,
			"router":                        v.Router,
			"unnumbered":                    v.Unnumbered,
			"virtual_ip_discovery":          virtualIpDiscovery,
		})

	return objVal, diags
}

func (v Spec3Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AnycastGatewayMac.Equal(other.AnycastGatewayMac) {
		return false
	}

	if !v.ArpTimeout.Equal(other.ArpTimeout) {
		return false
	}

	if !v.Bfd.Equal(other.Bfd) {
		return false
	}

	if !v.BridgeDomain.Equal(other.BridgeDomain) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Egress2.Equal(other.Egress2) {
		return false
	}

	if !v.EvpnRouteAdvertisementType.Equal(other.EvpnRouteAdvertisementType) {
		return false
	}

	if !v.HostRoutePopulate.Equal(other.HostRoutePopulate) {
		return false
	}

	if !v.Ingress2.Equal(other.Ingress2) {
		return false
	}

	if !v.IpAddresses.Equal(other.IpAddresses) {
		return false
	}

	if !v.IpMtu.Equal(other.IpMtu) {
		return false
	}

	if !v.Ipv4Parameters.Equal(other.Ipv4Parameters) {
		return false
	}

	if !v.Ipv6RouterAdvertisement.Equal(other.Ipv6RouterAdvertisement) {
		return false
	}

	if !v.L3proxyArpnd.Equal(other.L3proxyArpnd) {
		return false
	}

	if !v.LearnUnsolicited.Equal(other.LearnUnsolicited) {
		return false
	}

	if !v.Router.Equal(other.Router) {
		return false
	}

	if !v.Unnumbered.Equal(other.Unnumbered) {
		return false
	}

	if !v.VirtualIpDiscovery.Equal(other.VirtualIpDiscovery) {
		return false
	}

	return true
}

func (v Spec3Value) Type(ctx context.Context) attr.Type {
	return Spec3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"anycast_gateway_mac": basetypes.StringType{},
		"arp_timeout":         basetypes.Int64Type{},
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"bridge_domain": basetypes.StringType{},
		"description":   basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: Egress2Value{}.AttributeTypes(ctx),
		},
		"evpn_route_advertisement_type": basetypes.ObjectType{
			AttrTypes: EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx),
		},
		"host_route_populate": basetypes.ObjectType{
			AttrTypes: HostRoutePopulateValue{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: Ingress2Value{}.AttributeTypes(ctx),
		},
		"ip_addresses": basetypes.ListType{
			ElemType: IpAddressesValue{}.Type(ctx),
		},
		"ip_mtu": basetypes.Int64Type{},
		"ipv4_parameters": basetypes.ObjectType{
			AttrTypes: Ipv4ParametersValue{}.AttributeTypes(ctx),
		},
		"ipv6_router_advertisement": basetypes.ObjectType{
			AttrTypes: Ipv6RouterAdvertisementValue{}.AttributeTypes(ctx),
		},
		"l3proxy_arpnd": basetypes.ObjectType{
			AttrTypes: L3proxyArpndValue{}.AttributeTypes(ctx),
		},
		"learn_unsolicited": basetypes.StringType{},
		"router":            basetypes.StringType{},
		"unnumbered":        basetypes.StringType{},
		"virtual_ip_discovery": basetypes.ListType{
			ElemType: VirtualIpDiscoveryValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = BfdType{}

type BfdType struct {
	basetypes.ObjectType
}

func (t BfdType) Equal(o attr.Type) bool {
	other, ok := o.(BfdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BfdType) String() string {
	return "BfdType"
}

func (t BfdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return nil, diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return nil, diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return nil, diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return nil, diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return nil, diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BfdValue{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfdValueNull() BfdValue {
	return BfdValue{
		state: attr.ValueStateNull,
	}
}

func NewBfdValueUnknown() BfdValue {
	return BfdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBfdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BfdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BfdValue Attribute Value",
				"While creating a BfdValue value, a missing attribute value was detected. "+
					"A BfdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BfdValue Attribute Type",
				"While creating a BfdValue value, an invalid attribute value was detected. "+
					"A BfdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BfdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BfdValue Attribute Value",
				"While creating a BfdValue value, an extra attribute value was detected. "+
					"A BfdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BfdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	return BfdValue{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BfdValue {
	object, diags := NewBfdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBfdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BfdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBfdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBfdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBfdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBfdValueMust(BfdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BfdType) ValueType(ctx context.Context) attr.Value {
	return BfdValue{}
}

var _ basetypes.ObjectValuable = BfdValue{}

type BfdValue struct {
	DesiredMinTransmitInt  basetypes.Int64Value `tfsdk:"desired_min_transmit_int"`
	DetectionMultiplier    basetypes.Int64Value `tfsdk:"detection_multiplier"`
	Enabled                basetypes.BoolValue  `tfsdk:"enabled"`
	MinEchoReceiveInterval basetypes.Int64Value `tfsdk:"min_echo_receive_interval"`
	RequiredMinReceive     basetypes.Int64Value `tfsdk:"required_min_receive"`
	Ttl                    basetypes.Int64Value `tfsdk:"ttl"`
	state                  attr.ValueState
}

func (v BfdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["desired_min_transmit_int"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["detection_multiplier"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["min_echo_receive_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["required_min_receive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ttl"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.DesiredMinTransmitInt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_min_transmit_int"] = val

		val, err = v.DetectionMultiplier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["detection_multiplier"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.MinEchoReceiveInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_echo_receive_interval"] = val

		val, err = v.RequiredMinReceive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required_min_receive"] = val

		val, err = v.Ttl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ttl"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BfdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BfdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BfdValue) String() string {
	return "BfdValue"
}

func (v BfdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"desired_min_transmit_int":  v.DesiredMinTransmitInt,
			"detection_multiplier":      v.DetectionMultiplier,
			"enabled":                   v.Enabled,
			"min_echo_receive_interval": v.MinEchoReceiveInterval,
			"required_min_receive":      v.RequiredMinReceive,
			"ttl":                       v.Ttl,
		})

	return objVal, diags
}

func (v BfdValue) Equal(o attr.Value) bool {
	other, ok := o.(BfdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DesiredMinTransmitInt.Equal(other.DesiredMinTransmitInt) {
		return false
	}

	if !v.DetectionMultiplier.Equal(other.DetectionMultiplier) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.MinEchoReceiveInterval.Equal(other.MinEchoReceiveInterval) {
		return false
	}

	if !v.RequiredMinReceive.Equal(other.RequiredMinReceive) {
		return false
	}

	if !v.Ttl.Equal(other.Ttl) {
		return false
	}

	return true
}

func (v BfdValue) Type(ctx context.Context) attr.Type {
	return BfdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BfdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Egress2Type{}

type Egress2Type struct {
	basetypes.ObjectType
}

func (t Egress2Type) Equal(o attr.Type) bool {
	other, ok := o.(Egress2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Egress2Type) String() string {
	return "Egress2Type"
}

func (t Egress2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Egress2Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgress2ValueNull() Egress2Value {
	return Egress2Value{
		state: attr.ValueStateNull,
	}
}

func NewEgress2ValueUnknown() Egress2Value {
	return Egress2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewEgress2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Egress2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Egress2Value Attribute Value",
				"While creating a Egress2Value value, a missing attribute value was detected. "+
					"A Egress2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Egress2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Egress2Value Attribute Type",
				"While creating a Egress2Value value, an invalid attribute value was detected. "+
					"A Egress2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Egress2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Egress2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Egress2Value Attribute Value",
				"While creating a Egress2Value value, an extra attribute value was detected. "+
					"A Egress2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Egress2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEgress2ValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewEgress2ValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewEgress2ValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewEgress2ValueUnknown(), diags
	}

	return Egress2Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgress2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Egress2Value {
	object, diags := NewEgress2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEgress2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Egress2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEgress2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEgress2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEgress2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEgress2ValueMust(Egress2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Egress2Type) ValueType(ctx context.Context) attr.Value {
	return Egress2Value{}
}

var _ basetypes.ObjectValuable = Egress2Value{}

type Egress2Value struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v Egress2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Egress2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Egress2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Egress2Value) String() string {
	return "Egress2Value"
}

func (v Egress2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v Egress2Value) Equal(o attr.Value) bool {
	other, ok := o.(Egress2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v Egress2Value) Type(ctx context.Context) attr.Type {
	return Egress2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Egress2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = EvpnRouteAdvertisementTypeType{}

type EvpnRouteAdvertisementTypeType struct {
	basetypes.ObjectType
}

func (t EvpnRouteAdvertisementTypeType) Equal(o attr.Type) bool {
	other, ok := o.(EvpnRouteAdvertisementTypeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EvpnRouteAdvertisementTypeType) String() string {
	return "EvpnRouteAdvertisementTypeType"
}

func (t EvpnRouteAdvertisementTypeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	arpDynamicAttribute, ok := attributes["arp_dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_dynamic is missing from object`)

		return nil, diags
	}

	arpDynamicVal, ok := arpDynamicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_dynamic expected to be basetypes.BoolValue, was: %T`, arpDynamicAttribute))
	}

	arpStaticAttribute, ok := attributes["arp_static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_static is missing from object`)

		return nil, diags
	}

	arpStaticVal, ok := arpStaticAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_static expected to be basetypes.BoolValue, was: %T`, arpStaticAttribute))
	}

	ndDynamicAttribute, ok := attributes["nd_dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nd_dynamic is missing from object`)

		return nil, diags
	}

	ndDynamicVal, ok := ndDynamicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nd_dynamic expected to be basetypes.BoolValue, was: %T`, ndDynamicAttribute))
	}

	ndStaticAttribute, ok := attributes["nd_static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nd_static is missing from object`)

		return nil, diags
	}

	ndStaticVal, ok := ndStaticAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nd_static expected to be basetypes.BoolValue, was: %T`, ndStaticAttribute))
	}

	rfc9135SymmetricModeAttribute, ok := attributes["rfc9135_symmetric_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rfc9135_symmetric_mode is missing from object`)

		return nil, diags
	}

	rfc9135SymmetricModeVal, ok := rfc9135SymmetricModeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rfc9135_symmetric_mode expected to be basetypes.BoolValue, was: %T`, rfc9135SymmetricModeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EvpnRouteAdvertisementTypeValue{
		ArpDynamic:           arpDynamicVal,
		ArpStatic:            arpStaticVal,
		NdDynamic:            ndDynamicVal,
		NdStatic:             ndStaticVal,
		Rfc9135SymmetricMode: rfc9135SymmetricModeVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewEvpnRouteAdvertisementTypeValueNull() EvpnRouteAdvertisementTypeValue {
	return EvpnRouteAdvertisementTypeValue{
		state: attr.ValueStateNull,
	}
}

func NewEvpnRouteAdvertisementTypeValueUnknown() EvpnRouteAdvertisementTypeValue {
	return EvpnRouteAdvertisementTypeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEvpnRouteAdvertisementTypeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EvpnRouteAdvertisementTypeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EvpnRouteAdvertisementTypeValue Attribute Value",
				"While creating a EvpnRouteAdvertisementTypeValue value, a missing attribute value was detected. "+
					"A EvpnRouteAdvertisementTypeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvpnRouteAdvertisementTypeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EvpnRouteAdvertisementTypeValue Attribute Type",
				"While creating a EvpnRouteAdvertisementTypeValue value, an invalid attribute value was detected. "+
					"A EvpnRouteAdvertisementTypeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvpnRouteAdvertisementTypeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EvpnRouteAdvertisementTypeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EvpnRouteAdvertisementTypeValue Attribute Value",
				"While creating a EvpnRouteAdvertisementTypeValue value, an extra attribute value was detected. "+
					"A EvpnRouteAdvertisementTypeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EvpnRouteAdvertisementTypeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEvpnRouteAdvertisementTypeValueUnknown(), diags
	}

	arpDynamicAttribute, ok := attributes["arp_dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_dynamic is missing from object`)

		return NewEvpnRouteAdvertisementTypeValueUnknown(), diags
	}

	arpDynamicVal, ok := arpDynamicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_dynamic expected to be basetypes.BoolValue, was: %T`, arpDynamicAttribute))
	}

	arpStaticAttribute, ok := attributes["arp_static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_static is missing from object`)

		return NewEvpnRouteAdvertisementTypeValueUnknown(), diags
	}

	arpStaticVal, ok := arpStaticAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_static expected to be basetypes.BoolValue, was: %T`, arpStaticAttribute))
	}

	ndDynamicAttribute, ok := attributes["nd_dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nd_dynamic is missing from object`)

		return NewEvpnRouteAdvertisementTypeValueUnknown(), diags
	}

	ndDynamicVal, ok := ndDynamicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nd_dynamic expected to be basetypes.BoolValue, was: %T`, ndDynamicAttribute))
	}

	ndStaticAttribute, ok := attributes["nd_static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nd_static is missing from object`)

		return NewEvpnRouteAdvertisementTypeValueUnknown(), diags
	}

	ndStaticVal, ok := ndStaticAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nd_static expected to be basetypes.BoolValue, was: %T`, ndStaticAttribute))
	}

	rfc9135SymmetricModeAttribute, ok := attributes["rfc9135_symmetric_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rfc9135_symmetric_mode is missing from object`)

		return NewEvpnRouteAdvertisementTypeValueUnknown(), diags
	}

	rfc9135SymmetricModeVal, ok := rfc9135SymmetricModeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rfc9135_symmetric_mode expected to be basetypes.BoolValue, was: %T`, rfc9135SymmetricModeAttribute))
	}

	if diags.HasError() {
		return NewEvpnRouteAdvertisementTypeValueUnknown(), diags
	}

	return EvpnRouteAdvertisementTypeValue{
		ArpDynamic:           arpDynamicVal,
		ArpStatic:            arpStaticVal,
		NdDynamic:            ndDynamicVal,
		NdStatic:             ndStaticVal,
		Rfc9135SymmetricMode: rfc9135SymmetricModeVal,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewEvpnRouteAdvertisementTypeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EvpnRouteAdvertisementTypeValue {
	object, diags := NewEvpnRouteAdvertisementTypeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEvpnRouteAdvertisementTypeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EvpnRouteAdvertisementTypeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEvpnRouteAdvertisementTypeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEvpnRouteAdvertisementTypeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEvpnRouteAdvertisementTypeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEvpnRouteAdvertisementTypeValueMust(EvpnRouteAdvertisementTypeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EvpnRouteAdvertisementTypeType) ValueType(ctx context.Context) attr.Value {
	return EvpnRouteAdvertisementTypeValue{}
}

var _ basetypes.ObjectValuable = EvpnRouteAdvertisementTypeValue{}

type EvpnRouteAdvertisementTypeValue struct {
	ArpDynamic           basetypes.BoolValue `tfsdk:"arp_dynamic"`
	ArpStatic            basetypes.BoolValue `tfsdk:"arp_static"`
	NdDynamic            basetypes.BoolValue `tfsdk:"nd_dynamic"`
	NdStatic             basetypes.BoolValue `tfsdk:"nd_static"`
	Rfc9135SymmetricMode basetypes.BoolValue `tfsdk:"rfc9135_symmetric_mode"`
	state                attr.ValueState
}

func (v EvpnRouteAdvertisementTypeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["arp_dynamic"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["arp_static"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["nd_dynamic"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["nd_static"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["rfc9135_symmetric_mode"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ArpDynamic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_dynamic"] = val

		val, err = v.ArpStatic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_static"] = val

		val, err = v.NdDynamic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nd_dynamic"] = val

		val, err = v.NdStatic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nd_static"] = val

		val, err = v.Rfc9135SymmetricMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rfc9135_symmetric_mode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EvpnRouteAdvertisementTypeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EvpnRouteAdvertisementTypeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EvpnRouteAdvertisementTypeValue) String() string {
	return "EvpnRouteAdvertisementTypeValue"
}

func (v EvpnRouteAdvertisementTypeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"arp_dynamic":            basetypes.BoolType{},
		"arp_static":             basetypes.BoolType{},
		"nd_dynamic":             basetypes.BoolType{},
		"nd_static":              basetypes.BoolType{},
		"rfc9135_symmetric_mode": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"arp_dynamic":            v.ArpDynamic,
			"arp_static":             v.ArpStatic,
			"nd_dynamic":             v.NdDynamic,
			"nd_static":              v.NdStatic,
			"rfc9135_symmetric_mode": v.Rfc9135SymmetricMode,
		})

	return objVal, diags
}

func (v EvpnRouteAdvertisementTypeValue) Equal(o attr.Value) bool {
	other, ok := o.(EvpnRouteAdvertisementTypeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ArpDynamic.Equal(other.ArpDynamic) {
		return false
	}

	if !v.ArpStatic.Equal(other.ArpStatic) {
		return false
	}

	if !v.NdDynamic.Equal(other.NdDynamic) {
		return false
	}

	if !v.NdStatic.Equal(other.NdStatic) {
		return false
	}

	if !v.Rfc9135SymmetricMode.Equal(other.Rfc9135SymmetricMode) {
		return false
	}

	return true
}

func (v EvpnRouteAdvertisementTypeValue) Type(ctx context.Context) attr.Type {
	return EvpnRouteAdvertisementTypeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EvpnRouteAdvertisementTypeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"arp_dynamic":            basetypes.BoolType{},
		"arp_static":             basetypes.BoolType{},
		"nd_dynamic":             basetypes.BoolType{},
		"nd_static":              basetypes.BoolType{},
		"rfc9135_symmetric_mode": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = HostRoutePopulateType{}

type HostRoutePopulateType struct {
	basetypes.ObjectType
}

func (t HostRoutePopulateType) Equal(o attr.Type) bool {
	other, ok := o.(HostRoutePopulateType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HostRoutePopulateType) String() string {
	return "HostRoutePopulateType"
}

func (t HostRoutePopulateType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dynamicAttribute, ok := attributes["dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic is missing from object`)

		return nil, diags
	}

	dynamicVal, ok := dynamicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic expected to be basetypes.BoolValue, was: %T`, dynamicAttribute))
	}

	evpnAttribute, ok := attributes["evpn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn is missing from object`)

		return nil, diags
	}

	evpnVal, ok := evpnAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn expected to be basetypes.BoolValue, was: %T`, evpnAttribute))
	}

	staticAttribute, ok := attributes["static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static is missing from object`)

		return nil, diags
	}

	staticVal, ok := staticAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static expected to be basetypes.BoolValue, was: %T`, staticAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HostRoutePopulateValue{
		Dynamic: dynamicVal,
		Evpn:    evpnVal,
		Static:  staticVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewHostRoutePopulateValueNull() HostRoutePopulateValue {
	return HostRoutePopulateValue{
		state: attr.ValueStateNull,
	}
}

func NewHostRoutePopulateValueUnknown() HostRoutePopulateValue {
	return HostRoutePopulateValue{
		state: attr.ValueStateUnknown,
	}
}

func NewHostRoutePopulateValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HostRoutePopulateValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HostRoutePopulateValue Attribute Value",
				"While creating a HostRoutePopulateValue value, a missing attribute value was detected. "+
					"A HostRoutePopulateValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HostRoutePopulateValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HostRoutePopulateValue Attribute Type",
				"While creating a HostRoutePopulateValue value, an invalid attribute value was detected. "+
					"A HostRoutePopulateValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HostRoutePopulateValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HostRoutePopulateValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HostRoutePopulateValue Attribute Value",
				"While creating a HostRoutePopulateValue value, an extra attribute value was detected. "+
					"A HostRoutePopulateValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HostRoutePopulateValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHostRoutePopulateValueUnknown(), diags
	}

	dynamicAttribute, ok := attributes["dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic is missing from object`)

		return NewHostRoutePopulateValueUnknown(), diags
	}

	dynamicVal, ok := dynamicAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic expected to be basetypes.BoolValue, was: %T`, dynamicAttribute))
	}

	evpnAttribute, ok := attributes["evpn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn is missing from object`)

		return NewHostRoutePopulateValueUnknown(), diags
	}

	evpnVal, ok := evpnAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn expected to be basetypes.BoolValue, was: %T`, evpnAttribute))
	}

	staticAttribute, ok := attributes["static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static is missing from object`)

		return NewHostRoutePopulateValueUnknown(), diags
	}

	staticVal, ok := staticAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static expected to be basetypes.BoolValue, was: %T`, staticAttribute))
	}

	if diags.HasError() {
		return NewHostRoutePopulateValueUnknown(), diags
	}

	return HostRoutePopulateValue{
		Dynamic: dynamicVal,
		Evpn:    evpnVal,
		Static:  staticVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewHostRoutePopulateValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HostRoutePopulateValue {
	object, diags := NewHostRoutePopulateValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHostRoutePopulateValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HostRoutePopulateType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHostRoutePopulateValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHostRoutePopulateValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHostRoutePopulateValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHostRoutePopulateValueMust(HostRoutePopulateValue{}.AttributeTypes(ctx), attributes), nil
}

func (t HostRoutePopulateType) ValueType(ctx context.Context) attr.Value {
	return HostRoutePopulateValue{}
}

var _ basetypes.ObjectValuable = HostRoutePopulateValue{}

type HostRoutePopulateValue struct {
	Dynamic basetypes.BoolValue `tfsdk:"dynamic"`
	Evpn    basetypes.BoolValue `tfsdk:"evpn"`
	Static  basetypes.BoolValue `tfsdk:"static"`
	state   attr.ValueState
}

func (v HostRoutePopulateValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["dynamic"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["evpn"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["static"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Dynamic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic"] = val

		val, err = v.Evpn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpn"] = val

		val, err = v.Static.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HostRoutePopulateValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HostRoutePopulateValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HostRoutePopulateValue) String() string {
	return "HostRoutePopulateValue"
}

func (v HostRoutePopulateValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"dynamic": basetypes.BoolType{},
		"evpn":    basetypes.BoolType{},
		"static":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dynamic": v.Dynamic,
			"evpn":    v.Evpn,
			"static":  v.Static,
		})

	return objVal, diags
}

func (v HostRoutePopulateValue) Equal(o attr.Value) bool {
	other, ok := o.(HostRoutePopulateValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dynamic.Equal(other.Dynamic) {
		return false
	}

	if !v.Evpn.Equal(other.Evpn) {
		return false
	}

	if !v.Static.Equal(other.Static) {
		return false
	}

	return true
}

func (v HostRoutePopulateValue) Type(ctx context.Context) attr.Type {
	return HostRoutePopulateType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HostRoutePopulateValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dynamic": basetypes.BoolType{},
		"evpn":    basetypes.BoolType{},
		"static":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ingress2Type{}

type Ingress2Type struct {
	basetypes.ObjectType
}

func (t Ingress2Type) Equal(o attr.Type) bool {
	other, ok := o.(Ingress2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ingress2Type) String() string {
	return "Ingress2Type"
}

func (t Ingress2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ingress2Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngress2ValueNull() Ingress2Value {
	return Ingress2Value{
		state: attr.ValueStateNull,
	}
}

func NewIngress2ValueUnknown() Ingress2Value {
	return Ingress2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIngress2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ingress2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ingress2Value Attribute Value",
				"While creating a Ingress2Value value, a missing attribute value was detected. "+
					"A Ingress2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ingress2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ingress2Value Attribute Type",
				"While creating a Ingress2Value value, an invalid attribute value was detected. "+
					"A Ingress2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ingress2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ingress2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ingress2Value Attribute Value",
				"While creating a Ingress2Value value, an extra attribute value was detected. "+
					"A Ingress2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ingress2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIngress2ValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewIngress2ValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewIngress2ValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewIngress2ValueUnknown(), diags
	}

	return Ingress2Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngress2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ingress2Value {
	object, diags := NewIngress2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIngress2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ingress2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIngress2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIngress2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIngress2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIngress2ValueMust(Ingress2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ingress2Type) ValueType(ctx context.Context) attr.Value {
	return Ingress2Value{}
}

var _ basetypes.ObjectValuable = Ingress2Value{}

type Ingress2Value struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v Ingress2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ingress2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ingress2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ingress2Value) String() string {
	return "Ingress2Value"
}

func (v Ingress2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v Ingress2Value) Equal(o attr.Value) bool {
	other, ok := o.(Ingress2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v Ingress2Value) Type(ctx context.Context) attr.Type {
	return Ingress2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ingress2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = IpAddressesType{}

type IpAddressesType struct {
	basetypes.ObjectType
}

func (t IpAddressesType) Equal(o attr.Type) bool {
	other, ok := o.(IpAddressesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpAddressesType) String() string {
	return "IpAddressesType"
}

func (t IpAddressesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipv4AddressAttribute, ok := attributes["ipv4_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_address is missing from object`)

		return nil, diags
	}

	ipv4AddressVal, ok := ipv4AddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_address expected to be basetypes.ObjectValue, was: %T`, ipv4AddressAttribute))
	}

	ipv6AddressAttribute, ok := attributes["ipv6_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_address is missing from object`)

		return nil, diags
	}

	ipv6AddressVal, ok := ipv6AddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_address expected to be basetypes.ObjectValue, was: %T`, ipv6AddressAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpAddressesValue{
		Ipv4Address: ipv4AddressVal,
		Ipv6Address: ipv6AddressVal,
		Node:        nodeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewIpAddressesValueNull() IpAddressesValue {
	return IpAddressesValue{
		state: attr.ValueStateNull,
	}
}

func NewIpAddressesValueUnknown() IpAddressesValue {
	return IpAddressesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpAddressesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpAddressesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpAddressesValue Attribute Value",
				"While creating a IpAddressesValue value, a missing attribute value was detected. "+
					"A IpAddressesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpAddressesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpAddressesValue Attribute Type",
				"While creating a IpAddressesValue value, an invalid attribute value was detected. "+
					"A IpAddressesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpAddressesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpAddressesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpAddressesValue Attribute Value",
				"While creating a IpAddressesValue value, an extra attribute value was detected. "+
					"A IpAddressesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpAddressesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpAddressesValueUnknown(), diags
	}

	ipv4AddressAttribute, ok := attributes["ipv4_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_address is missing from object`)

		return NewIpAddressesValueUnknown(), diags
	}

	ipv4AddressVal, ok := ipv4AddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_address expected to be basetypes.ObjectValue, was: %T`, ipv4AddressAttribute))
	}

	ipv6AddressAttribute, ok := attributes["ipv6_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_address is missing from object`)

		return NewIpAddressesValueUnknown(), diags
	}

	ipv6AddressVal, ok := ipv6AddressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_address expected to be basetypes.ObjectValue, was: %T`, ipv6AddressAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewIpAddressesValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	if diags.HasError() {
		return NewIpAddressesValueUnknown(), diags
	}

	return IpAddressesValue{
		Ipv4Address: ipv4AddressVal,
		Ipv6Address: ipv6AddressVal,
		Node:        nodeVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewIpAddressesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpAddressesValue {
	object, diags := NewIpAddressesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpAddressesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpAddressesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpAddressesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpAddressesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpAddressesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpAddressesValueMust(IpAddressesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpAddressesType) ValueType(ctx context.Context) attr.Value {
	return IpAddressesValue{}
}

var _ basetypes.ObjectValuable = IpAddressesValue{}

type IpAddressesValue struct {
	Ipv4Address basetypes.ObjectValue `tfsdk:"ipv4_address"`
	Ipv6Address basetypes.ObjectValue `tfsdk:"ipv6_address"`
	Node        basetypes.StringValue `tfsdk:"node"`
	state       attr.ValueState
}

func (v IpAddressesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["ipv4_address"] = basetypes.ObjectType{
		AttrTypes: Ipv4AddressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6_address"] = basetypes.ObjectType{
		AttrTypes: Ipv6AddressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Ipv4Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_address"] = val

		val, err = v.Ipv6Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_address"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpAddressesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpAddressesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpAddressesValue) String() string {
	return "IpAddressesValue"
}

func (v IpAddressesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ipv4Address basetypes.ObjectValue

	if v.Ipv4Address.IsNull() {
		ipv4Address = types.ObjectNull(
			Ipv4AddressValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv4Address.IsUnknown() {
		ipv4Address = types.ObjectUnknown(
			Ipv4AddressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv4Address.IsNull() && !v.Ipv4Address.IsUnknown() {
		ipv4Address = types.ObjectValueMust(
			Ipv4AddressValue{}.AttributeTypes(ctx),
			v.Ipv4Address.Attributes(),
		)
	}

	var ipv6Address basetypes.ObjectValue

	if v.Ipv6Address.IsNull() {
		ipv6Address = types.ObjectNull(
			Ipv6AddressValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv6Address.IsUnknown() {
		ipv6Address = types.ObjectUnknown(
			Ipv6AddressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv6Address.IsNull() && !v.Ipv6Address.IsUnknown() {
		ipv6Address = types.ObjectValueMust(
			Ipv6AddressValue{}.AttributeTypes(ctx),
			v.Ipv6Address.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"ipv4_address": basetypes.ObjectType{
			AttrTypes: Ipv4AddressValue{}.AttributeTypes(ctx),
		},
		"ipv6_address": basetypes.ObjectType{
			AttrTypes: Ipv6AddressValue{}.AttributeTypes(ctx),
		},
		"node": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ipv4_address": ipv4Address,
			"ipv6_address": ipv6Address,
			"node":         v.Node,
		})

	return objVal, diags
}

func (v IpAddressesValue) Equal(o attr.Value) bool {
	other, ok := o.(IpAddressesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Ipv4Address.Equal(other.Ipv4Address) {
		return false
	}

	if !v.Ipv6Address.Equal(other.Ipv6Address) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	return true
}

func (v IpAddressesValue) Type(ctx context.Context) attr.Type {
	return IpAddressesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpAddressesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ipv4_address": basetypes.ObjectType{
			AttrTypes: Ipv4AddressValue{}.AttributeTypes(ctx),
		},
		"ipv6_address": basetypes.ObjectType{
			AttrTypes: Ipv6AddressValue{}.AttributeTypes(ctx),
		},
		"node": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Ipv4AddressType{}

type Ipv4AddressType struct {
	basetypes.ObjectType
}

func (t Ipv4AddressType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4AddressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4AddressType) String() string {
	return "Ipv4AddressType"
}

func (t Ipv4AddressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return nil, diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4AddressValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv4AddressValueNull() Ipv4AddressValue {
	return Ipv4AddressValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv4AddressValueUnknown() Ipv4AddressValue {
	return Ipv4AddressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4AddressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4AddressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4AddressValue Attribute Value",
				"While creating a Ipv4AddressValue value, a missing attribute value was detected. "+
					"A Ipv4AddressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4AddressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4AddressValue Attribute Type",
				"While creating a Ipv4AddressValue value, an invalid attribute value was detected. "+
					"A Ipv4AddressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4AddressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4AddressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4AddressValue Attribute Value",
				"While creating a Ipv4AddressValue value, an extra attribute value was detected. "+
					"A Ipv4AddressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4AddressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4AddressValueUnknown(), diags
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return NewIpv4AddressValueUnknown(), diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewIpv4AddressValueUnknown(), diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return NewIpv4AddressValueUnknown(), diags
	}

	return Ipv4AddressValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv4AddressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4AddressValue {
	object, diags := NewIpv4AddressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4AddressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4AddressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4AddressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4AddressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4AddressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4AddressValueMust(Ipv4AddressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4AddressType) ValueType(ctx context.Context) attr.Value {
	return Ipv4AddressValue{}
}

var _ basetypes.ObjectValuable = Ipv4AddressValue{}

type Ipv4AddressValue struct {
	IpPrefix basetypes.StringValue `tfsdk:"ip_prefix"`
	Primary  basetypes.BoolValue   `tfsdk:"primary"`
	state    attr.ValueState
}

func (v Ipv4AddressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_prefix"] = val

		val, err = v.Primary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4AddressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4AddressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4AddressValue) String() string {
	return "Ipv4AddressValue"
}

func (v Ipv4AddressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_prefix": v.IpPrefix,
			"primary":   v.Primary,
		})

	return objVal, diags
}

func (v Ipv4AddressValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4AddressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpPrefix.Equal(other.IpPrefix) {
		return false
	}

	if !v.Primary.Equal(other.Primary) {
		return false
	}

	return true
}

func (v Ipv4AddressValue) Type(ctx context.Context) attr.Type {
	return Ipv4AddressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4AddressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ipv6AddressType{}

type Ipv6AddressType struct {
	basetypes.ObjectType
}

func (t Ipv6AddressType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6AddressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6AddressType) String() string {
	return "Ipv6AddressType"
}

func (t Ipv6AddressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return nil, diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6AddressValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv6AddressValueNull() Ipv6AddressValue {
	return Ipv6AddressValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv6AddressValueUnknown() Ipv6AddressValue {
	return Ipv6AddressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6AddressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6AddressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6AddressValue Attribute Value",
				"While creating a Ipv6AddressValue value, a missing attribute value was detected. "+
					"A Ipv6AddressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6AddressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6AddressValue Attribute Type",
				"While creating a Ipv6AddressValue value, an invalid attribute value was detected. "+
					"A Ipv6AddressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6AddressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6AddressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6AddressValue Attribute Value",
				"While creating a Ipv6AddressValue value, an extra attribute value was detected. "+
					"A Ipv6AddressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6AddressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6AddressValueUnknown(), diags
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return NewIpv6AddressValueUnknown(), diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewIpv6AddressValueUnknown(), diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return NewIpv6AddressValueUnknown(), diags
	}

	return Ipv6AddressValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv6AddressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6AddressValue {
	object, diags := NewIpv6AddressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6AddressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6AddressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6AddressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6AddressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6AddressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6AddressValueMust(Ipv6AddressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6AddressType) ValueType(ctx context.Context) attr.Value {
	return Ipv6AddressValue{}
}

var _ basetypes.ObjectValuable = Ipv6AddressValue{}

type Ipv6AddressValue struct {
	IpPrefix basetypes.StringValue `tfsdk:"ip_prefix"`
	Primary  basetypes.BoolValue   `tfsdk:"primary"`
	state    attr.ValueState
}

func (v Ipv6AddressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_prefix"] = val

		val, err = v.Primary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6AddressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6AddressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6AddressValue) String() string {
	return "Ipv6AddressValue"
}

func (v Ipv6AddressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_prefix": v.IpPrefix,
			"primary":   v.Primary,
		})

	return objVal, diags
}

func (v Ipv6AddressValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6AddressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpPrefix.Equal(other.IpPrefix) {
		return false
	}

	if !v.Primary.Equal(other.Primary) {
		return false
	}

	return true
}

func (v Ipv6AddressValue) Type(ctx context.Context) attr.Type {
	return Ipv6AddressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6AddressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ipv4ParametersType{}

type Ipv4ParametersType struct {
	basetypes.ObjectType
}

func (t Ipv4ParametersType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4ParametersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4ParametersType) String() string {
	return "Ipv4ParametersType"
}

func (t Ipv4ParametersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	directedBroadcastAttribute, ok := attributes["directed_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`directed_broadcast is missing from object`)

		return nil, diags
	}

	directedBroadcastVal, ok := directedBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`directed_broadcast expected to be basetypes.BoolValue, was: %T`, directedBroadcastAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4ParametersValue{
		DirectedBroadcast: directedBroadcastVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewIpv4ParametersValueNull() Ipv4ParametersValue {
	return Ipv4ParametersValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv4ParametersValueUnknown() Ipv4ParametersValue {
	return Ipv4ParametersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4ParametersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4ParametersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4ParametersValue Attribute Value",
				"While creating a Ipv4ParametersValue value, a missing attribute value was detected. "+
					"A Ipv4ParametersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4ParametersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4ParametersValue Attribute Type",
				"While creating a Ipv4ParametersValue value, an invalid attribute value was detected. "+
					"A Ipv4ParametersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4ParametersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4ParametersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4ParametersValue Attribute Value",
				"While creating a Ipv4ParametersValue value, an extra attribute value was detected. "+
					"A Ipv4ParametersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4ParametersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4ParametersValueUnknown(), diags
	}

	directedBroadcastAttribute, ok := attributes["directed_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`directed_broadcast is missing from object`)

		return NewIpv4ParametersValueUnknown(), diags
	}

	directedBroadcastVal, ok := directedBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`directed_broadcast expected to be basetypes.BoolValue, was: %T`, directedBroadcastAttribute))
	}

	if diags.HasError() {
		return NewIpv4ParametersValueUnknown(), diags
	}

	return Ipv4ParametersValue{
		DirectedBroadcast: directedBroadcastVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewIpv4ParametersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4ParametersValue {
	object, diags := NewIpv4ParametersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4ParametersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4ParametersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4ParametersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4ParametersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4ParametersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4ParametersValueMust(Ipv4ParametersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4ParametersType) ValueType(ctx context.Context) attr.Value {
	return Ipv4ParametersValue{}
}

var _ basetypes.ObjectValuable = Ipv4ParametersValue{}

type Ipv4ParametersValue struct {
	DirectedBroadcast basetypes.BoolValue `tfsdk:"directed_broadcast"`
	state             attr.ValueState
}

func (v Ipv4ParametersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["directed_broadcast"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.DirectedBroadcast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["directed_broadcast"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4ParametersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4ParametersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4ParametersValue) String() string {
	return "Ipv4ParametersValue"
}

func (v Ipv4ParametersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"directed_broadcast": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"directed_broadcast": v.DirectedBroadcast,
		})

	return objVal, diags
}

func (v Ipv4ParametersValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4ParametersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DirectedBroadcast.Equal(other.DirectedBroadcast) {
		return false
	}

	return true
}

func (v Ipv4ParametersValue) Type(ctx context.Context) attr.Type {
	return Ipv4ParametersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4ParametersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"directed_broadcast": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ipv6RouterAdvertisementType{}

type Ipv6RouterAdvertisementType struct {
	basetypes.ObjectType
}

func (t Ipv6RouterAdvertisementType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6RouterAdvertisementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6RouterAdvertisementType) String() string {
	return "Ipv6RouterAdvertisementType"
}

func (t Ipv6RouterAdvertisementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	currentHopLimitAttribute, ok := attributes["current_hop_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_hop_limit is missing from object`)

		return nil, diags
	}

	currentHopLimitVal, ok := currentHopLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_hop_limit expected to be basetypes.Int64Value, was: %T`, currentHopLimitAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return nil, diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	managedConfigurationFlagAttribute, ok := attributes["managed_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_configuration_flag is missing from object`)

		return nil, diags
	}

	managedConfigurationFlagVal, ok := managedConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_configuration_flag expected to be basetypes.BoolValue, was: %T`, managedConfigurationFlagAttribute))
	}

	maxAdvertisementIntervalAttribute, ok := attributes["max_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_advertisement_interval is missing from object`)

		return nil, diags
	}

	maxAdvertisementIntervalVal, ok := maxAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_advertisement_interval expected to be basetypes.Int64Value, was: %T`, maxAdvertisementIntervalAttribute))
	}

	minAdvertisementIntervalAttribute, ok := attributes["min_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_advertisement_interval is missing from object`)

		return nil, diags
	}

	minAdvertisementIntervalVal, ok := minAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minAdvertisementIntervalAttribute))
	}

	otherConfigurationFlagAttribute, ok := attributes["other_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_configuration_flag is missing from object`)

		return nil, diags
	}

	otherConfigurationFlagVal, ok := otherConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_configuration_flag expected to be basetypes.BoolValue, was: %T`, otherConfigurationFlagAttribute))
	}

	prefixesAttribute, ok := attributes["prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefixes is missing from object`)

		return nil, diags
	}

	prefixesVal, ok := prefixesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefixes expected to be basetypes.ListValue, was: %T`, prefixesAttribute))
	}

	reachableTimeAttribute, ok := attributes["reachable_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reachable_time is missing from object`)

		return nil, diags
	}

	reachableTimeVal, ok := reachableTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reachable_time expected to be basetypes.Int64Value, was: %T`, reachableTimeAttribute))
	}

	retransmitTimeAttribute, ok := attributes["retransmit_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retransmit_time is missing from object`)

		return nil, diags
	}

	retransmitTimeVal, ok := retransmitTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retransmit_time expected to be basetypes.Int64Value, was: %T`, retransmitTimeAttribute))
	}

	routerLifetimeAttribute, ok := attributes["router_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_lifetime is missing from object`)

		return nil, diags
	}

	routerLifetimeVal, ok := routerLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_lifetime expected to be basetypes.Int64Value, was: %T`, routerLifetimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6RouterAdvertisementValue{
		CurrentHopLimit:          currentHopLimitVal,
		Enabled:                  enabledVal,
		IpMtu:                    ipMtuVal,
		ManagedConfigurationFlag: managedConfigurationFlagVal,
		MaxAdvertisementInterval: maxAdvertisementIntervalVal,
		MinAdvertisementInterval: minAdvertisementIntervalVal,
		OtherConfigurationFlag:   otherConfigurationFlagVal,
		Prefixes:                 prefixesVal,
		ReachableTime:            reachableTimeVal,
		RetransmitTime:           retransmitTimeVal,
		RouterLifetime:           routerLifetimeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewIpv6RouterAdvertisementValueNull() Ipv6RouterAdvertisementValue {
	return Ipv6RouterAdvertisementValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv6RouterAdvertisementValueUnknown() Ipv6RouterAdvertisementValue {
	return Ipv6RouterAdvertisementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6RouterAdvertisementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6RouterAdvertisementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6RouterAdvertisementValue Attribute Value",
				"While creating a Ipv6RouterAdvertisementValue value, a missing attribute value was detected. "+
					"A Ipv6RouterAdvertisementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6RouterAdvertisementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6RouterAdvertisementValue Attribute Type",
				"While creating a Ipv6RouterAdvertisementValue value, an invalid attribute value was detected. "+
					"A Ipv6RouterAdvertisementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6RouterAdvertisementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6RouterAdvertisementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6RouterAdvertisementValue Attribute Value",
				"While creating a Ipv6RouterAdvertisementValue value, an extra attribute value was detected. "+
					"A Ipv6RouterAdvertisementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6RouterAdvertisementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6RouterAdvertisementValueUnknown(), diags
	}

	currentHopLimitAttribute, ok := attributes["current_hop_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_hop_limit is missing from object`)

		return NewIpv6RouterAdvertisementValueUnknown(), diags
	}

	currentHopLimitVal, ok := currentHopLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_hop_limit expected to be basetypes.Int64Value, was: %T`, currentHopLimitAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv6RouterAdvertisementValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return NewIpv6RouterAdvertisementValueUnknown(), diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	managedConfigurationFlagAttribute, ok := attributes["managed_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_configuration_flag is missing from object`)

		return NewIpv6RouterAdvertisementValueUnknown(), diags
	}

	managedConfigurationFlagVal, ok := managedConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_configuration_flag expected to be basetypes.BoolValue, was: %T`, managedConfigurationFlagAttribute))
	}

	maxAdvertisementIntervalAttribute, ok := attributes["max_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_advertisement_interval is missing from object`)

		return NewIpv6RouterAdvertisementValueUnknown(), diags
	}

	maxAdvertisementIntervalVal, ok := maxAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_advertisement_interval expected to be basetypes.Int64Value, was: %T`, maxAdvertisementIntervalAttribute))
	}

	minAdvertisementIntervalAttribute, ok := attributes["min_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_advertisement_interval is missing from object`)

		return NewIpv6RouterAdvertisementValueUnknown(), diags
	}

	minAdvertisementIntervalVal, ok := minAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minAdvertisementIntervalAttribute))
	}

	otherConfigurationFlagAttribute, ok := attributes["other_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_configuration_flag is missing from object`)

		return NewIpv6RouterAdvertisementValueUnknown(), diags
	}

	otherConfigurationFlagVal, ok := otherConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_configuration_flag expected to be basetypes.BoolValue, was: %T`, otherConfigurationFlagAttribute))
	}

	prefixesAttribute, ok := attributes["prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefixes is missing from object`)

		return NewIpv6RouterAdvertisementValueUnknown(), diags
	}

	prefixesVal, ok := prefixesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefixes expected to be basetypes.ListValue, was: %T`, prefixesAttribute))
	}

	reachableTimeAttribute, ok := attributes["reachable_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reachable_time is missing from object`)

		return NewIpv6RouterAdvertisementValueUnknown(), diags
	}

	reachableTimeVal, ok := reachableTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reachable_time expected to be basetypes.Int64Value, was: %T`, reachableTimeAttribute))
	}

	retransmitTimeAttribute, ok := attributes["retransmit_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retransmit_time is missing from object`)

		return NewIpv6RouterAdvertisementValueUnknown(), diags
	}

	retransmitTimeVal, ok := retransmitTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retransmit_time expected to be basetypes.Int64Value, was: %T`, retransmitTimeAttribute))
	}

	routerLifetimeAttribute, ok := attributes["router_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_lifetime is missing from object`)

		return NewIpv6RouterAdvertisementValueUnknown(), diags
	}

	routerLifetimeVal, ok := routerLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_lifetime expected to be basetypes.Int64Value, was: %T`, routerLifetimeAttribute))
	}

	if diags.HasError() {
		return NewIpv6RouterAdvertisementValueUnknown(), diags
	}

	return Ipv6RouterAdvertisementValue{
		CurrentHopLimit:          currentHopLimitVal,
		Enabled:                  enabledVal,
		IpMtu:                    ipMtuVal,
		ManagedConfigurationFlag: managedConfigurationFlagVal,
		MaxAdvertisementInterval: maxAdvertisementIntervalVal,
		MinAdvertisementInterval: minAdvertisementIntervalVal,
		OtherConfigurationFlag:   otherConfigurationFlagVal,
		Prefixes:                 prefixesVal,
		ReachableTime:            reachableTimeVal,
		RetransmitTime:           retransmitTimeVal,
		RouterLifetime:           routerLifetimeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewIpv6RouterAdvertisementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6RouterAdvertisementValue {
	object, diags := NewIpv6RouterAdvertisementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6RouterAdvertisementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6RouterAdvertisementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6RouterAdvertisementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6RouterAdvertisementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6RouterAdvertisementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6RouterAdvertisementValueMust(Ipv6RouterAdvertisementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6RouterAdvertisementType) ValueType(ctx context.Context) attr.Value {
	return Ipv6RouterAdvertisementValue{}
}

var _ basetypes.ObjectValuable = Ipv6RouterAdvertisementValue{}

type Ipv6RouterAdvertisementValue struct {
	CurrentHopLimit          basetypes.Int64Value `tfsdk:"current_hop_limit"`
	Enabled                  basetypes.BoolValue  `tfsdk:"enabled"`
	IpMtu                    basetypes.Int64Value `tfsdk:"ip_mtu"`
	ManagedConfigurationFlag basetypes.BoolValue  `tfsdk:"managed_configuration_flag"`
	MaxAdvertisementInterval basetypes.Int64Value `tfsdk:"max_advertisement_interval"`
	MinAdvertisementInterval basetypes.Int64Value `tfsdk:"min_advertisement_interval"`
	OtherConfigurationFlag   basetypes.BoolValue  `tfsdk:"other_configuration_flag"`
	Prefixes                 basetypes.ListValue  `tfsdk:"prefixes"`
	ReachableTime            basetypes.Int64Value `tfsdk:"reachable_time"`
	RetransmitTime           basetypes.Int64Value `tfsdk:"retransmit_time"`
	RouterLifetime           basetypes.Int64Value `tfsdk:"router_lifetime"`
	state                    attr.ValueState
}

func (v Ipv6RouterAdvertisementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["current_hop_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ip_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_configuration_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["other_configuration_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefixes"] = basetypes.ListType{
		ElemType: PrefixesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["reachable_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["retransmit_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["router_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.CurrentHopLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_hop_limit"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.IpMtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_mtu"] = val

		val, err = v.ManagedConfigurationFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_configuration_flag"] = val

		val, err = v.MaxAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_advertisement_interval"] = val

		val, err = v.MinAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_advertisement_interval"] = val

		val, err = v.OtherConfigurationFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["other_configuration_flag"] = val

		val, err = v.Prefixes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefixes"] = val

		val, err = v.ReachableTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reachable_time"] = val

		val, err = v.RetransmitTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["retransmit_time"] = val

		val, err = v.RouterLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router_lifetime"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6RouterAdvertisementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6RouterAdvertisementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6RouterAdvertisementValue) String() string {
	return "Ipv6RouterAdvertisementValue"
}

func (v Ipv6RouterAdvertisementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	prefixes := types.ListValueMust(
		PrefixesType{
			basetypes.ObjectType{
				AttrTypes: PrefixesValue{}.AttributeTypes(ctx),
			},
		},
		v.Prefixes.Elements(),
	)

	if v.Prefixes.IsNull() {
		prefixes = types.ListNull(
			PrefixesType{
				basetypes.ObjectType{
					AttrTypes: PrefixesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Prefixes.IsUnknown() {
		prefixes = types.ListUnknown(
			PrefixesType{
				basetypes.ObjectType{
					AttrTypes: PrefixesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"current_hop_limit":          basetypes.Int64Type{},
		"enabled":                    basetypes.BoolType{},
		"ip_mtu":                     basetypes.Int64Type{},
		"managed_configuration_flag": basetypes.BoolType{},
		"max_advertisement_interval": basetypes.Int64Type{},
		"min_advertisement_interval": basetypes.Int64Type{},
		"other_configuration_flag":   basetypes.BoolType{},
		"prefixes": basetypes.ListType{
			ElemType: PrefixesValue{}.Type(ctx),
		},
		"reachable_time":  basetypes.Int64Type{},
		"retransmit_time": basetypes.Int64Type{},
		"router_lifetime": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"current_hop_limit":          v.CurrentHopLimit,
			"enabled":                    v.Enabled,
			"ip_mtu":                     v.IpMtu,
			"managed_configuration_flag": v.ManagedConfigurationFlag,
			"max_advertisement_interval": v.MaxAdvertisementInterval,
			"min_advertisement_interval": v.MinAdvertisementInterval,
			"other_configuration_flag":   v.OtherConfigurationFlag,
			"prefixes":                   prefixes,
			"reachable_time":             v.ReachableTime,
			"retransmit_time":            v.RetransmitTime,
			"router_lifetime":            v.RouterLifetime,
		})

	return objVal, diags
}

func (v Ipv6RouterAdvertisementValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6RouterAdvertisementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CurrentHopLimit.Equal(other.CurrentHopLimit) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.IpMtu.Equal(other.IpMtu) {
		return false
	}

	if !v.ManagedConfigurationFlag.Equal(other.ManagedConfigurationFlag) {
		return false
	}

	if !v.MaxAdvertisementInterval.Equal(other.MaxAdvertisementInterval) {
		return false
	}

	if !v.MinAdvertisementInterval.Equal(other.MinAdvertisementInterval) {
		return false
	}

	if !v.OtherConfigurationFlag.Equal(other.OtherConfigurationFlag) {
		return false
	}

	if !v.Prefixes.Equal(other.Prefixes) {
		return false
	}

	if !v.ReachableTime.Equal(other.ReachableTime) {
		return false
	}

	if !v.RetransmitTime.Equal(other.RetransmitTime) {
		return false
	}

	if !v.RouterLifetime.Equal(other.RouterLifetime) {
		return false
	}

	return true
}

func (v Ipv6RouterAdvertisementValue) Type(ctx context.Context) attr.Type {
	return Ipv6RouterAdvertisementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6RouterAdvertisementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"current_hop_limit":          basetypes.Int64Type{},
		"enabled":                    basetypes.BoolType{},
		"ip_mtu":                     basetypes.Int64Type{},
		"managed_configuration_flag": basetypes.BoolType{},
		"max_advertisement_interval": basetypes.Int64Type{},
		"min_advertisement_interval": basetypes.Int64Type{},
		"other_configuration_flag":   basetypes.BoolType{},
		"prefixes": basetypes.ListType{
			ElemType: PrefixesValue{}.Type(ctx),
		},
		"reachable_time":  basetypes.Int64Type{},
		"retransmit_time": basetypes.Int64Type{},
		"router_lifetime": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrefixesType{}

type PrefixesType struct {
	basetypes.ObjectType
}

func (t PrefixesType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixesType) String() string {
	return "PrefixesType"
}

func (t PrefixesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousFlagAttribute, ok := attributes["autonomous_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_flag is missing from object`)

		return nil, diags
	}

	autonomousFlagVal, ok := autonomousFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_flag expected to be basetypes.BoolValue, was: %T`, autonomousFlagAttribute))
	}

	onLinkFlagAttribute, ok := attributes["on_link_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_link_flag is missing from object`)

		return nil, diags
	}

	onLinkFlagVal, ok := onLinkFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_link_flag expected to be basetypes.BoolValue, was: %T`, onLinkFlagAttribute))
	}

	preferredLifetimeAttribute, ok := attributes["preferred_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_lifetime is missing from object`)

		return nil, diags
	}

	preferredLifetimeVal, ok := preferredLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_lifetime expected to be basetypes.Int64Value, was: %T`, preferredLifetimeAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	validLifetimeAttribute, ok := attributes["valid_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`valid_lifetime is missing from object`)

		return nil, diags
	}

	validLifetimeVal, ok := validLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`valid_lifetime expected to be basetypes.Int64Value, was: %T`, validLifetimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixesValue{
		AutonomousFlag:    autonomousFlagVal,
		OnLinkFlag:        onLinkFlagVal,
		PreferredLifetime: preferredLifetimeVal,
		Prefix:            prefixVal,
		ValidLifetime:     validLifetimeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixesValueNull() PrefixesValue {
	return PrefixesValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixesValueUnknown() PrefixesValue {
	return PrefixesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixesValue Attribute Value",
				"While creating a PrefixesValue value, a missing attribute value was detected. "+
					"A PrefixesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixesValue Attribute Type",
				"While creating a PrefixesValue value, an invalid attribute value was detected. "+
					"A PrefixesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixesValue Attribute Value",
				"While creating a PrefixesValue value, an extra attribute value was detected. "+
					"A PrefixesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixesValueUnknown(), diags
	}

	autonomousFlagAttribute, ok := attributes["autonomous_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_flag is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	autonomousFlagVal, ok := autonomousFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_flag expected to be basetypes.BoolValue, was: %T`, autonomousFlagAttribute))
	}

	onLinkFlagAttribute, ok := attributes["on_link_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_link_flag is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	onLinkFlagVal, ok := onLinkFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_link_flag expected to be basetypes.BoolValue, was: %T`, onLinkFlagAttribute))
	}

	preferredLifetimeAttribute, ok := attributes["preferred_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_lifetime is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	preferredLifetimeVal, ok := preferredLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_lifetime expected to be basetypes.Int64Value, was: %T`, preferredLifetimeAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	validLifetimeAttribute, ok := attributes["valid_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`valid_lifetime is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	validLifetimeVal, ok := validLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`valid_lifetime expected to be basetypes.Int64Value, was: %T`, validLifetimeAttribute))
	}

	if diags.HasError() {
		return NewPrefixesValueUnknown(), diags
	}

	return PrefixesValue{
		AutonomousFlag:    autonomousFlagVal,
		OnLinkFlag:        onLinkFlagVal,
		PreferredLifetime: preferredLifetimeVal,
		Prefix:            prefixVal,
		ValidLifetime:     validLifetimeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixesValue {
	object, diags := NewPrefixesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixesValueMust(PrefixesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixesType) ValueType(ctx context.Context) attr.Value {
	return PrefixesValue{}
}

var _ basetypes.ObjectValuable = PrefixesValue{}

type PrefixesValue struct {
	AutonomousFlag    basetypes.BoolValue   `tfsdk:"autonomous_flag"`
	OnLinkFlag        basetypes.BoolValue   `tfsdk:"on_link_flag"`
	PreferredLifetime basetypes.Int64Value  `tfsdk:"preferred_lifetime"`
	Prefix            basetypes.StringValue `tfsdk:"prefix"`
	ValidLifetime     basetypes.Int64Value  `tfsdk:"valid_lifetime"`
	state             attr.ValueState
}

func (v PrefixesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["on_link_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["preferred_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["valid_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AutonomousFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_flag"] = val

		val, err = v.OnLinkFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["on_link_flag"] = val

		val, err = v.PreferredLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preferred_lifetime"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.ValidLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["valid_lifetime"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixesValue) String() string {
	return "PrefixesValue"
}

func (v PrefixesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"autonomous_flag":    basetypes.BoolType{},
		"on_link_flag":       basetypes.BoolType{},
		"preferred_lifetime": basetypes.Int64Type{},
		"prefix":             basetypes.StringType{},
		"valid_lifetime":     basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_flag":    v.AutonomousFlag,
			"on_link_flag":       v.OnLinkFlag,
			"preferred_lifetime": v.PreferredLifetime,
			"prefix":             v.Prefix,
			"valid_lifetime":     v.ValidLifetime,
		})

	return objVal, diags
}

func (v PrefixesValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousFlag.Equal(other.AutonomousFlag) {
		return false
	}

	if !v.OnLinkFlag.Equal(other.OnLinkFlag) {
		return false
	}

	if !v.PreferredLifetime.Equal(other.PreferredLifetime) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.ValidLifetime.Equal(other.ValidLifetime) {
		return false
	}

	return true
}

func (v PrefixesValue) Type(ctx context.Context) attr.Type {
	return PrefixesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_flag":    basetypes.BoolType{},
		"on_link_flag":       basetypes.BoolType{},
		"preferred_lifetime": basetypes.Int64Type{},
		"prefix":             basetypes.StringType{},
		"valid_lifetime":     basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = L3proxyArpndType{}

type L3proxyArpndType struct {
	basetypes.ObjectType
}

func (t L3proxyArpndType) Equal(o attr.Type) bool {
	other, ok := o.(L3proxyArpndType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t L3proxyArpndType) String() string {
	return "L3proxyArpndType"
}

func (t L3proxyArpndType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return nil, diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.BoolValue, was: %T`, proxyArpAttribute))
	}

	proxyNdAttribute, ok := attributes["proxy_nd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_nd is missing from object`)

		return nil, diags
	}

	proxyNdVal, ok := proxyNdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_nd expected to be basetypes.BoolValue, was: %T`, proxyNdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return L3proxyArpndValue{
		ProxyArp: proxyArpVal,
		ProxyNd:  proxyNdVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewL3proxyArpndValueNull() L3proxyArpndValue {
	return L3proxyArpndValue{
		state: attr.ValueStateNull,
	}
}

func NewL3proxyArpndValueUnknown() L3proxyArpndValue {
	return L3proxyArpndValue{
		state: attr.ValueStateUnknown,
	}
}

func NewL3proxyArpndValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (L3proxyArpndValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing L3proxyArpndValue Attribute Value",
				"While creating a L3proxyArpndValue value, a missing attribute value was detected. "+
					"A L3proxyArpndValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3proxyArpndValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid L3proxyArpndValue Attribute Type",
				"While creating a L3proxyArpndValue value, an invalid attribute value was detected. "+
					"A L3proxyArpndValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3proxyArpndValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("L3proxyArpndValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra L3proxyArpndValue Attribute Value",
				"While creating a L3proxyArpndValue value, an extra attribute value was detected. "+
					"A L3proxyArpndValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra L3proxyArpndValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewL3proxyArpndValueUnknown(), diags
	}

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return NewL3proxyArpndValueUnknown(), diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.BoolValue, was: %T`, proxyArpAttribute))
	}

	proxyNdAttribute, ok := attributes["proxy_nd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_nd is missing from object`)

		return NewL3proxyArpndValueUnknown(), diags
	}

	proxyNdVal, ok := proxyNdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_nd expected to be basetypes.BoolValue, was: %T`, proxyNdAttribute))
	}

	if diags.HasError() {
		return NewL3proxyArpndValueUnknown(), diags
	}

	return L3proxyArpndValue{
		ProxyArp: proxyArpVal,
		ProxyNd:  proxyNdVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewL3proxyArpndValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) L3proxyArpndValue {
	object, diags := NewL3proxyArpndValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewL3proxyArpndValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t L3proxyArpndType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewL3proxyArpndValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewL3proxyArpndValueUnknown(), nil
	}

	if in.IsNull() {
		return NewL3proxyArpndValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewL3proxyArpndValueMust(L3proxyArpndValue{}.AttributeTypes(ctx), attributes), nil
}

func (t L3proxyArpndType) ValueType(ctx context.Context) attr.Value {
	return L3proxyArpndValue{}
}

var _ basetypes.ObjectValuable = L3proxyArpndValue{}

type L3proxyArpndValue struct {
	ProxyArp basetypes.BoolValue `tfsdk:"proxy_arp"`
	ProxyNd  basetypes.BoolValue `tfsdk:"proxy_nd"`
	state    attr.ValueState
}

func (v L3proxyArpndValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["proxy_arp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["proxy_nd"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ProxyArp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_arp"] = val

		val, err = v.ProxyNd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_nd"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v L3proxyArpndValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v L3proxyArpndValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v L3proxyArpndValue) String() string {
	return "L3proxyArpndValue"
}

func (v L3proxyArpndValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"proxy_arp": basetypes.BoolType{},
		"proxy_nd":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"proxy_arp": v.ProxyArp,
			"proxy_nd":  v.ProxyNd,
		})

	return objVal, diags
}

func (v L3proxyArpndValue) Equal(o attr.Value) bool {
	other, ok := o.(L3proxyArpndValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ProxyArp.Equal(other.ProxyArp) {
		return false
	}

	if !v.ProxyNd.Equal(other.ProxyNd) {
		return false
	}

	return true
}

func (v L3proxyArpndValue) Type(ctx context.Context) attr.Type {
	return L3proxyArpndType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v L3proxyArpndValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"proxy_arp": basetypes.BoolType{},
		"proxy_nd":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = VirtualIpDiscoveryType{}

type VirtualIpDiscoveryType struct {
	basetypes.ObjectType
}

func (t VirtualIpDiscoveryType) Equal(o attr.Type) bool {
	other, ok := o.(VirtualIpDiscoveryType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VirtualIpDiscoveryType) String() string {
	return "VirtualIpDiscoveryType"
}

func (t VirtualIpDiscoveryType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return nil, diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	allowedMacAttribute, ok := attributes["allowed_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_mac is missing from object`)

		return nil, diags
	}

	allowedMacVal, ok := allowedMacAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_mac expected to be basetypes.ListValue, was: %T`, allowedMacAttribute))
	}

	bridgeInterfaceToProbeAttribute, ok := attributes["bridge_interface_to_probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_interface_to_probe is missing from object`)

		return nil, diags
	}

	bridgeInterfaceToProbeVal, ok := bridgeInterfaceToProbeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_interface_to_probe expected to be basetypes.ListValue, was: %T`, bridgeInterfaceToProbeAttribute))
	}

	probeIntervalAttribute, ok := attributes["probe_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_interval is missing from object`)

		return nil, diags
	}

	probeIntervalVal, ok := probeIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_interval expected to be basetypes.Int64Value, was: %T`, probeIntervalAttribute))
	}

	vlanToProbeAttribute, ok := attributes["vlan_to_probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_to_probe is missing from object`)

		return nil, diags
	}

	vlanToProbeVal, ok := vlanToProbeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_to_probe expected to be basetypes.ListValue, was: %T`, vlanToProbeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VirtualIpDiscoveryValue{
		Address:                addressVal,
		AllowedMac:             allowedMacVal,
		BridgeInterfaceToProbe: bridgeInterfaceToProbeVal,
		ProbeInterval:          probeIntervalVal,
		VlanToProbe:            vlanToProbeVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewVirtualIpDiscoveryValueNull() VirtualIpDiscoveryValue {
	return VirtualIpDiscoveryValue{
		state: attr.ValueStateNull,
	}
}

func NewVirtualIpDiscoveryValueUnknown() VirtualIpDiscoveryValue {
	return VirtualIpDiscoveryValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVirtualIpDiscoveryValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VirtualIpDiscoveryValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VirtualIpDiscoveryValue Attribute Value",
				"While creating a VirtualIpDiscoveryValue value, a missing attribute value was detected. "+
					"A VirtualIpDiscoveryValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VirtualIpDiscoveryValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VirtualIpDiscoveryValue Attribute Type",
				"While creating a VirtualIpDiscoveryValue value, an invalid attribute value was detected. "+
					"A VirtualIpDiscoveryValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VirtualIpDiscoveryValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VirtualIpDiscoveryValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VirtualIpDiscoveryValue Attribute Value",
				"While creating a VirtualIpDiscoveryValue value, an extra attribute value was detected. "+
					"A VirtualIpDiscoveryValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VirtualIpDiscoveryValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVirtualIpDiscoveryValueUnknown(), diags
	}

	addressAttribute, ok := attributes["address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address is missing from object`)

		return NewVirtualIpDiscoveryValueUnknown(), diags
	}

	addressVal, ok := addressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address expected to be basetypes.StringValue, was: %T`, addressAttribute))
	}

	allowedMacAttribute, ok := attributes["allowed_mac"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allowed_mac is missing from object`)

		return NewVirtualIpDiscoveryValueUnknown(), diags
	}

	allowedMacVal, ok := allowedMacAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allowed_mac expected to be basetypes.ListValue, was: %T`, allowedMacAttribute))
	}

	bridgeInterfaceToProbeAttribute, ok := attributes["bridge_interface_to_probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_interface_to_probe is missing from object`)

		return NewVirtualIpDiscoveryValueUnknown(), diags
	}

	bridgeInterfaceToProbeVal, ok := bridgeInterfaceToProbeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_interface_to_probe expected to be basetypes.ListValue, was: %T`, bridgeInterfaceToProbeAttribute))
	}

	probeIntervalAttribute, ok := attributes["probe_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`probe_interval is missing from object`)

		return NewVirtualIpDiscoveryValueUnknown(), diags
	}

	probeIntervalVal, ok := probeIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`probe_interval expected to be basetypes.Int64Value, was: %T`, probeIntervalAttribute))
	}

	vlanToProbeAttribute, ok := attributes["vlan_to_probe"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_to_probe is missing from object`)

		return NewVirtualIpDiscoveryValueUnknown(), diags
	}

	vlanToProbeVal, ok := vlanToProbeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_to_probe expected to be basetypes.ListValue, was: %T`, vlanToProbeAttribute))
	}

	if diags.HasError() {
		return NewVirtualIpDiscoveryValueUnknown(), diags
	}

	return VirtualIpDiscoveryValue{
		Address:                addressVal,
		AllowedMac:             allowedMacVal,
		BridgeInterfaceToProbe: bridgeInterfaceToProbeVal,
		ProbeInterval:          probeIntervalVal,
		VlanToProbe:            vlanToProbeVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewVirtualIpDiscoveryValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VirtualIpDiscoveryValue {
	object, diags := NewVirtualIpDiscoveryValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVirtualIpDiscoveryValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VirtualIpDiscoveryType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVirtualIpDiscoveryValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVirtualIpDiscoveryValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVirtualIpDiscoveryValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVirtualIpDiscoveryValueMust(VirtualIpDiscoveryValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VirtualIpDiscoveryType) ValueType(ctx context.Context) attr.Value {
	return VirtualIpDiscoveryValue{}
}

var _ basetypes.ObjectValuable = VirtualIpDiscoveryValue{}

type VirtualIpDiscoveryValue struct {
	Address                basetypes.StringValue `tfsdk:"address"`
	AllowedMac             basetypes.ListValue   `tfsdk:"allowed_mac"`
	BridgeInterfaceToProbe basetypes.ListValue   `tfsdk:"bridge_interface_to_probe"`
	ProbeInterval          basetypes.Int64Value  `tfsdk:"probe_interval"`
	VlanToProbe            basetypes.ListValue   `tfsdk:"vlan_to_probe"`
	state                  attr.ValueState
}

func (v VirtualIpDiscoveryValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["allowed_mac"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["bridge_interface_to_probe"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["probe_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vlan_to_probe"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Address.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address"] = val

		val, err = v.AllowedMac.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allowed_mac"] = val

		val, err = v.BridgeInterfaceToProbe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bridge_interface_to_probe"] = val

		val, err = v.ProbeInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["probe_interval"] = val

		val, err = v.VlanToProbe.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_to_probe"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VirtualIpDiscoveryValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VirtualIpDiscoveryValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VirtualIpDiscoveryValue) String() string {
	return "VirtualIpDiscoveryValue"
}

func (v VirtualIpDiscoveryValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var allowedMacVal basetypes.ListValue
	switch {
	case v.AllowedMac.IsUnknown():
		allowedMacVal = types.ListUnknown(types.StringType)
	case v.AllowedMac.IsNull():
		allowedMacVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		allowedMacVal, d = types.ListValue(types.StringType, v.AllowedMac.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address": basetypes.StringType{},
			"allowed_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bridge_interface_to_probe": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_interval": basetypes.Int64Type{},
			"vlan_to_probe": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var bridgeInterfaceToProbeVal basetypes.ListValue
	switch {
	case v.BridgeInterfaceToProbe.IsUnknown():
		bridgeInterfaceToProbeVal = types.ListUnknown(types.StringType)
	case v.BridgeInterfaceToProbe.IsNull():
		bridgeInterfaceToProbeVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		bridgeInterfaceToProbeVal, d = types.ListValue(types.StringType, v.BridgeInterfaceToProbe.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address": basetypes.StringType{},
			"allowed_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bridge_interface_to_probe": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_interval": basetypes.Int64Type{},
			"vlan_to_probe": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var vlanToProbeVal basetypes.ListValue
	switch {
	case v.VlanToProbe.IsUnknown():
		vlanToProbeVal = types.ListUnknown(types.StringType)
	case v.VlanToProbe.IsNull():
		vlanToProbeVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		vlanToProbeVal, d = types.ListValue(types.StringType, v.VlanToProbe.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address": basetypes.StringType{},
			"allowed_mac": basetypes.ListType{
				ElemType: types.StringType,
			},
			"bridge_interface_to_probe": basetypes.ListType{
				ElemType: types.StringType,
			},
			"probe_interval": basetypes.Int64Type{},
			"vlan_to_probe": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"address": basetypes.StringType{},
		"allowed_mac": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bridge_interface_to_probe": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_interval": basetypes.Int64Type{},
		"vlan_to_probe": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address":                   v.Address,
			"allowed_mac":               allowedMacVal,
			"bridge_interface_to_probe": bridgeInterfaceToProbeVal,
			"probe_interval":            v.ProbeInterval,
			"vlan_to_probe":             vlanToProbeVal,
		})

	return objVal, diags
}

func (v VirtualIpDiscoveryValue) Equal(o attr.Value) bool {
	other, ok := o.(VirtualIpDiscoveryValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Address.Equal(other.Address) {
		return false
	}

	if !v.AllowedMac.Equal(other.AllowedMac) {
		return false
	}

	if !v.BridgeInterfaceToProbe.Equal(other.BridgeInterfaceToProbe) {
		return false
	}

	if !v.ProbeInterval.Equal(other.ProbeInterval) {
		return false
	}

	if !v.VlanToProbe.Equal(other.VlanToProbe) {
		return false
	}

	return true
}

func (v VirtualIpDiscoveryValue) Type(ctx context.Context) attr.Type {
	return VirtualIpDiscoveryType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VirtualIpDiscoveryValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address": basetypes.StringType{},
		"allowed_mac": basetypes.ListType{
			ElemType: types.StringType,
		},
		"bridge_interface_to_probe": basetypes.ListType{
			ElemType: types.StringType,
		},
		"probe_interval": basetypes.Int64Type{},
		"vlan_to_probe": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = ProtocolsType{}

type ProtocolsType struct {
	basetypes.ObjectType
}

func (t ProtocolsType) Equal(o attr.Type) bool {
	other, ok := o.(ProtocolsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ProtocolsType) String() string {
	return "ProtocolsType"
}

func (t ProtocolsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bgpAttribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp is missing from object`)

		return nil, diags
	}

	bgpVal, ok := bgpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp expected to be basetypes.ObjectValue, was: %T`, bgpAttribute))
	}

	ospfAttribute, ok := attributes["ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf is missing from object`)

		return nil, diags
	}

	ospfVal, ok := ospfAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf expected to be basetypes.ListValue, was: %T`, ospfAttribute))
	}

	routingPoliciesAttribute, ok := attributes["routing_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routing_policies is missing from object`)

		return nil, diags
	}

	routingPoliciesVal, ok := routingPoliciesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routing_policies expected to be basetypes.ObjectValue, was: %T`, routingPoliciesAttribute))
	}

	staticRoutesAttribute, ok := attributes["static_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_routes is missing from object`)

		return nil, diags
	}

	staticRoutesVal, ok := staticRoutesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_routes expected to be basetypes.ListValue, was: %T`, staticRoutesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ProtocolsValue{
		Bgp:             bgpVal,
		Ospf:            ospfVal,
		RoutingPolicies: routingPoliciesVal,
		StaticRoutes:    staticRoutesVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewProtocolsValueNull() ProtocolsValue {
	return ProtocolsValue{
		state: attr.ValueStateNull,
	}
}

func NewProtocolsValueUnknown() ProtocolsValue {
	return ProtocolsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewProtocolsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ProtocolsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ProtocolsValue Attribute Value",
				"While creating a ProtocolsValue value, a missing attribute value was detected. "+
					"A ProtocolsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProtocolsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ProtocolsValue Attribute Type",
				"While creating a ProtocolsValue value, an invalid attribute value was detected. "+
					"A ProtocolsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ProtocolsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ProtocolsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ProtocolsValue Attribute Value",
				"While creating a ProtocolsValue value, an extra attribute value was detected. "+
					"A ProtocolsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ProtocolsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewProtocolsValueUnknown(), diags
	}

	bgpAttribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp is missing from object`)

		return NewProtocolsValueUnknown(), diags
	}

	bgpVal, ok := bgpAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp expected to be basetypes.ObjectValue, was: %T`, bgpAttribute))
	}

	ospfAttribute, ok := attributes["ospf"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf is missing from object`)

		return NewProtocolsValueUnknown(), diags
	}

	ospfVal, ok := ospfAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf expected to be basetypes.ListValue, was: %T`, ospfAttribute))
	}

	routingPoliciesAttribute, ok := attributes["routing_policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`routing_policies is missing from object`)

		return NewProtocolsValueUnknown(), diags
	}

	routingPoliciesVal, ok := routingPoliciesAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`routing_policies expected to be basetypes.ObjectValue, was: %T`, routingPoliciesAttribute))
	}

	staticRoutesAttribute, ok := attributes["static_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static_routes is missing from object`)

		return NewProtocolsValueUnknown(), diags
	}

	staticRoutesVal, ok := staticRoutesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static_routes expected to be basetypes.ListValue, was: %T`, staticRoutesAttribute))
	}

	if diags.HasError() {
		return NewProtocolsValueUnknown(), diags
	}

	return ProtocolsValue{
		Bgp:             bgpVal,
		Ospf:            ospfVal,
		RoutingPolicies: routingPoliciesVal,
		StaticRoutes:    staticRoutesVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewProtocolsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ProtocolsValue {
	object, diags := NewProtocolsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewProtocolsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ProtocolsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewProtocolsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewProtocolsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewProtocolsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewProtocolsValueMust(ProtocolsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ProtocolsType) ValueType(ctx context.Context) attr.Value {
	return ProtocolsValue{}
}

var _ basetypes.ObjectValuable = ProtocolsValue{}

type ProtocolsValue struct {
	Bgp             basetypes.ObjectValue `tfsdk:"bgp"`
	Ospf            basetypes.ListValue   `tfsdk:"ospf"`
	RoutingPolicies basetypes.ObjectValue `tfsdk:"routing_policies"`
	StaticRoutes    basetypes.ListValue   `tfsdk:"static_routes"`
	state           attr.ValueState
}

func (v ProtocolsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["bgp"] = basetypes.ObjectType{
		AttrTypes: BgpValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ospf"] = basetypes.ListType{
		ElemType: OspfValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["routing_policies"] = basetypes.ObjectType{
		AttrTypes: RoutingPoliciesValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["static_routes"] = basetypes.ListType{
		ElemType: StaticRoutesValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Bgp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp"] = val

		val, err = v.Ospf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ospf"] = val

		val, err = v.RoutingPolicies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["routing_policies"] = val

		val, err = v.StaticRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static_routes"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ProtocolsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ProtocolsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ProtocolsValue) String() string {
	return "ProtocolsValue"
}

func (v ProtocolsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bgp basetypes.ObjectValue

	if v.Bgp.IsNull() {
		bgp = types.ObjectNull(
			BgpValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bgp.IsUnknown() {
		bgp = types.ObjectUnknown(
			BgpValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bgp.IsNull() && !v.Bgp.IsUnknown() {
		bgp = types.ObjectValueMust(
			BgpValue{}.AttributeTypes(ctx),
			v.Bgp.Attributes(),
		)
	}

	ospf := types.ListValueMust(
		OspfType{
			basetypes.ObjectType{
				AttrTypes: OspfValue{}.AttributeTypes(ctx),
			},
		},
		v.Ospf.Elements(),
	)

	if v.Ospf.IsNull() {
		ospf = types.ListNull(
			OspfType{
				basetypes.ObjectType{
					AttrTypes: OspfValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ospf.IsUnknown() {
		ospf = types.ListUnknown(
			OspfType{
				basetypes.ObjectType{
					AttrTypes: OspfValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var routingPolicies basetypes.ObjectValue

	if v.RoutingPolicies.IsNull() {
		routingPolicies = types.ObjectNull(
			RoutingPoliciesValue{}.AttributeTypes(ctx),
		)
	}

	if v.RoutingPolicies.IsUnknown() {
		routingPolicies = types.ObjectUnknown(
			RoutingPoliciesValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RoutingPolicies.IsNull() && !v.RoutingPolicies.IsUnknown() {
		routingPolicies = types.ObjectValueMust(
			RoutingPoliciesValue{}.AttributeTypes(ctx),
			v.RoutingPolicies.Attributes(),
		)
	}

	staticRoutes := types.ListValueMust(
		StaticRoutesType{
			basetypes.ObjectType{
				AttrTypes: StaticRoutesValue{}.AttributeTypes(ctx),
			},
		},
		v.StaticRoutes.Elements(),
	)

	if v.StaticRoutes.IsNull() {
		staticRoutes = types.ListNull(
			StaticRoutesType{
				basetypes.ObjectType{
					AttrTypes: StaticRoutesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.StaticRoutes.IsUnknown() {
		staticRoutes = types.ListUnknown(
			StaticRoutesType{
				basetypes.ObjectType{
					AttrTypes: StaticRoutesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: BgpValue{}.AttributeTypes(ctx),
		},
		"ospf": basetypes.ListType{
			ElemType: OspfValue{}.Type(ctx),
		},
		"routing_policies": basetypes.ObjectType{
			AttrTypes: RoutingPoliciesValue{}.AttributeTypes(ctx),
		},
		"static_routes": basetypes.ListType{
			ElemType: StaticRoutesValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bgp":              bgp,
			"ospf":             ospf,
			"routing_policies": routingPolicies,
			"static_routes":    staticRoutes,
		})

	return objVal, diags
}

func (v ProtocolsValue) Equal(o attr.Value) bool {
	other, ok := o.(ProtocolsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bgp.Equal(other.Bgp) {
		return false
	}

	if !v.Ospf.Equal(other.Ospf) {
		return false
	}

	if !v.RoutingPolicies.Equal(other.RoutingPolicies) {
		return false
	}

	if !v.StaticRoutes.Equal(other.StaticRoutes) {
		return false
	}

	return true
}

func (v ProtocolsValue) Type(ctx context.Context) attr.Type {
	return ProtocolsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ProtocolsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: BgpValue{}.AttributeTypes(ctx),
		},
		"ospf": basetypes.ListType{
			ElemType: OspfValue{}.Type(ctx),
		},
		"routing_policies": basetypes.ObjectType{
			AttrTypes: RoutingPoliciesValue{}.AttributeTypes(ctx),
		},
		"static_routes": basetypes.ListType{
			ElemType: StaticRoutesValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = BgpType{}

type BgpType struct {
	basetypes.ObjectType
}

func (t BgpType) Equal(o attr.Type) bool {
	other, ok := o.(BgpType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BgpType) String() string {
	return "BgpType"
}

func (t BgpType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bgpGroupsAttribute, ok := attributes["bgp_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_groups is missing from object`)

		return nil, diags
	}

	bgpGroupsVal, ok := bgpGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_groups expected to be basetypes.ListValue, was: %T`, bgpGroupsAttribute))
	}

	bgpPeersAttribute, ok := attributes["bgp_peers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_peers is missing from object`)

		return nil, diags
	}

	bgpPeersVal, ok := bgpPeersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_peers expected to be basetypes.ListValue, was: %T`, bgpPeersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BgpValue{
		BgpGroups: bgpGroupsVal,
		BgpPeers:  bgpPeersVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewBgpValueNull() BgpValue {
	return BgpValue{
		state: attr.ValueStateNull,
	}
}

func NewBgpValueUnknown() BgpValue {
	return BgpValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBgpValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BgpValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BgpValue Attribute Value",
				"While creating a BgpValue value, a missing attribute value was detected. "+
					"A BgpValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BgpValue Attribute Type",
				"While creating a BgpValue value, an invalid attribute value was detected. "+
					"A BgpValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BgpValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BgpValue Attribute Value",
				"While creating a BgpValue value, an extra attribute value was detected. "+
					"A BgpValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BgpValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgpValueUnknown(), diags
	}

	bgpGroupsAttribute, ok := attributes["bgp_groups"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_groups is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	bgpGroupsVal, ok := bgpGroupsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_groups expected to be basetypes.ListValue, was: %T`, bgpGroupsAttribute))
	}

	bgpPeersAttribute, ok := attributes["bgp_peers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_peers is missing from object`)

		return NewBgpValueUnknown(), diags
	}

	bgpPeersVal, ok := bgpPeersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_peers expected to be basetypes.ListValue, was: %T`, bgpPeersAttribute))
	}

	if diags.HasError() {
		return NewBgpValueUnknown(), diags
	}

	return BgpValue{
		BgpGroups: bgpGroupsVal,
		BgpPeers:  bgpPeersVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewBgpValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BgpValue {
	object, diags := NewBgpValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgpValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BgpType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgpValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgpValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgpValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgpValueMust(BgpValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BgpType) ValueType(ctx context.Context) attr.Value {
	return BgpValue{}
}

var _ basetypes.ObjectValuable = BgpValue{}

type BgpValue struct {
	BgpGroups basetypes.ListValue `tfsdk:"bgp_groups"`
	BgpPeers  basetypes.ListValue `tfsdk:"bgp_peers"`
	state     attr.ValueState
}

func (v BgpValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["bgp_groups"] = basetypes.ListType{
		ElemType: BgpGroupsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["bgp_peers"] = basetypes.ListType{
		ElemType: BgpPeersValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.BgpGroups.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp_groups"] = val

		val, err = v.BgpPeers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp_peers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BgpValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BgpValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BgpValue) String() string {
	return "BgpValue"
}

func (v BgpValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	bgpGroups := types.ListValueMust(
		BgpGroupsType{
			basetypes.ObjectType{
				AttrTypes: BgpGroupsValue{}.AttributeTypes(ctx),
			},
		},
		v.BgpGroups.Elements(),
	)

	if v.BgpGroups.IsNull() {
		bgpGroups = types.ListNull(
			BgpGroupsType{
				basetypes.ObjectType{
					AttrTypes: BgpGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.BgpGroups.IsUnknown() {
		bgpGroups = types.ListUnknown(
			BgpGroupsType{
				basetypes.ObjectType{
					AttrTypes: BgpGroupsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	bgpPeers := types.ListValueMust(
		BgpPeersType{
			basetypes.ObjectType{
				AttrTypes: BgpPeersValue{}.AttributeTypes(ctx),
			},
		},
		v.BgpPeers.Elements(),
	)

	if v.BgpPeers.IsNull() {
		bgpPeers = types.ListNull(
			BgpPeersType{
				basetypes.ObjectType{
					AttrTypes: BgpPeersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.BgpPeers.IsUnknown() {
		bgpPeers = types.ListUnknown(
			BgpPeersType{
				basetypes.ObjectType{
					AttrTypes: BgpPeersValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"bgp_groups": basetypes.ListType{
			ElemType: BgpGroupsValue{}.Type(ctx),
		},
		"bgp_peers": basetypes.ListType{
			ElemType: BgpPeersValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bgp_groups": bgpGroups,
			"bgp_peers":  bgpPeers,
		})

	return objVal, diags
}

func (v BgpValue) Equal(o attr.Value) bool {
	other, ok := o.(BgpValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BgpGroups.Equal(other.BgpGroups) {
		return false
	}

	if !v.BgpPeers.Equal(other.BgpPeers) {
		return false
	}

	return true
}

func (v BgpValue) Type(ctx context.Context) attr.Type {
	return BgpType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BgpValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bgp_groups": basetypes.ListType{
			ElemType: BgpGroupsValue{}.Type(ctx),
		},
		"bgp_peers": basetypes.ListType{
			ElemType: BgpPeersValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = BgpGroupsType{}

type BgpGroupsType struct {
	basetypes.ObjectType
}

func (t BgpGroupsType) Equal(o attr.Type) bool {
	other, ok := o.(BgpGroupsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BgpGroupsType) String() string {
	return "BgpGroupsType"
}

func (t BgpGroupsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec4Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_4 is missing from object`)

		return nil, diags
	}

	spec4Val, ok := spec4Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_4 expected to be basetypes.ObjectValue, was: %T`, spec4Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BgpGroupsValue{
		Name:  nameVal,
		Spec4: spec4Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBgpGroupsValueNull() BgpGroupsValue {
	return BgpGroupsValue{
		state: attr.ValueStateNull,
	}
}

func NewBgpGroupsValueUnknown() BgpGroupsValue {
	return BgpGroupsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBgpGroupsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BgpGroupsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BgpGroupsValue Attribute Value",
				"While creating a BgpGroupsValue value, a missing attribute value was detected. "+
					"A BgpGroupsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpGroupsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BgpGroupsValue Attribute Type",
				"While creating a BgpGroupsValue value, an invalid attribute value was detected. "+
					"A BgpGroupsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpGroupsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BgpGroupsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BgpGroupsValue Attribute Value",
				"While creating a BgpGroupsValue value, an extra attribute value was detected. "+
					"A BgpGroupsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BgpGroupsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgpGroupsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewBgpGroupsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec4Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_4 is missing from object`)

		return NewBgpGroupsValueUnknown(), diags
	}

	spec4Val, ok := spec4Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_4 expected to be basetypes.ObjectValue, was: %T`, spec4Attribute))
	}

	if diags.HasError() {
		return NewBgpGroupsValueUnknown(), diags
	}

	return BgpGroupsValue{
		Name:  nameVal,
		Spec4: spec4Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBgpGroupsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BgpGroupsValue {
	object, diags := NewBgpGroupsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgpGroupsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BgpGroupsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgpGroupsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgpGroupsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgpGroupsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgpGroupsValueMust(BgpGroupsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BgpGroupsType) ValueType(ctx context.Context) attr.Value {
	return BgpGroupsValue{}
}

var _ basetypes.ObjectValuable = BgpGroupsValue{}

type BgpGroupsValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Spec4 basetypes.ObjectValue `tfsdk:"spec"`
	state attr.ValueState
}

func (v BgpGroupsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec4Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Spec4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BgpGroupsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BgpGroupsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BgpGroupsValue) String() string {
	return "BgpGroupsValue"
}

func (v BgpGroupsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spec4 basetypes.ObjectValue

	if v.Spec4.IsNull() {
		spec4 = types.ObjectNull(
			Spec4Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec4.IsUnknown() {
		spec4 = types.ObjectUnknown(
			Spec4Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec4.IsNull() && !v.Spec4.IsUnknown() {
		spec4 = types.ObjectValueMust(
			Spec4Value{}.AttributeTypes(ctx),
			v.Spec4.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec4Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"spec": spec4,
		})

	return objVal, diags
}

func (v BgpGroupsValue) Equal(o attr.Value) bool {
	other, ok := o.(BgpGroupsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Spec4.Equal(other.Spec4) {
		return false
	}

	return true
}

func (v BgpGroupsValue) Type(ctx context.Context) attr.Type {
	return BgpGroupsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BgpGroupsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec4Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Spec4Type{}

type Spec4Type struct {
	basetypes.ObjectType
}

func (t Spec4Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec4Type) String() string {
	return "Spec4Type"
}

func (t Spec4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathOptionsAttribute, ok := attributes["as_path_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_options is missing from object`)

		return nil, diags
	}

	asPathOptionsVal, ok := asPathOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_options expected to be basetypes.ObjectValue, was: %T`, asPathOptionsAttribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return nil, diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.BoolValue, was: %T`, bfdAttribute))
	}

	clientAttribute, ok := attributes["client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client is missing from object`)

		return nil, diags
	}

	clientVal, ok := clientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client expected to be basetypes.BoolValue, was: %T`, clientAttribute))
	}

	clusterIdAttribute, ok := attributes["cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_id is missing from object`)

		return nil, diags
	}

	clusterIdVal, ok := clusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_id expected to be basetypes.StringValue, was: %T`, clusterIdAttribute))
	}

	configuredNameAttribute, ok := attributes["configured_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_name is missing from object`)

		return nil, diags
	}

	configuredNameVal, ok := configuredNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_name expected to be basetypes.StringValue, was: %T`, configuredNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	grStaleRouteTimeAttribute, ok := attributes["gr_stale_route_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gr_stale_route_time is missing from object`)

		return nil, diags
	}

	grStaleRouteTimeVal, ok := grStaleRouteTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gr_stale_route_time expected to be basetypes.Int64Value, was: %T`, grStaleRouteTimeAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	ipv4UnicastAttribute, ok := attributes["ipv4_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_unicast is missing from object`)

		return nil, diags
	}

	ipv4UnicastVal, ok := ipv4UnicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_unicast expected to be basetypes.ObjectValue, was: %T`, ipv4UnicastAttribute))
	}

	ipv6UnicastAttribute, ok := attributes["ipv6_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_unicast is missing from object`)

		return nil, diags
	}

	ipv6UnicastVal, ok := ipv6UnicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_unicast expected to be basetypes.ObjectValue, was: %T`, ipv6UnicastAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return nil, diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return nil, diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.ObjectValue, was: %T`, localAsAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return nil, diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	multiHopMaxHopAttribute, ok := attributes["multi_hop_max_hop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multi_hop_max_hop is missing from object`)

		return nil, diags
	}

	multiHopMaxHopVal, ok := multiHopMaxHopAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multi_hop_max_hop expected to be basetypes.Int64Value, was: %T`, multiHopMaxHopAttribute))
	}

	nextHopSelfAttribute, ok := attributes["next_hop_self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_hop_self is missing from object`)

		return nil, diags
	}

	nextHopSelfVal, ok := nextHopSelfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_hop_self expected to be basetypes.BoolValue, was: %T`, nextHopSelfAttribute))
	}

	peerAsAttribute, ok := attributes["peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_as is missing from object`)

		return nil, diags
	}

	peerAsVal, ok := peerAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_as expected to be basetypes.ObjectValue, was: %T`, peerAsAttribute))
	}

	sendCommunityLargeAttribute, ok := attributes["send_community_large"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_large is missing from object`)

		return nil, diags
	}

	sendCommunityLargeVal, ok := sendCommunityLargeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_large expected to be basetypes.BoolValue, was: %T`, sendCommunityLargeAttribute))
	}

	sendCommunityStandardAttribute, ok := attributes["send_community_standard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_standard is missing from object`)

		return nil, diags
	}

	sendCommunityStandardVal, ok := sendCommunityStandardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_standard expected to be basetypes.BoolValue, was: %T`, sendCommunityStandardAttribute))
	}

	sendDefaultRouteAttribute, ok := attributes["send_default_route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_default_route is missing from object`)

		return nil, diags
	}

	sendDefaultRouteVal, ok := sendDefaultRouteAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_default_route expected to be basetypes.ObjectValue, was: %T`, sendDefaultRouteAttribute))
	}

	timersAttribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers is missing from object`)

		return nil, diags
	}

	timersVal, ok := timersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers expected to be basetypes.ObjectValue, was: %T`, timersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec4Value{
		AsPathOptions:         asPathOptionsVal,
		Bfd:                   bfdVal,
		Client:                clientVal,
		ClusterId:             clusterIdVal,
		ConfiguredName:        configuredNameVal,
		Description:           descriptionVal,
		ExportPolicy:          exportPolicyVal,
		GrStaleRouteTime:      grStaleRouteTimeVal,
		ImportPolicy:          importPolicyVal,
		Ipv4Unicast:           ipv4UnicastVal,
		Ipv6Unicast:           ipv6UnicastVal,
		Keychain:              keychainVal,
		LocalAs:               localAsVal,
		LocalPreference:       localPreferenceVal,
		MultiHopMaxHop:        multiHopMaxHopVal,
		NextHopSelf:           nextHopSelfVal,
		PeerAs:                peerAsVal,
		SendCommunityLarge:    sendCommunityLargeVal,
		SendCommunityStandard: sendCommunityStandardVal,
		SendDefaultRoute:      sendDefaultRouteVal,
		Timers:                timersVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSpec4ValueNull() Spec4Value {
	return Spec4Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec4ValueUnknown() Spec4Value {
	return Spec4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec4Value Attribute Value",
				"While creating a Spec4Value value, a missing attribute value was detected. "+
					"A Spec4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec4Value Attribute Type",
				"While creating a Spec4Value value, an invalid attribute value was detected. "+
					"A Spec4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec4Value Attribute Value",
				"While creating a Spec4Value value, an extra attribute value was detected. "+
					"A Spec4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec4ValueUnknown(), diags
	}

	asPathOptionsAttribute, ok := attributes["as_path_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_options is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	asPathOptionsVal, ok := asPathOptionsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_options expected to be basetypes.ObjectValue, was: %T`, asPathOptionsAttribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.BoolValue, was: %T`, bfdAttribute))
	}

	clientAttribute, ok := attributes["client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	clientVal, ok := clientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client expected to be basetypes.BoolValue, was: %T`, clientAttribute))
	}

	clusterIdAttribute, ok := attributes["cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_id is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	clusterIdVal, ok := clusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_id expected to be basetypes.StringValue, was: %T`, clusterIdAttribute))
	}

	configuredNameAttribute, ok := attributes["configured_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_name is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	configuredNameVal, ok := configuredNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_name expected to be basetypes.StringValue, was: %T`, configuredNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	grStaleRouteTimeAttribute, ok := attributes["gr_stale_route_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gr_stale_route_time is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	grStaleRouteTimeVal, ok := grStaleRouteTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gr_stale_route_time expected to be basetypes.Int64Value, was: %T`, grStaleRouteTimeAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	ipv4UnicastAttribute, ok := attributes["ipv4_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_unicast is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	ipv4UnicastVal, ok := ipv4UnicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_unicast expected to be basetypes.ObjectValue, was: %T`, ipv4UnicastAttribute))
	}

	ipv6UnicastAttribute, ok := attributes["ipv6_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_unicast is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	ipv6UnicastVal, ok := ipv6UnicastAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_unicast expected to be basetypes.ObjectValue, was: %T`, ipv6UnicastAttribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	localAsAttribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	localAsVal, ok := localAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as expected to be basetypes.ObjectValue, was: %T`, localAsAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	multiHopMaxHopAttribute, ok := attributes["multi_hop_max_hop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multi_hop_max_hop is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	multiHopMaxHopVal, ok := multiHopMaxHopAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multi_hop_max_hop expected to be basetypes.Int64Value, was: %T`, multiHopMaxHopAttribute))
	}

	nextHopSelfAttribute, ok := attributes["next_hop_self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_hop_self is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	nextHopSelfVal, ok := nextHopSelfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_hop_self expected to be basetypes.BoolValue, was: %T`, nextHopSelfAttribute))
	}

	peerAsAttribute, ok := attributes["peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_as is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	peerAsVal, ok := peerAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_as expected to be basetypes.ObjectValue, was: %T`, peerAsAttribute))
	}

	sendCommunityLargeAttribute, ok := attributes["send_community_large"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_large is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	sendCommunityLargeVal, ok := sendCommunityLargeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_large expected to be basetypes.BoolValue, was: %T`, sendCommunityLargeAttribute))
	}

	sendCommunityStandardAttribute, ok := attributes["send_community_standard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_standard is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	sendCommunityStandardVal, ok := sendCommunityStandardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_standard expected to be basetypes.BoolValue, was: %T`, sendCommunityStandardAttribute))
	}

	sendDefaultRouteAttribute, ok := attributes["send_default_route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_default_route is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	sendDefaultRouteVal, ok := sendDefaultRouteAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_default_route expected to be basetypes.ObjectValue, was: %T`, sendDefaultRouteAttribute))
	}

	timersAttribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers is missing from object`)

		return NewSpec4ValueUnknown(), diags
	}

	timersVal, ok := timersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers expected to be basetypes.ObjectValue, was: %T`, timersAttribute))
	}

	if diags.HasError() {
		return NewSpec4ValueUnknown(), diags
	}

	return Spec4Value{
		AsPathOptions:         asPathOptionsVal,
		Bfd:                   bfdVal,
		Client:                clientVal,
		ClusterId:             clusterIdVal,
		ConfiguredName:        configuredNameVal,
		Description:           descriptionVal,
		ExportPolicy:          exportPolicyVal,
		GrStaleRouteTime:      grStaleRouteTimeVal,
		ImportPolicy:          importPolicyVal,
		Ipv4Unicast:           ipv4UnicastVal,
		Ipv6Unicast:           ipv6UnicastVal,
		Keychain:              keychainVal,
		LocalAs:               localAsVal,
		LocalPreference:       localPreferenceVal,
		MultiHopMaxHop:        multiHopMaxHopVal,
		NextHopSelf:           nextHopSelfVal,
		PeerAs:                peerAsVal,
		SendCommunityLarge:    sendCommunityLargeVal,
		SendCommunityStandard: sendCommunityStandardVal,
		SendDefaultRoute:      sendDefaultRouteVal,
		Timers:                timersVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSpec4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec4Value {
	object, diags := NewSpec4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec4ValueMust(Spec4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec4Type) ValueType(ctx context.Context) attr.Value {
	return Spec4Value{}
}

var _ basetypes.ObjectValuable = Spec4Value{}

type Spec4Value struct {
	AsPathOptions         basetypes.ObjectValue `tfsdk:"as_path_options"`
	Bfd                   basetypes.BoolValue   `tfsdk:"bfd"`
	Client                basetypes.BoolValue   `tfsdk:"client"`
	ClusterId             basetypes.StringValue `tfsdk:"cluster_id"`
	ConfiguredName        basetypes.StringValue `tfsdk:"configured_name"`
	Description           basetypes.StringValue `tfsdk:"description"`
	ExportPolicy          basetypes.ListValue   `tfsdk:"export_policy"`
	GrStaleRouteTime      basetypes.Int64Value  `tfsdk:"gr_stale_route_time"`
	ImportPolicy          basetypes.ListValue   `tfsdk:"import_policy"`
	Ipv4Unicast           basetypes.ObjectValue `tfsdk:"ipv4_unicast"`
	Ipv6Unicast           basetypes.ObjectValue `tfsdk:"ipv6_unicast"`
	Keychain              basetypes.StringValue `tfsdk:"keychain"`
	LocalAs               basetypes.ObjectValue `tfsdk:"local_as"`
	LocalPreference       basetypes.Int64Value  `tfsdk:"local_preference"`
	MultiHopMaxHop        basetypes.Int64Value  `tfsdk:"multi_hop_max_hop"`
	NextHopSelf           basetypes.BoolValue   `tfsdk:"next_hop_self"`
	PeerAs                basetypes.ObjectValue `tfsdk:"peer_as"`
	SendCommunityLarge    basetypes.BoolValue   `tfsdk:"send_community_large"`
	SendCommunityStandard basetypes.BoolValue   `tfsdk:"send_community_standard"`
	SendDefaultRoute      basetypes.ObjectValue `tfsdk:"send_default_route"`
	Timers                basetypes.ObjectValue `tfsdk:"timers"`
	state                 attr.ValueState
}

func (v Spec4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 21)

	var val tftypes.Value
	var err error

	attrTypes["as_path_options"] = basetypes.ObjectType{
		AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["bfd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["client"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cluster_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["configured_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gr_stale_route_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["ipv4_unicast"] = basetypes.ObjectType{
		AttrTypes: Ipv4UnicastValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6_unicast"] = basetypes.ObjectType{
		AttrTypes: Ipv6UnicastValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["keychain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_as"] = basetypes.ObjectType{
		AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["local_preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["multi_hop_max_hop"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["next_hop_self"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["peer_as"] = basetypes.ObjectType{
		AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["send_community_large"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["send_community_standard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["send_default_route"] = basetypes.ObjectType{
		AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["timers"] = basetypes.ObjectType{
		AttrTypes: TimersValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 21)

		val, err = v.AsPathOptions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_options"] = val

		val, err = v.Bfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.Client.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client"] = val

		val, err = v.ClusterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_id"] = val

		val, err = v.ConfiguredName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configured_name"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.GrStaleRouteTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gr_stale_route_time"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.Ipv4Unicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_unicast"] = val

		val, err = v.Ipv6Unicast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_unicast"] = val

		val, err = v.Keychain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keychain"] = val

		val, err = v.LocalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_as"] = val

		val, err = v.LocalPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_preference"] = val

		val, err = v.MultiHopMaxHop.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multi_hop_max_hop"] = val

		val, err = v.NextHopSelf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_hop_self"] = val

		val, err = v.PeerAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_as"] = val

		val, err = v.SendCommunityLarge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_community_large"] = val

		val, err = v.SendCommunityStandard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_community_standard"] = val

		val, err = v.SendDefaultRoute.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_default_route"] = val

		val, err = v.Timers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec4Value) String() string {
	return "Spec4Value"
}

func (v Spec4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var asPathOptions basetypes.ObjectValue

	if v.AsPathOptions.IsNull() {
		asPathOptions = types.ObjectNull(
			AsPathOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if v.AsPathOptions.IsUnknown() {
		asPathOptions = types.ObjectUnknown(
			AsPathOptionsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AsPathOptions.IsNull() && !v.AsPathOptions.IsUnknown() {
		asPathOptions = types.ObjectValueMust(
			AsPathOptionsValue{}.AttributeTypes(ctx),
			v.AsPathOptions.Attributes(),
		)
	}

	var ipv4Unicast basetypes.ObjectValue

	if v.Ipv4Unicast.IsNull() {
		ipv4Unicast = types.ObjectNull(
			Ipv4UnicastValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv4Unicast.IsUnknown() {
		ipv4Unicast = types.ObjectUnknown(
			Ipv4UnicastValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv4Unicast.IsNull() && !v.Ipv4Unicast.IsUnknown() {
		ipv4Unicast = types.ObjectValueMust(
			Ipv4UnicastValue{}.AttributeTypes(ctx),
			v.Ipv4Unicast.Attributes(),
		)
	}

	var ipv6Unicast basetypes.ObjectValue

	if v.Ipv6Unicast.IsNull() {
		ipv6Unicast = types.ObjectNull(
			Ipv6UnicastValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv6Unicast.IsUnknown() {
		ipv6Unicast = types.ObjectUnknown(
			Ipv6UnicastValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv6Unicast.IsNull() && !v.Ipv6Unicast.IsUnknown() {
		ipv6Unicast = types.ObjectValueMust(
			Ipv6UnicastValue{}.AttributeTypes(ctx),
			v.Ipv6Unicast.Attributes(),
		)
	}

	var localAs basetypes.ObjectValue

	if v.LocalAs.IsNull() {
		localAs = types.ObjectNull(
			LocalAsValue{}.AttributeTypes(ctx),
		)
	}

	if v.LocalAs.IsUnknown() {
		localAs = types.ObjectUnknown(
			LocalAsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LocalAs.IsNull() && !v.LocalAs.IsUnknown() {
		localAs = types.ObjectValueMust(
			LocalAsValue{}.AttributeTypes(ctx),
			v.LocalAs.Attributes(),
		)
	}

	var peerAs basetypes.ObjectValue

	if v.PeerAs.IsNull() {
		peerAs = types.ObjectNull(
			PeerAsValue{}.AttributeTypes(ctx),
		)
	}

	if v.PeerAs.IsUnknown() {
		peerAs = types.ObjectUnknown(
			PeerAsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PeerAs.IsNull() && !v.PeerAs.IsUnknown() {
		peerAs = types.ObjectValueMust(
			PeerAsValue{}.AttributeTypes(ctx),
			v.PeerAs.Attributes(),
		)
	}

	var sendDefaultRoute basetypes.ObjectValue

	if v.SendDefaultRoute.IsNull() {
		sendDefaultRoute = types.ObjectNull(
			SendDefaultRouteValue{}.AttributeTypes(ctx),
		)
	}

	if v.SendDefaultRoute.IsUnknown() {
		sendDefaultRoute = types.ObjectUnknown(
			SendDefaultRouteValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SendDefaultRoute.IsNull() && !v.SendDefaultRoute.IsUnknown() {
		sendDefaultRoute = types.ObjectValueMust(
			SendDefaultRouteValue{}.AttributeTypes(ctx),
			v.SendDefaultRoute.Attributes(),
		)
	}

	var timers basetypes.ObjectValue

	if v.Timers.IsNull() {
		timers = types.ObjectNull(
			TimersValue{}.AttributeTypes(ctx),
		)
	}

	if v.Timers.IsUnknown() {
		timers = types.ObjectUnknown(
			TimersValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Timers.IsNull() && !v.Timers.IsUnknown() {
		timers = types.ObjectValueMust(
			TimersValue{}.AttributeTypes(ctx),
			v.Timers.Attributes(),
		)
	}

	var exportPolicyVal basetypes.ListValue
	switch {
	case v.ExportPolicy.IsUnknown():
		exportPolicyVal = types.ListUnknown(types.StringType)
	case v.ExportPolicy.IsNull():
		exportPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		exportPolicyVal, d = types.ListValue(types.StringType, v.ExportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_options": basetypes.ObjectType{
				AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
			},
			"bfd":             basetypes.BoolType{},
			"client":          basetypes.BoolType{},
			"cluster_id":      basetypes.StringType{},
			"configured_name": basetypes.StringType{},
			"description":     basetypes.StringType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gr_stale_route_time": basetypes.Int64Type{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"ipv4_unicast": basetypes.ObjectType{
				AttrTypes: Ipv4UnicastValue{}.AttributeTypes(ctx),
			},
			"ipv6_unicast": basetypes.ObjectType{
				AttrTypes: Ipv6UnicastValue{}.AttributeTypes(ctx),
			},
			"keychain": basetypes.StringType{},
			"local_as": basetypes.ObjectType{
				AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
			},
			"local_preference":  basetypes.Int64Type{},
			"multi_hop_max_hop": basetypes.Int64Type{},
			"next_hop_self":     basetypes.BoolType{},
			"peer_as": basetypes.ObjectType{
				AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
			},
			"send_community_large":    basetypes.BoolType{},
			"send_community_standard": basetypes.BoolType{},
			"send_default_route": basetypes.ObjectType{
				AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var importPolicyVal basetypes.ListValue
	switch {
	case v.ImportPolicy.IsUnknown():
		importPolicyVal = types.ListUnknown(types.StringType)
	case v.ImportPolicy.IsNull():
		importPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		importPolicyVal, d = types.ListValue(types.StringType, v.ImportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_options": basetypes.ObjectType{
				AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
			},
			"bfd":             basetypes.BoolType{},
			"client":          basetypes.BoolType{},
			"cluster_id":      basetypes.StringType{},
			"configured_name": basetypes.StringType{},
			"description":     basetypes.StringType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gr_stale_route_time": basetypes.Int64Type{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"ipv4_unicast": basetypes.ObjectType{
				AttrTypes: Ipv4UnicastValue{}.AttributeTypes(ctx),
			},
			"ipv6_unicast": basetypes.ObjectType{
				AttrTypes: Ipv6UnicastValue{}.AttributeTypes(ctx),
			},
			"keychain": basetypes.StringType{},
			"local_as": basetypes.ObjectType{
				AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
			},
			"local_preference":  basetypes.Int64Type{},
			"multi_hop_max_hop": basetypes.Int64Type{},
			"next_hop_self":     basetypes.BoolType{},
			"peer_as": basetypes.ObjectType{
				AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
			},
			"send_community_large":    basetypes.BoolType{},
			"send_community_standard": basetypes.BoolType{},
			"send_default_route": basetypes.ObjectType{
				AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
			},
			"timers": basetypes.ObjectType{
				AttrTypes: TimersValue{}.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"as_path_options": basetypes.ObjectType{
			AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
		},
		"bfd":             basetypes.BoolType{},
		"client":          basetypes.BoolType{},
		"cluster_id":      basetypes.StringType{},
		"configured_name": basetypes.StringType{},
		"description":     basetypes.StringType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gr_stale_route_time": basetypes.Int64Type{},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"ipv4_unicast": basetypes.ObjectType{
			AttrTypes: Ipv4UnicastValue{}.AttributeTypes(ctx),
		},
		"ipv6_unicast": basetypes.ObjectType{
			AttrTypes: Ipv6UnicastValue{}.AttributeTypes(ctx),
		},
		"keychain": basetypes.StringType{},
		"local_as": basetypes.ObjectType{
			AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
		},
		"local_preference":  basetypes.Int64Type{},
		"multi_hop_max_hop": basetypes.Int64Type{},
		"next_hop_self":     basetypes.BoolType{},
		"peer_as": basetypes.ObjectType{
			AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
		},
		"send_community_large":    basetypes.BoolType{},
		"send_community_standard": basetypes.BoolType{},
		"send_default_route": basetypes.ObjectType{
			AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
		},
		"timers": basetypes.ObjectType{
			AttrTypes: TimersValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path_options":         asPathOptions,
			"bfd":                     v.Bfd,
			"client":                  v.Client,
			"cluster_id":              v.ClusterId,
			"configured_name":         v.ConfiguredName,
			"description":             v.Description,
			"export_policy":           exportPolicyVal,
			"gr_stale_route_time":     v.GrStaleRouteTime,
			"import_policy":           importPolicyVal,
			"ipv4_unicast":            ipv4Unicast,
			"ipv6_unicast":            ipv6Unicast,
			"keychain":                v.Keychain,
			"local_as":                localAs,
			"local_preference":        v.LocalPreference,
			"multi_hop_max_hop":       v.MultiHopMaxHop,
			"next_hop_self":           v.NextHopSelf,
			"peer_as":                 peerAs,
			"send_community_large":    v.SendCommunityLarge,
			"send_community_standard": v.SendCommunityStandard,
			"send_default_route":      sendDefaultRoute,
			"timers":                  timers,
		})

	return objVal, diags
}

func (v Spec4Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPathOptions.Equal(other.AsPathOptions) {
		return false
	}

	if !v.Bfd.Equal(other.Bfd) {
		return false
	}

	if !v.Client.Equal(other.Client) {
		return false
	}

	if !v.ClusterId.Equal(other.ClusterId) {
		return false
	}

	if !v.ConfiguredName.Equal(other.ConfiguredName) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.GrStaleRouteTime.Equal(other.GrStaleRouteTime) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.Ipv4Unicast.Equal(other.Ipv4Unicast) {
		return false
	}

	if !v.Ipv6Unicast.Equal(other.Ipv6Unicast) {
		return false
	}

	if !v.Keychain.Equal(other.Keychain) {
		return false
	}

	if !v.LocalAs.Equal(other.LocalAs) {
		return false
	}

	if !v.LocalPreference.Equal(other.LocalPreference) {
		return false
	}

	if !v.MultiHopMaxHop.Equal(other.MultiHopMaxHop) {
		return false
	}

	if !v.NextHopSelf.Equal(other.NextHopSelf) {
		return false
	}

	if !v.PeerAs.Equal(other.PeerAs) {
		return false
	}

	if !v.SendCommunityLarge.Equal(other.SendCommunityLarge) {
		return false
	}

	if !v.SendCommunityStandard.Equal(other.SendCommunityStandard) {
		return false
	}

	if !v.SendDefaultRoute.Equal(other.SendDefaultRoute) {
		return false
	}

	if !v.Timers.Equal(other.Timers) {
		return false
	}

	return true
}

func (v Spec4Value) Type(ctx context.Context) attr.Type {
	return Spec4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path_options": basetypes.ObjectType{
			AttrTypes: AsPathOptionsValue{}.AttributeTypes(ctx),
		},
		"bfd":             basetypes.BoolType{},
		"client":          basetypes.BoolType{},
		"cluster_id":      basetypes.StringType{},
		"configured_name": basetypes.StringType{},
		"description":     basetypes.StringType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gr_stale_route_time": basetypes.Int64Type{},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"ipv4_unicast": basetypes.ObjectType{
			AttrTypes: Ipv4UnicastValue{}.AttributeTypes(ctx),
		},
		"ipv6_unicast": basetypes.ObjectType{
			AttrTypes: Ipv6UnicastValue{}.AttributeTypes(ctx),
		},
		"keychain": basetypes.StringType{},
		"local_as": basetypes.ObjectType{
			AttrTypes: LocalAsValue{}.AttributeTypes(ctx),
		},
		"local_preference":  basetypes.Int64Type{},
		"multi_hop_max_hop": basetypes.Int64Type{},
		"next_hop_self":     basetypes.BoolType{},
		"peer_as": basetypes.ObjectType{
			AttrTypes: PeerAsValue{}.AttributeTypes(ctx),
		},
		"send_community_large":    basetypes.BoolType{},
		"send_community_standard": basetypes.BoolType{},
		"send_default_route": basetypes.ObjectType{
			AttrTypes: SendDefaultRouteValue{}.AttributeTypes(ctx),
		},
		"timers": basetypes.ObjectType{
			AttrTypes: TimersValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AsPathOptionsType{}

type AsPathOptionsType struct {
	basetypes.ObjectType
}

func (t AsPathOptionsType) Equal(o attr.Type) bool {
	other, ok := o.(AsPathOptionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AsPathOptionsType) String() string {
	return "AsPathOptionsType"
}

func (t AsPathOptionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowOwnAsAttribute, ok := attributes["allow_own_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_own_as is missing from object`)

		return nil, diags
	}

	allowOwnAsVal, ok := allowOwnAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_own_as expected to be basetypes.Int64Value, was: %T`, allowOwnAsAttribute))
	}

	removePrivateAsAttribute, ok := attributes["remove_private_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as is missing from object`)

		return nil, diags
	}

	removePrivateAsVal, ok := removePrivateAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as expected to be basetypes.ObjectValue, was: %T`, removePrivateAsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AsPathOptionsValue{
		AllowOwnAs:      allowOwnAsVal,
		RemovePrivateAs: removePrivateAsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewAsPathOptionsValueNull() AsPathOptionsValue {
	return AsPathOptionsValue{
		state: attr.ValueStateNull,
	}
}

func NewAsPathOptionsValueUnknown() AsPathOptionsValue {
	return AsPathOptionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAsPathOptionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AsPathOptionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AsPathOptionsValue Attribute Value",
				"While creating a AsPathOptionsValue value, a missing attribute value was detected. "+
					"A AsPathOptionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsPathOptionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AsPathOptionsValue Attribute Type",
				"While creating a AsPathOptionsValue value, an invalid attribute value was detected. "+
					"A AsPathOptionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsPathOptionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AsPathOptionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AsPathOptionsValue Attribute Value",
				"While creating a AsPathOptionsValue value, an extra attribute value was detected. "+
					"A AsPathOptionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AsPathOptionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAsPathOptionsValueUnknown(), diags
	}

	allowOwnAsAttribute, ok := attributes["allow_own_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_own_as is missing from object`)

		return NewAsPathOptionsValueUnknown(), diags
	}

	allowOwnAsVal, ok := allowOwnAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_own_as expected to be basetypes.Int64Value, was: %T`, allowOwnAsAttribute))
	}

	removePrivateAsAttribute, ok := attributes["remove_private_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as is missing from object`)

		return NewAsPathOptionsValueUnknown(), diags
	}

	removePrivateAsVal, ok := removePrivateAsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as expected to be basetypes.ObjectValue, was: %T`, removePrivateAsAttribute))
	}

	if diags.HasError() {
		return NewAsPathOptionsValueUnknown(), diags
	}

	return AsPathOptionsValue{
		AllowOwnAs:      allowOwnAsVal,
		RemovePrivateAs: removePrivateAsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewAsPathOptionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AsPathOptionsValue {
	object, diags := NewAsPathOptionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAsPathOptionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AsPathOptionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAsPathOptionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAsPathOptionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAsPathOptionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAsPathOptionsValueMust(AsPathOptionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AsPathOptionsType) ValueType(ctx context.Context) attr.Value {
	return AsPathOptionsValue{}
}

var _ basetypes.ObjectValuable = AsPathOptionsValue{}

type AsPathOptionsValue struct {
	AllowOwnAs      basetypes.Int64Value  `tfsdk:"allow_own_as"`
	RemovePrivateAs basetypes.ObjectValue `tfsdk:"remove_private_as"`
	state           attr.ValueState
}

func (v AsPathOptionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["allow_own_as"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["remove_private_as"] = basetypes.ObjectType{
		AttrTypes: RemovePrivateAsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AllowOwnAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_own_as"] = val

		val, err = v.RemovePrivateAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove_private_as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AsPathOptionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AsPathOptionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AsPathOptionsValue) String() string {
	return "AsPathOptionsValue"
}

func (v AsPathOptionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var removePrivateAs basetypes.ObjectValue

	if v.RemovePrivateAs.IsNull() {
		removePrivateAs = types.ObjectNull(
			RemovePrivateAsValue{}.AttributeTypes(ctx),
		)
	}

	if v.RemovePrivateAs.IsUnknown() {
		removePrivateAs = types.ObjectUnknown(
			RemovePrivateAsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RemovePrivateAs.IsNull() && !v.RemovePrivateAs.IsUnknown() {
		removePrivateAs = types.ObjectValueMust(
			RemovePrivateAsValue{}.AttributeTypes(ctx),
			v.RemovePrivateAs.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"allow_own_as": basetypes.Int64Type{},
		"remove_private_as": basetypes.ObjectType{
			AttrTypes: RemovePrivateAsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_own_as":      v.AllowOwnAs,
			"remove_private_as": removePrivateAs,
		})

	return objVal, diags
}

func (v AsPathOptionsValue) Equal(o attr.Value) bool {
	other, ok := o.(AsPathOptionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowOwnAs.Equal(other.AllowOwnAs) {
		return false
	}

	if !v.RemovePrivateAs.Equal(other.RemovePrivateAs) {
		return false
	}

	return true
}

func (v AsPathOptionsValue) Type(ctx context.Context) attr.Type {
	return AsPathOptionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AsPathOptionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_own_as": basetypes.Int64Type{},
		"remove_private_as": basetypes.ObjectType{
			AttrTypes: RemovePrivateAsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = RemovePrivateAsType{}

type RemovePrivateAsType struct {
	basetypes.ObjectType
}

func (t RemovePrivateAsType) Equal(o attr.Type) bool {
	other, ok := o.(RemovePrivateAsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemovePrivateAsType) String() string {
	return "RemovePrivateAsType"
}

func (t RemovePrivateAsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ignorePeerAsAttribute, ok := attributes["ignore_peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ignore_peer_as is missing from object`)

		return nil, diags
	}

	ignorePeerAsVal, ok := ignorePeerAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ignore_peer_as expected to be basetypes.BoolValue, was: %T`, ignorePeerAsAttribute))
	}

	leadingOnlyAttribute, ok := attributes["leading_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leading_only is missing from object`)

		return nil, diags
	}

	leadingOnlyVal, ok := leadingOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leading_only expected to be basetypes.BoolValue, was: %T`, leadingOnlyAttribute))
	}

	removePrivateAsModeAttribute, ok := attributes["remove_private_as_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as_mode is missing from object`)

		return nil, diags
	}

	removePrivateAsModeVal, ok := removePrivateAsModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as_mode expected to be basetypes.StringValue, was: %T`, removePrivateAsModeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemovePrivateAsValue{
		IgnorePeerAs:        ignorePeerAsVal,
		LeadingOnly:         leadingOnlyVal,
		RemovePrivateAsMode: removePrivateAsModeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRemovePrivateAsValueNull() RemovePrivateAsValue {
	return RemovePrivateAsValue{
		state: attr.ValueStateNull,
	}
}

func NewRemovePrivateAsValueUnknown() RemovePrivateAsValue {
	return RemovePrivateAsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRemovePrivateAsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemovePrivateAsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemovePrivateAsValue Attribute Value",
				"While creating a RemovePrivateAsValue value, a missing attribute value was detected. "+
					"A RemovePrivateAsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemovePrivateAsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemovePrivateAsValue Attribute Type",
				"While creating a RemovePrivateAsValue value, an invalid attribute value was detected. "+
					"A RemovePrivateAsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemovePrivateAsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemovePrivateAsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemovePrivateAsValue Attribute Value",
				"While creating a RemovePrivateAsValue value, an extra attribute value was detected. "+
					"A RemovePrivateAsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemovePrivateAsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemovePrivateAsValueUnknown(), diags
	}

	ignorePeerAsAttribute, ok := attributes["ignore_peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ignore_peer_as is missing from object`)

		return NewRemovePrivateAsValueUnknown(), diags
	}

	ignorePeerAsVal, ok := ignorePeerAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ignore_peer_as expected to be basetypes.BoolValue, was: %T`, ignorePeerAsAttribute))
	}

	leadingOnlyAttribute, ok := attributes["leading_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leading_only is missing from object`)

		return NewRemovePrivateAsValueUnknown(), diags
	}

	leadingOnlyVal, ok := leadingOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leading_only expected to be basetypes.BoolValue, was: %T`, leadingOnlyAttribute))
	}

	removePrivateAsModeAttribute, ok := attributes["remove_private_as_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as_mode is missing from object`)

		return NewRemovePrivateAsValueUnknown(), diags
	}

	removePrivateAsModeVal, ok := removePrivateAsModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as_mode expected to be basetypes.StringValue, was: %T`, removePrivateAsModeAttribute))
	}

	if diags.HasError() {
		return NewRemovePrivateAsValueUnknown(), diags
	}

	return RemovePrivateAsValue{
		IgnorePeerAs:        ignorePeerAsVal,
		LeadingOnly:         leadingOnlyVal,
		RemovePrivateAsMode: removePrivateAsModeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRemovePrivateAsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemovePrivateAsValue {
	object, diags := NewRemovePrivateAsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemovePrivateAsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemovePrivateAsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemovePrivateAsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemovePrivateAsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemovePrivateAsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemovePrivateAsValueMust(RemovePrivateAsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RemovePrivateAsType) ValueType(ctx context.Context) attr.Value {
	return RemovePrivateAsValue{}
}

var _ basetypes.ObjectValuable = RemovePrivateAsValue{}

type RemovePrivateAsValue struct {
	IgnorePeerAs        basetypes.BoolValue   `tfsdk:"ignore_peer_as"`
	LeadingOnly         basetypes.BoolValue   `tfsdk:"leading_only"`
	RemovePrivateAsMode basetypes.StringValue `tfsdk:"remove_private_as_mode"`
	state               attr.ValueState
}

func (v RemovePrivateAsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["ignore_peer_as"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["leading_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["remove_private_as_mode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.IgnorePeerAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ignore_peer_as"] = val

		val, err = v.LeadingOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["leading_only"] = val

		val, err = v.RemovePrivateAsMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove_private_as_mode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemovePrivateAsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemovePrivateAsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemovePrivateAsValue) String() string {
	return "RemovePrivateAsValue"
}

func (v RemovePrivateAsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ignore_peer_as":         basetypes.BoolType{},
		"leading_only":           basetypes.BoolType{},
		"remove_private_as_mode": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ignore_peer_as":         v.IgnorePeerAs,
			"leading_only":           v.LeadingOnly,
			"remove_private_as_mode": v.RemovePrivateAsMode,
		})

	return objVal, diags
}

func (v RemovePrivateAsValue) Equal(o attr.Value) bool {
	other, ok := o.(RemovePrivateAsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IgnorePeerAs.Equal(other.IgnorePeerAs) {
		return false
	}

	if !v.LeadingOnly.Equal(other.LeadingOnly) {
		return false
	}

	if !v.RemovePrivateAsMode.Equal(other.RemovePrivateAsMode) {
		return false
	}

	return true
}

func (v RemovePrivateAsValue) Type(ctx context.Context) attr.Type {
	return RemovePrivateAsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemovePrivateAsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ignore_peer_as":         basetypes.BoolType{},
		"leading_only":           basetypes.BoolType{},
		"remove_private_as_mode": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Ipv4UnicastType{}

type Ipv4UnicastType struct {
	basetypes.ObjectType
}

func (t Ipv4UnicastType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4UnicastType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4UnicastType) String() string {
	return "Ipv4UnicastType"
}

func (t Ipv4UnicastType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advertiseIpv6NextHopsAttribute, ok := attributes["advertise_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6_next_hops is missing from object`)

		return nil, diags
	}

	advertiseIpv6NextHopsVal, ok := advertiseIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6NextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimitAttribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit is missing from object`)

		return nil, diags
	}

	prefixLimitVal, ok := prefixLimitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit expected to be basetypes.ObjectValue, was: %T`, prefixLimitAttribute))
	}

	receiveIpv6NextHopsAttribute, ok := attributes["receive_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receive_ipv6_next_hops is missing from object`)

		return nil, diags
	}

	receiveIpv6NextHopsVal, ok := receiveIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receive_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, receiveIpv6NextHopsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4UnicastValue{
		AdvertiseIpv6NextHops: advertiseIpv6NextHopsVal,
		Enabled:               enabledVal,
		PrefixLimit:           prefixLimitVal,
		ReceiveIpv6NextHops:   receiveIpv6NextHopsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIpv4UnicastValueNull() Ipv4UnicastValue {
	return Ipv4UnicastValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv4UnicastValueUnknown() Ipv4UnicastValue {
	return Ipv4UnicastValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4UnicastValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4UnicastValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4UnicastValue Attribute Value",
				"While creating a Ipv4UnicastValue value, a missing attribute value was detected. "+
					"A Ipv4UnicastValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4UnicastValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4UnicastValue Attribute Type",
				"While creating a Ipv4UnicastValue value, an invalid attribute value was detected. "+
					"A Ipv4UnicastValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4UnicastValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4UnicastValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4UnicastValue Attribute Value",
				"While creating a Ipv4UnicastValue value, an extra attribute value was detected. "+
					"A Ipv4UnicastValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4UnicastValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4UnicastValueUnknown(), diags
	}

	advertiseIpv6NextHopsAttribute, ok := attributes["advertise_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6_next_hops is missing from object`)

		return NewIpv4UnicastValueUnknown(), diags
	}

	advertiseIpv6NextHopsVal, ok := advertiseIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6NextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv4UnicastValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimitAttribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit is missing from object`)

		return NewIpv4UnicastValueUnknown(), diags
	}

	prefixLimitVal, ok := prefixLimitAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit expected to be basetypes.ObjectValue, was: %T`, prefixLimitAttribute))
	}

	receiveIpv6NextHopsAttribute, ok := attributes["receive_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receive_ipv6_next_hops is missing from object`)

		return NewIpv4UnicastValueUnknown(), diags
	}

	receiveIpv6NextHopsVal, ok := receiveIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receive_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, receiveIpv6NextHopsAttribute))
	}

	if diags.HasError() {
		return NewIpv4UnicastValueUnknown(), diags
	}

	return Ipv4UnicastValue{
		AdvertiseIpv6NextHops: advertiseIpv6NextHopsVal,
		Enabled:               enabledVal,
		PrefixLimit:           prefixLimitVal,
		ReceiveIpv6NextHops:   receiveIpv6NextHopsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIpv4UnicastValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4UnicastValue {
	object, diags := NewIpv4UnicastValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4UnicastValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4UnicastType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4UnicastValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4UnicastValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4UnicastValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4UnicastValueMust(Ipv4UnicastValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4UnicastType) ValueType(ctx context.Context) attr.Value {
	return Ipv4UnicastValue{}
}

var _ basetypes.ObjectValuable = Ipv4UnicastValue{}

type Ipv4UnicastValue struct {
	AdvertiseIpv6NextHops basetypes.BoolValue   `tfsdk:"advertise_ipv6_next_hops"`
	Enabled               basetypes.BoolValue   `tfsdk:"enabled"`
	PrefixLimit           basetypes.ObjectValue `tfsdk:"prefix_limit"`
	ReceiveIpv6NextHops   basetypes.BoolValue   `tfsdk:"receive_ipv6_next_hops"`
	state                 attr.ValueState
}

func (v Ipv4UnicastValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["advertise_ipv6_next_hops"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix_limit"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["receive_ipv6_next_hops"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AdvertiseIpv6NextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advertise_ipv6_next_hops"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.PrefixLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit"] = val

		val, err = v.ReceiveIpv6NextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["receive_ipv6_next_hops"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4UnicastValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4UnicastValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4UnicastValue) String() string {
	return "Ipv4UnicastValue"
}

func (v Ipv4UnicastValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimit basetypes.ObjectValue

	if v.PrefixLimit.IsNull() {
		prefixLimit = types.ObjectNull(
			PrefixLimitValue{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimit.IsUnknown() {
		prefixLimit = types.ObjectUnknown(
			PrefixLimitValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimit.IsNull() && !v.PrefixLimit.IsUnknown() {
		prefixLimit = types.ObjectValueMust(
			PrefixLimitValue{}.AttributeTypes(ctx),
			v.PrefixLimit.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"advertise_ipv6_next_hops": basetypes.BoolType{},
		"enabled":                  basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimitValue{}.AttributeTypes(ctx),
		},
		"receive_ipv6_next_hops": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advertise_ipv6_next_hops": v.AdvertiseIpv6NextHops,
			"enabled":                  v.Enabled,
			"prefix_limit":             prefixLimit,
			"receive_ipv6_next_hops":   v.ReceiveIpv6NextHops,
		})

	return objVal, diags
}

func (v Ipv4UnicastValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4UnicastValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvertiseIpv6NextHops.Equal(other.AdvertiseIpv6NextHops) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.PrefixLimit.Equal(other.PrefixLimit) {
		return false
	}

	if !v.ReceiveIpv6NextHops.Equal(other.ReceiveIpv6NextHops) {
		return false
	}

	return true
}

func (v Ipv4UnicastValue) Type(ctx context.Context) attr.Type {
	return Ipv4UnicastType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4UnicastValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advertise_ipv6_next_hops": basetypes.BoolType{},
		"enabled":                  basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimitValue{}.AttributeTypes(ctx),
		},
		"receive_ipv6_next_hops": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitType{}

type PrefixLimitType struct {
	basetypes.ObjectType
}

func (t PrefixLimitType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitType) String() string {
	return "PrefixLimitType"
}

func (t PrefixLimitType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	prefixLimitAcceptedAttribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted is missing from object`)

		return nil, diags
	}

	prefixLimitAcceptedVal, ok := prefixLimitAcceptedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted expected to be basetypes.ObjectValue, was: %T`, prefixLimitAcceptedAttribute))
	}

	prefixLimitReceivedAttribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received is missing from object`)

		return nil, diags
	}

	prefixLimitReceivedVal, ok := prefixLimitReceivedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceivedAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitValue{
		PrefixLimitAccepted: prefixLimitAcceptedVal,
		PrefixLimitReceived: prefixLimitReceivedVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitValueNull() PrefixLimitValue {
	return PrefixLimitValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitValueUnknown() PrefixLimitValue {
	return PrefixLimitValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitValue Attribute Value",
				"While creating a PrefixLimitValue value, a missing attribute value was detected. "+
					"A PrefixLimitValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitValue Attribute Type",
				"While creating a PrefixLimitValue value, an invalid attribute value was detected. "+
					"A PrefixLimitValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitValue Attribute Value",
				"While creating a PrefixLimitValue value, an extra attribute value was detected. "+
					"A PrefixLimitValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitValueUnknown(), diags
	}

	prefixLimitAcceptedAttribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted is missing from object`)

		return NewPrefixLimitValueUnknown(), diags
	}

	prefixLimitAcceptedVal, ok := prefixLimitAcceptedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted expected to be basetypes.ObjectValue, was: %T`, prefixLimitAcceptedAttribute))
	}

	prefixLimitReceivedAttribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received is missing from object`)

		return NewPrefixLimitValueUnknown(), diags
	}

	prefixLimitReceivedVal, ok := prefixLimitReceivedAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceivedAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitValueUnknown(), diags
	}

	return PrefixLimitValue{
		PrefixLimitAccepted: prefixLimitAcceptedVal,
		PrefixLimitReceived: prefixLimitReceivedVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitValue {
	object, diags := NewPrefixLimitValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitValueMust(PrefixLimitValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitType) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitValue{}
}

var _ basetypes.ObjectValuable = PrefixLimitValue{}

type PrefixLimitValue struct {
	PrefixLimitAccepted basetypes.ObjectValue `tfsdk:"prefix_limit_accepted"`
	PrefixLimitReceived basetypes.ObjectValue `tfsdk:"prefix_limit_received"`
	state               attr.ValueState
}

func (v PrefixLimitValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["prefix_limit_accepted"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["prefix_limit_received"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitReceivedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PrefixLimitAccepted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_accepted"] = val

		val, err = v.PrefixLimitReceived.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_received"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitValue) String() string {
	return "PrefixLimitValue"
}

func (v PrefixLimitValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimitAccepted basetypes.ObjectValue

	if v.PrefixLimitAccepted.IsNull() {
		prefixLimitAccepted = types.ObjectNull(
			PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitAccepted.IsUnknown() {
		prefixLimitAccepted = types.ObjectUnknown(
			PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitAccepted.IsNull() && !v.PrefixLimitAccepted.IsUnknown() {
		prefixLimitAccepted = types.ObjectValueMust(
			PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
			v.PrefixLimitAccepted.Attributes(),
		)
	}

	var prefixLimitReceived basetypes.ObjectValue

	if v.PrefixLimitReceived.IsNull() {
		prefixLimitReceived = types.ObjectNull(
			PrefixLimitReceivedValue{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitReceived.IsUnknown() {
		prefixLimitReceived = types.ObjectUnknown(
			PrefixLimitReceivedValue{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitReceived.IsNull() && !v.PrefixLimitReceived.IsUnknown() {
		prefixLimitReceived = types.ObjectValueMust(
			PrefixLimitReceivedValue{}.AttributeTypes(ctx),
			v.PrefixLimitReceived.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceivedValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"prefix_limit_accepted": prefixLimitAccepted,
			"prefix_limit_received": prefixLimitReceived,
		})

	return objVal, diags
}

func (v PrefixLimitValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PrefixLimitAccepted.Equal(other.PrefixLimitAccepted) {
		return false
	}

	if !v.PrefixLimitReceived.Equal(other.PrefixLimitReceived) {
		return false
	}

	return true
}

func (v PrefixLimitValue) Type(ctx context.Context) attr.Type {
	return PrefixLimitType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAcceptedValue{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceivedValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitAcceptedType{}

type PrefixLimitAcceptedType struct {
	basetypes.ObjectType
}

func (t PrefixLimitAcceptedType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitAcceptedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitAcceptedType) String() string {
	return "PrefixLimitAcceptedType"
}

func (t PrefixLimitAcceptedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitAcceptedValue{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAcceptedValueNull() PrefixLimitAcceptedValue {
	return PrefixLimitAcceptedValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitAcceptedValueUnknown() PrefixLimitAcceptedValue {
	return PrefixLimitAcceptedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitAcceptedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitAcceptedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitAcceptedValue Attribute Value",
				"While creating a PrefixLimitAcceptedValue value, a missing attribute value was detected. "+
					"A PrefixLimitAcceptedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAcceptedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitAcceptedValue Attribute Type",
				"While creating a PrefixLimitAcceptedValue value, an invalid attribute value was detected. "+
					"A PrefixLimitAcceptedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAcceptedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitAcceptedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitAcceptedValue Attribute Value",
				"While creating a PrefixLimitAcceptedValue value, an extra attribute value was detected. "+
					"A PrefixLimitAcceptedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitAcceptedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitAcceptedValueUnknown(), diags
	}

	return PrefixLimitAcceptedValue{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAcceptedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitAcceptedValue {
	object, diags := NewPrefixLimitAcceptedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitAcceptedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitAcceptedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitAcceptedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitAcceptedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitAcceptedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitAcceptedValueMust(PrefixLimitAcceptedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitAcceptedType) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitAcceptedValue{}
}

var _ basetypes.ObjectValuable = PrefixLimitAcceptedValue{}

type PrefixLimitAcceptedValue struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitAcceptedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitAcceptedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitAcceptedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitAcceptedValue) String() string {
	return "PrefixLimitAcceptedValue"
}

func (v PrefixLimitAcceptedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitAcceptedValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitAcceptedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitAcceptedValue) Type(ctx context.Context) attr.Type {
	return PrefixLimitAcceptedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitAcceptedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitReceivedType{}

type PrefixLimitReceivedType struct {
	basetypes.ObjectType
}

func (t PrefixLimitReceivedType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitReceivedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitReceivedType) String() string {
	return "PrefixLimitReceivedType"
}

func (t PrefixLimitReceivedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitReceivedValue{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceivedValueNull() PrefixLimitReceivedValue {
	return PrefixLimitReceivedValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitReceivedValueUnknown() PrefixLimitReceivedValue {
	return PrefixLimitReceivedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitReceivedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitReceivedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitReceivedValue Attribute Value",
				"While creating a PrefixLimitReceivedValue value, a missing attribute value was detected. "+
					"A PrefixLimitReceivedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceivedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitReceivedValue Attribute Type",
				"While creating a PrefixLimitReceivedValue value, an invalid attribute value was detected. "+
					"A PrefixLimitReceivedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceivedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitReceivedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitReceivedValue Attribute Value",
				"While creating a PrefixLimitReceivedValue value, an extra attribute value was detected. "+
					"A PrefixLimitReceivedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitReceivedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitReceivedValueUnknown(), diags
	}

	return PrefixLimitReceivedValue{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceivedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitReceivedValue {
	object, diags := NewPrefixLimitReceivedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitReceivedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitReceivedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitReceivedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitReceivedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitReceivedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitReceivedValueMust(PrefixLimitReceivedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitReceivedType) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitReceivedValue{}
}

var _ basetypes.ObjectValuable = PrefixLimitReceivedValue{}

type PrefixLimitReceivedValue struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitReceivedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitReceivedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitReceivedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitReceivedValue) String() string {
	return "PrefixLimitReceivedValue"
}

func (v PrefixLimitReceivedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitReceivedValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitReceivedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitReceivedValue) Type(ctx context.Context) attr.Type {
	return PrefixLimitReceivedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitReceivedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Ipv6UnicastType{}

type Ipv6UnicastType struct {
	basetypes.ObjectType
}

func (t Ipv6UnicastType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6UnicastType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6UnicastType) String() string {
	return "Ipv6UnicastType"
}

func (t Ipv6UnicastType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit1Attribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_1 is missing from object`)

		return nil, diags
	}

	prefixLimit1Val, ok := prefixLimit1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimit1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6UnicastValue{
		Enabled:      enabledVal,
		PrefixLimit1: prefixLimit1Val,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpv6UnicastValueNull() Ipv6UnicastValue {
	return Ipv6UnicastValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv6UnicastValueUnknown() Ipv6UnicastValue {
	return Ipv6UnicastValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6UnicastValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6UnicastValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6UnicastValue Attribute Value",
				"While creating a Ipv6UnicastValue value, a missing attribute value was detected. "+
					"A Ipv6UnicastValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6UnicastValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6UnicastValue Attribute Type",
				"While creating a Ipv6UnicastValue value, an invalid attribute value was detected. "+
					"A Ipv6UnicastValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6UnicastValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6UnicastValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6UnicastValue Attribute Value",
				"While creating a Ipv6UnicastValue value, an extra attribute value was detected. "+
					"A Ipv6UnicastValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6UnicastValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6UnicastValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv6UnicastValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit1Attribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_1 is missing from object`)

		return NewIpv6UnicastValueUnknown(), diags
	}

	prefixLimit1Val, ok := prefixLimit1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimit1Attribute))
	}

	if diags.HasError() {
		return NewIpv6UnicastValueUnknown(), diags
	}

	return Ipv6UnicastValue{
		Enabled:      enabledVal,
		PrefixLimit1: prefixLimit1Val,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpv6UnicastValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6UnicastValue {
	object, diags := NewIpv6UnicastValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6UnicastValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6UnicastType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6UnicastValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6UnicastValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6UnicastValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6UnicastValueMust(Ipv6UnicastValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6UnicastType) ValueType(ctx context.Context) attr.Value {
	return Ipv6UnicastValue{}
}

var _ basetypes.ObjectValuable = Ipv6UnicastValue{}

type Ipv6UnicastValue struct {
	Enabled      basetypes.BoolValue   `tfsdk:"enabled"`
	PrefixLimit1 basetypes.ObjectValue `tfsdk:"prefix_limit"`
	state        attr.ValueState
}

func (v Ipv6UnicastValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix_limit"] = basetypes.ObjectType{
		AttrTypes: PrefixLimit1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.PrefixLimit1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6UnicastValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6UnicastValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6UnicastValue) String() string {
	return "Ipv6UnicastValue"
}

func (v Ipv6UnicastValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimit1 basetypes.ObjectValue

	if v.PrefixLimit1.IsNull() {
		prefixLimit1 = types.ObjectNull(
			PrefixLimit1Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimit1.IsUnknown() {
		prefixLimit1 = types.ObjectUnknown(
			PrefixLimit1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimit1.IsNull() && !v.PrefixLimit1.IsUnknown() {
		prefixLimit1 = types.ObjectValueMust(
			PrefixLimit1Value{}.AttributeTypes(ctx),
			v.PrefixLimit1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimit1Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":      v.Enabled,
			"prefix_limit": prefixLimit1,
		})

	return objVal, diags
}

func (v Ipv6UnicastValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6UnicastValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.PrefixLimit1.Equal(other.PrefixLimit1) {
		return false
	}

	return true
}

func (v Ipv6UnicastValue) Type(ctx context.Context) attr.Type {
	return Ipv6UnicastType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6UnicastValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimit1Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimit1Type{}

type PrefixLimit1Type struct {
	basetypes.ObjectType
}

func (t PrefixLimit1Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimit1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimit1Type) String() string {
	return "PrefixLimit1Type"
}

func (t PrefixLimit1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	prefixLimitAccepted1Attribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_1 is missing from object`)

		return nil, diags
	}

	prefixLimitAccepted1Val, ok := prefixLimitAccepted1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted1Attribute))
	}

	prefixLimitReceived1Attribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_1 is missing from object`)

		return nil, diags
	}

	prefixLimitReceived1Val, ok := prefixLimitReceived1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimit1Value{
		PrefixLimitAccepted1: prefixLimitAccepted1Val,
		PrefixLimitReceived1: prefixLimitReceived1Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit1ValueNull() PrefixLimit1Value {
	return PrefixLimit1Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimit1ValueUnknown() PrefixLimit1Value {
	return PrefixLimit1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimit1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimit1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimit1Value Attribute Value",
				"While creating a PrefixLimit1Value value, a missing attribute value was detected. "+
					"A PrefixLimit1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimit1Value Attribute Type",
				"While creating a PrefixLimit1Value value, an invalid attribute value was detected. "+
					"A PrefixLimit1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimit1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimit1Value Attribute Value",
				"While creating a PrefixLimit1Value value, an extra attribute value was detected. "+
					"A PrefixLimit1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimit1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimit1ValueUnknown(), diags
	}

	prefixLimitAccepted1Attribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_1 is missing from object`)

		return NewPrefixLimit1ValueUnknown(), diags
	}

	prefixLimitAccepted1Val, ok := prefixLimitAccepted1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted1Attribute))
	}

	prefixLimitReceived1Attribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_1 is missing from object`)

		return NewPrefixLimit1ValueUnknown(), diags
	}

	prefixLimitReceived1Val, ok := prefixLimitReceived1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_1 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived1Attribute))
	}

	if diags.HasError() {
		return NewPrefixLimit1ValueUnknown(), diags
	}

	return PrefixLimit1Value{
		PrefixLimitAccepted1: prefixLimitAccepted1Val,
		PrefixLimitReceived1: prefixLimitReceived1Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimit1Value {
	object, diags := NewPrefixLimit1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimit1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimit1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimit1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimit1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimit1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimit1ValueMust(PrefixLimit1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimit1Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimit1Value{}
}

var _ basetypes.ObjectValuable = PrefixLimit1Value{}

type PrefixLimit1Value struct {
	PrefixLimitAccepted1 basetypes.ObjectValue `tfsdk:"prefix_limit_accepted"`
	PrefixLimitReceived1 basetypes.ObjectValue `tfsdk:"prefix_limit_received"`
	state                attr.ValueState
}

func (v PrefixLimit1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["prefix_limit_accepted"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["prefix_limit_received"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitReceived1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PrefixLimitAccepted1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_accepted"] = val

		val, err = v.PrefixLimitReceived1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_received"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimit1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimit1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimit1Value) String() string {
	return "PrefixLimit1Value"
}

func (v PrefixLimit1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimitAccepted1 basetypes.ObjectValue

	if v.PrefixLimitAccepted1.IsNull() {
		prefixLimitAccepted1 = types.ObjectNull(
			PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitAccepted1.IsUnknown() {
		prefixLimitAccepted1 = types.ObjectUnknown(
			PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitAccepted1.IsNull() && !v.PrefixLimitAccepted1.IsUnknown() {
		prefixLimitAccepted1 = types.ObjectValueMust(
			PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
			v.PrefixLimitAccepted1.Attributes(),
		)
	}

	var prefixLimitReceived1 basetypes.ObjectValue

	if v.PrefixLimitReceived1.IsNull() {
		prefixLimitReceived1 = types.ObjectNull(
			PrefixLimitReceived1Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitReceived1.IsUnknown() {
		prefixLimitReceived1 = types.ObjectUnknown(
			PrefixLimitReceived1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitReceived1.IsNull() && !v.PrefixLimitReceived1.IsUnknown() {
		prefixLimitReceived1 = types.ObjectValueMust(
			PrefixLimitReceived1Value{}.AttributeTypes(ctx),
			v.PrefixLimitReceived1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived1Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"prefix_limit_accepted": prefixLimitAccepted1,
			"prefix_limit_received": prefixLimitReceived1,
		})

	return objVal, diags
}

func (v PrefixLimit1Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimit1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PrefixLimitAccepted1.Equal(other.PrefixLimitAccepted1) {
		return false
	}

	if !v.PrefixLimitReceived1.Equal(other.PrefixLimitReceived1) {
		return false
	}

	return true
}

func (v PrefixLimit1Value) Type(ctx context.Context) attr.Type {
	return PrefixLimit1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimit1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted1Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived1Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitAccepted1Type{}

type PrefixLimitAccepted1Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitAccepted1Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitAccepted1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitAccepted1Type) String() string {
	return "PrefixLimitAccepted1Type"
}

func (t PrefixLimitAccepted1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitAccepted1Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted1ValueNull() PrefixLimitAccepted1Value {
	return PrefixLimitAccepted1Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitAccepted1ValueUnknown() PrefixLimitAccepted1Value {
	return PrefixLimitAccepted1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitAccepted1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitAccepted1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitAccepted1Value Attribute Value",
				"While creating a PrefixLimitAccepted1Value value, a missing attribute value was detected. "+
					"A PrefixLimitAccepted1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitAccepted1Value Attribute Type",
				"While creating a PrefixLimitAccepted1Value value, an invalid attribute value was detected. "+
					"A PrefixLimitAccepted1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitAccepted1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitAccepted1Value Attribute Value",
				"While creating a PrefixLimitAccepted1Value value, an extra attribute value was detected. "+
					"A PrefixLimitAccepted1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitAccepted1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted1ValueUnknown(), diags
	}

	return PrefixLimitAccepted1Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitAccepted1Value {
	object, diags := NewPrefixLimitAccepted1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitAccepted1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitAccepted1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitAccepted1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitAccepted1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitAccepted1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitAccepted1ValueMust(PrefixLimitAccepted1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitAccepted1Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitAccepted1Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitAccepted1Value{}

type PrefixLimitAccepted1Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitAccepted1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitAccepted1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitAccepted1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitAccepted1Value) String() string {
	return "PrefixLimitAccepted1Value"
}

func (v PrefixLimitAccepted1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitAccepted1Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitAccepted1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitAccepted1Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitAccepted1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitAccepted1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitReceived1Type{}

type PrefixLimitReceived1Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitReceived1Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitReceived1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitReceived1Type) String() string {
	return "PrefixLimitReceived1Type"
}

func (t PrefixLimitReceived1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitReceived1Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived1ValueNull() PrefixLimitReceived1Value {
	return PrefixLimitReceived1Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitReceived1ValueUnknown() PrefixLimitReceived1Value {
	return PrefixLimitReceived1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitReceived1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitReceived1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitReceived1Value Attribute Value",
				"While creating a PrefixLimitReceived1Value value, a missing attribute value was detected. "+
					"A PrefixLimitReceived1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitReceived1Value Attribute Type",
				"While creating a PrefixLimitReceived1Value value, an invalid attribute value was detected. "+
					"A PrefixLimitReceived1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitReceived1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitReceived1Value Attribute Value",
				"While creating a PrefixLimitReceived1Value value, an extra attribute value was detected. "+
					"A PrefixLimitReceived1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitReceived1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitReceived1ValueUnknown(), diags
	}

	return PrefixLimitReceived1Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitReceived1Value {
	object, diags := NewPrefixLimitReceived1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitReceived1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitReceived1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitReceived1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitReceived1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitReceived1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitReceived1ValueMust(PrefixLimitReceived1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitReceived1Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitReceived1Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitReceived1Value{}

type PrefixLimitReceived1Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitReceived1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitReceived1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitReceived1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitReceived1Value) String() string {
	return "PrefixLimitReceived1Value"
}

func (v PrefixLimitReceived1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitReceived1Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitReceived1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitReceived1Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitReceived1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitReceived1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LocalAsType{}

type LocalAsType struct {
	basetypes.ObjectType
}

func (t LocalAsType) Equal(o attr.Type) bool {
	other, ok := o.(LocalAsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocalAsType) String() string {
	return "LocalAsType"
}

func (t LocalAsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return nil, diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	prependGlobalAsAttribute, ok := attributes["prepend_global_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_global_as is missing from object`)

		return nil, diags
	}

	prependGlobalAsVal, ok := prependGlobalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_global_as expected to be basetypes.BoolValue, was: %T`, prependGlobalAsAttribute))
	}

	prependLocalAsAttribute, ok := attributes["prepend_local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_local_as is missing from object`)

		return nil, diags
	}

	prependLocalAsVal, ok := prependLocalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_local_as expected to be basetypes.BoolValue, was: %T`, prependLocalAsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocalAsValue{
		AutonomousSystem: autonomousSystemVal,
		PrependGlobalAs:  prependGlobalAsVal,
		PrependLocalAs:   prependLocalAsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLocalAsValueNull() LocalAsValue {
	return LocalAsValue{
		state: attr.ValueStateNull,
	}
}

func NewLocalAsValueUnknown() LocalAsValue {
	return LocalAsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLocalAsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocalAsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocalAsValue Attribute Value",
				"While creating a LocalAsValue value, a missing attribute value was detected. "+
					"A LocalAsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocalAsValue Attribute Type",
				"While creating a LocalAsValue value, an invalid attribute value was detected. "+
					"A LocalAsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocalAsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocalAsValue Attribute Value",
				"While creating a LocalAsValue value, an extra attribute value was detected. "+
					"A LocalAsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocalAsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocalAsValueUnknown(), diags
	}

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	prependGlobalAsAttribute, ok := attributes["prepend_global_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_global_as is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	prependGlobalAsVal, ok := prependGlobalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_global_as expected to be basetypes.BoolValue, was: %T`, prependGlobalAsAttribute))
	}

	prependLocalAsAttribute, ok := attributes["prepend_local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_local_as is missing from object`)

		return NewLocalAsValueUnknown(), diags
	}

	prependLocalAsVal, ok := prependLocalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_local_as expected to be basetypes.BoolValue, was: %T`, prependLocalAsAttribute))
	}

	if diags.HasError() {
		return NewLocalAsValueUnknown(), diags
	}

	return LocalAsValue{
		AutonomousSystem: autonomousSystemVal,
		PrependGlobalAs:  prependGlobalAsVal,
		PrependLocalAs:   prependLocalAsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLocalAsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocalAsValue {
	object, diags := NewLocalAsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocalAsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocalAsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocalAsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocalAsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocalAsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocalAsValueMust(LocalAsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LocalAsType) ValueType(ctx context.Context) attr.Value {
	return LocalAsValue{}
}

var _ basetypes.ObjectValuable = LocalAsValue{}

type LocalAsValue struct {
	AutonomousSystem basetypes.Int64Value `tfsdk:"autonomous_system"`
	PrependGlobalAs  basetypes.BoolValue  `tfsdk:"prepend_global_as"`
	PrependLocalAs   basetypes.BoolValue  `tfsdk:"prepend_local_as"`
	state            attr.ValueState
}

func (v LocalAsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prepend_global_as"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prepend_local_as"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_system"] = val

		val, err = v.PrependGlobalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prepend_global_as"] = val

		val, err = v.PrependLocalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prepend_local_as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocalAsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocalAsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocalAsValue) String() string {
	return "LocalAsValue"
}

func (v LocalAsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"prepend_global_as": basetypes.BoolType{},
		"prepend_local_as":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_system": v.AutonomousSystem,
			"prepend_global_as": v.PrependGlobalAs,
			"prepend_local_as":  v.PrependLocalAs,
		})

	return objVal, diags
}

func (v LocalAsValue) Equal(o attr.Value) bool {
	other, ok := o.(LocalAsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousSystem.Equal(other.AutonomousSystem) {
		return false
	}

	if !v.PrependGlobalAs.Equal(other.PrependGlobalAs) {
		return false
	}

	if !v.PrependLocalAs.Equal(other.PrependLocalAs) {
		return false
	}

	return true
}

func (v LocalAsValue) Type(ctx context.Context) attr.Type {
	return LocalAsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocalAsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"prepend_global_as": basetypes.BoolType{},
		"prepend_local_as":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PeerAsType{}

type PeerAsType struct {
	basetypes.ObjectType
}

func (t PeerAsType) Equal(o attr.Type) bool {
	other, ok := o.(PeerAsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PeerAsType) String() string {
	return "PeerAsType"
}

func (t PeerAsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return nil, diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PeerAsValue{
		AutonomousSystem: autonomousSystemVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPeerAsValueNull() PeerAsValue {
	return PeerAsValue{
		state: attr.ValueStateNull,
	}
}

func NewPeerAsValueUnknown() PeerAsValue {
	return PeerAsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPeerAsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PeerAsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PeerAsValue Attribute Value",
				"While creating a PeerAsValue value, a missing attribute value was detected. "+
					"A PeerAsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PeerAsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PeerAsValue Attribute Type",
				"While creating a PeerAsValue value, an invalid attribute value was detected. "+
					"A PeerAsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PeerAsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PeerAsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PeerAsValue Attribute Value",
				"While creating a PeerAsValue value, an extra attribute value was detected. "+
					"A PeerAsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PeerAsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPeerAsValueUnknown(), diags
	}

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return NewPeerAsValueUnknown(), diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	if diags.HasError() {
		return NewPeerAsValueUnknown(), diags
	}

	return PeerAsValue{
		AutonomousSystem: autonomousSystemVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPeerAsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PeerAsValue {
	object, diags := NewPeerAsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPeerAsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PeerAsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPeerAsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPeerAsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPeerAsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPeerAsValueMust(PeerAsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PeerAsType) ValueType(ctx context.Context) attr.Value {
	return PeerAsValue{}
}

var _ basetypes.ObjectValuable = PeerAsValue{}

type PeerAsValue struct {
	AutonomousSystem basetypes.Int64Value `tfsdk:"autonomous_system"`
	state            attr.ValueState
}

func (v PeerAsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.AutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_system"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PeerAsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PeerAsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PeerAsValue) String() string {
	return "PeerAsValue"
}

func (v PeerAsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_system": v.AutonomousSystem,
		})

	return objVal, diags
}

func (v PeerAsValue) Equal(o attr.Value) bool {
	other, ok := o.(PeerAsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousSystem.Equal(other.AutonomousSystem) {
		return false
	}

	return true
}

func (v PeerAsValue) Type(ctx context.Context) attr.Type {
	return PeerAsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PeerAsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SendDefaultRouteType{}

type SendDefaultRouteType struct {
	basetypes.ObjectType
}

func (t SendDefaultRouteType) Equal(o attr.Type) bool {
	other, ok := o.(SendDefaultRouteType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SendDefaultRouteType) String() string {
	return "SendDefaultRouteType"
}

func (t SendDefaultRouteType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return nil, diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.ListValue, was: %T`, addressFamilyAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SendDefaultRouteValue{
		AddressFamily: addressFamilyVal,
		ExportPolicy:  exportPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSendDefaultRouteValueNull() SendDefaultRouteValue {
	return SendDefaultRouteValue{
		state: attr.ValueStateNull,
	}
}

func NewSendDefaultRouteValueUnknown() SendDefaultRouteValue {
	return SendDefaultRouteValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSendDefaultRouteValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SendDefaultRouteValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SendDefaultRouteValue Attribute Value",
				"While creating a SendDefaultRouteValue value, a missing attribute value was detected. "+
					"A SendDefaultRouteValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SendDefaultRouteValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SendDefaultRouteValue Attribute Type",
				"While creating a SendDefaultRouteValue value, an invalid attribute value was detected. "+
					"A SendDefaultRouteValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SendDefaultRouteValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SendDefaultRouteValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SendDefaultRouteValue Attribute Value",
				"While creating a SendDefaultRouteValue value, an extra attribute value was detected. "+
					"A SendDefaultRouteValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SendDefaultRouteValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSendDefaultRouteValueUnknown(), diags
	}

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return NewSendDefaultRouteValueUnknown(), diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.ListValue, was: %T`, addressFamilyAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewSendDefaultRouteValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	if diags.HasError() {
		return NewSendDefaultRouteValueUnknown(), diags
	}

	return SendDefaultRouteValue{
		AddressFamily: addressFamilyVal,
		ExportPolicy:  exportPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSendDefaultRouteValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SendDefaultRouteValue {
	object, diags := NewSendDefaultRouteValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSendDefaultRouteValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SendDefaultRouteType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSendDefaultRouteValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSendDefaultRouteValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSendDefaultRouteValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSendDefaultRouteValueMust(SendDefaultRouteValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SendDefaultRouteType) ValueType(ctx context.Context) attr.Value {
	return SendDefaultRouteValue{}
}

var _ basetypes.ObjectValuable = SendDefaultRouteValue{}

type SendDefaultRouteValue struct {
	AddressFamily basetypes.ListValue   `tfsdk:"address_family"`
	ExportPolicy  basetypes.StringValue `tfsdk:"export_policy"`
	state         attr.ValueState
}

func (v SendDefaultRouteValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["address_family"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AddressFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_family"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SendDefaultRouteValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SendDefaultRouteValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SendDefaultRouteValue) String() string {
	return "SendDefaultRouteValue"
}

func (v SendDefaultRouteValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var addressFamilyVal basetypes.ListValue
	switch {
	case v.AddressFamily.IsUnknown():
		addressFamilyVal = types.ListUnknown(types.StringType)
	case v.AddressFamily.IsNull():
		addressFamilyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		addressFamilyVal, d = types.ListValue(types.StringType, v.AddressFamily.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_family": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_policy": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"address_family": basetypes.ListType{
			ElemType: types.StringType,
		},
		"export_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address_family": addressFamilyVal,
			"export_policy":  v.ExportPolicy,
		})

	return objVal, diags
}

func (v SendDefaultRouteValue) Equal(o attr.Value) bool {
	other, ok := o.(SendDefaultRouteValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddressFamily.Equal(other.AddressFamily) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	return true
}

func (v SendDefaultRouteValue) Type(ctx context.Context) attr.Type {
	return SendDefaultRouteType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SendDefaultRouteValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address_family": basetypes.ListType{
			ElemType: types.StringType,
		},
		"export_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TimersType{}

type TimersType struct {
	basetypes.ObjectType
}

func (t TimersType) Equal(o attr.Type) bool {
	other, ok := o.(TimersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TimersType) String() string {
	return "TimersType"
}

func (t TimersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	connectRetryAttribute, ok := attributes["connect_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_retry is missing from object`)

		return nil, diags
	}

	connectRetryVal, ok := connectRetryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_retry expected to be basetypes.Int64Value, was: %T`, connectRetryAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return nil, diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	keepAliveAttribute, ok := attributes["keep_alive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_alive is missing from object`)

		return nil, diags
	}

	keepAliveVal, ok := keepAliveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_alive expected to be basetypes.Int64Value, was: %T`, keepAliveAttribute))
	}

	minimumAdvertisementIntervalAttribute, ok := attributes["minimum_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_advertisement_interval is missing from object`)

		return nil, diags
	}

	minimumAdvertisementIntervalVal, ok := minimumAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minimumAdvertisementIntervalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TimersValue{
		ConnectRetry:                 connectRetryVal,
		HoldTime:                     holdTimeVal,
		KeepAlive:                    keepAliveVal,
		MinimumAdvertisementInterval: minimumAdvertisementIntervalVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewTimersValueNull() TimersValue {
	return TimersValue{
		state: attr.ValueStateNull,
	}
}

func NewTimersValueUnknown() TimersValue {
	return TimersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTimersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TimersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TimersValue Attribute Value",
				"While creating a TimersValue value, a missing attribute value was detected. "+
					"A TimersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TimersValue Attribute Type",
				"While creating a TimersValue value, an invalid attribute value was detected. "+
					"A TimersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TimersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TimersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TimersValue Attribute Value",
				"While creating a TimersValue value, an extra attribute value was detected. "+
					"A TimersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TimersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTimersValueUnknown(), diags
	}

	connectRetryAttribute, ok := attributes["connect_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_retry is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	connectRetryVal, ok := connectRetryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_retry expected to be basetypes.Int64Value, was: %T`, connectRetryAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	keepAliveAttribute, ok := attributes["keep_alive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_alive is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	keepAliveVal, ok := keepAliveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_alive expected to be basetypes.Int64Value, was: %T`, keepAliveAttribute))
	}

	minimumAdvertisementIntervalAttribute, ok := attributes["minimum_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_advertisement_interval is missing from object`)

		return NewTimersValueUnknown(), diags
	}

	minimumAdvertisementIntervalVal, ok := minimumAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minimumAdvertisementIntervalAttribute))
	}

	if diags.HasError() {
		return NewTimersValueUnknown(), diags
	}

	return TimersValue{
		ConnectRetry:                 connectRetryVal,
		HoldTime:                     holdTimeVal,
		KeepAlive:                    keepAliveVal,
		MinimumAdvertisementInterval: minimumAdvertisementIntervalVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewTimersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TimersValue {
	object, diags := NewTimersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTimersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TimersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTimersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTimersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTimersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTimersValueMust(TimersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TimersType) ValueType(ctx context.Context) attr.Value {
	return TimersValue{}
}

var _ basetypes.ObjectValuable = TimersValue{}

type TimersValue struct {
	ConnectRetry                 basetypes.Int64Value `tfsdk:"connect_retry"`
	HoldTime                     basetypes.Int64Value `tfsdk:"hold_time"`
	KeepAlive                    basetypes.Int64Value `tfsdk:"keep_alive"`
	MinimumAdvertisementInterval basetypes.Int64Value `tfsdk:"minimum_advertisement_interval"`
	state                        attr.ValueState
}

func (v TimersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["connect_retry"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["hold_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_alive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minimum_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ConnectRetry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connect_retry"] = val

		val, err = v.HoldTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_time"] = val

		val, err = v.KeepAlive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_alive"] = val

		val, err = v.MinimumAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimum_advertisement_interval"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TimersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TimersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TimersValue) String() string {
	return "TimersValue"
}

func (v TimersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"connect_retry":                  basetypes.Int64Type{},
		"hold_time":                      basetypes.Int64Type{},
		"keep_alive":                     basetypes.Int64Type{},
		"minimum_advertisement_interval": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"connect_retry":                  v.ConnectRetry,
			"hold_time":                      v.HoldTime,
			"keep_alive":                     v.KeepAlive,
			"minimum_advertisement_interval": v.MinimumAdvertisementInterval,
		})

	return objVal, diags
}

func (v TimersValue) Equal(o attr.Value) bool {
	other, ok := o.(TimersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConnectRetry.Equal(other.ConnectRetry) {
		return false
	}

	if !v.HoldTime.Equal(other.HoldTime) {
		return false
	}

	if !v.KeepAlive.Equal(other.KeepAlive) {
		return false
	}

	if !v.MinimumAdvertisementInterval.Equal(other.MinimumAdvertisementInterval) {
		return false
	}

	return true
}

func (v TimersValue) Type(ctx context.Context) attr.Type {
	return TimersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TimersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"connect_retry":                  basetypes.Int64Type{},
		"hold_time":                      basetypes.Int64Type{},
		"keep_alive":                     basetypes.Int64Type{},
		"minimum_advertisement_interval": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = BgpPeersType{}

type BgpPeersType struct {
	basetypes.ObjectType
}

func (t BgpPeersType) Equal(o attr.Type) bool {
	other, ok := o.(BgpPeersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BgpPeersType) String() string {
	return "BgpPeersType"
}

func (t BgpPeersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec5Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_5 is missing from object`)

		return nil, diags
	}

	spec5Val, ok := spec5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_5 expected to be basetypes.ObjectValue, was: %T`, spec5Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BgpPeersValue{
		Name:  nameVal,
		Spec5: spec5Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBgpPeersValueNull() BgpPeersValue {
	return BgpPeersValue{
		state: attr.ValueStateNull,
	}
}

func NewBgpPeersValueUnknown() BgpPeersValue {
	return BgpPeersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBgpPeersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BgpPeersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BgpPeersValue Attribute Value",
				"While creating a BgpPeersValue value, a missing attribute value was detected. "+
					"A BgpPeersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpPeersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BgpPeersValue Attribute Type",
				"While creating a BgpPeersValue value, an invalid attribute value was detected. "+
					"A BgpPeersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BgpPeersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BgpPeersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BgpPeersValue Attribute Value",
				"While creating a BgpPeersValue value, an extra attribute value was detected. "+
					"A BgpPeersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BgpPeersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgpPeersValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec5Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_5 is missing from object`)

		return NewBgpPeersValueUnknown(), diags
	}

	spec5Val, ok := spec5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_5 expected to be basetypes.ObjectValue, was: %T`, spec5Attribute))
	}

	if diags.HasError() {
		return NewBgpPeersValueUnknown(), diags
	}

	return BgpPeersValue{
		Name:  nameVal,
		Spec5: spec5Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewBgpPeersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BgpPeersValue {
	object, diags := NewBgpPeersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgpPeersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BgpPeersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgpPeersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgpPeersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgpPeersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgpPeersValueMust(BgpPeersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BgpPeersType) ValueType(ctx context.Context) attr.Value {
	return BgpPeersValue{}
}

var _ basetypes.ObjectValuable = BgpPeersValue{}

type BgpPeersValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Spec5 basetypes.ObjectValue `tfsdk:"spec"`
	state attr.ValueState
}

func (v BgpPeersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Spec5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BgpPeersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BgpPeersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BgpPeersValue) String() string {
	return "BgpPeersValue"
}

func (v BgpPeersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spec5 basetypes.ObjectValue

	if v.Spec5.IsNull() {
		spec5 = types.ObjectNull(
			Spec5Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec5.IsUnknown() {
		spec5 = types.ObjectUnknown(
			Spec5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec5.IsNull() && !v.Spec5.IsUnknown() {
		spec5 = types.ObjectValueMust(
			Spec5Value{}.AttributeTypes(ctx),
			v.Spec5.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec5Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"spec": spec5,
		})

	return objVal, diags
}

func (v BgpPeersValue) Equal(o attr.Value) bool {
	other, ok := o.(BgpPeersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Spec5.Equal(other.Spec5) {
		return false
	}

	return true
}

func (v BgpPeersValue) Type(ctx context.Context) attr.Type {
	return BgpPeersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BgpPeersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec5Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Spec5Type{}

type Spec5Type struct {
	basetypes.ObjectType
}

func (t Spec5Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec5Type) String() string {
	return "Spec5Type"
}

func (t Spec5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathOptions1Attribute, ok := attributes["as_path_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_options_1 is missing from object`)

		return nil, diags
	}

	asPathOptions1Val, ok := asPathOptions1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_options_1 expected to be basetypes.ObjectValue, was: %T`, asPathOptions1Attribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return nil, diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.BoolValue, was: %T`, bfdAttribute))
	}

	clientAttribute, ok := attributes["client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client is missing from object`)

		return nil, diags
	}

	clientVal, ok := clientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client expected to be basetypes.BoolValue, was: %T`, clientAttribute))
	}

	clusterIdAttribute, ok := attributes["cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_id is missing from object`)

		return nil, diags
	}

	clusterIdVal, ok := clusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_id expected to be basetypes.StringValue, was: %T`, clusterIdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	dynamicNeighborAttribute, ok := attributes["dynamic_neighbor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_neighbor is missing from object`)

		return nil, diags
	}

	dynamicNeighborVal, ok := dynamicNeighborAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_neighbor expected to be basetypes.BoolValue, was: %T`, dynamicNeighborAttribute))
	}

	dynamicNeighborAllowedPeerAsAttribute, ok := attributes["dynamic_neighbor_allowed_peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_neighbor_allowed_peer_as is missing from object`)

		return nil, diags
	}

	dynamicNeighborAllowedPeerAsVal, ok := dynamicNeighborAllowedPeerAsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_neighbor_allowed_peer_as expected to be basetypes.ListValue, was: %T`, dynamicNeighborAllowedPeerAsAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	grStaleRouteTimeAttribute, ok := attributes["gr_stale_route_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gr_stale_route_time is missing from object`)

		return nil, diags
	}

	grStaleRouteTimeVal, ok := grStaleRouteTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gr_stale_route_time expected to be basetypes.Int64Value, was: %T`, grStaleRouteTimeAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return nil, diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceKindAttribute, ok := attributes["interface_kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_kind is missing from object`)

		return nil, diags
	}

	interfaceKindVal, ok := interfaceKindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_kind expected to be basetypes.StringValue, was: %T`, interfaceKindAttribute))
	}

	ipv4Unicast1Attribute, ok := attributes["ipv4_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_unicast_1 is missing from object`)

		return nil, diags
	}

	ipv4Unicast1Val, ok := ipv4Unicast1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_unicast_1 expected to be basetypes.ObjectValue, was: %T`, ipv4Unicast1Attribute))
	}

	ipv6Unicast1Attribute, ok := attributes["ipv6_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_unicast_1 is missing from object`)

		return nil, diags
	}

	ipv6Unicast1Val, ok := ipv6Unicast1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_unicast_1 expected to be basetypes.ObjectValue, was: %T`, ipv6Unicast1Attribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return nil, diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	localAs1Attribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as_1 is missing from object`)

		return nil, diags
	}

	localAs1Val, ok := localAs1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as_1 expected to be basetypes.ObjectValue, was: %T`, localAs1Attribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return nil, diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	multiHopMaxHopAttribute, ok := attributes["multi_hop_max_hop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multi_hop_max_hop is missing from object`)

		return nil, diags
	}

	multiHopMaxHopVal, ok := multiHopMaxHopAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multi_hop_max_hop expected to be basetypes.Int64Value, was: %T`, multiHopMaxHopAttribute))
	}

	nextHopSelfAttribute, ok := attributes["next_hop_self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_hop_self is missing from object`)

		return nil, diags
	}

	nextHopSelfVal, ok := nextHopSelfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_hop_self expected to be basetypes.BoolValue, was: %T`, nextHopSelfAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	peerAs1Attribute, ok := attributes["peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_as_1 is missing from object`)

		return nil, diags
	}

	peerAs1Val, ok := peerAs1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_as_1 expected to be basetypes.ObjectValue, was: %T`, peerAs1Attribute))
	}

	peerIpAttribute, ok := attributes["peer_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_ip is missing from object`)

		return nil, diags
	}

	peerIpVal, ok := peerIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_ip expected to be basetypes.StringValue, was: %T`, peerIpAttribute))
	}

	sendCommunityLargeAttribute, ok := attributes["send_community_large"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_large is missing from object`)

		return nil, diags
	}

	sendCommunityLargeVal, ok := sendCommunityLargeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_large expected to be basetypes.BoolValue, was: %T`, sendCommunityLargeAttribute))
	}

	sendCommunityStandardAttribute, ok := attributes["send_community_standard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_standard is missing from object`)

		return nil, diags
	}

	sendCommunityStandardVal, ok := sendCommunityStandardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_standard expected to be basetypes.BoolValue, was: %T`, sendCommunityStandardAttribute))
	}

	sendDefaultRoute1Attribute, ok := attributes["send_default_route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_default_route_1 is missing from object`)

		return nil, diags
	}

	sendDefaultRoute1Val, ok := sendDefaultRoute1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_default_route_1 expected to be basetypes.ObjectValue, was: %T`, sendDefaultRoute1Attribute))
	}

	timers1Attribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers_1 is missing from object`)

		return nil, diags
	}

	timers1Val, ok := timers1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers_1 expected to be basetypes.ObjectValue, was: %T`, timers1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec5Value{
		AsPathOptions1:               asPathOptions1Val,
		Bfd:                          bfdVal,
		Client:                       clientVal,
		ClusterId:                    clusterIdVal,
		Description:                  descriptionVal,
		DynamicNeighbor:              dynamicNeighborVal,
		DynamicNeighborAllowedPeerAs: dynamicNeighborAllowedPeerAsVal,
		ExportPolicy:                 exportPolicyVal,
		GrStaleRouteTime:             grStaleRouteTimeVal,
		Group:                        groupVal,
		ImportPolicy:                 importPolicyVal,
		Interface:                    interfaceVal,
		InterfaceKind:                interfaceKindVal,
		Ipv4Unicast1:                 ipv4Unicast1Val,
		Ipv6Unicast1:                 ipv6Unicast1Val,
		Keychain:                     keychainVal,
		LocalAs1:                     localAs1Val,
		LocalPreference:              localPreferenceVal,
		MultiHopMaxHop:               multiHopMaxHopVal,
		NextHopSelf:                  nextHopSelfVal,
		Node:                         nodeVal,
		PeerAs1:                      peerAs1Val,
		PeerIp:                       peerIpVal,
		SendCommunityLarge:           sendCommunityLargeVal,
		SendCommunityStandard:        sendCommunityStandardVal,
		SendDefaultRoute1:            sendDefaultRoute1Val,
		Timers1:                      timers1Val,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewSpec5ValueNull() Spec5Value {
	return Spec5Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec5ValueUnknown() Spec5Value {
	return Spec5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec5Value Attribute Value",
				"While creating a Spec5Value value, a missing attribute value was detected. "+
					"A Spec5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec5Value Attribute Type",
				"While creating a Spec5Value value, an invalid attribute value was detected. "+
					"A Spec5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec5Value Attribute Value",
				"While creating a Spec5Value value, an extra attribute value was detected. "+
					"A Spec5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec5ValueUnknown(), diags
	}

	asPathOptions1Attribute, ok := attributes["as_path_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_options_1 is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	asPathOptions1Val, ok := asPathOptions1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_options_1 expected to be basetypes.ObjectValue, was: %T`, asPathOptions1Attribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.BoolValue, was: %T`, bfdAttribute))
	}

	clientAttribute, ok := attributes["client"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`client is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	clientVal, ok := clientAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`client expected to be basetypes.BoolValue, was: %T`, clientAttribute))
	}

	clusterIdAttribute, ok := attributes["cluster_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cluster_id is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	clusterIdVal, ok := clusterIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cluster_id expected to be basetypes.StringValue, was: %T`, clusterIdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	dynamicNeighborAttribute, ok := attributes["dynamic_neighbor"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_neighbor is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	dynamicNeighborVal, ok := dynamicNeighborAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_neighbor expected to be basetypes.BoolValue, was: %T`, dynamicNeighborAttribute))
	}

	dynamicNeighborAllowedPeerAsAttribute, ok := attributes["dynamic_neighbor_allowed_peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_neighbor_allowed_peer_as is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	dynamicNeighborAllowedPeerAsVal, ok := dynamicNeighborAllowedPeerAsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_neighbor_allowed_peer_as expected to be basetypes.ListValue, was: %T`, dynamicNeighborAllowedPeerAsAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	grStaleRouteTimeAttribute, ok := attributes["gr_stale_route_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gr_stale_route_time is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	grStaleRouteTimeVal, ok := grStaleRouteTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gr_stale_route_time expected to be basetypes.Int64Value, was: %T`, grStaleRouteTimeAttribute))
	}

	groupAttribute, ok := attributes["group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`group is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	groupVal, ok := groupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`group expected to be basetypes.StringValue, was: %T`, groupAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceKindAttribute, ok := attributes["interface_kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_kind is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	interfaceKindVal, ok := interfaceKindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_kind expected to be basetypes.StringValue, was: %T`, interfaceKindAttribute))
	}

	ipv4Unicast1Attribute, ok := attributes["ipv4_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_unicast_1 is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	ipv4Unicast1Val, ok := ipv4Unicast1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_unicast_1 expected to be basetypes.ObjectValue, was: %T`, ipv4Unicast1Attribute))
	}

	ipv6Unicast1Attribute, ok := attributes["ipv6_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_unicast_1 is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	ipv6Unicast1Val, ok := ipv6Unicast1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_unicast_1 expected to be basetypes.ObjectValue, was: %T`, ipv6Unicast1Attribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	localAs1Attribute, ok := attributes["local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_as_1 is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	localAs1Val, ok := localAs1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_as_1 expected to be basetypes.ObjectValue, was: %T`, localAs1Attribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	multiHopMaxHopAttribute, ok := attributes["multi_hop_max_hop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multi_hop_max_hop is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	multiHopMaxHopVal, ok := multiHopMaxHopAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multi_hop_max_hop expected to be basetypes.Int64Value, was: %T`, multiHopMaxHopAttribute))
	}

	nextHopSelfAttribute, ok := attributes["next_hop_self"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_hop_self is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	nextHopSelfVal, ok := nextHopSelfAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_hop_self expected to be basetypes.BoolValue, was: %T`, nextHopSelfAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	peerAs1Attribute, ok := attributes["peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_as_1 is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	peerAs1Val, ok := peerAs1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_as_1 expected to be basetypes.ObjectValue, was: %T`, peerAs1Attribute))
	}

	peerIpAttribute, ok := attributes["peer_ip"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`peer_ip is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	peerIpVal, ok := peerIpAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`peer_ip expected to be basetypes.StringValue, was: %T`, peerIpAttribute))
	}

	sendCommunityLargeAttribute, ok := attributes["send_community_large"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_large is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	sendCommunityLargeVal, ok := sendCommunityLargeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_large expected to be basetypes.BoolValue, was: %T`, sendCommunityLargeAttribute))
	}

	sendCommunityStandardAttribute, ok := attributes["send_community_standard"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_community_standard is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	sendCommunityStandardVal, ok := sendCommunityStandardAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_community_standard expected to be basetypes.BoolValue, was: %T`, sendCommunityStandardAttribute))
	}

	sendDefaultRoute1Attribute, ok := attributes["send_default_route"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_default_route_1 is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	sendDefaultRoute1Val, ok := sendDefaultRoute1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_default_route_1 expected to be basetypes.ObjectValue, was: %T`, sendDefaultRoute1Attribute))
	}

	timers1Attribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers_1 is missing from object`)

		return NewSpec5ValueUnknown(), diags
	}

	timers1Val, ok := timers1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers_1 expected to be basetypes.ObjectValue, was: %T`, timers1Attribute))
	}

	if diags.HasError() {
		return NewSpec5ValueUnknown(), diags
	}

	return Spec5Value{
		AsPathOptions1:               asPathOptions1Val,
		Bfd:                          bfdVal,
		Client:                       clientVal,
		ClusterId:                    clusterIdVal,
		Description:                  descriptionVal,
		DynamicNeighbor:              dynamicNeighborVal,
		DynamicNeighborAllowedPeerAs: dynamicNeighborAllowedPeerAsVal,
		ExportPolicy:                 exportPolicyVal,
		GrStaleRouteTime:             grStaleRouteTimeVal,
		Group:                        groupVal,
		ImportPolicy:                 importPolicyVal,
		Interface:                    interfaceVal,
		InterfaceKind:                interfaceKindVal,
		Ipv4Unicast1:                 ipv4Unicast1Val,
		Ipv6Unicast1:                 ipv6Unicast1Val,
		Keychain:                     keychainVal,
		LocalAs1:                     localAs1Val,
		LocalPreference:              localPreferenceVal,
		MultiHopMaxHop:               multiHopMaxHopVal,
		NextHopSelf:                  nextHopSelfVal,
		Node:                         nodeVal,
		PeerAs1:                      peerAs1Val,
		PeerIp:                       peerIpVal,
		SendCommunityLarge:           sendCommunityLargeVal,
		SendCommunityStandard:        sendCommunityStandardVal,
		SendDefaultRoute1:            sendDefaultRoute1Val,
		Timers1:                      timers1Val,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewSpec5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec5Value {
	object, diags := NewSpec5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec5ValueMust(Spec5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec5Type) ValueType(ctx context.Context) attr.Value {
	return Spec5Value{}
}

var _ basetypes.ObjectValuable = Spec5Value{}

type Spec5Value struct {
	AsPathOptions1               basetypes.ObjectValue `tfsdk:"as_path_options"`
	Bfd                          basetypes.BoolValue   `tfsdk:"bfd"`
	Client                       basetypes.BoolValue   `tfsdk:"client"`
	ClusterId                    basetypes.StringValue `tfsdk:"cluster_id"`
	Description                  basetypes.StringValue `tfsdk:"description"`
	DynamicNeighbor              basetypes.BoolValue   `tfsdk:"dynamic_neighbor"`
	DynamicNeighborAllowedPeerAs basetypes.ListValue   `tfsdk:"dynamic_neighbor_allowed_peer_as"`
	ExportPolicy                 basetypes.ListValue   `tfsdk:"export_policy"`
	GrStaleRouteTime             basetypes.Int64Value  `tfsdk:"gr_stale_route_time"`
	Group                        basetypes.StringValue `tfsdk:"group"`
	ImportPolicy                 basetypes.ListValue   `tfsdk:"import_policy"`
	Interface                    basetypes.StringValue `tfsdk:"interface"`
	InterfaceKind                basetypes.StringValue `tfsdk:"interface_kind"`
	Ipv4Unicast1                 basetypes.ObjectValue `tfsdk:"ipv4_unicast"`
	Ipv6Unicast1                 basetypes.ObjectValue `tfsdk:"ipv6_unicast"`
	Keychain                     basetypes.StringValue `tfsdk:"keychain"`
	LocalAs1                     basetypes.ObjectValue `tfsdk:"local_as"`
	LocalPreference              basetypes.Int64Value  `tfsdk:"local_preference"`
	MultiHopMaxHop               basetypes.Int64Value  `tfsdk:"multi_hop_max_hop"`
	NextHopSelf                  basetypes.BoolValue   `tfsdk:"next_hop_self"`
	Node                         basetypes.StringValue `tfsdk:"node"`
	PeerAs1                      basetypes.ObjectValue `tfsdk:"peer_as"`
	PeerIp                       basetypes.StringValue `tfsdk:"peer_ip"`
	SendCommunityLarge           basetypes.BoolValue   `tfsdk:"send_community_large"`
	SendCommunityStandard        basetypes.BoolValue   `tfsdk:"send_community_standard"`
	SendDefaultRoute1            basetypes.ObjectValue `tfsdk:"send_default_route"`
	Timers1                      basetypes.ObjectValue `tfsdk:"timers"`
	state                        attr.ValueState
}

func (v Spec5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 27)

	var val tftypes.Value
	var err error

	attrTypes["as_path_options"] = basetypes.ObjectType{
		AttrTypes: AsPathOptions1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["bfd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["client"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cluster_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["dynamic_neighbor"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["dynamic_neighbor_allowed_peer_as"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["gr_stale_route_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ipv4_unicast"] = basetypes.ObjectType{
		AttrTypes: Ipv4Unicast1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6_unicast"] = basetypes.ObjectType{
		AttrTypes: Ipv6Unicast1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["keychain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_as"] = basetypes.ObjectType{
		AttrTypes: LocalAs1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["local_preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["multi_hop_max_hop"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["next_hop_self"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["peer_as"] = basetypes.ObjectType{
		AttrTypes: PeerAs1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["peer_ip"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["send_community_large"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["send_community_standard"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["send_default_route"] = basetypes.ObjectType{
		AttrTypes: SendDefaultRoute1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["timers"] = basetypes.ObjectType{
		AttrTypes: Timers1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 27)

		val, err = v.AsPathOptions1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_options"] = val

		val, err = v.Bfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.Client.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["client"] = val

		val, err = v.ClusterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cluster_id"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.DynamicNeighbor.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_neighbor"] = val

		val, err = v.DynamicNeighborAllowedPeerAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_neighbor_allowed_peer_as"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.GrStaleRouteTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gr_stale_route_time"] = val

		val, err = v.Group.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["group"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.InterfaceKind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_kind"] = val

		val, err = v.Ipv4Unicast1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_unicast"] = val

		val, err = v.Ipv6Unicast1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_unicast"] = val

		val, err = v.Keychain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keychain"] = val

		val, err = v.LocalAs1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_as"] = val

		val, err = v.LocalPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_preference"] = val

		val, err = v.MultiHopMaxHop.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multi_hop_max_hop"] = val

		val, err = v.NextHopSelf.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_hop_self"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.PeerAs1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_as"] = val

		val, err = v.PeerIp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["peer_ip"] = val

		val, err = v.SendCommunityLarge.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_community_large"] = val

		val, err = v.SendCommunityStandard.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_community_standard"] = val

		val, err = v.SendDefaultRoute1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_default_route"] = val

		val, err = v.Timers1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec5Value) String() string {
	return "Spec5Value"
}

func (v Spec5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var asPathOptions1 basetypes.ObjectValue

	if v.AsPathOptions1.IsNull() {
		asPathOptions1 = types.ObjectNull(
			AsPathOptions1Value{}.AttributeTypes(ctx),
		)
	}

	if v.AsPathOptions1.IsUnknown() {
		asPathOptions1 = types.ObjectUnknown(
			AsPathOptions1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.AsPathOptions1.IsNull() && !v.AsPathOptions1.IsUnknown() {
		asPathOptions1 = types.ObjectValueMust(
			AsPathOptions1Value{}.AttributeTypes(ctx),
			v.AsPathOptions1.Attributes(),
		)
	}

	var ipv4Unicast1 basetypes.ObjectValue

	if v.Ipv4Unicast1.IsNull() {
		ipv4Unicast1 = types.ObjectNull(
			Ipv4Unicast1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv4Unicast1.IsUnknown() {
		ipv4Unicast1 = types.ObjectUnknown(
			Ipv4Unicast1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv4Unicast1.IsNull() && !v.Ipv4Unicast1.IsUnknown() {
		ipv4Unicast1 = types.ObjectValueMust(
			Ipv4Unicast1Value{}.AttributeTypes(ctx),
			v.Ipv4Unicast1.Attributes(),
		)
	}

	var ipv6Unicast1 basetypes.ObjectValue

	if v.Ipv6Unicast1.IsNull() {
		ipv6Unicast1 = types.ObjectNull(
			Ipv6Unicast1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv6Unicast1.IsUnknown() {
		ipv6Unicast1 = types.ObjectUnknown(
			Ipv6Unicast1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv6Unicast1.IsNull() && !v.Ipv6Unicast1.IsUnknown() {
		ipv6Unicast1 = types.ObjectValueMust(
			Ipv6Unicast1Value{}.AttributeTypes(ctx),
			v.Ipv6Unicast1.Attributes(),
		)
	}

	var localAs1 basetypes.ObjectValue

	if v.LocalAs1.IsNull() {
		localAs1 = types.ObjectNull(
			LocalAs1Value{}.AttributeTypes(ctx),
		)
	}

	if v.LocalAs1.IsUnknown() {
		localAs1 = types.ObjectUnknown(
			LocalAs1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.LocalAs1.IsNull() && !v.LocalAs1.IsUnknown() {
		localAs1 = types.ObjectValueMust(
			LocalAs1Value{}.AttributeTypes(ctx),
			v.LocalAs1.Attributes(),
		)
	}

	var peerAs1 basetypes.ObjectValue

	if v.PeerAs1.IsNull() {
		peerAs1 = types.ObjectNull(
			PeerAs1Value{}.AttributeTypes(ctx),
		)
	}

	if v.PeerAs1.IsUnknown() {
		peerAs1 = types.ObjectUnknown(
			PeerAs1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PeerAs1.IsNull() && !v.PeerAs1.IsUnknown() {
		peerAs1 = types.ObjectValueMust(
			PeerAs1Value{}.AttributeTypes(ctx),
			v.PeerAs1.Attributes(),
		)
	}

	var sendDefaultRoute1 basetypes.ObjectValue

	if v.SendDefaultRoute1.IsNull() {
		sendDefaultRoute1 = types.ObjectNull(
			SendDefaultRoute1Value{}.AttributeTypes(ctx),
		)
	}

	if v.SendDefaultRoute1.IsUnknown() {
		sendDefaultRoute1 = types.ObjectUnknown(
			SendDefaultRoute1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.SendDefaultRoute1.IsNull() && !v.SendDefaultRoute1.IsUnknown() {
		sendDefaultRoute1 = types.ObjectValueMust(
			SendDefaultRoute1Value{}.AttributeTypes(ctx),
			v.SendDefaultRoute1.Attributes(),
		)
	}

	var timers1 basetypes.ObjectValue

	if v.Timers1.IsNull() {
		timers1 = types.ObjectNull(
			Timers1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Timers1.IsUnknown() {
		timers1 = types.ObjectUnknown(
			Timers1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Timers1.IsNull() && !v.Timers1.IsUnknown() {
		timers1 = types.ObjectValueMust(
			Timers1Value{}.AttributeTypes(ctx),
			v.Timers1.Attributes(),
		)
	}

	var dynamicNeighborAllowedPeerAsVal basetypes.ListValue
	switch {
	case v.DynamicNeighborAllowedPeerAs.IsUnknown():
		dynamicNeighborAllowedPeerAsVal = types.ListUnknown(types.Int64Type)
	case v.DynamicNeighborAllowedPeerAs.IsNull():
		dynamicNeighborAllowedPeerAsVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		dynamicNeighborAllowedPeerAsVal, d = types.ListValue(types.Int64Type, v.DynamicNeighborAllowedPeerAs.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_options": basetypes.ObjectType{
				AttrTypes: AsPathOptions1Value{}.AttributeTypes(ctx),
			},
			"bfd":              basetypes.BoolType{},
			"client":           basetypes.BoolType{},
			"cluster_id":       basetypes.StringType{},
			"description":      basetypes.StringType{},
			"dynamic_neighbor": basetypes.BoolType{},
			"dynamic_neighbor_allowed_peer_as": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gr_stale_route_time": basetypes.Int64Type{},
			"group":               basetypes.StringType{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"interface":      basetypes.StringType{},
			"interface_kind": basetypes.StringType{},
			"ipv4_unicast": basetypes.ObjectType{
				AttrTypes: Ipv4Unicast1Value{}.AttributeTypes(ctx),
			},
			"ipv6_unicast": basetypes.ObjectType{
				AttrTypes: Ipv6Unicast1Value{}.AttributeTypes(ctx),
			},
			"keychain": basetypes.StringType{},
			"local_as": basetypes.ObjectType{
				AttrTypes: LocalAs1Value{}.AttributeTypes(ctx),
			},
			"local_preference":  basetypes.Int64Type{},
			"multi_hop_max_hop": basetypes.Int64Type{},
			"next_hop_self":     basetypes.BoolType{},
			"node":              basetypes.StringType{},
			"peer_as": basetypes.ObjectType{
				AttrTypes: PeerAs1Value{}.AttributeTypes(ctx),
			},
			"peer_ip":                 basetypes.StringType{},
			"send_community_large":    basetypes.BoolType{},
			"send_community_standard": basetypes.BoolType{},
			"send_default_route": basetypes.ObjectType{
				AttrTypes: SendDefaultRoute1Value{}.AttributeTypes(ctx),
			},
			"timers": basetypes.ObjectType{
				AttrTypes: Timers1Value{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var exportPolicyVal basetypes.ListValue
	switch {
	case v.ExportPolicy.IsUnknown():
		exportPolicyVal = types.ListUnknown(types.StringType)
	case v.ExportPolicy.IsNull():
		exportPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		exportPolicyVal, d = types.ListValue(types.StringType, v.ExportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_options": basetypes.ObjectType{
				AttrTypes: AsPathOptions1Value{}.AttributeTypes(ctx),
			},
			"bfd":              basetypes.BoolType{},
			"client":           basetypes.BoolType{},
			"cluster_id":       basetypes.StringType{},
			"description":      basetypes.StringType{},
			"dynamic_neighbor": basetypes.BoolType{},
			"dynamic_neighbor_allowed_peer_as": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gr_stale_route_time": basetypes.Int64Type{},
			"group":               basetypes.StringType{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"interface":      basetypes.StringType{},
			"interface_kind": basetypes.StringType{},
			"ipv4_unicast": basetypes.ObjectType{
				AttrTypes: Ipv4Unicast1Value{}.AttributeTypes(ctx),
			},
			"ipv6_unicast": basetypes.ObjectType{
				AttrTypes: Ipv6Unicast1Value{}.AttributeTypes(ctx),
			},
			"keychain": basetypes.StringType{},
			"local_as": basetypes.ObjectType{
				AttrTypes: LocalAs1Value{}.AttributeTypes(ctx),
			},
			"local_preference":  basetypes.Int64Type{},
			"multi_hop_max_hop": basetypes.Int64Type{},
			"next_hop_self":     basetypes.BoolType{},
			"node":              basetypes.StringType{},
			"peer_as": basetypes.ObjectType{
				AttrTypes: PeerAs1Value{}.AttributeTypes(ctx),
			},
			"peer_ip":                 basetypes.StringType{},
			"send_community_large":    basetypes.BoolType{},
			"send_community_standard": basetypes.BoolType{},
			"send_default_route": basetypes.ObjectType{
				AttrTypes: SendDefaultRoute1Value{}.AttributeTypes(ctx),
			},
			"timers": basetypes.ObjectType{
				AttrTypes: Timers1Value{}.AttributeTypes(ctx),
			},
		}), diags
	}

	var importPolicyVal basetypes.ListValue
	switch {
	case v.ImportPolicy.IsUnknown():
		importPolicyVal = types.ListUnknown(types.StringType)
	case v.ImportPolicy.IsNull():
		importPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		importPolicyVal, d = types.ListValue(types.StringType, v.ImportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_options": basetypes.ObjectType{
				AttrTypes: AsPathOptions1Value{}.AttributeTypes(ctx),
			},
			"bfd":              basetypes.BoolType{},
			"client":           basetypes.BoolType{},
			"cluster_id":       basetypes.StringType{},
			"description":      basetypes.StringType{},
			"dynamic_neighbor": basetypes.BoolType{},
			"dynamic_neighbor_allowed_peer_as": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"gr_stale_route_time": basetypes.Int64Type{},
			"group":               basetypes.StringType{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"interface":      basetypes.StringType{},
			"interface_kind": basetypes.StringType{},
			"ipv4_unicast": basetypes.ObjectType{
				AttrTypes: Ipv4Unicast1Value{}.AttributeTypes(ctx),
			},
			"ipv6_unicast": basetypes.ObjectType{
				AttrTypes: Ipv6Unicast1Value{}.AttributeTypes(ctx),
			},
			"keychain": basetypes.StringType{},
			"local_as": basetypes.ObjectType{
				AttrTypes: LocalAs1Value{}.AttributeTypes(ctx),
			},
			"local_preference":  basetypes.Int64Type{},
			"multi_hop_max_hop": basetypes.Int64Type{},
			"next_hop_self":     basetypes.BoolType{},
			"node":              basetypes.StringType{},
			"peer_as": basetypes.ObjectType{
				AttrTypes: PeerAs1Value{}.AttributeTypes(ctx),
			},
			"peer_ip":                 basetypes.StringType{},
			"send_community_large":    basetypes.BoolType{},
			"send_community_standard": basetypes.BoolType{},
			"send_default_route": basetypes.ObjectType{
				AttrTypes: SendDefaultRoute1Value{}.AttributeTypes(ctx),
			},
			"timers": basetypes.ObjectType{
				AttrTypes: Timers1Value{}.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"as_path_options": basetypes.ObjectType{
			AttrTypes: AsPathOptions1Value{}.AttributeTypes(ctx),
		},
		"bfd":              basetypes.BoolType{},
		"client":           basetypes.BoolType{},
		"cluster_id":       basetypes.StringType{},
		"description":      basetypes.StringType{},
		"dynamic_neighbor": basetypes.BoolType{},
		"dynamic_neighbor_allowed_peer_as": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gr_stale_route_time": basetypes.Int64Type{},
		"group":               basetypes.StringType{},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"interface":      basetypes.StringType{},
		"interface_kind": basetypes.StringType{},
		"ipv4_unicast": basetypes.ObjectType{
			AttrTypes: Ipv4Unicast1Value{}.AttributeTypes(ctx),
		},
		"ipv6_unicast": basetypes.ObjectType{
			AttrTypes: Ipv6Unicast1Value{}.AttributeTypes(ctx),
		},
		"keychain": basetypes.StringType{},
		"local_as": basetypes.ObjectType{
			AttrTypes: LocalAs1Value{}.AttributeTypes(ctx),
		},
		"local_preference":  basetypes.Int64Type{},
		"multi_hop_max_hop": basetypes.Int64Type{},
		"next_hop_self":     basetypes.BoolType{},
		"node":              basetypes.StringType{},
		"peer_as": basetypes.ObjectType{
			AttrTypes: PeerAs1Value{}.AttributeTypes(ctx),
		},
		"peer_ip":                 basetypes.StringType{},
		"send_community_large":    basetypes.BoolType{},
		"send_community_standard": basetypes.BoolType{},
		"send_default_route": basetypes.ObjectType{
			AttrTypes: SendDefaultRoute1Value{}.AttributeTypes(ctx),
		},
		"timers": basetypes.ObjectType{
			AttrTypes: Timers1Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path_options":                  asPathOptions1,
			"bfd":                              v.Bfd,
			"client":                           v.Client,
			"cluster_id":                       v.ClusterId,
			"description":                      v.Description,
			"dynamic_neighbor":                 v.DynamicNeighbor,
			"dynamic_neighbor_allowed_peer_as": dynamicNeighborAllowedPeerAsVal,
			"export_policy":                    exportPolicyVal,
			"gr_stale_route_time":              v.GrStaleRouteTime,
			"group":                            v.Group,
			"import_policy":                    importPolicyVal,
			"interface":                        v.Interface,
			"interface_kind":                   v.InterfaceKind,
			"ipv4_unicast":                     ipv4Unicast1,
			"ipv6_unicast":                     ipv6Unicast1,
			"keychain":                         v.Keychain,
			"local_as":                         localAs1,
			"local_preference":                 v.LocalPreference,
			"multi_hop_max_hop":                v.MultiHopMaxHop,
			"next_hop_self":                    v.NextHopSelf,
			"node":                             v.Node,
			"peer_as":                          peerAs1,
			"peer_ip":                          v.PeerIp,
			"send_community_large":             v.SendCommunityLarge,
			"send_community_standard":          v.SendCommunityStandard,
			"send_default_route":               sendDefaultRoute1,
			"timers":                           timers1,
		})

	return objVal, diags
}

func (v Spec5Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPathOptions1.Equal(other.AsPathOptions1) {
		return false
	}

	if !v.Bfd.Equal(other.Bfd) {
		return false
	}

	if !v.Client.Equal(other.Client) {
		return false
	}

	if !v.ClusterId.Equal(other.ClusterId) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.DynamicNeighbor.Equal(other.DynamicNeighbor) {
		return false
	}

	if !v.DynamicNeighborAllowedPeerAs.Equal(other.DynamicNeighborAllowedPeerAs) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.GrStaleRouteTime.Equal(other.GrStaleRouteTime) {
		return false
	}

	if !v.Group.Equal(other.Group) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.InterfaceKind.Equal(other.InterfaceKind) {
		return false
	}

	if !v.Ipv4Unicast1.Equal(other.Ipv4Unicast1) {
		return false
	}

	if !v.Ipv6Unicast1.Equal(other.Ipv6Unicast1) {
		return false
	}

	if !v.Keychain.Equal(other.Keychain) {
		return false
	}

	if !v.LocalAs1.Equal(other.LocalAs1) {
		return false
	}

	if !v.LocalPreference.Equal(other.LocalPreference) {
		return false
	}

	if !v.MultiHopMaxHop.Equal(other.MultiHopMaxHop) {
		return false
	}

	if !v.NextHopSelf.Equal(other.NextHopSelf) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.PeerAs1.Equal(other.PeerAs1) {
		return false
	}

	if !v.PeerIp.Equal(other.PeerIp) {
		return false
	}

	if !v.SendCommunityLarge.Equal(other.SendCommunityLarge) {
		return false
	}

	if !v.SendCommunityStandard.Equal(other.SendCommunityStandard) {
		return false
	}

	if !v.SendDefaultRoute1.Equal(other.SendDefaultRoute1) {
		return false
	}

	if !v.Timers1.Equal(other.Timers1) {
		return false
	}

	return true
}

func (v Spec5Value) Type(ctx context.Context) attr.Type {
	return Spec5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path_options": basetypes.ObjectType{
			AttrTypes: AsPathOptions1Value{}.AttributeTypes(ctx),
		},
		"bfd":              basetypes.BoolType{},
		"client":           basetypes.BoolType{},
		"cluster_id":       basetypes.StringType{},
		"description":      basetypes.StringType{},
		"dynamic_neighbor": basetypes.BoolType{},
		"dynamic_neighbor_allowed_peer_as": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"gr_stale_route_time": basetypes.Int64Type{},
		"group":               basetypes.StringType{},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"interface":      basetypes.StringType{},
		"interface_kind": basetypes.StringType{},
		"ipv4_unicast": basetypes.ObjectType{
			AttrTypes: Ipv4Unicast1Value{}.AttributeTypes(ctx),
		},
		"ipv6_unicast": basetypes.ObjectType{
			AttrTypes: Ipv6Unicast1Value{}.AttributeTypes(ctx),
		},
		"keychain": basetypes.StringType{},
		"local_as": basetypes.ObjectType{
			AttrTypes: LocalAs1Value{}.AttributeTypes(ctx),
		},
		"local_preference":  basetypes.Int64Type{},
		"multi_hop_max_hop": basetypes.Int64Type{},
		"next_hop_self":     basetypes.BoolType{},
		"node":              basetypes.StringType{},
		"peer_as": basetypes.ObjectType{
			AttrTypes: PeerAs1Value{}.AttributeTypes(ctx),
		},
		"peer_ip":                 basetypes.StringType{},
		"send_community_large":    basetypes.BoolType{},
		"send_community_standard": basetypes.BoolType{},
		"send_default_route": basetypes.ObjectType{
			AttrTypes: SendDefaultRoute1Value{}.AttributeTypes(ctx),
		},
		"timers": basetypes.ObjectType{
			AttrTypes: Timers1Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = AsPathOptions1Type{}

type AsPathOptions1Type struct {
	basetypes.ObjectType
}

func (t AsPathOptions1Type) Equal(o attr.Type) bool {
	other, ok := o.(AsPathOptions1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AsPathOptions1Type) String() string {
	return "AsPathOptions1Type"
}

func (t AsPathOptions1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowOwnAsAttribute, ok := attributes["allow_own_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_own_as is missing from object`)

		return nil, diags
	}

	allowOwnAsVal, ok := allowOwnAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_own_as expected to be basetypes.Int64Value, was: %T`, allowOwnAsAttribute))
	}

	removePrivateAs1Attribute, ok := attributes["remove_private_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as_1 is missing from object`)

		return nil, diags
	}

	removePrivateAs1Val, ok := removePrivateAs1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as_1 expected to be basetypes.ObjectValue, was: %T`, removePrivateAs1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AsPathOptions1Value{
		AllowOwnAs:       allowOwnAsVal,
		RemovePrivateAs1: removePrivateAs1Val,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAsPathOptions1ValueNull() AsPathOptions1Value {
	return AsPathOptions1Value{
		state: attr.ValueStateNull,
	}
}

func NewAsPathOptions1ValueUnknown() AsPathOptions1Value {
	return AsPathOptions1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewAsPathOptions1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AsPathOptions1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AsPathOptions1Value Attribute Value",
				"While creating a AsPathOptions1Value value, a missing attribute value was detected. "+
					"A AsPathOptions1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsPathOptions1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AsPathOptions1Value Attribute Type",
				"While creating a AsPathOptions1Value value, an invalid attribute value was detected. "+
					"A AsPathOptions1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsPathOptions1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AsPathOptions1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AsPathOptions1Value Attribute Value",
				"While creating a AsPathOptions1Value value, an extra attribute value was detected. "+
					"A AsPathOptions1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AsPathOptions1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAsPathOptions1ValueUnknown(), diags
	}

	allowOwnAsAttribute, ok := attributes["allow_own_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_own_as is missing from object`)

		return NewAsPathOptions1ValueUnknown(), diags
	}

	allowOwnAsVal, ok := allowOwnAsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_own_as expected to be basetypes.Int64Value, was: %T`, allowOwnAsAttribute))
	}

	removePrivateAs1Attribute, ok := attributes["remove_private_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as_1 is missing from object`)

		return NewAsPathOptions1ValueUnknown(), diags
	}

	removePrivateAs1Val, ok := removePrivateAs1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as_1 expected to be basetypes.ObjectValue, was: %T`, removePrivateAs1Attribute))
	}

	if diags.HasError() {
		return NewAsPathOptions1ValueUnknown(), diags
	}

	return AsPathOptions1Value{
		AllowOwnAs:       allowOwnAsVal,
		RemovePrivateAs1: removePrivateAs1Val,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAsPathOptions1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AsPathOptions1Value {
	object, diags := NewAsPathOptions1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAsPathOptions1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AsPathOptions1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAsPathOptions1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAsPathOptions1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAsPathOptions1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAsPathOptions1ValueMust(AsPathOptions1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t AsPathOptions1Type) ValueType(ctx context.Context) attr.Value {
	return AsPathOptions1Value{}
}

var _ basetypes.ObjectValuable = AsPathOptions1Value{}

type AsPathOptions1Value struct {
	AllowOwnAs       basetypes.Int64Value  `tfsdk:"allow_own_as"`
	RemovePrivateAs1 basetypes.ObjectValue `tfsdk:"remove_private_as"`
	state            attr.ValueState
}

func (v AsPathOptions1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["allow_own_as"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["remove_private_as"] = basetypes.ObjectType{
		AttrTypes: RemovePrivateAs1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AllowOwnAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_own_as"] = val

		val, err = v.RemovePrivateAs1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove_private_as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AsPathOptions1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AsPathOptions1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AsPathOptions1Value) String() string {
	return "AsPathOptions1Value"
}

func (v AsPathOptions1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var removePrivateAs1 basetypes.ObjectValue

	if v.RemovePrivateAs1.IsNull() {
		removePrivateAs1 = types.ObjectNull(
			RemovePrivateAs1Value{}.AttributeTypes(ctx),
		)
	}

	if v.RemovePrivateAs1.IsUnknown() {
		removePrivateAs1 = types.ObjectUnknown(
			RemovePrivateAs1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.RemovePrivateAs1.IsNull() && !v.RemovePrivateAs1.IsUnknown() {
		removePrivateAs1 = types.ObjectValueMust(
			RemovePrivateAs1Value{}.AttributeTypes(ctx),
			v.RemovePrivateAs1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"allow_own_as": basetypes.Int64Type{},
		"remove_private_as": basetypes.ObjectType{
			AttrTypes: RemovePrivateAs1Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_own_as":      v.AllowOwnAs,
			"remove_private_as": removePrivateAs1,
		})

	return objVal, diags
}

func (v AsPathOptions1Value) Equal(o attr.Value) bool {
	other, ok := o.(AsPathOptions1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowOwnAs.Equal(other.AllowOwnAs) {
		return false
	}

	if !v.RemovePrivateAs1.Equal(other.RemovePrivateAs1) {
		return false
	}

	return true
}

func (v AsPathOptions1Value) Type(ctx context.Context) attr.Type {
	return AsPathOptions1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AsPathOptions1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_own_as": basetypes.Int64Type{},
		"remove_private_as": basetypes.ObjectType{
			AttrTypes: RemovePrivateAs1Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = RemovePrivateAs1Type{}

type RemovePrivateAs1Type struct {
	basetypes.ObjectType
}

func (t RemovePrivateAs1Type) Equal(o attr.Type) bool {
	other, ok := o.(RemovePrivateAs1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RemovePrivateAs1Type) String() string {
	return "RemovePrivateAs1Type"
}

func (t RemovePrivateAs1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ignorePeerAsAttribute, ok := attributes["ignore_peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ignore_peer_as is missing from object`)

		return nil, diags
	}

	ignorePeerAsVal, ok := ignorePeerAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ignore_peer_as expected to be basetypes.BoolValue, was: %T`, ignorePeerAsAttribute))
	}

	leadingOnlyAttribute, ok := attributes["leading_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leading_only is missing from object`)

		return nil, diags
	}

	leadingOnlyVal, ok := leadingOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leading_only expected to be basetypes.BoolValue, was: %T`, leadingOnlyAttribute))
	}

	removePrivateAsModeAttribute, ok := attributes["remove_private_as_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as_mode is missing from object`)

		return nil, diags
	}

	removePrivateAsModeVal, ok := removePrivateAsModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as_mode expected to be basetypes.StringValue, was: %T`, removePrivateAsModeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RemovePrivateAs1Value{
		IgnorePeerAs:        ignorePeerAsVal,
		LeadingOnly:         leadingOnlyVal,
		RemovePrivateAsMode: removePrivateAsModeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRemovePrivateAs1ValueNull() RemovePrivateAs1Value {
	return RemovePrivateAs1Value{
		state: attr.ValueStateNull,
	}
}

func NewRemovePrivateAs1ValueUnknown() RemovePrivateAs1Value {
	return RemovePrivateAs1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewRemovePrivateAs1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RemovePrivateAs1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RemovePrivateAs1Value Attribute Value",
				"While creating a RemovePrivateAs1Value value, a missing attribute value was detected. "+
					"A RemovePrivateAs1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemovePrivateAs1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RemovePrivateAs1Value Attribute Type",
				"While creating a RemovePrivateAs1Value value, an invalid attribute value was detected. "+
					"A RemovePrivateAs1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RemovePrivateAs1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RemovePrivateAs1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RemovePrivateAs1Value Attribute Value",
				"While creating a RemovePrivateAs1Value value, an extra attribute value was detected. "+
					"A RemovePrivateAs1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RemovePrivateAs1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRemovePrivateAs1ValueUnknown(), diags
	}

	ignorePeerAsAttribute, ok := attributes["ignore_peer_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ignore_peer_as is missing from object`)

		return NewRemovePrivateAs1ValueUnknown(), diags
	}

	ignorePeerAsVal, ok := ignorePeerAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ignore_peer_as expected to be basetypes.BoolValue, was: %T`, ignorePeerAsAttribute))
	}

	leadingOnlyAttribute, ok := attributes["leading_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`leading_only is missing from object`)

		return NewRemovePrivateAs1ValueUnknown(), diags
	}

	leadingOnlyVal, ok := leadingOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`leading_only expected to be basetypes.BoolValue, was: %T`, leadingOnlyAttribute))
	}

	removePrivateAsModeAttribute, ok := attributes["remove_private_as_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove_private_as_mode is missing from object`)

		return NewRemovePrivateAs1ValueUnknown(), diags
	}

	removePrivateAsModeVal, ok := removePrivateAsModeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove_private_as_mode expected to be basetypes.StringValue, was: %T`, removePrivateAsModeAttribute))
	}

	if diags.HasError() {
		return NewRemovePrivateAs1ValueUnknown(), diags
	}

	return RemovePrivateAs1Value{
		IgnorePeerAs:        ignorePeerAsVal,
		LeadingOnly:         leadingOnlyVal,
		RemovePrivateAsMode: removePrivateAsModeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewRemovePrivateAs1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RemovePrivateAs1Value {
	object, diags := NewRemovePrivateAs1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRemovePrivateAs1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RemovePrivateAs1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRemovePrivateAs1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRemovePrivateAs1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRemovePrivateAs1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRemovePrivateAs1ValueMust(RemovePrivateAs1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t RemovePrivateAs1Type) ValueType(ctx context.Context) attr.Value {
	return RemovePrivateAs1Value{}
}

var _ basetypes.ObjectValuable = RemovePrivateAs1Value{}

type RemovePrivateAs1Value struct {
	IgnorePeerAs        basetypes.BoolValue   `tfsdk:"ignore_peer_as"`
	LeadingOnly         basetypes.BoolValue   `tfsdk:"leading_only"`
	RemovePrivateAsMode basetypes.StringValue `tfsdk:"remove_private_as_mode"`
	state               attr.ValueState
}

func (v RemovePrivateAs1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["ignore_peer_as"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["leading_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["remove_private_as_mode"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.IgnorePeerAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ignore_peer_as"] = val

		val, err = v.LeadingOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["leading_only"] = val

		val, err = v.RemovePrivateAsMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove_private_as_mode"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RemovePrivateAs1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RemovePrivateAs1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RemovePrivateAs1Value) String() string {
	return "RemovePrivateAs1Value"
}

func (v RemovePrivateAs1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ignore_peer_as":         basetypes.BoolType{},
		"leading_only":           basetypes.BoolType{},
		"remove_private_as_mode": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ignore_peer_as":         v.IgnorePeerAs,
			"leading_only":           v.LeadingOnly,
			"remove_private_as_mode": v.RemovePrivateAsMode,
		})

	return objVal, diags
}

func (v RemovePrivateAs1Value) Equal(o attr.Value) bool {
	other, ok := o.(RemovePrivateAs1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IgnorePeerAs.Equal(other.IgnorePeerAs) {
		return false
	}

	if !v.LeadingOnly.Equal(other.LeadingOnly) {
		return false
	}

	if !v.RemovePrivateAsMode.Equal(other.RemovePrivateAsMode) {
		return false
	}

	return true
}

func (v RemovePrivateAs1Value) Type(ctx context.Context) attr.Type {
	return RemovePrivateAs1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RemovePrivateAs1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ignore_peer_as":         basetypes.BoolType{},
		"leading_only":           basetypes.BoolType{},
		"remove_private_as_mode": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Ipv4Unicast1Type{}

type Ipv4Unicast1Type struct {
	basetypes.ObjectType
}

func (t Ipv4Unicast1Type) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4Unicast1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4Unicast1Type) String() string {
	return "Ipv4Unicast1Type"
}

func (t Ipv4Unicast1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advertiseIpv6NextHopsAttribute, ok := attributes["advertise_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6_next_hops is missing from object`)

		return nil, diags
	}

	advertiseIpv6NextHopsVal, ok := advertiseIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6NextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit2Attribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_2 is missing from object`)

		return nil, diags
	}

	prefixLimit2Val, ok := prefixLimit2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimit2Attribute))
	}

	receiveIpv6NextHopsAttribute, ok := attributes["receive_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receive_ipv6_next_hops is missing from object`)

		return nil, diags
	}

	receiveIpv6NextHopsVal, ok := receiveIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receive_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, receiveIpv6NextHopsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4Unicast1Value{
		AdvertiseIpv6NextHops: advertiseIpv6NextHopsVal,
		Enabled:               enabledVal,
		PrefixLimit2:          prefixLimit2Val,
		ReceiveIpv6NextHops:   receiveIpv6NextHopsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIpv4Unicast1ValueNull() Ipv4Unicast1Value {
	return Ipv4Unicast1Value{
		state: attr.ValueStateNull,
	}
}

func NewIpv4Unicast1ValueUnknown() Ipv4Unicast1Value {
	return Ipv4Unicast1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4Unicast1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4Unicast1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4Unicast1Value Attribute Value",
				"While creating a Ipv4Unicast1Value value, a missing attribute value was detected. "+
					"A Ipv4Unicast1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4Unicast1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4Unicast1Value Attribute Type",
				"While creating a Ipv4Unicast1Value value, an invalid attribute value was detected. "+
					"A Ipv4Unicast1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4Unicast1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4Unicast1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4Unicast1Value Attribute Value",
				"While creating a Ipv4Unicast1Value value, an extra attribute value was detected. "+
					"A Ipv4Unicast1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4Unicast1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4Unicast1ValueUnknown(), diags
	}

	advertiseIpv6NextHopsAttribute, ok := attributes["advertise_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6_next_hops is missing from object`)

		return NewIpv4Unicast1ValueUnknown(), diags
	}

	advertiseIpv6NextHopsVal, ok := advertiseIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6NextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv4Unicast1ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit2Attribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_2 is missing from object`)

		return NewIpv4Unicast1ValueUnknown(), diags
	}

	prefixLimit2Val, ok := prefixLimit2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimit2Attribute))
	}

	receiveIpv6NextHopsAttribute, ok := attributes["receive_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receive_ipv6_next_hops is missing from object`)

		return NewIpv4Unicast1ValueUnknown(), diags
	}

	receiveIpv6NextHopsVal, ok := receiveIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receive_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, receiveIpv6NextHopsAttribute))
	}

	if diags.HasError() {
		return NewIpv4Unicast1ValueUnknown(), diags
	}

	return Ipv4Unicast1Value{
		AdvertiseIpv6NextHops: advertiseIpv6NextHopsVal,
		Enabled:               enabledVal,
		PrefixLimit2:          prefixLimit2Val,
		ReceiveIpv6NextHops:   receiveIpv6NextHopsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIpv4Unicast1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4Unicast1Value {
	object, diags := NewIpv4Unicast1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4Unicast1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4Unicast1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4Unicast1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4Unicast1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4Unicast1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4Unicast1ValueMust(Ipv4Unicast1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4Unicast1Type) ValueType(ctx context.Context) attr.Value {
	return Ipv4Unicast1Value{}
}

var _ basetypes.ObjectValuable = Ipv4Unicast1Value{}

type Ipv4Unicast1Value struct {
	AdvertiseIpv6NextHops basetypes.BoolValue   `tfsdk:"advertise_ipv6_next_hops"`
	Enabled               basetypes.BoolValue   `tfsdk:"enabled"`
	PrefixLimit2          basetypes.ObjectValue `tfsdk:"prefix_limit"`
	ReceiveIpv6NextHops   basetypes.BoolValue   `tfsdk:"receive_ipv6_next_hops"`
	state                 attr.ValueState
}

func (v Ipv4Unicast1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["advertise_ipv6_next_hops"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix_limit"] = basetypes.ObjectType{
		AttrTypes: PrefixLimit2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["receive_ipv6_next_hops"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AdvertiseIpv6NextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advertise_ipv6_next_hops"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.PrefixLimit2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit"] = val

		val, err = v.ReceiveIpv6NextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["receive_ipv6_next_hops"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4Unicast1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4Unicast1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4Unicast1Value) String() string {
	return "Ipv4Unicast1Value"
}

func (v Ipv4Unicast1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimit2 basetypes.ObjectValue

	if v.PrefixLimit2.IsNull() {
		prefixLimit2 = types.ObjectNull(
			PrefixLimit2Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimit2.IsUnknown() {
		prefixLimit2 = types.ObjectUnknown(
			PrefixLimit2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimit2.IsNull() && !v.PrefixLimit2.IsUnknown() {
		prefixLimit2 = types.ObjectValueMust(
			PrefixLimit2Value{}.AttributeTypes(ctx),
			v.PrefixLimit2.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"advertise_ipv6_next_hops": basetypes.BoolType{},
		"enabled":                  basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimit2Value{}.AttributeTypes(ctx),
		},
		"receive_ipv6_next_hops": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advertise_ipv6_next_hops": v.AdvertiseIpv6NextHops,
			"enabled":                  v.Enabled,
			"prefix_limit":             prefixLimit2,
			"receive_ipv6_next_hops":   v.ReceiveIpv6NextHops,
		})

	return objVal, diags
}

func (v Ipv4Unicast1Value) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4Unicast1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvertiseIpv6NextHops.Equal(other.AdvertiseIpv6NextHops) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.PrefixLimit2.Equal(other.PrefixLimit2) {
		return false
	}

	if !v.ReceiveIpv6NextHops.Equal(other.ReceiveIpv6NextHops) {
		return false
	}

	return true
}

func (v Ipv4Unicast1Value) Type(ctx context.Context) attr.Type {
	return Ipv4Unicast1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4Unicast1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advertise_ipv6_next_hops": basetypes.BoolType{},
		"enabled":                  basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimit2Value{}.AttributeTypes(ctx),
		},
		"receive_ipv6_next_hops": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimit2Type{}

type PrefixLimit2Type struct {
	basetypes.ObjectType
}

func (t PrefixLimit2Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimit2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimit2Type) String() string {
	return "PrefixLimit2Type"
}

func (t PrefixLimit2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	prefixLimitAccepted2Attribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_2 is missing from object`)

		return nil, diags
	}

	prefixLimitAccepted2Val, ok := prefixLimitAccepted2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted2Attribute))
	}

	prefixLimitReceived2Attribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_2 is missing from object`)

		return nil, diags
	}

	prefixLimitReceived2Val, ok := prefixLimitReceived2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived2Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimit2Value{
		PrefixLimitAccepted2: prefixLimitAccepted2Val,
		PrefixLimitReceived2: prefixLimitReceived2Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit2ValueNull() PrefixLimit2Value {
	return PrefixLimit2Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimit2ValueUnknown() PrefixLimit2Value {
	return PrefixLimit2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimit2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimit2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimit2Value Attribute Value",
				"While creating a PrefixLimit2Value value, a missing attribute value was detected. "+
					"A PrefixLimit2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimit2Value Attribute Type",
				"While creating a PrefixLimit2Value value, an invalid attribute value was detected. "+
					"A PrefixLimit2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimit2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimit2Value Attribute Value",
				"While creating a PrefixLimit2Value value, an extra attribute value was detected. "+
					"A PrefixLimit2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimit2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimit2ValueUnknown(), diags
	}

	prefixLimitAccepted2Attribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_2 is missing from object`)

		return NewPrefixLimit2ValueUnknown(), diags
	}

	prefixLimitAccepted2Val, ok := prefixLimitAccepted2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted2Attribute))
	}

	prefixLimitReceived2Attribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_2 is missing from object`)

		return NewPrefixLimit2ValueUnknown(), diags
	}

	prefixLimitReceived2Val, ok := prefixLimitReceived2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_2 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived2Attribute))
	}

	if diags.HasError() {
		return NewPrefixLimit2ValueUnknown(), diags
	}

	return PrefixLimit2Value{
		PrefixLimitAccepted2: prefixLimitAccepted2Val,
		PrefixLimitReceived2: prefixLimitReceived2Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimit2Value {
	object, diags := NewPrefixLimit2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimit2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimit2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimit2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimit2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimit2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimit2ValueMust(PrefixLimit2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimit2Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimit2Value{}
}

var _ basetypes.ObjectValuable = PrefixLimit2Value{}

type PrefixLimit2Value struct {
	PrefixLimitAccepted2 basetypes.ObjectValue `tfsdk:"prefix_limit_accepted"`
	PrefixLimitReceived2 basetypes.ObjectValue `tfsdk:"prefix_limit_received"`
	state                attr.ValueState
}

func (v PrefixLimit2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["prefix_limit_accepted"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["prefix_limit_received"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitReceived2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PrefixLimitAccepted2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_accepted"] = val

		val, err = v.PrefixLimitReceived2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_received"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimit2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimit2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimit2Value) String() string {
	return "PrefixLimit2Value"
}

func (v PrefixLimit2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimitAccepted2 basetypes.ObjectValue

	if v.PrefixLimitAccepted2.IsNull() {
		prefixLimitAccepted2 = types.ObjectNull(
			PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitAccepted2.IsUnknown() {
		prefixLimitAccepted2 = types.ObjectUnknown(
			PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitAccepted2.IsNull() && !v.PrefixLimitAccepted2.IsUnknown() {
		prefixLimitAccepted2 = types.ObjectValueMust(
			PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
			v.PrefixLimitAccepted2.Attributes(),
		)
	}

	var prefixLimitReceived2 basetypes.ObjectValue

	if v.PrefixLimitReceived2.IsNull() {
		prefixLimitReceived2 = types.ObjectNull(
			PrefixLimitReceived2Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitReceived2.IsUnknown() {
		prefixLimitReceived2 = types.ObjectUnknown(
			PrefixLimitReceived2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitReceived2.IsNull() && !v.PrefixLimitReceived2.IsUnknown() {
		prefixLimitReceived2 = types.ObjectValueMust(
			PrefixLimitReceived2Value{}.AttributeTypes(ctx),
			v.PrefixLimitReceived2.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived2Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"prefix_limit_accepted": prefixLimitAccepted2,
			"prefix_limit_received": prefixLimitReceived2,
		})

	return objVal, diags
}

func (v PrefixLimit2Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimit2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PrefixLimitAccepted2.Equal(other.PrefixLimitAccepted2) {
		return false
	}

	if !v.PrefixLimitReceived2.Equal(other.PrefixLimitReceived2) {
		return false
	}

	return true
}

func (v PrefixLimit2Value) Type(ctx context.Context) attr.Type {
	return PrefixLimit2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimit2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted2Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived2Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitAccepted2Type{}

type PrefixLimitAccepted2Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitAccepted2Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitAccepted2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitAccepted2Type) String() string {
	return "PrefixLimitAccepted2Type"
}

func (t PrefixLimitAccepted2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitAccepted2Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted2ValueNull() PrefixLimitAccepted2Value {
	return PrefixLimitAccepted2Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitAccepted2ValueUnknown() PrefixLimitAccepted2Value {
	return PrefixLimitAccepted2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitAccepted2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitAccepted2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitAccepted2Value Attribute Value",
				"While creating a PrefixLimitAccepted2Value value, a missing attribute value was detected. "+
					"A PrefixLimitAccepted2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitAccepted2Value Attribute Type",
				"While creating a PrefixLimitAccepted2Value value, an invalid attribute value was detected. "+
					"A PrefixLimitAccepted2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitAccepted2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitAccepted2Value Attribute Value",
				"While creating a PrefixLimitAccepted2Value value, an extra attribute value was detected. "+
					"A PrefixLimitAccepted2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitAccepted2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted2ValueUnknown(), diags
	}

	return PrefixLimitAccepted2Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitAccepted2Value {
	object, diags := NewPrefixLimitAccepted2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitAccepted2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitAccepted2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitAccepted2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitAccepted2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitAccepted2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitAccepted2ValueMust(PrefixLimitAccepted2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitAccepted2Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitAccepted2Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitAccepted2Value{}

type PrefixLimitAccepted2Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitAccepted2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitAccepted2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitAccepted2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitAccepted2Value) String() string {
	return "PrefixLimitAccepted2Value"
}

func (v PrefixLimitAccepted2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitAccepted2Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitAccepted2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitAccepted2Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitAccepted2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitAccepted2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitReceived2Type{}

type PrefixLimitReceived2Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitReceived2Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitReceived2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitReceived2Type) String() string {
	return "PrefixLimitReceived2Type"
}

func (t PrefixLimitReceived2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitReceived2Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived2ValueNull() PrefixLimitReceived2Value {
	return PrefixLimitReceived2Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitReceived2ValueUnknown() PrefixLimitReceived2Value {
	return PrefixLimitReceived2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitReceived2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitReceived2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitReceived2Value Attribute Value",
				"While creating a PrefixLimitReceived2Value value, a missing attribute value was detected. "+
					"A PrefixLimitReceived2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitReceived2Value Attribute Type",
				"While creating a PrefixLimitReceived2Value value, an invalid attribute value was detected. "+
					"A PrefixLimitReceived2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitReceived2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitReceived2Value Attribute Value",
				"While creating a PrefixLimitReceived2Value value, an extra attribute value was detected. "+
					"A PrefixLimitReceived2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitReceived2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitReceived2ValueUnknown(), diags
	}

	return PrefixLimitReceived2Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitReceived2Value {
	object, diags := NewPrefixLimitReceived2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitReceived2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitReceived2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitReceived2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitReceived2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitReceived2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitReceived2ValueMust(PrefixLimitReceived2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitReceived2Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitReceived2Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitReceived2Value{}

type PrefixLimitReceived2Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitReceived2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitReceived2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitReceived2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitReceived2Value) String() string {
	return "PrefixLimitReceived2Value"
}

func (v PrefixLimitReceived2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitReceived2Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitReceived2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitReceived2Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitReceived2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitReceived2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Ipv6Unicast1Type{}

type Ipv6Unicast1Type struct {
	basetypes.ObjectType
}

func (t Ipv6Unicast1Type) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6Unicast1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6Unicast1Type) String() string {
	return "Ipv6Unicast1Type"
}

func (t Ipv6Unicast1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit3Attribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_3 is missing from object`)

		return nil, diags
	}

	prefixLimit3Val, ok := prefixLimit3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_3 expected to be basetypes.ObjectValue, was: %T`, prefixLimit3Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6Unicast1Value{
		Enabled:      enabledVal,
		PrefixLimit3: prefixLimit3Val,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpv6Unicast1ValueNull() Ipv6Unicast1Value {
	return Ipv6Unicast1Value{
		state: attr.ValueStateNull,
	}
}

func NewIpv6Unicast1ValueUnknown() Ipv6Unicast1Value {
	return Ipv6Unicast1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6Unicast1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6Unicast1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6Unicast1Value Attribute Value",
				"While creating a Ipv6Unicast1Value value, a missing attribute value was detected. "+
					"A Ipv6Unicast1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6Unicast1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6Unicast1Value Attribute Type",
				"While creating a Ipv6Unicast1Value value, an invalid attribute value was detected. "+
					"A Ipv6Unicast1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6Unicast1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6Unicast1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6Unicast1Value Attribute Value",
				"While creating a Ipv6Unicast1Value value, an extra attribute value was detected. "+
					"A Ipv6Unicast1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6Unicast1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6Unicast1ValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv6Unicast1ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	prefixLimit3Attribute, ok := attributes["prefix_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_3 is missing from object`)

		return NewIpv6Unicast1ValueUnknown(), diags
	}

	prefixLimit3Val, ok := prefixLimit3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_3 expected to be basetypes.ObjectValue, was: %T`, prefixLimit3Attribute))
	}

	if diags.HasError() {
		return NewIpv6Unicast1ValueUnknown(), diags
	}

	return Ipv6Unicast1Value{
		Enabled:      enabledVal,
		PrefixLimit3: prefixLimit3Val,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewIpv6Unicast1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6Unicast1Value {
	object, diags := NewIpv6Unicast1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6Unicast1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6Unicast1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6Unicast1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6Unicast1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6Unicast1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6Unicast1ValueMust(Ipv6Unicast1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6Unicast1Type) ValueType(ctx context.Context) attr.Value {
	return Ipv6Unicast1Value{}
}

var _ basetypes.ObjectValuable = Ipv6Unicast1Value{}

type Ipv6Unicast1Value struct {
	Enabled      basetypes.BoolValue   `tfsdk:"enabled"`
	PrefixLimit3 basetypes.ObjectValue `tfsdk:"prefix_limit"`
	state        attr.ValueState
}

func (v Ipv6Unicast1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix_limit"] = basetypes.ObjectType{
		AttrTypes: PrefixLimit3Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.PrefixLimit3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6Unicast1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6Unicast1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6Unicast1Value) String() string {
	return "Ipv6Unicast1Value"
}

func (v Ipv6Unicast1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimit3 basetypes.ObjectValue

	if v.PrefixLimit3.IsNull() {
		prefixLimit3 = types.ObjectNull(
			PrefixLimit3Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimit3.IsUnknown() {
		prefixLimit3 = types.ObjectUnknown(
			PrefixLimit3Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimit3.IsNull() && !v.PrefixLimit3.IsUnknown() {
		prefixLimit3 = types.ObjectValueMust(
			PrefixLimit3Value{}.AttributeTypes(ctx),
			v.PrefixLimit3.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimit3Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":      v.Enabled,
			"prefix_limit": prefixLimit3,
		})

	return objVal, diags
}

func (v Ipv6Unicast1Value) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6Unicast1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.PrefixLimit3.Equal(other.PrefixLimit3) {
		return false
	}

	return true
}

func (v Ipv6Unicast1Value) Type(ctx context.Context) attr.Type {
	return Ipv6Unicast1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6Unicast1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"prefix_limit": basetypes.ObjectType{
			AttrTypes: PrefixLimit3Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimit3Type{}

type PrefixLimit3Type struct {
	basetypes.ObjectType
}

func (t PrefixLimit3Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimit3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimit3Type) String() string {
	return "PrefixLimit3Type"
}

func (t PrefixLimit3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	prefixLimitAccepted3Attribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_3 is missing from object`)

		return nil, diags
	}

	prefixLimitAccepted3Val, ok := prefixLimitAccepted3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_3 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted3Attribute))
	}

	prefixLimitReceived3Attribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_3 is missing from object`)

		return nil, diags
	}

	prefixLimitReceived3Val, ok := prefixLimitReceived3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_3 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived3Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimit3Value{
		PrefixLimitAccepted3: prefixLimitAccepted3Val,
		PrefixLimitReceived3: prefixLimitReceived3Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit3ValueNull() PrefixLimit3Value {
	return PrefixLimit3Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimit3ValueUnknown() PrefixLimit3Value {
	return PrefixLimit3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimit3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimit3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimit3Value Attribute Value",
				"While creating a PrefixLimit3Value value, a missing attribute value was detected. "+
					"A PrefixLimit3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimit3Value Attribute Type",
				"While creating a PrefixLimit3Value value, an invalid attribute value was detected. "+
					"A PrefixLimit3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimit3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimit3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimit3Value Attribute Value",
				"While creating a PrefixLimit3Value value, an extra attribute value was detected. "+
					"A PrefixLimit3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimit3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimit3ValueUnknown(), diags
	}

	prefixLimitAccepted3Attribute, ok := attributes["prefix_limit_accepted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_accepted_3 is missing from object`)

		return NewPrefixLimit3ValueUnknown(), diags
	}

	prefixLimitAccepted3Val, ok := prefixLimitAccepted3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_accepted_3 expected to be basetypes.ObjectValue, was: %T`, prefixLimitAccepted3Attribute))
	}

	prefixLimitReceived3Attribute, ok := attributes["prefix_limit_received"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_limit_received_3 is missing from object`)

		return NewPrefixLimit3ValueUnknown(), diags
	}

	prefixLimitReceived3Val, ok := prefixLimitReceived3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_limit_received_3 expected to be basetypes.ObjectValue, was: %T`, prefixLimitReceived3Attribute))
	}

	if diags.HasError() {
		return NewPrefixLimit3ValueUnknown(), diags
	}

	return PrefixLimit3Value{
		PrefixLimitAccepted3: prefixLimitAccepted3Val,
		PrefixLimitReceived3: prefixLimitReceived3Val,
		state:                attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimit3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimit3Value {
	object, diags := NewPrefixLimit3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimit3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimit3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimit3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimit3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimit3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimit3ValueMust(PrefixLimit3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimit3Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimit3Value{}
}

var _ basetypes.ObjectValuable = PrefixLimit3Value{}

type PrefixLimit3Value struct {
	PrefixLimitAccepted3 basetypes.ObjectValue `tfsdk:"prefix_limit_accepted"`
	PrefixLimitReceived3 basetypes.ObjectValue `tfsdk:"prefix_limit_received"`
	state                attr.ValueState
}

func (v PrefixLimit3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["prefix_limit_accepted"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitAccepted3Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["prefix_limit_received"] = basetypes.ObjectType{
		AttrTypes: PrefixLimitReceived3Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.PrefixLimitAccepted3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_accepted"] = val

		val, err = v.PrefixLimitReceived3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_limit_received"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimit3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimit3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimit3Value) String() string {
	return "PrefixLimit3Value"
}

func (v PrefixLimit3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var prefixLimitAccepted3 basetypes.ObjectValue

	if v.PrefixLimitAccepted3.IsNull() {
		prefixLimitAccepted3 = types.ObjectNull(
			PrefixLimitAccepted3Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitAccepted3.IsUnknown() {
		prefixLimitAccepted3 = types.ObjectUnknown(
			PrefixLimitAccepted3Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitAccepted3.IsNull() && !v.PrefixLimitAccepted3.IsUnknown() {
		prefixLimitAccepted3 = types.ObjectValueMust(
			PrefixLimitAccepted3Value{}.AttributeTypes(ctx),
			v.PrefixLimitAccepted3.Attributes(),
		)
	}

	var prefixLimitReceived3 basetypes.ObjectValue

	if v.PrefixLimitReceived3.IsNull() {
		prefixLimitReceived3 = types.ObjectNull(
			PrefixLimitReceived3Value{}.AttributeTypes(ctx),
		)
	}

	if v.PrefixLimitReceived3.IsUnknown() {
		prefixLimitReceived3 = types.ObjectUnknown(
			PrefixLimitReceived3Value{}.AttributeTypes(ctx),
		)
	}

	if !v.PrefixLimitReceived3.IsNull() && !v.PrefixLimitReceived3.IsUnknown() {
		prefixLimitReceived3 = types.ObjectValueMust(
			PrefixLimitReceived3Value{}.AttributeTypes(ctx),
			v.PrefixLimitReceived3.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted3Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived3Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"prefix_limit_accepted": prefixLimitAccepted3,
			"prefix_limit_received": prefixLimitReceived3,
		})

	return objVal, diags
}

func (v PrefixLimit3Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimit3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.PrefixLimitAccepted3.Equal(other.PrefixLimitAccepted3) {
		return false
	}

	if !v.PrefixLimitReceived3.Equal(other.PrefixLimitReceived3) {
		return false
	}

	return true
}

func (v PrefixLimit3Value) Type(ctx context.Context) attr.Type {
	return PrefixLimit3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimit3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"prefix_limit_accepted": basetypes.ObjectType{
			AttrTypes: PrefixLimitAccepted3Value{}.AttributeTypes(ctx),
		},
		"prefix_limit_received": basetypes.ObjectType{
			AttrTypes: PrefixLimitReceived3Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitAccepted3Type{}

type PrefixLimitAccepted3Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitAccepted3Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitAccepted3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitAccepted3Type) String() string {
	return "PrefixLimitAccepted3Type"
}

func (t PrefixLimitAccepted3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitAccepted3Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted3ValueNull() PrefixLimitAccepted3Value {
	return PrefixLimitAccepted3Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitAccepted3ValueUnknown() PrefixLimitAccepted3Value {
	return PrefixLimitAccepted3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitAccepted3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitAccepted3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitAccepted3Value Attribute Value",
				"While creating a PrefixLimitAccepted3Value value, a missing attribute value was detected. "+
					"A PrefixLimitAccepted3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitAccepted3Value Attribute Type",
				"While creating a PrefixLimitAccepted3Value value, an invalid attribute value was detected. "+
					"A PrefixLimitAccepted3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitAccepted3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitAccepted3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitAccepted3Value Attribute Value",
				"While creating a PrefixLimitAccepted3Value value, an extra attribute value was detected. "+
					"A PrefixLimitAccepted3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitAccepted3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted3ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitAccepted3ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitAccepted3ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitAccepted3ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitAccepted3ValueUnknown(), diags
	}

	return PrefixLimitAccepted3Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitAccepted3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitAccepted3Value {
	object, diags := NewPrefixLimitAccepted3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitAccepted3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitAccepted3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitAccepted3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitAccepted3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitAccepted3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitAccepted3ValueMust(PrefixLimitAccepted3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitAccepted3Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitAccepted3Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitAccepted3Value{}

type PrefixLimitAccepted3Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitAccepted3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitAccepted3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitAccepted3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitAccepted3Value) String() string {
	return "PrefixLimitAccepted3Value"
}

func (v PrefixLimitAccepted3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitAccepted3Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitAccepted3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitAccepted3Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitAccepted3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitAccepted3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrefixLimitReceived3Type{}

type PrefixLimitReceived3Type struct {
	basetypes.ObjectType
}

func (t PrefixLimitReceived3Type) Equal(o attr.Type) bool {
	other, ok := o.(PrefixLimitReceived3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixLimitReceived3Type) String() string {
	return "PrefixLimitReceived3Type"
}

func (t PrefixLimitReceived3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return nil, diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return nil, diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return nil, diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixLimitReceived3Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived3ValueNull() PrefixLimitReceived3Value {
	return PrefixLimitReceived3Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixLimitReceived3ValueUnknown() PrefixLimitReceived3Value {
	return PrefixLimitReceived3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixLimitReceived3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixLimitReceived3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixLimitReceived3Value Attribute Value",
				"While creating a PrefixLimitReceived3Value value, a missing attribute value was detected. "+
					"A PrefixLimitReceived3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixLimitReceived3Value Attribute Type",
				"While creating a PrefixLimitReceived3Value value, an invalid attribute value was detected. "+
					"A PrefixLimitReceived3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixLimitReceived3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixLimitReceived3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixLimitReceived3Value Attribute Value",
				"While creating a PrefixLimitReceived3Value value, an extra attribute value was detected. "+
					"A PrefixLimitReceived3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixLimitReceived3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixLimitReceived3ValueUnknown(), diags
	}

	logOnlyAttribute, ok := attributes["log_only"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`log_only is missing from object`)

		return NewPrefixLimitReceived3ValueUnknown(), diags
	}

	logOnlyVal, ok := logOnlyAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`log_only expected to be basetypes.BoolValue, was: %T`, logOnlyAttribute))
	}

	maxReceivedRoutesAttribute, ok := attributes["max_received_routes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_received_routes is missing from object`)

		return NewPrefixLimitReceived3ValueUnknown(), diags
	}

	maxReceivedRoutesVal, ok := maxReceivedRoutesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_received_routes expected to be basetypes.Int64Value, was: %T`, maxReceivedRoutesAttribute))
	}

	warningThresholdAttribute, ok := attributes["warning_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`warning_threshold is missing from object`)

		return NewPrefixLimitReceived3ValueUnknown(), diags
	}

	warningThresholdVal, ok := warningThresholdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`warning_threshold expected to be basetypes.Int64Value, was: %T`, warningThresholdAttribute))
	}

	if diags.HasError() {
		return NewPrefixLimitReceived3ValueUnknown(), diags
	}

	return PrefixLimitReceived3Value{
		LogOnly:           logOnlyVal,
		MaxReceivedRoutes: maxReceivedRoutesVal,
		WarningThreshold:  warningThresholdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixLimitReceived3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixLimitReceived3Value {
	object, diags := NewPrefixLimitReceived3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixLimitReceived3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixLimitReceived3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixLimitReceived3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixLimitReceived3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixLimitReceived3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixLimitReceived3ValueMust(PrefixLimitReceived3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixLimitReceived3Type) ValueType(ctx context.Context) attr.Value {
	return PrefixLimitReceived3Value{}
}

var _ basetypes.ObjectValuable = PrefixLimitReceived3Value{}

type PrefixLimitReceived3Value struct {
	LogOnly           basetypes.BoolValue  `tfsdk:"log_only"`
	MaxReceivedRoutes basetypes.Int64Value `tfsdk:"max_received_routes"`
	WarningThreshold  basetypes.Int64Value `tfsdk:"warning_threshold"`
	state             attr.ValueState
}

func (v PrefixLimitReceived3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["log_only"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_received_routes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["warning_threshold"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.LogOnly.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["log_only"] = val

		val, err = v.MaxReceivedRoutes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_received_routes"] = val

		val, err = v.WarningThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["warning_threshold"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixLimitReceived3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixLimitReceived3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixLimitReceived3Value) String() string {
	return "PrefixLimitReceived3Value"
}

func (v PrefixLimitReceived3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"log_only":            v.LogOnly,
			"max_received_routes": v.MaxReceivedRoutes,
			"warning_threshold":   v.WarningThreshold,
		})

	return objVal, diags
}

func (v PrefixLimitReceived3Value) Equal(o attr.Value) bool {
	other, ok := o.(PrefixLimitReceived3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LogOnly.Equal(other.LogOnly) {
		return false
	}

	if !v.MaxReceivedRoutes.Equal(other.MaxReceivedRoutes) {
		return false
	}

	if !v.WarningThreshold.Equal(other.WarningThreshold) {
		return false
	}

	return true
}

func (v PrefixLimitReceived3Value) Type(ctx context.Context) attr.Type {
	return PrefixLimitReceived3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixLimitReceived3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"log_only":            basetypes.BoolType{},
		"max_received_routes": basetypes.Int64Type{},
		"warning_threshold":   basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = LocalAs1Type{}

type LocalAs1Type struct {
	basetypes.ObjectType
}

func (t LocalAs1Type) Equal(o attr.Type) bool {
	other, ok := o.(LocalAs1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LocalAs1Type) String() string {
	return "LocalAs1Type"
}

func (t LocalAs1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return nil, diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	prependGlobalAsAttribute, ok := attributes["prepend_global_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_global_as is missing from object`)

		return nil, diags
	}

	prependGlobalAsVal, ok := prependGlobalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_global_as expected to be basetypes.BoolValue, was: %T`, prependGlobalAsAttribute))
	}

	prependLocalAsAttribute, ok := attributes["prepend_local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_local_as is missing from object`)

		return nil, diags
	}

	prependLocalAsVal, ok := prependLocalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_local_as expected to be basetypes.BoolValue, was: %T`, prependLocalAsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LocalAs1Value{
		AutonomousSystem: autonomousSystemVal,
		PrependGlobalAs:  prependGlobalAsVal,
		PrependLocalAs:   prependLocalAsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLocalAs1ValueNull() LocalAs1Value {
	return LocalAs1Value{
		state: attr.ValueStateNull,
	}
}

func NewLocalAs1ValueUnknown() LocalAs1Value {
	return LocalAs1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewLocalAs1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LocalAs1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LocalAs1Value Attribute Value",
				"While creating a LocalAs1Value value, a missing attribute value was detected. "+
					"A LocalAs1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAs1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LocalAs1Value Attribute Type",
				"While creating a LocalAs1Value value, an invalid attribute value was detected. "+
					"A LocalAs1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LocalAs1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LocalAs1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LocalAs1Value Attribute Value",
				"While creating a LocalAs1Value value, an extra attribute value was detected. "+
					"A LocalAs1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LocalAs1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLocalAs1ValueUnknown(), diags
	}

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return NewLocalAs1ValueUnknown(), diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	prependGlobalAsAttribute, ok := attributes["prepend_global_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_global_as is missing from object`)

		return NewLocalAs1ValueUnknown(), diags
	}

	prependGlobalAsVal, ok := prependGlobalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_global_as expected to be basetypes.BoolValue, was: %T`, prependGlobalAsAttribute))
	}

	prependLocalAsAttribute, ok := attributes["prepend_local_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prepend_local_as is missing from object`)

		return NewLocalAs1ValueUnknown(), diags
	}

	prependLocalAsVal, ok := prependLocalAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prepend_local_as expected to be basetypes.BoolValue, was: %T`, prependLocalAsAttribute))
	}

	if diags.HasError() {
		return NewLocalAs1ValueUnknown(), diags
	}

	return LocalAs1Value{
		AutonomousSystem: autonomousSystemVal,
		PrependGlobalAs:  prependGlobalAsVal,
		PrependLocalAs:   prependLocalAsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewLocalAs1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LocalAs1Value {
	object, diags := NewLocalAs1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLocalAs1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LocalAs1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLocalAs1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLocalAs1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLocalAs1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLocalAs1ValueMust(LocalAs1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t LocalAs1Type) ValueType(ctx context.Context) attr.Value {
	return LocalAs1Value{}
}

var _ basetypes.ObjectValuable = LocalAs1Value{}

type LocalAs1Value struct {
	AutonomousSystem basetypes.Int64Value `tfsdk:"autonomous_system"`
	PrependGlobalAs  basetypes.BoolValue  `tfsdk:"prepend_global_as"`
	PrependLocalAs   basetypes.BoolValue  `tfsdk:"prepend_local_as"`
	state            attr.ValueState
}

func (v LocalAs1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prepend_global_as"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prepend_local_as"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_system"] = val

		val, err = v.PrependGlobalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prepend_global_as"] = val

		val, err = v.PrependLocalAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prepend_local_as"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LocalAs1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LocalAs1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LocalAs1Value) String() string {
	return "LocalAs1Value"
}

func (v LocalAs1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"prepend_global_as": basetypes.BoolType{},
		"prepend_local_as":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_system": v.AutonomousSystem,
			"prepend_global_as": v.PrependGlobalAs,
			"prepend_local_as":  v.PrependLocalAs,
		})

	return objVal, diags
}

func (v LocalAs1Value) Equal(o attr.Value) bool {
	other, ok := o.(LocalAs1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousSystem.Equal(other.AutonomousSystem) {
		return false
	}

	if !v.PrependGlobalAs.Equal(other.PrependGlobalAs) {
		return false
	}

	if !v.PrependLocalAs.Equal(other.PrependLocalAs) {
		return false
	}

	return true
}

func (v LocalAs1Value) Type(ctx context.Context) attr.Type {
	return LocalAs1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LocalAs1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"prepend_global_as": basetypes.BoolType{},
		"prepend_local_as":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PeerAs1Type{}

type PeerAs1Type struct {
	basetypes.ObjectType
}

func (t PeerAs1Type) Equal(o attr.Type) bool {
	other, ok := o.(PeerAs1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PeerAs1Type) String() string {
	return "PeerAs1Type"
}

func (t PeerAs1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return nil, diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PeerAs1Value{
		AutonomousSystem: autonomousSystemVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPeerAs1ValueNull() PeerAs1Value {
	return PeerAs1Value{
		state: attr.ValueStateNull,
	}
}

func NewPeerAs1ValueUnknown() PeerAs1Value {
	return PeerAs1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPeerAs1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PeerAs1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PeerAs1Value Attribute Value",
				"While creating a PeerAs1Value value, a missing attribute value was detected. "+
					"A PeerAs1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PeerAs1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PeerAs1Value Attribute Type",
				"While creating a PeerAs1Value value, an invalid attribute value was detected. "+
					"A PeerAs1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PeerAs1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PeerAs1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PeerAs1Value Attribute Value",
				"While creating a PeerAs1Value value, an extra attribute value was detected. "+
					"A PeerAs1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PeerAs1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPeerAs1ValueUnknown(), diags
	}

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return NewPeerAs1ValueUnknown(), diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	if diags.HasError() {
		return NewPeerAs1ValueUnknown(), diags
	}

	return PeerAs1Value{
		AutonomousSystem: autonomousSystemVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewPeerAs1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PeerAs1Value {
	object, diags := NewPeerAs1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPeerAs1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PeerAs1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPeerAs1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPeerAs1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPeerAs1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPeerAs1ValueMust(PeerAs1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t PeerAs1Type) ValueType(ctx context.Context) attr.Value {
	return PeerAs1Value{}
}

var _ basetypes.ObjectValuable = PeerAs1Value{}

type PeerAs1Value struct {
	AutonomousSystem basetypes.Int64Value `tfsdk:"autonomous_system"`
	state            attr.ValueState
}

func (v PeerAs1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.AutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_system"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PeerAs1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PeerAs1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PeerAs1Value) String() string {
	return "PeerAs1Value"
}

func (v PeerAs1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_system": v.AutonomousSystem,
		})

	return objVal, diags
}

func (v PeerAs1Value) Equal(o attr.Value) bool {
	other, ok := o.(PeerAs1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousSystem.Equal(other.AutonomousSystem) {
		return false
	}

	return true
}

func (v PeerAs1Value) Type(ctx context.Context) attr.Type {
	return PeerAs1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PeerAs1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SendDefaultRoute1Type{}

type SendDefaultRoute1Type struct {
	basetypes.ObjectType
}

func (t SendDefaultRoute1Type) Equal(o attr.Type) bool {
	other, ok := o.(SendDefaultRoute1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SendDefaultRoute1Type) String() string {
	return "SendDefaultRoute1Type"
}

func (t SendDefaultRoute1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return nil, diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.ListValue, was: %T`, addressFamilyAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SendDefaultRoute1Value{
		AddressFamily: addressFamilyVal,
		ExportPolicy:  exportPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSendDefaultRoute1ValueNull() SendDefaultRoute1Value {
	return SendDefaultRoute1Value{
		state: attr.ValueStateNull,
	}
}

func NewSendDefaultRoute1ValueUnknown() SendDefaultRoute1Value {
	return SendDefaultRoute1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSendDefaultRoute1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SendDefaultRoute1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SendDefaultRoute1Value Attribute Value",
				"While creating a SendDefaultRoute1Value value, a missing attribute value was detected. "+
					"A SendDefaultRoute1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SendDefaultRoute1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SendDefaultRoute1Value Attribute Type",
				"While creating a SendDefaultRoute1Value value, an invalid attribute value was detected. "+
					"A SendDefaultRoute1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SendDefaultRoute1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SendDefaultRoute1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SendDefaultRoute1Value Attribute Value",
				"While creating a SendDefaultRoute1Value value, an extra attribute value was detected. "+
					"A SendDefaultRoute1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SendDefaultRoute1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSendDefaultRoute1ValueUnknown(), diags
	}

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return NewSendDefaultRoute1ValueUnknown(), diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.ListValue, was: %T`, addressFamilyAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewSendDefaultRoute1ValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	if diags.HasError() {
		return NewSendDefaultRoute1ValueUnknown(), diags
	}

	return SendDefaultRoute1Value{
		AddressFamily: addressFamilyVal,
		ExportPolicy:  exportPolicyVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSendDefaultRoute1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SendDefaultRoute1Value {
	object, diags := NewSendDefaultRoute1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSendDefaultRoute1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SendDefaultRoute1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSendDefaultRoute1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSendDefaultRoute1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSendDefaultRoute1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSendDefaultRoute1ValueMust(SendDefaultRoute1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t SendDefaultRoute1Type) ValueType(ctx context.Context) attr.Value {
	return SendDefaultRoute1Value{}
}

var _ basetypes.ObjectValuable = SendDefaultRoute1Value{}

type SendDefaultRoute1Value struct {
	AddressFamily basetypes.ListValue   `tfsdk:"address_family"`
	ExportPolicy  basetypes.StringValue `tfsdk:"export_policy"`
	state         attr.ValueState
}

func (v SendDefaultRoute1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["address_family"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AddressFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_family"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SendDefaultRoute1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SendDefaultRoute1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SendDefaultRoute1Value) String() string {
	return "SendDefaultRoute1Value"
}

func (v SendDefaultRoute1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var addressFamilyVal basetypes.ListValue
	switch {
	case v.AddressFamily.IsUnknown():
		addressFamilyVal = types.ListUnknown(types.StringType)
	case v.AddressFamily.IsNull():
		addressFamilyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		addressFamilyVal, d = types.ListValue(types.StringType, v.AddressFamily.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"address_family": basetypes.ListType{
				ElemType: types.StringType,
			},
			"export_policy": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"address_family": basetypes.ListType{
			ElemType: types.StringType,
		},
		"export_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address_family": addressFamilyVal,
			"export_policy":  v.ExportPolicy,
		})

	return objVal, diags
}

func (v SendDefaultRoute1Value) Equal(o attr.Value) bool {
	other, ok := o.(SendDefaultRoute1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddressFamily.Equal(other.AddressFamily) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	return true
}

func (v SendDefaultRoute1Value) Type(ctx context.Context) attr.Type {
	return SendDefaultRoute1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SendDefaultRoute1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address_family": basetypes.ListType{
			ElemType: types.StringType,
		},
		"export_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Timers1Type{}

type Timers1Type struct {
	basetypes.ObjectType
}

func (t Timers1Type) Equal(o attr.Type) bool {
	other, ok := o.(Timers1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Timers1Type) String() string {
	return "Timers1Type"
}

func (t Timers1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	connectRetryAttribute, ok := attributes["connect_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_retry is missing from object`)

		return nil, diags
	}

	connectRetryVal, ok := connectRetryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_retry expected to be basetypes.Int64Value, was: %T`, connectRetryAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return nil, diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	keepAliveAttribute, ok := attributes["keep_alive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_alive is missing from object`)

		return nil, diags
	}

	keepAliveVal, ok := keepAliveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_alive expected to be basetypes.Int64Value, was: %T`, keepAliveAttribute))
	}

	minimumAdvertisementIntervalAttribute, ok := attributes["minimum_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_advertisement_interval is missing from object`)

		return nil, diags
	}

	minimumAdvertisementIntervalVal, ok := minimumAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minimumAdvertisementIntervalAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Timers1Value{
		ConnectRetry:                 connectRetryVal,
		HoldTime:                     holdTimeVal,
		KeepAlive:                    keepAliveVal,
		MinimumAdvertisementInterval: minimumAdvertisementIntervalVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewTimers1ValueNull() Timers1Value {
	return Timers1Value{
		state: attr.ValueStateNull,
	}
}

func NewTimers1ValueUnknown() Timers1Value {
	return Timers1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewTimers1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Timers1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Timers1Value Attribute Value",
				"While creating a Timers1Value value, a missing attribute value was detected. "+
					"A Timers1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Timers1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Timers1Value Attribute Type",
				"While creating a Timers1Value value, an invalid attribute value was detected. "+
					"A Timers1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Timers1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Timers1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Timers1Value Attribute Value",
				"While creating a Timers1Value value, an extra attribute value was detected. "+
					"A Timers1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Timers1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTimers1ValueUnknown(), diags
	}

	connectRetryAttribute, ok := attributes["connect_retry"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`connect_retry is missing from object`)

		return NewTimers1ValueUnknown(), diags
	}

	connectRetryVal, ok := connectRetryAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`connect_retry expected to be basetypes.Int64Value, was: %T`, connectRetryAttribute))
	}

	holdTimeAttribute, ok := attributes["hold_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_time is missing from object`)

		return NewTimers1ValueUnknown(), diags
	}

	holdTimeVal, ok := holdTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_time expected to be basetypes.Int64Value, was: %T`, holdTimeAttribute))
	}

	keepAliveAttribute, ok := attributes["keep_alive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keep_alive is missing from object`)

		return NewTimers1ValueUnknown(), diags
	}

	keepAliveVal, ok := keepAliveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keep_alive expected to be basetypes.Int64Value, was: %T`, keepAliveAttribute))
	}

	minimumAdvertisementIntervalAttribute, ok := attributes["minimum_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`minimum_advertisement_interval is missing from object`)

		return NewTimers1ValueUnknown(), diags
	}

	minimumAdvertisementIntervalVal, ok := minimumAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`minimum_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minimumAdvertisementIntervalAttribute))
	}

	if diags.HasError() {
		return NewTimers1ValueUnknown(), diags
	}

	return Timers1Value{
		ConnectRetry:                 connectRetryVal,
		HoldTime:                     holdTimeVal,
		KeepAlive:                    keepAliveVal,
		MinimumAdvertisementInterval: minimumAdvertisementIntervalVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewTimers1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Timers1Value {
	object, diags := NewTimers1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTimers1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Timers1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTimers1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTimers1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTimers1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTimers1ValueMust(Timers1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Timers1Type) ValueType(ctx context.Context) attr.Value {
	return Timers1Value{}
}

var _ basetypes.ObjectValuable = Timers1Value{}

type Timers1Value struct {
	ConnectRetry                 basetypes.Int64Value `tfsdk:"connect_retry"`
	HoldTime                     basetypes.Int64Value `tfsdk:"hold_time"`
	KeepAlive                    basetypes.Int64Value `tfsdk:"keep_alive"`
	MinimumAdvertisementInterval basetypes.Int64Value `tfsdk:"minimum_advertisement_interval"`
	state                        attr.ValueState
}

func (v Timers1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["connect_retry"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["hold_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["keep_alive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["minimum_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ConnectRetry.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["connect_retry"] = val

		val, err = v.HoldTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_time"] = val

		val, err = v.KeepAlive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keep_alive"] = val

		val, err = v.MinimumAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["minimum_advertisement_interval"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Timers1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Timers1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Timers1Value) String() string {
	return "Timers1Value"
}

func (v Timers1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"connect_retry":                  basetypes.Int64Type{},
		"hold_time":                      basetypes.Int64Type{},
		"keep_alive":                     basetypes.Int64Type{},
		"minimum_advertisement_interval": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"connect_retry":                  v.ConnectRetry,
			"hold_time":                      v.HoldTime,
			"keep_alive":                     v.KeepAlive,
			"minimum_advertisement_interval": v.MinimumAdvertisementInterval,
		})

	return objVal, diags
}

func (v Timers1Value) Equal(o attr.Value) bool {
	other, ok := o.(Timers1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConnectRetry.Equal(other.ConnectRetry) {
		return false
	}

	if !v.HoldTime.Equal(other.HoldTime) {
		return false
	}

	if !v.KeepAlive.Equal(other.KeepAlive) {
		return false
	}

	if !v.MinimumAdvertisementInterval.Equal(other.MinimumAdvertisementInterval) {
		return false
	}

	return true
}

func (v Timers1Value) Type(ctx context.Context) attr.Type {
	return Timers1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Timers1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"connect_retry":                  basetypes.Int64Type{},
		"hold_time":                      basetypes.Int64Type{},
		"keep_alive":                     basetypes.Int64Type{},
		"minimum_advertisement_interval": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = OspfType{}

type OspfType struct {
	basetypes.ObjectType
}

func (t OspfType) Equal(o attr.Type) bool {
	other, ok := o.(OspfType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OspfType) String() string {
	return "OspfType"
}

func (t OspfType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	ospfAreasAttribute, ok := attributes["ospf_areas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf_areas is missing from object`)

		return nil, diags
	}

	ospfAreasVal, ok := ospfAreasAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf_areas expected to be basetypes.ListValue, was: %T`, ospfAreasAttribute))
	}

	ospfInterfacesAttribute, ok := attributes["ospf_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf_interfaces is missing from object`)

		return nil, diags
	}

	ospfInterfacesVal, ok := ospfInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf_interfaces expected to be basetypes.ListValue, was: %T`, ospfInterfacesAttribute))
	}

	spec8Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_8 is missing from object`)

		return nil, diags
	}

	spec8Val, ok := spec8Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_8 expected to be basetypes.ObjectValue, was: %T`, spec8Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OspfValue{
		Name:           nameVal,
		OspfAreas:      ospfAreasVal,
		OspfInterfaces: ospfInterfacesVal,
		Spec8:          spec8Val,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOspfValueNull() OspfValue {
	return OspfValue{
		state: attr.ValueStateNull,
	}
}

func NewOspfValueUnknown() OspfValue {
	return OspfValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOspfValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OspfValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OspfValue Attribute Value",
				"While creating a OspfValue value, a missing attribute value was detected. "+
					"A OspfValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OspfValue Attribute Type",
				"While creating a OspfValue value, an invalid attribute value was detected. "+
					"A OspfValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OspfValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OspfValue Attribute Value",
				"While creating a OspfValue value, an extra attribute value was detected. "+
					"A OspfValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OspfValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOspfValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOspfValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	ospfAreasAttribute, ok := attributes["ospf_areas"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf_areas is missing from object`)

		return NewOspfValueUnknown(), diags
	}

	ospfAreasVal, ok := ospfAreasAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf_areas expected to be basetypes.ListValue, was: %T`, ospfAreasAttribute))
	}

	ospfInterfacesAttribute, ok := attributes["ospf_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf_interfaces is missing from object`)

		return NewOspfValueUnknown(), diags
	}

	ospfInterfacesVal, ok := ospfInterfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf_interfaces expected to be basetypes.ListValue, was: %T`, ospfInterfacesAttribute))
	}

	spec8Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_8 is missing from object`)

		return NewOspfValueUnknown(), diags
	}

	spec8Val, ok := spec8Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_8 expected to be basetypes.ObjectValue, was: %T`, spec8Attribute))
	}

	if diags.HasError() {
		return NewOspfValueUnknown(), diags
	}

	return OspfValue{
		Name:           nameVal,
		OspfAreas:      ospfAreasVal,
		OspfInterfaces: ospfInterfacesVal,
		Spec8:          spec8Val,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewOspfValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OspfValue {
	object, diags := NewOspfValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOspfValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OspfType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOspfValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOspfValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOspfValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOspfValueMust(OspfValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OspfType) ValueType(ctx context.Context) attr.Value {
	return OspfValue{}
}

var _ basetypes.ObjectValuable = OspfValue{}

type OspfValue struct {
	Name           basetypes.StringValue `tfsdk:"name"`
	OspfAreas      basetypes.ListValue   `tfsdk:"ospf_areas"`
	OspfInterfaces basetypes.ListValue   `tfsdk:"ospf_interfaces"`
	Spec8          basetypes.ObjectValue `tfsdk:"spec"`
	state          attr.ValueState
}

func (v OspfValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ospf_areas"] = basetypes.ListType{
		ElemType: OspfAreasValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ospf_interfaces"] = basetypes.ListType{
		ElemType: OspfInterfacesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec8Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.OspfAreas.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ospf_areas"] = val

		val, err = v.OspfInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ospf_interfaces"] = val

		val, err = v.Spec8.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OspfValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OspfValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OspfValue) String() string {
	return "OspfValue"
}

func (v OspfValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	ospfAreas := types.ListValueMust(
		OspfAreasType{
			basetypes.ObjectType{
				AttrTypes: OspfAreasValue{}.AttributeTypes(ctx),
			},
		},
		v.OspfAreas.Elements(),
	)

	if v.OspfAreas.IsNull() {
		ospfAreas = types.ListNull(
			OspfAreasType{
				basetypes.ObjectType{
					AttrTypes: OspfAreasValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.OspfAreas.IsUnknown() {
		ospfAreas = types.ListUnknown(
			OspfAreasType{
				basetypes.ObjectType{
					AttrTypes: OspfAreasValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	ospfInterfaces := types.ListValueMust(
		OspfInterfacesType{
			basetypes.ObjectType{
				AttrTypes: OspfInterfacesValue{}.AttributeTypes(ctx),
			},
		},
		v.OspfInterfaces.Elements(),
	)

	if v.OspfInterfaces.IsNull() {
		ospfInterfaces = types.ListNull(
			OspfInterfacesType{
				basetypes.ObjectType{
					AttrTypes: OspfInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.OspfInterfaces.IsUnknown() {
		ospfInterfaces = types.ListUnknown(
			OspfInterfacesType{
				basetypes.ObjectType{
					AttrTypes: OspfInterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var spec8 basetypes.ObjectValue

	if v.Spec8.IsNull() {
		spec8 = types.ObjectNull(
			Spec8Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec8.IsUnknown() {
		spec8 = types.ObjectUnknown(
			Spec8Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec8.IsNull() && !v.Spec8.IsUnknown() {
		spec8 = types.ObjectValueMust(
			Spec8Value{}.AttributeTypes(ctx),
			v.Spec8.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"ospf_areas": basetypes.ListType{
			ElemType: OspfAreasValue{}.Type(ctx),
		},
		"ospf_interfaces": basetypes.ListType{
			ElemType: OspfInterfacesValue{}.Type(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec8Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name":            v.Name,
			"ospf_areas":      ospfAreas,
			"ospf_interfaces": ospfInterfaces,
			"spec":            spec8,
		})

	return objVal, diags
}

func (v OspfValue) Equal(o attr.Value) bool {
	other, ok := o.(OspfValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.OspfAreas.Equal(other.OspfAreas) {
		return false
	}

	if !v.OspfInterfaces.Equal(other.OspfInterfaces) {
		return false
	}

	if !v.Spec8.Equal(other.Spec8) {
		return false
	}

	return true
}

func (v OspfValue) Type(ctx context.Context) attr.Type {
	return OspfType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OspfValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"ospf_areas": basetypes.ListType{
			ElemType: OspfAreasValue{}.Type(ctx),
		},
		"ospf_interfaces": basetypes.ListType{
			ElemType: OspfInterfacesValue{}.Type(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec8Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = OspfAreasType{}

type OspfAreasType struct {
	basetypes.ObjectType
}

func (t OspfAreasType) Equal(o attr.Type) bool {
	other, ok := o.(OspfAreasType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OspfAreasType) String() string {
	return "OspfAreasType"
}

func (t OspfAreasType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec6Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_6 is missing from object`)

		return nil, diags
	}

	spec6Val, ok := spec6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_6 expected to be basetypes.ObjectValue, was: %T`, spec6Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OspfAreasValue{
		Name:  nameVal,
		Spec6: spec6Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOspfAreasValueNull() OspfAreasValue {
	return OspfAreasValue{
		state: attr.ValueStateNull,
	}
}

func NewOspfAreasValueUnknown() OspfAreasValue {
	return OspfAreasValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOspfAreasValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OspfAreasValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OspfAreasValue Attribute Value",
				"While creating a OspfAreasValue value, a missing attribute value was detected. "+
					"A OspfAreasValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfAreasValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OspfAreasValue Attribute Type",
				"While creating a OspfAreasValue value, an invalid attribute value was detected. "+
					"A OspfAreasValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfAreasValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OspfAreasValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OspfAreasValue Attribute Value",
				"While creating a OspfAreasValue value, an extra attribute value was detected. "+
					"A OspfAreasValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OspfAreasValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOspfAreasValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOspfAreasValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec6Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_6 is missing from object`)

		return NewOspfAreasValueUnknown(), diags
	}

	spec6Val, ok := spec6Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_6 expected to be basetypes.ObjectValue, was: %T`, spec6Attribute))
	}

	if diags.HasError() {
		return NewOspfAreasValueUnknown(), diags
	}

	return OspfAreasValue{
		Name:  nameVal,
		Spec6: spec6Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOspfAreasValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OspfAreasValue {
	object, diags := NewOspfAreasValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOspfAreasValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OspfAreasType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOspfAreasValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOspfAreasValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOspfAreasValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOspfAreasValueMust(OspfAreasValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OspfAreasType) ValueType(ctx context.Context) attr.Value {
	return OspfAreasValue{}
}

var _ basetypes.ObjectValuable = OspfAreasValue{}

type OspfAreasValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Spec6 basetypes.ObjectValue `tfsdk:"spec"`
	state attr.ValueState
}

func (v OspfAreasValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec6Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Spec6.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OspfAreasValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OspfAreasValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OspfAreasValue) String() string {
	return "OspfAreasValue"
}

func (v OspfAreasValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spec6 basetypes.ObjectValue

	if v.Spec6.IsNull() {
		spec6 = types.ObjectNull(
			Spec6Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec6.IsUnknown() {
		spec6 = types.ObjectUnknown(
			Spec6Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec6.IsNull() && !v.Spec6.IsUnknown() {
		spec6 = types.ObjectValueMust(
			Spec6Value{}.AttributeTypes(ctx),
			v.Spec6.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec6Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"spec": spec6,
		})

	return objVal, diags
}

func (v OspfAreasValue) Equal(o attr.Value) bool {
	other, ok := o.(OspfAreasValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Spec6.Equal(other.Spec6) {
		return false
	}

	return true
}

func (v OspfAreasValue) Type(ctx context.Context) attr.Type {
	return OspfAreasType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OspfAreasValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec6Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Spec6Type{}

type Spec6Type struct {
	basetypes.ObjectType
}

func (t Spec6Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec6Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec6Type) String() string {
	return "Spec6Type"
}

func (t Spec6Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	areaIdAttribute, ok := attributes["area_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`area_id is missing from object`)

		return nil, diags
	}

	areaIdVal, ok := areaIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`area_id expected to be basetypes.StringValue, was: %T`, areaIdAttribute))
	}

	areaTypeAttribute, ok := attributes["area_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`area_type is missing from object`)

		return nil, diags
	}

	areaTypeVal, ok := areaTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`area_type expected to be basetypes.StringValue, was: %T`, areaTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec6Value{
		AreaId:   areaIdVal,
		AreaType: areaTypeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSpec6ValueNull() Spec6Value {
	return Spec6Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec6ValueUnknown() Spec6Value {
	return Spec6Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec6Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec6Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec6Value Attribute Value",
				"While creating a Spec6Value value, a missing attribute value was detected. "+
					"A Spec6Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec6Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec6Value Attribute Type",
				"While creating a Spec6Value value, an invalid attribute value was detected. "+
					"A Spec6Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec6Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec6Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec6Value Attribute Value",
				"While creating a Spec6Value value, an extra attribute value was detected. "+
					"A Spec6Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec6Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec6ValueUnknown(), diags
	}

	areaIdAttribute, ok := attributes["area_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`area_id is missing from object`)

		return NewSpec6ValueUnknown(), diags
	}

	areaIdVal, ok := areaIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`area_id expected to be basetypes.StringValue, was: %T`, areaIdAttribute))
	}

	areaTypeAttribute, ok := attributes["area_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`area_type is missing from object`)

		return NewSpec6ValueUnknown(), diags
	}

	areaTypeVal, ok := areaTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`area_type expected to be basetypes.StringValue, was: %T`, areaTypeAttribute))
	}

	if diags.HasError() {
		return NewSpec6ValueUnknown(), diags
	}

	return Spec6Value{
		AreaId:   areaIdVal,
		AreaType: areaTypeVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewSpec6ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec6Value {
	object, diags := NewSpec6Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec6ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec6Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec6ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec6ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec6ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec6ValueMust(Spec6Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec6Type) ValueType(ctx context.Context) attr.Value {
	return Spec6Value{}
}

var _ basetypes.ObjectValuable = Spec6Value{}

type Spec6Value struct {
	AreaId   basetypes.StringValue `tfsdk:"area_id"`
	AreaType basetypes.StringValue `tfsdk:"area_type"`
	state    attr.ValueState
}

func (v Spec6Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["area_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["area_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AreaId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["area_id"] = val

		val, err = v.AreaType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["area_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec6Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec6Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec6Value) String() string {
	return "Spec6Value"
}

func (v Spec6Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"area_id":   basetypes.StringType{},
		"area_type": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"area_id":   v.AreaId,
			"area_type": v.AreaType,
		})

	return objVal, diags
}

func (v Spec6Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec6Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AreaId.Equal(other.AreaId) {
		return false
	}

	if !v.AreaType.Equal(other.AreaType) {
		return false
	}

	return true
}

func (v Spec6Value) Type(ctx context.Context) attr.Type {
	return Spec6Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec6Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"area_id":   basetypes.StringType{},
		"area_type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OspfInterfacesType{}

type OspfInterfacesType struct {
	basetypes.ObjectType
}

func (t OspfInterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(OspfInterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OspfInterfacesType) String() string {
	return "OspfInterfacesType"
}

func (t OspfInterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec7Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_7 is missing from object`)

		return nil, diags
	}

	spec7Val, ok := spec7Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_7 expected to be basetypes.ObjectValue, was: %T`, spec7Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OspfInterfacesValue{
		Name:  nameVal,
		Spec7: spec7Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOspfInterfacesValueNull() OspfInterfacesValue {
	return OspfInterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewOspfInterfacesValueUnknown() OspfInterfacesValue {
	return OspfInterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOspfInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OspfInterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OspfInterfacesValue Attribute Value",
				"While creating a OspfInterfacesValue value, a missing attribute value was detected. "+
					"A OspfInterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfInterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OspfInterfacesValue Attribute Type",
				"While creating a OspfInterfacesValue value, an invalid attribute value was detected. "+
					"A OspfInterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfInterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OspfInterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OspfInterfacesValue Attribute Value",
				"While creating a OspfInterfacesValue value, an extra attribute value was detected. "+
					"A OspfInterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OspfInterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOspfInterfacesValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOspfInterfacesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec7Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_7 is missing from object`)

		return NewOspfInterfacesValueUnknown(), diags
	}

	spec7Val, ok := spec7Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_7 expected to be basetypes.ObjectValue, was: %T`, spec7Attribute))
	}

	if diags.HasError() {
		return NewOspfInterfacesValueUnknown(), diags
	}

	return OspfInterfacesValue{
		Name:  nameVal,
		Spec7: spec7Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewOspfInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OspfInterfacesValue {
	object, diags := NewOspfInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOspfInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OspfInterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOspfInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOspfInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOspfInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOspfInterfacesValueMust(OspfInterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OspfInterfacesType) ValueType(ctx context.Context) attr.Value {
	return OspfInterfacesValue{}
}

var _ basetypes.ObjectValuable = OspfInterfacesValue{}

type OspfInterfacesValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Spec7 basetypes.ObjectValue `tfsdk:"spec"`
	state attr.ValueState
}

func (v OspfInterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec7Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Spec7.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OspfInterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OspfInterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OspfInterfacesValue) String() string {
	return "OspfInterfacesValue"
}

func (v OspfInterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spec7 basetypes.ObjectValue

	if v.Spec7.IsNull() {
		spec7 = types.ObjectNull(
			Spec7Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec7.IsUnknown() {
		spec7 = types.ObjectUnknown(
			Spec7Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec7.IsNull() && !v.Spec7.IsUnknown() {
		spec7 = types.ObjectValueMust(
			Spec7Value{}.AttributeTypes(ctx),
			v.Spec7.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec7Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"spec": spec7,
		})

	return objVal, diags
}

func (v OspfInterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(OspfInterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Spec7.Equal(other.Spec7) {
		return false
	}

	return true
}

func (v OspfInterfacesValue) Type(ctx context.Context) attr.Type {
	return OspfInterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OspfInterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec7Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Spec7Type{}

type Spec7Type struct {
	basetypes.ObjectType
}

func (t Spec7Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec7Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec7Type) String() string {
	return "Spec7Type"
}

func (t Spec7Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	deadIntervalSecAttribute, ok := attributes["dead_interval_sec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dead_interval_sec is missing from object`)

		return nil, diags
	}

	deadIntervalSecVal, ok := deadIntervalSecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dead_interval_sec expected to be basetypes.Int64Value, was: %T`, deadIntervalSecAttribute))
	}

	helloIntervalSecAttribute, ok := attributes["hello_interval_sec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hello_interval_sec is missing from object`)

		return nil, diags
	}

	helloIntervalSecVal, ok := helloIntervalSecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hello_interval_sec expected to be basetypes.Int64Value, was: %T`, helloIntervalSecAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceKindAttribute, ok := attributes["interface_kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_kind is missing from object`)

		return nil, diags
	}

	interfaceKindVal, ok := interfaceKindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_kind expected to be basetypes.StringValue, was: %T`, interfaceKindAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return nil, diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return nil, diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	ospfAreaAttribute, ok := attributes["ospf_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf_area is missing from object`)

		return nil, diags
	}

	ospfAreaVal, ok := ospfAreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf_area expected to be basetypes.StringValue, was: %T`, ospfAreaAttribute))
	}

	ospfBfdAttribute, ok := attributes["ospf_bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf_bfd is missing from object`)

		return nil, diags
	}

	ospfBfdVal, ok := ospfBfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf_bfd expected to be basetypes.ObjectValue, was: %T`, ospfBfdAttribute))
	}

	ospfInstanceAttribute, ok := attributes["ospf_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf_instance is missing from object`)

		return nil, diags
	}

	ospfInstanceVal, ok := ospfInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf_instance expected to be basetypes.StringValue, was: %T`, ospfInstanceAttribute))
	}

	passiveAttribute, ok := attributes["passive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passive is missing from object`)

		return nil, diags
	}

	passiveVal, ok := passiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passive expected to be basetypes.BoolValue, was: %T`, passiveAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec7Value{
		DeadIntervalSec:  deadIntervalSecVal,
		HelloIntervalSec: helloIntervalSecVal,
		Interface:        interfaceVal,
		InterfaceKind:    interfaceKindVal,
		Metric:           metricVal,
		Mtu:              mtuVal,
		OspfArea:         ospfAreaVal,
		OspfBfd:          ospfBfdVal,
		OspfInstance:     ospfInstanceVal,
		Passive:          passiveVal,
		Spec7Type:        typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSpec7ValueNull() Spec7Value {
	return Spec7Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec7ValueUnknown() Spec7Value {
	return Spec7Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec7Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec7Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec7Value Attribute Value",
				"While creating a Spec7Value value, a missing attribute value was detected. "+
					"A Spec7Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec7Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec7Value Attribute Type",
				"While creating a Spec7Value value, an invalid attribute value was detected. "+
					"A Spec7Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec7Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec7Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec7Value Attribute Value",
				"While creating a Spec7Value value, an extra attribute value was detected. "+
					"A Spec7Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec7Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec7ValueUnknown(), diags
	}

	deadIntervalSecAttribute, ok := attributes["dead_interval_sec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dead_interval_sec is missing from object`)

		return NewSpec7ValueUnknown(), diags
	}

	deadIntervalSecVal, ok := deadIntervalSecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dead_interval_sec expected to be basetypes.Int64Value, was: %T`, deadIntervalSecAttribute))
	}

	helloIntervalSecAttribute, ok := attributes["hello_interval_sec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hello_interval_sec is missing from object`)

		return NewSpec7ValueUnknown(), diags
	}

	helloIntervalSecVal, ok := helloIntervalSecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hello_interval_sec expected to be basetypes.Int64Value, was: %T`, helloIntervalSecAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewSpec7ValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceKindAttribute, ok := attributes["interface_kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_kind is missing from object`)

		return NewSpec7ValueUnknown(), diags
	}

	interfaceKindVal, ok := interfaceKindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_kind expected to be basetypes.StringValue, was: %T`, interfaceKindAttribute))
	}

	metricAttribute, ok := attributes["metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric is missing from object`)

		return NewSpec7ValueUnknown(), diags
	}

	metricVal, ok := metricAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric expected to be basetypes.Int64Value, was: %T`, metricAttribute))
	}

	mtuAttribute, ok := attributes["mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mtu is missing from object`)

		return NewSpec7ValueUnknown(), diags
	}

	mtuVal, ok := mtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mtu expected to be basetypes.Int64Value, was: %T`, mtuAttribute))
	}

	ospfAreaAttribute, ok := attributes["ospf_area"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf_area is missing from object`)

		return NewSpec7ValueUnknown(), diags
	}

	ospfAreaVal, ok := ospfAreaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf_area expected to be basetypes.StringValue, was: %T`, ospfAreaAttribute))
	}

	ospfBfdAttribute, ok := attributes["ospf_bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf_bfd is missing from object`)

		return NewSpec7ValueUnknown(), diags
	}

	ospfBfdVal, ok := ospfBfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf_bfd expected to be basetypes.ObjectValue, was: %T`, ospfBfdAttribute))
	}

	ospfInstanceAttribute, ok := attributes["ospf_instance"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ospf_instance is missing from object`)

		return NewSpec7ValueUnknown(), diags
	}

	ospfInstanceVal, ok := ospfInstanceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ospf_instance expected to be basetypes.StringValue, was: %T`, ospfInstanceAttribute))
	}

	passiveAttribute, ok := attributes["passive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`passive is missing from object`)

		return NewSpec7ValueUnknown(), diags
	}

	passiveVal, ok := passiveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`passive expected to be basetypes.BoolValue, was: %T`, passiveAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSpec7ValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewSpec7ValueUnknown(), diags
	}

	return Spec7Value{
		DeadIntervalSec:  deadIntervalSecVal,
		HelloIntervalSec: helloIntervalSecVal,
		Interface:        interfaceVal,
		InterfaceKind:    interfaceKindVal,
		Metric:           metricVal,
		Mtu:              mtuVal,
		OspfArea:         ospfAreaVal,
		OspfBfd:          ospfBfdVal,
		OspfInstance:     ospfInstanceVal,
		Passive:          passiveVal,
		Spec7Type:        typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewSpec7ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec7Value {
	object, diags := NewSpec7Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec7ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec7Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec7ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec7ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec7ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec7ValueMust(Spec7Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec7Type) ValueType(ctx context.Context) attr.Value {
	return Spec7Value{}
}

var _ basetypes.ObjectValuable = Spec7Value{}

type Spec7Value struct {
	DeadIntervalSec  basetypes.Int64Value  `tfsdk:"dead_interval_sec"`
	HelloIntervalSec basetypes.Int64Value  `tfsdk:"hello_interval_sec"`
	Interface        basetypes.StringValue `tfsdk:"interface"`
	InterfaceKind    basetypes.StringValue `tfsdk:"interface_kind"`
	Metric           basetypes.Int64Value  `tfsdk:"metric"`
	Mtu              basetypes.Int64Value  `tfsdk:"mtu"`
	OspfArea         basetypes.StringValue `tfsdk:"ospf_area"`
	OspfBfd          basetypes.ObjectValue `tfsdk:"ospf_bfd"`
	OspfInstance     basetypes.StringValue `tfsdk:"ospf_instance"`
	Passive          basetypes.BoolValue   `tfsdk:"passive"`
	Spec7Type        basetypes.StringValue `tfsdk:"type"`
	state            attr.ValueState
}

func (v Spec7Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["dead_interval_sec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["hello_interval_sec"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metric"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ospf_area"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ospf_bfd"] = basetypes.ObjectType{
		AttrTypes: OspfBfdValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ospf_instance"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["passive"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.DeadIntervalSec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dead_interval_sec"] = val

		val, err = v.HelloIntervalSec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hello_interval_sec"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.InterfaceKind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_kind"] = val

		val, err = v.Metric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric"] = val

		val, err = v.Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mtu"] = val

		val, err = v.OspfArea.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ospf_area"] = val

		val, err = v.OspfBfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ospf_bfd"] = val

		val, err = v.OspfInstance.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ospf_instance"] = val

		val, err = v.Passive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["passive"] = val

		val, err = v.Spec7Type.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec7Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec7Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec7Value) String() string {
	return "Spec7Value"
}

func (v Spec7Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var ospfBfd basetypes.ObjectValue

	if v.OspfBfd.IsNull() {
		ospfBfd = types.ObjectNull(
			OspfBfdValue{}.AttributeTypes(ctx),
		)
	}

	if v.OspfBfd.IsUnknown() {
		ospfBfd = types.ObjectUnknown(
			OspfBfdValue{}.AttributeTypes(ctx),
		)
	}

	if !v.OspfBfd.IsNull() && !v.OspfBfd.IsUnknown() {
		ospfBfd = types.ObjectValueMust(
			OspfBfdValue{}.AttributeTypes(ctx),
			v.OspfBfd.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"dead_interval_sec":  basetypes.Int64Type{},
		"hello_interval_sec": basetypes.Int64Type{},
		"interface":          basetypes.StringType{},
		"interface_kind":     basetypes.StringType{},
		"metric":             basetypes.Int64Type{},
		"mtu":                basetypes.Int64Type{},
		"ospf_area":          basetypes.StringType{},
		"ospf_bfd": basetypes.ObjectType{
			AttrTypes: OspfBfdValue{}.AttributeTypes(ctx),
		},
		"ospf_instance": basetypes.StringType{},
		"passive":       basetypes.BoolType{},
		"type":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dead_interval_sec":  v.DeadIntervalSec,
			"hello_interval_sec": v.HelloIntervalSec,
			"interface":          v.Interface,
			"interface_kind":     v.InterfaceKind,
			"metric":             v.Metric,
			"mtu":                v.Mtu,
			"ospf_area":          v.OspfArea,
			"ospf_bfd":           ospfBfd,
			"ospf_instance":      v.OspfInstance,
			"passive":            v.Passive,
			"type":               v.Spec7Type,
		})

	return objVal, diags
}

func (v Spec7Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec7Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DeadIntervalSec.Equal(other.DeadIntervalSec) {
		return false
	}

	if !v.HelloIntervalSec.Equal(other.HelloIntervalSec) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.InterfaceKind.Equal(other.InterfaceKind) {
		return false
	}

	if !v.Metric.Equal(other.Metric) {
		return false
	}

	if !v.Mtu.Equal(other.Mtu) {
		return false
	}

	if !v.OspfArea.Equal(other.OspfArea) {
		return false
	}

	if !v.OspfBfd.Equal(other.OspfBfd) {
		return false
	}

	if !v.OspfInstance.Equal(other.OspfInstance) {
		return false
	}

	if !v.Passive.Equal(other.Passive) {
		return false
	}

	if !v.Spec7Type.Equal(other.Spec7Type) {
		return false
	}

	return true
}

func (v Spec7Value) Type(ctx context.Context) attr.Type {
	return Spec7Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec7Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dead_interval_sec":  basetypes.Int64Type{},
		"hello_interval_sec": basetypes.Int64Type{},
		"interface":          basetypes.StringType{},
		"interface_kind":     basetypes.StringType{},
		"metric":             basetypes.Int64Type{},
		"mtu":                basetypes.Int64Type{},
		"ospf_area":          basetypes.StringType{},
		"ospf_bfd": basetypes.ObjectType{
			AttrTypes: OspfBfdValue{}.AttributeTypes(ctx),
		},
		"ospf_instance": basetypes.StringType{},
		"passive":       basetypes.BoolType{},
		"type":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = OspfBfdType{}

type OspfBfdType struct {
	basetypes.ObjectType
}

func (t OspfBfdType) Equal(o attr.Type) bool {
	other, ok := o.(OspfBfdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OspfBfdType) String() string {
	return "OspfBfdType"
}

func (t OspfBfdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	strictModeAttribute, ok := attributes["strict_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`strict_mode is missing from object`)

		return nil, diags
	}

	strictModeVal, ok := strictModeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`strict_mode expected to be basetypes.BoolValue, was: %T`, strictModeAttribute))
	}

	strictModeHoldDownSecAttribute, ok := attributes["strict_mode_hold_down_sec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`strict_mode_hold_down_sec is missing from object`)

		return nil, diags
	}

	strictModeHoldDownSecVal, ok := strictModeHoldDownSecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`strict_mode_hold_down_sec expected to be basetypes.Int64Value, was: %T`, strictModeHoldDownSecAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OspfBfdValue{
		Enabled:               enabledVal,
		StrictMode:            strictModeVal,
		StrictModeHoldDownSec: strictModeHoldDownSecVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewOspfBfdValueNull() OspfBfdValue {
	return OspfBfdValue{
		state: attr.ValueStateNull,
	}
}

func NewOspfBfdValueUnknown() OspfBfdValue {
	return OspfBfdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOspfBfdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OspfBfdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OspfBfdValue Attribute Value",
				"While creating a OspfBfdValue value, a missing attribute value was detected. "+
					"A OspfBfdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfBfdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OspfBfdValue Attribute Type",
				"While creating a OspfBfdValue value, an invalid attribute value was detected. "+
					"A OspfBfdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OspfBfdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OspfBfdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OspfBfdValue Attribute Value",
				"While creating a OspfBfdValue value, an extra attribute value was detected. "+
					"A OspfBfdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OspfBfdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOspfBfdValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewOspfBfdValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	strictModeAttribute, ok := attributes["strict_mode"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`strict_mode is missing from object`)

		return NewOspfBfdValueUnknown(), diags
	}

	strictModeVal, ok := strictModeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`strict_mode expected to be basetypes.BoolValue, was: %T`, strictModeAttribute))
	}

	strictModeHoldDownSecAttribute, ok := attributes["strict_mode_hold_down_sec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`strict_mode_hold_down_sec is missing from object`)

		return NewOspfBfdValueUnknown(), diags
	}

	strictModeHoldDownSecVal, ok := strictModeHoldDownSecAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`strict_mode_hold_down_sec expected to be basetypes.Int64Value, was: %T`, strictModeHoldDownSecAttribute))
	}

	if diags.HasError() {
		return NewOspfBfdValueUnknown(), diags
	}

	return OspfBfdValue{
		Enabled:               enabledVal,
		StrictMode:            strictModeVal,
		StrictModeHoldDownSec: strictModeHoldDownSecVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewOspfBfdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OspfBfdValue {
	object, diags := NewOspfBfdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOspfBfdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OspfBfdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOspfBfdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOspfBfdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOspfBfdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOspfBfdValueMust(OspfBfdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OspfBfdType) ValueType(ctx context.Context) attr.Value {
	return OspfBfdValue{}
}

var _ basetypes.ObjectValuable = OspfBfdValue{}

type OspfBfdValue struct {
	Enabled               basetypes.BoolValue  `tfsdk:"enabled"`
	StrictMode            basetypes.BoolValue  `tfsdk:"strict_mode"`
	StrictModeHoldDownSec basetypes.Int64Value `tfsdk:"strict_mode_hold_down_sec"`
	state                 attr.ValueState
}

func (v OspfBfdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["strict_mode"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["strict_mode_hold_down_sec"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.StrictMode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["strict_mode"] = val

		val, err = v.StrictModeHoldDownSec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["strict_mode_hold_down_sec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OspfBfdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OspfBfdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OspfBfdValue) String() string {
	return "OspfBfdValue"
}

func (v OspfBfdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":                   basetypes.BoolType{},
		"strict_mode":               basetypes.BoolType{},
		"strict_mode_hold_down_sec": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":                   v.Enabled,
			"strict_mode":               v.StrictMode,
			"strict_mode_hold_down_sec": v.StrictModeHoldDownSec,
		})

	return objVal, diags
}

func (v OspfBfdValue) Equal(o attr.Value) bool {
	other, ok := o.(OspfBfdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.StrictMode.Equal(other.StrictMode) {
		return false
	}

	if !v.StrictModeHoldDownSec.Equal(other.StrictModeHoldDownSec) {
		return false
	}

	return true
}

func (v OspfBfdValue) Type(ctx context.Context) attr.Type {
	return OspfBfdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OspfBfdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":                   basetypes.BoolType{},
		"strict_mode":               basetypes.BoolType{},
		"strict_mode_hold_down_sec": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Spec8Type{}

type Spec8Type struct {
	basetypes.ObjectType
}

func (t Spec8Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec8Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec8Type) String() string {
	return "Spec8Type"
}

func (t Spec8Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return nil, diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.StringValue, was: %T`, addressFamilyAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	maxEcmpAttribute, ok := attributes["max_ecmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_ecmp is missing from object`)

		return nil, diags
	}

	maxEcmpVal, ok := maxEcmpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_ecmp expected to be basetypes.Int64Value, was: %T`, maxEcmpAttribute))
	}

	maxMetricAttribute, ok := attributes["max_metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_metric is missing from object`)

		return nil, diags
	}

	maxMetricVal, ok := maxMetricAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_metric expected to be basetypes.ObjectValue, was: %T`, maxMetricAttribute))
	}

	refBwGbpsAttribute, ok := attributes["ref_bw_gbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ref_bw_gbps is missing from object`)

		return nil, diags
	}

	refBwGbpsVal, ok := refBwGbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ref_bw_gbps expected to be basetypes.Int64Value, was: %T`, refBwGbpsAttribute))
	}

	timers2Attribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers_2 is missing from object`)

		return nil, diags
	}

	timers2Val, ok := timers2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers_2 expected to be basetypes.ObjectValue, was: %T`, timers2Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return nil, diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec8Value{
		AddressFamily: addressFamilyVal,
		Enabled:       enabledVal,
		MaxEcmp:       maxEcmpVal,
		MaxMetric:     maxMetricVal,
		RefBwGbps:     refBwGbpsVal,
		Timers2:       timers2Val,
		Version:       versionVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSpec8ValueNull() Spec8Value {
	return Spec8Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec8ValueUnknown() Spec8Value {
	return Spec8Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec8Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec8Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec8Value Attribute Value",
				"While creating a Spec8Value value, a missing attribute value was detected. "+
					"A Spec8Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec8Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec8Value Attribute Type",
				"While creating a Spec8Value value, an invalid attribute value was detected. "+
					"A Spec8Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec8Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec8Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec8Value Attribute Value",
				"While creating a Spec8Value value, an extra attribute value was detected. "+
					"A Spec8Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec8Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec8ValueUnknown(), diags
	}

	addressFamilyAttribute, ok := attributes["address_family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`address_family is missing from object`)

		return NewSpec8ValueUnknown(), diags
	}

	addressFamilyVal, ok := addressFamilyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`address_family expected to be basetypes.StringValue, was: %T`, addressFamilyAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewSpec8ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	maxEcmpAttribute, ok := attributes["max_ecmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_ecmp is missing from object`)

		return NewSpec8ValueUnknown(), diags
	}

	maxEcmpVal, ok := maxEcmpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_ecmp expected to be basetypes.Int64Value, was: %T`, maxEcmpAttribute))
	}

	maxMetricAttribute, ok := attributes["max_metric"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_metric is missing from object`)

		return NewSpec8ValueUnknown(), diags
	}

	maxMetricVal, ok := maxMetricAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_metric expected to be basetypes.ObjectValue, was: %T`, maxMetricAttribute))
	}

	refBwGbpsAttribute, ok := attributes["ref_bw_gbps"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ref_bw_gbps is missing from object`)

		return NewSpec8ValueUnknown(), diags
	}

	refBwGbpsVal, ok := refBwGbpsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ref_bw_gbps expected to be basetypes.Int64Value, was: %T`, refBwGbpsAttribute))
	}

	timers2Attribute, ok := attributes["timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`timers_2 is missing from object`)

		return NewSpec8ValueUnknown(), diags
	}

	timers2Val, ok := timers2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`timers_2 expected to be basetypes.ObjectValue, was: %T`, timers2Attribute))
	}

	versionAttribute, ok := attributes["version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`version is missing from object`)

		return NewSpec8ValueUnknown(), diags
	}

	versionVal, ok := versionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`version expected to be basetypes.StringValue, was: %T`, versionAttribute))
	}

	if diags.HasError() {
		return NewSpec8ValueUnknown(), diags
	}

	return Spec8Value{
		AddressFamily: addressFamilyVal,
		Enabled:       enabledVal,
		MaxEcmp:       maxEcmpVal,
		MaxMetric:     maxMetricVal,
		RefBwGbps:     refBwGbpsVal,
		Timers2:       timers2Val,
		Version:       versionVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewSpec8ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec8Value {
	object, diags := NewSpec8Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec8ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec8Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec8ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec8ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec8ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec8ValueMust(Spec8Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec8Type) ValueType(ctx context.Context) attr.Value {
	return Spec8Value{}
}

var _ basetypes.ObjectValuable = Spec8Value{}

type Spec8Value struct {
	AddressFamily basetypes.StringValue `tfsdk:"address_family"`
	Enabled       basetypes.BoolValue   `tfsdk:"enabled"`
	MaxEcmp       basetypes.Int64Value  `tfsdk:"max_ecmp"`
	MaxMetric     basetypes.ObjectValue `tfsdk:"max_metric"`
	RefBwGbps     basetypes.Int64Value  `tfsdk:"ref_bw_gbps"`
	Timers2       basetypes.ObjectValue `tfsdk:"timers"`
	Version       basetypes.StringValue `tfsdk:"version"`
	state         attr.ValueState
}

func (v Spec8Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["address_family"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_ecmp"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_metric"] = basetypes.ObjectType{
		AttrTypes: MaxMetricValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ref_bw_gbps"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["timers"] = basetypes.ObjectType{
		AttrTypes: Timers2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["version"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AddressFamily.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["address_family"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.MaxEcmp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_ecmp"] = val

		val, err = v.MaxMetric.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_metric"] = val

		val, err = v.RefBwGbps.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ref_bw_gbps"] = val

		val, err = v.Timers2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["timers"] = val

		val, err = v.Version.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["version"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec8Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec8Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec8Value) String() string {
	return "Spec8Value"
}

func (v Spec8Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var maxMetric basetypes.ObjectValue

	if v.MaxMetric.IsNull() {
		maxMetric = types.ObjectNull(
			MaxMetricValue{}.AttributeTypes(ctx),
		)
	}

	if v.MaxMetric.IsUnknown() {
		maxMetric = types.ObjectUnknown(
			MaxMetricValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MaxMetric.IsNull() && !v.MaxMetric.IsUnknown() {
		maxMetric = types.ObjectValueMust(
			MaxMetricValue{}.AttributeTypes(ctx),
			v.MaxMetric.Attributes(),
		)
	}

	var timers2 basetypes.ObjectValue

	if v.Timers2.IsNull() {
		timers2 = types.ObjectNull(
			Timers2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Timers2.IsUnknown() {
		timers2 = types.ObjectUnknown(
			Timers2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Timers2.IsNull() && !v.Timers2.IsUnknown() {
		timers2 = types.ObjectValueMust(
			Timers2Value{}.AttributeTypes(ctx),
			v.Timers2.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"address_family": basetypes.StringType{},
		"enabled":        basetypes.BoolType{},
		"max_ecmp":       basetypes.Int64Type{},
		"max_metric": basetypes.ObjectType{
			AttrTypes: MaxMetricValue{}.AttributeTypes(ctx),
		},
		"ref_bw_gbps": basetypes.Int64Type{},
		"timers": basetypes.ObjectType{
			AttrTypes: Timers2Value{}.AttributeTypes(ctx),
		},
		"version": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"address_family": v.AddressFamily,
			"enabled":        v.Enabled,
			"max_ecmp":       v.MaxEcmp,
			"max_metric":     maxMetric,
			"ref_bw_gbps":    v.RefBwGbps,
			"timers":         timers2,
			"version":        v.Version,
		})

	return objVal, diags
}

func (v Spec8Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec8Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AddressFamily.Equal(other.AddressFamily) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.MaxEcmp.Equal(other.MaxEcmp) {
		return false
	}

	if !v.MaxMetric.Equal(other.MaxMetric) {
		return false
	}

	if !v.RefBwGbps.Equal(other.RefBwGbps) {
		return false
	}

	if !v.Timers2.Equal(other.Timers2) {
		return false
	}

	if !v.Version.Equal(other.Version) {
		return false
	}

	return true
}

func (v Spec8Value) Type(ctx context.Context) attr.Type {
	return Spec8Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec8Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"address_family": basetypes.StringType{},
		"enabled":        basetypes.BoolType{},
		"max_ecmp":       basetypes.Int64Type{},
		"max_metric": basetypes.ObjectType{
			AttrTypes: MaxMetricValue{}.AttributeTypes(ctx),
		},
		"ref_bw_gbps": basetypes.Int64Type{},
		"timers": basetypes.ObjectType{
			AttrTypes: Timers2Value{}.AttributeTypes(ctx),
		},
		"version": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MaxMetricType{}

type MaxMetricType struct {
	basetypes.ObjectType
}

func (t MaxMetricType) Equal(o attr.Type) bool {
	other, ok := o.(MaxMetricType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MaxMetricType) String() string {
	return "MaxMetricType"
}

func (t MaxMetricType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	onBootAttribute, ok := attributes["on_boot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_boot is missing from object`)

		return nil, diags
	}

	onBootVal, ok := onBootAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_boot expected to be basetypes.Int64Value, was: %T`, onBootAttribute))
	}

	overloadAttribute, ok := attributes["overload"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overload is missing from object`)

		return nil, diags
	}

	overloadVal, ok := overloadAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overload expected to be basetypes.BoolValue, was: %T`, overloadAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MaxMetricValue{
		OnBoot:   onBootVal,
		Overload: overloadVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewMaxMetricValueNull() MaxMetricValue {
	return MaxMetricValue{
		state: attr.ValueStateNull,
	}
}

func NewMaxMetricValueUnknown() MaxMetricValue {
	return MaxMetricValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMaxMetricValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MaxMetricValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MaxMetricValue Attribute Value",
				"While creating a MaxMetricValue value, a missing attribute value was detected. "+
					"A MaxMetricValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MaxMetricValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MaxMetricValue Attribute Type",
				"While creating a MaxMetricValue value, an invalid attribute value was detected. "+
					"A MaxMetricValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MaxMetricValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MaxMetricValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MaxMetricValue Attribute Value",
				"While creating a MaxMetricValue value, an extra attribute value was detected. "+
					"A MaxMetricValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MaxMetricValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMaxMetricValueUnknown(), diags
	}

	onBootAttribute, ok := attributes["on_boot"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_boot is missing from object`)

		return NewMaxMetricValueUnknown(), diags
	}

	onBootVal, ok := onBootAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_boot expected to be basetypes.Int64Value, was: %T`, onBootAttribute))
	}

	overloadAttribute, ok := attributes["overload"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`overload is missing from object`)

		return NewMaxMetricValueUnknown(), diags
	}

	overloadVal, ok := overloadAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`overload expected to be basetypes.BoolValue, was: %T`, overloadAttribute))
	}

	if diags.HasError() {
		return NewMaxMetricValueUnknown(), diags
	}

	return MaxMetricValue{
		OnBoot:   onBootVal,
		Overload: overloadVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewMaxMetricValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MaxMetricValue {
	object, diags := NewMaxMetricValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMaxMetricValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MaxMetricType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMaxMetricValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMaxMetricValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMaxMetricValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMaxMetricValueMust(MaxMetricValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MaxMetricType) ValueType(ctx context.Context) attr.Value {
	return MaxMetricValue{}
}

var _ basetypes.ObjectValuable = MaxMetricValue{}

type MaxMetricValue struct {
	OnBoot   basetypes.Int64Value `tfsdk:"on_boot"`
	Overload basetypes.BoolValue  `tfsdk:"overload"`
	state    attr.ValueState
}

func (v MaxMetricValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["on_boot"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["overload"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.OnBoot.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["on_boot"] = val

		val, err = v.Overload.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["overload"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MaxMetricValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MaxMetricValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MaxMetricValue) String() string {
	return "MaxMetricValue"
}

func (v MaxMetricValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"on_boot":  basetypes.Int64Type{},
		"overload": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"on_boot":  v.OnBoot,
			"overload": v.Overload,
		})

	return objVal, diags
}

func (v MaxMetricValue) Equal(o attr.Value) bool {
	other, ok := o.(MaxMetricValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.OnBoot.Equal(other.OnBoot) {
		return false
	}

	if !v.Overload.Equal(other.Overload) {
		return false
	}

	return true
}

func (v MaxMetricValue) Type(ctx context.Context) attr.Type {
	return MaxMetricType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MaxMetricValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"on_boot":  basetypes.Int64Type{},
		"overload": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Timers2Type{}

type Timers2Type struct {
	basetypes.ObjectType
}

func (t Timers2Type) Equal(o attr.Type) bool {
	other, ok := o.(Timers2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Timers2Type) String() string {
	return "Timers2Type"
}

func (t Timers2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	lsaTimersAttribute, ok := attributes["lsa_timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lsa_timers is missing from object`)

		return nil, diags
	}

	lsaTimersVal, ok := lsaTimersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lsa_timers expected to be basetypes.ObjectValue, was: %T`, lsaTimersAttribute))
	}

	spfTimersAttribute, ok := attributes["spf_timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spf_timers is missing from object`)

		return nil, diags
	}

	spfTimersVal, ok := spfTimersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spf_timers expected to be basetypes.ObjectValue, was: %T`, spfTimersAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Timers2Value{
		LsaTimers: lsaTimersVal,
		SpfTimers: spfTimersVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewTimers2ValueNull() Timers2Value {
	return Timers2Value{
		state: attr.ValueStateNull,
	}
}

func NewTimers2ValueUnknown() Timers2Value {
	return Timers2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewTimers2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Timers2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Timers2Value Attribute Value",
				"While creating a Timers2Value value, a missing attribute value was detected. "+
					"A Timers2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Timers2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Timers2Value Attribute Type",
				"While creating a Timers2Value value, an invalid attribute value was detected. "+
					"A Timers2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Timers2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Timers2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Timers2Value Attribute Value",
				"While creating a Timers2Value value, an extra attribute value was detected. "+
					"A Timers2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Timers2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTimers2ValueUnknown(), diags
	}

	lsaTimersAttribute, ok := attributes["lsa_timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`lsa_timers is missing from object`)

		return NewTimers2ValueUnknown(), diags
	}

	lsaTimersVal, ok := lsaTimersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`lsa_timers expected to be basetypes.ObjectValue, was: %T`, lsaTimersAttribute))
	}

	spfTimersAttribute, ok := attributes["spf_timers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spf_timers is missing from object`)

		return NewTimers2ValueUnknown(), diags
	}

	spfTimersVal, ok := spfTimersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spf_timers expected to be basetypes.ObjectValue, was: %T`, spfTimersAttribute))
	}

	if diags.HasError() {
		return NewTimers2ValueUnknown(), diags
	}

	return Timers2Value{
		LsaTimers: lsaTimersVal,
		SpfTimers: spfTimersVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewTimers2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Timers2Value {
	object, diags := NewTimers2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTimers2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Timers2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTimers2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTimers2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTimers2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTimers2ValueMust(Timers2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Timers2Type) ValueType(ctx context.Context) attr.Value {
	return Timers2Value{}
}

var _ basetypes.ObjectValuable = Timers2Value{}

type Timers2Value struct {
	LsaTimers basetypes.ObjectValue `tfsdk:"lsa_timers"`
	SpfTimers basetypes.ObjectValue `tfsdk:"spf_timers"`
	state     attr.ValueState
}

func (v Timers2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["lsa_timers"] = basetypes.ObjectType{
		AttrTypes: LsaTimersValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["spf_timers"] = basetypes.ObjectType{
		AttrTypes: SpfTimersValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.LsaTimers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["lsa_timers"] = val

		val, err = v.SpfTimers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spf_timers"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Timers2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Timers2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Timers2Value) String() string {
	return "Timers2Value"
}

func (v Timers2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var lsaTimers basetypes.ObjectValue

	if v.LsaTimers.IsNull() {
		lsaTimers = types.ObjectNull(
			LsaTimersValue{}.AttributeTypes(ctx),
		)
	}

	if v.LsaTimers.IsUnknown() {
		lsaTimers = types.ObjectUnknown(
			LsaTimersValue{}.AttributeTypes(ctx),
		)
	}

	if !v.LsaTimers.IsNull() && !v.LsaTimers.IsUnknown() {
		lsaTimers = types.ObjectValueMust(
			LsaTimersValue{}.AttributeTypes(ctx),
			v.LsaTimers.Attributes(),
		)
	}

	var spfTimers basetypes.ObjectValue

	if v.SpfTimers.IsNull() {
		spfTimers = types.ObjectNull(
			SpfTimersValue{}.AttributeTypes(ctx),
		)
	}

	if v.SpfTimers.IsUnknown() {
		spfTimers = types.ObjectUnknown(
			SpfTimersValue{}.AttributeTypes(ctx),
		)
	}

	if !v.SpfTimers.IsNull() && !v.SpfTimers.IsUnknown() {
		spfTimers = types.ObjectValueMust(
			SpfTimersValue{}.AttributeTypes(ctx),
			v.SpfTimers.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"lsa_timers": basetypes.ObjectType{
			AttrTypes: LsaTimersValue{}.AttributeTypes(ctx),
		},
		"spf_timers": basetypes.ObjectType{
			AttrTypes: SpfTimersValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"lsa_timers": lsaTimers,
			"spf_timers": spfTimers,
		})

	return objVal, diags
}

func (v Timers2Value) Equal(o attr.Value) bool {
	other, ok := o.(Timers2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.LsaTimers.Equal(other.LsaTimers) {
		return false
	}

	if !v.SpfTimers.Equal(other.SpfTimers) {
		return false
	}

	return true
}

func (v Timers2Value) Type(ctx context.Context) attr.Type {
	return Timers2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Timers2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"lsa_timers": basetypes.ObjectType{
			AttrTypes: LsaTimersValue{}.AttributeTypes(ctx),
		},
		"spf_timers": basetypes.ObjectType{
			AttrTypes: SpfTimersValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = LsaTimersType{}

type LsaTimersType struct {
	basetypes.ObjectType
}

func (t LsaTimersType) Equal(o attr.Type) bool {
	other, ok := o.(LsaTimersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t LsaTimersType) String() string {
	return "LsaTimersType"
}

func (t LsaTimersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	accumulateMsAttribute, ok := attributes["accumulate_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accumulate_ms is missing from object`)

		return nil, diags
	}

	accumulateMsVal, ok := accumulateMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accumulate_ms expected to be basetypes.Int64Value, was: %T`, accumulateMsAttribute))
	}

	arrivalMsAttribute, ok := attributes["arrival_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arrival_ms is missing from object`)

		return nil, diags
	}

	arrivalMsVal, ok := arrivalMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arrival_ms expected to be basetypes.Int64Value, was: %T`, arrivalMsAttribute))
	}

	genHoldIntervalMsAttribute, ok := attributes["gen_hold_interval_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gen_hold_interval_ms is missing from object`)

		return nil, diags
	}

	genHoldIntervalMsVal, ok := genHoldIntervalMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gen_hold_interval_ms expected to be basetypes.Int64Value, was: %T`, genHoldIntervalMsAttribute))
	}

	genInitialDelayMsAttribute, ok := attributes["gen_initial_delay_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gen_initial_delay_ms is missing from object`)

		return nil, diags
	}

	genInitialDelayMsVal, ok := genInitialDelayMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gen_initial_delay_ms expected to be basetypes.Int64Value, was: %T`, genInitialDelayMsAttribute))
	}

	genMaxDelayMsAttribute, ok := attributes["gen_max_delay_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gen_max_delay_ms is missing from object`)

		return nil, diags
	}

	genMaxDelayMsVal, ok := genMaxDelayMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gen_max_delay_ms expected to be basetypes.Int64Value, was: %T`, genMaxDelayMsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return LsaTimersValue{
		AccumulateMs:      accumulateMsVal,
		ArrivalMs:         arrivalMsVal,
		GenHoldIntervalMs: genHoldIntervalMsVal,
		GenInitialDelayMs: genInitialDelayMsVal,
		GenMaxDelayMs:     genMaxDelayMsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewLsaTimersValueNull() LsaTimersValue {
	return LsaTimersValue{
		state: attr.ValueStateNull,
	}
}

func NewLsaTimersValueUnknown() LsaTimersValue {
	return LsaTimersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewLsaTimersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (LsaTimersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing LsaTimersValue Attribute Value",
				"While creating a LsaTimersValue value, a missing attribute value was detected. "+
					"A LsaTimersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LsaTimersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid LsaTimersValue Attribute Type",
				"While creating a LsaTimersValue value, an invalid attribute value was detected. "+
					"A LsaTimersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("LsaTimersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("LsaTimersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra LsaTimersValue Attribute Value",
				"While creating a LsaTimersValue value, an extra attribute value was detected. "+
					"A LsaTimersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra LsaTimersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewLsaTimersValueUnknown(), diags
	}

	accumulateMsAttribute, ok := attributes["accumulate_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`accumulate_ms is missing from object`)

		return NewLsaTimersValueUnknown(), diags
	}

	accumulateMsVal, ok := accumulateMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`accumulate_ms expected to be basetypes.Int64Value, was: %T`, accumulateMsAttribute))
	}

	arrivalMsAttribute, ok := attributes["arrival_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arrival_ms is missing from object`)

		return NewLsaTimersValueUnknown(), diags
	}

	arrivalMsVal, ok := arrivalMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arrival_ms expected to be basetypes.Int64Value, was: %T`, arrivalMsAttribute))
	}

	genHoldIntervalMsAttribute, ok := attributes["gen_hold_interval_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gen_hold_interval_ms is missing from object`)

		return NewLsaTimersValueUnknown(), diags
	}

	genHoldIntervalMsVal, ok := genHoldIntervalMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gen_hold_interval_ms expected to be basetypes.Int64Value, was: %T`, genHoldIntervalMsAttribute))
	}

	genInitialDelayMsAttribute, ok := attributes["gen_initial_delay_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gen_initial_delay_ms is missing from object`)

		return NewLsaTimersValueUnknown(), diags
	}

	genInitialDelayMsVal, ok := genInitialDelayMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gen_initial_delay_ms expected to be basetypes.Int64Value, was: %T`, genInitialDelayMsAttribute))
	}

	genMaxDelayMsAttribute, ok := attributes["gen_max_delay_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`gen_max_delay_ms is missing from object`)

		return NewLsaTimersValueUnknown(), diags
	}

	genMaxDelayMsVal, ok := genMaxDelayMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`gen_max_delay_ms expected to be basetypes.Int64Value, was: %T`, genMaxDelayMsAttribute))
	}

	if diags.HasError() {
		return NewLsaTimersValueUnknown(), diags
	}

	return LsaTimersValue{
		AccumulateMs:      accumulateMsVal,
		ArrivalMs:         arrivalMsVal,
		GenHoldIntervalMs: genHoldIntervalMsVal,
		GenInitialDelayMs: genInitialDelayMsVal,
		GenMaxDelayMs:     genMaxDelayMsVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewLsaTimersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) LsaTimersValue {
	object, diags := NewLsaTimersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewLsaTimersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t LsaTimersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewLsaTimersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewLsaTimersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewLsaTimersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewLsaTimersValueMust(LsaTimersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t LsaTimersType) ValueType(ctx context.Context) attr.Value {
	return LsaTimersValue{}
}

var _ basetypes.ObjectValuable = LsaTimersValue{}

type LsaTimersValue struct {
	AccumulateMs      basetypes.Int64Value `tfsdk:"accumulate_ms"`
	ArrivalMs         basetypes.Int64Value `tfsdk:"arrival_ms"`
	GenHoldIntervalMs basetypes.Int64Value `tfsdk:"gen_hold_interval_ms"`
	GenInitialDelayMs basetypes.Int64Value `tfsdk:"gen_initial_delay_ms"`
	GenMaxDelayMs     basetypes.Int64Value `tfsdk:"gen_max_delay_ms"`
	state             attr.ValueState
}

func (v LsaTimersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["accumulate_ms"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["arrival_ms"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gen_hold_interval_ms"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gen_initial_delay_ms"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["gen_max_delay_ms"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AccumulateMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["accumulate_ms"] = val

		val, err = v.ArrivalMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arrival_ms"] = val

		val, err = v.GenHoldIntervalMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gen_hold_interval_ms"] = val

		val, err = v.GenInitialDelayMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gen_initial_delay_ms"] = val

		val, err = v.GenMaxDelayMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["gen_max_delay_ms"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v LsaTimersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v LsaTimersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v LsaTimersValue) String() string {
	return "LsaTimersValue"
}

func (v LsaTimersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"accumulate_ms":        basetypes.Int64Type{},
		"arrival_ms":           basetypes.Int64Type{},
		"gen_hold_interval_ms": basetypes.Int64Type{},
		"gen_initial_delay_ms": basetypes.Int64Type{},
		"gen_max_delay_ms":     basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"accumulate_ms":        v.AccumulateMs,
			"arrival_ms":           v.ArrivalMs,
			"gen_hold_interval_ms": v.GenHoldIntervalMs,
			"gen_initial_delay_ms": v.GenInitialDelayMs,
			"gen_max_delay_ms":     v.GenMaxDelayMs,
		})

	return objVal, diags
}

func (v LsaTimersValue) Equal(o attr.Value) bool {
	other, ok := o.(LsaTimersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AccumulateMs.Equal(other.AccumulateMs) {
		return false
	}

	if !v.ArrivalMs.Equal(other.ArrivalMs) {
		return false
	}

	if !v.GenHoldIntervalMs.Equal(other.GenHoldIntervalMs) {
		return false
	}

	if !v.GenInitialDelayMs.Equal(other.GenInitialDelayMs) {
		return false
	}

	if !v.GenMaxDelayMs.Equal(other.GenMaxDelayMs) {
		return false
	}

	return true
}

func (v LsaTimersValue) Type(ctx context.Context) attr.Type {
	return LsaTimersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v LsaTimersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"accumulate_ms":        basetypes.Int64Type{},
		"arrival_ms":           basetypes.Int64Type{},
		"gen_hold_interval_ms": basetypes.Int64Type{},
		"gen_initial_delay_ms": basetypes.Int64Type{},
		"gen_max_delay_ms":     basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = SpfTimersType{}

type SpfTimersType struct {
	basetypes.ObjectType
}

func (t SpfTimersType) Equal(o attr.Type) bool {
	other, ok := o.(SpfTimersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpfTimersType) String() string {
	return "SpfTimersType"
}

func (t SpfTimersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	holdIntervalMsAttribute, ok := attributes["hold_interval_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_interval_ms is missing from object`)

		return nil, diags
	}

	holdIntervalMsVal, ok := holdIntervalMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_interval_ms expected to be basetypes.Int64Value, was: %T`, holdIntervalMsAttribute))
	}

	incrementalSpfDelayMsAttribute, ok := attributes["incremental_spf_delay_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incremental_spf_delay_ms is missing from object`)

		return nil, diags
	}

	incrementalSpfDelayMsVal, ok := incrementalSpfDelayMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incremental_spf_delay_ms expected to be basetypes.Int64Value, was: %T`, incrementalSpfDelayMsAttribute))
	}

	initialDelayMsAttribute, ok := attributes["initial_delay_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_delay_ms is missing from object`)

		return nil, diags
	}

	initialDelayMsVal, ok := initialDelayMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_delay_ms expected to be basetypes.Int64Value, was: %T`, initialDelayMsAttribute))
	}

	maxDelayMsAttribute, ok := attributes["max_delay_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_delay_ms is missing from object`)

		return nil, diags
	}

	maxDelayMsVal, ok := maxDelayMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_delay_ms expected to be basetypes.Int64Value, was: %T`, maxDelayMsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpfTimersValue{
		HoldIntervalMs:        holdIntervalMsVal,
		IncrementalSpfDelayMs: incrementalSpfDelayMsVal,
		InitialDelayMs:        initialDelayMsVal,
		MaxDelayMs:            maxDelayMsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSpfTimersValueNull() SpfTimersValue {
	return SpfTimersValue{
		state: attr.ValueStateNull,
	}
}

func NewSpfTimersValueUnknown() SpfTimersValue {
	return SpfTimersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpfTimersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpfTimersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpfTimersValue Attribute Value",
				"While creating a SpfTimersValue value, a missing attribute value was detected. "+
					"A SpfTimersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpfTimersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpfTimersValue Attribute Type",
				"While creating a SpfTimersValue value, an invalid attribute value was detected. "+
					"A SpfTimersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpfTimersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpfTimersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpfTimersValue Attribute Value",
				"While creating a SpfTimersValue value, an extra attribute value was detected. "+
					"A SpfTimersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpfTimersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpfTimersValueUnknown(), diags
	}

	holdIntervalMsAttribute, ok := attributes["hold_interval_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_interval_ms is missing from object`)

		return NewSpfTimersValueUnknown(), diags
	}

	holdIntervalMsVal, ok := holdIntervalMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_interval_ms expected to be basetypes.Int64Value, was: %T`, holdIntervalMsAttribute))
	}

	incrementalSpfDelayMsAttribute, ok := attributes["incremental_spf_delay_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`incremental_spf_delay_ms is missing from object`)

		return NewSpfTimersValueUnknown(), diags
	}

	incrementalSpfDelayMsVal, ok := incrementalSpfDelayMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`incremental_spf_delay_ms expected to be basetypes.Int64Value, was: %T`, incrementalSpfDelayMsAttribute))
	}

	initialDelayMsAttribute, ok := attributes["initial_delay_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`initial_delay_ms is missing from object`)

		return NewSpfTimersValueUnknown(), diags
	}

	initialDelayMsVal, ok := initialDelayMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`initial_delay_ms expected to be basetypes.Int64Value, was: %T`, initialDelayMsAttribute))
	}

	maxDelayMsAttribute, ok := attributes["max_delay_ms"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_delay_ms is missing from object`)

		return NewSpfTimersValueUnknown(), diags
	}

	maxDelayMsVal, ok := maxDelayMsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_delay_ms expected to be basetypes.Int64Value, was: %T`, maxDelayMsAttribute))
	}

	if diags.HasError() {
		return NewSpfTimersValueUnknown(), diags
	}

	return SpfTimersValue{
		HoldIntervalMs:        holdIntervalMsVal,
		IncrementalSpfDelayMs: incrementalSpfDelayMsVal,
		InitialDelayMs:        initialDelayMsVal,
		MaxDelayMs:            maxDelayMsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewSpfTimersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpfTimersValue {
	object, diags := NewSpfTimersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpfTimersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpfTimersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpfTimersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpfTimersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpfTimersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpfTimersValueMust(SpfTimersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpfTimersType) ValueType(ctx context.Context) attr.Value {
	return SpfTimersValue{}
}

var _ basetypes.ObjectValuable = SpfTimersValue{}

type SpfTimersValue struct {
	HoldIntervalMs        basetypes.Int64Value `tfsdk:"hold_interval_ms"`
	IncrementalSpfDelayMs basetypes.Int64Value `tfsdk:"incremental_spf_delay_ms"`
	InitialDelayMs        basetypes.Int64Value `tfsdk:"initial_delay_ms"`
	MaxDelayMs            basetypes.Int64Value `tfsdk:"max_delay_ms"`
	state                 attr.ValueState
}

func (v SpfTimersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["hold_interval_ms"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["incremental_spf_delay_ms"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["initial_delay_ms"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_delay_ms"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.HoldIntervalMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_interval_ms"] = val

		val, err = v.IncrementalSpfDelayMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["incremental_spf_delay_ms"] = val

		val, err = v.InitialDelayMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["initial_delay_ms"] = val

		val, err = v.MaxDelayMs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_delay_ms"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpfTimersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpfTimersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpfTimersValue) String() string {
	return "SpfTimersValue"
}

func (v SpfTimersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"hold_interval_ms":         basetypes.Int64Type{},
		"incremental_spf_delay_ms": basetypes.Int64Type{},
		"initial_delay_ms":         basetypes.Int64Type{},
		"max_delay_ms":             basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"hold_interval_ms":         v.HoldIntervalMs,
			"incremental_spf_delay_ms": v.IncrementalSpfDelayMs,
			"initial_delay_ms":         v.InitialDelayMs,
			"max_delay_ms":             v.MaxDelayMs,
		})

	return objVal, diags
}

func (v SpfTimersValue) Equal(o attr.Value) bool {
	other, ok := o.(SpfTimersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.HoldIntervalMs.Equal(other.HoldIntervalMs) {
		return false
	}

	if !v.IncrementalSpfDelayMs.Equal(other.IncrementalSpfDelayMs) {
		return false
	}

	if !v.InitialDelayMs.Equal(other.InitialDelayMs) {
		return false
	}

	if !v.MaxDelayMs.Equal(other.MaxDelayMs) {
		return false
	}

	return true
}

func (v SpfTimersValue) Type(ctx context.Context) attr.Type {
	return SpfTimersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpfTimersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"hold_interval_ms":         basetypes.Int64Type{},
		"incremental_spf_delay_ms": basetypes.Int64Type{},
		"initial_delay_ms":         basetypes.Int64Type{},
		"max_delay_ms":             basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = RoutingPoliciesType{}

type RoutingPoliciesType struct {
	basetypes.ObjectType
}

func (t RoutingPoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(RoutingPoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RoutingPoliciesType) String() string {
	return "RoutingPoliciesType"
}

func (t RoutingPoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	policiesAttribute, ok := attributes["policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policies is missing from object`)

		return nil, diags
	}

	policiesVal, ok := policiesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policies expected to be basetypes.ListValue, was: %T`, policiesAttribute))
	}

	prefixSetsAttribute, ok := attributes["prefix_sets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_sets is missing from object`)

		return nil, diags
	}

	prefixSetsVal, ok := prefixSetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_sets expected to be basetypes.ListValue, was: %T`, prefixSetsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RoutingPoliciesValue{
		Policies:   policiesVal,
		PrefixSets: prefixSetsVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewRoutingPoliciesValueNull() RoutingPoliciesValue {
	return RoutingPoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewRoutingPoliciesValueUnknown() RoutingPoliciesValue {
	return RoutingPoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRoutingPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RoutingPoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RoutingPoliciesValue Attribute Value",
				"While creating a RoutingPoliciesValue value, a missing attribute value was detected. "+
					"A RoutingPoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingPoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RoutingPoliciesValue Attribute Type",
				"While creating a RoutingPoliciesValue value, an invalid attribute value was detected. "+
					"A RoutingPoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutingPoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RoutingPoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RoutingPoliciesValue Attribute Value",
				"While creating a RoutingPoliciesValue value, an extra attribute value was detected. "+
					"A RoutingPoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RoutingPoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRoutingPoliciesValueUnknown(), diags
	}

	policiesAttribute, ok := attributes["policies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policies is missing from object`)

		return NewRoutingPoliciesValueUnknown(), diags
	}

	policiesVal, ok := policiesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policies expected to be basetypes.ListValue, was: %T`, policiesAttribute))
	}

	prefixSetsAttribute, ok := attributes["prefix_sets"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_sets is missing from object`)

		return NewRoutingPoliciesValueUnknown(), diags
	}

	prefixSetsVal, ok := prefixSetsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_sets expected to be basetypes.ListValue, was: %T`, prefixSetsAttribute))
	}

	if diags.HasError() {
		return NewRoutingPoliciesValueUnknown(), diags
	}

	return RoutingPoliciesValue{
		Policies:   policiesVal,
		PrefixSets: prefixSetsVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewRoutingPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RoutingPoliciesValue {
	object, diags := NewRoutingPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRoutingPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RoutingPoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRoutingPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRoutingPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRoutingPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRoutingPoliciesValueMust(RoutingPoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RoutingPoliciesType) ValueType(ctx context.Context) attr.Value {
	return RoutingPoliciesValue{}
}

var _ basetypes.ObjectValuable = RoutingPoliciesValue{}

type RoutingPoliciesValue struct {
	Policies   basetypes.ListValue `tfsdk:"policies"`
	PrefixSets basetypes.ListValue `tfsdk:"prefix_sets"`
	state      attr.ValueState
}

func (v RoutingPoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["policies"] = basetypes.ListType{
		ElemType: PoliciesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["prefix_sets"] = basetypes.ListType{
		ElemType: PrefixSetsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Policies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policies"] = val

		val, err = v.PrefixSets.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_sets"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RoutingPoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RoutingPoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RoutingPoliciesValue) String() string {
	return "RoutingPoliciesValue"
}

func (v RoutingPoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	policies := types.ListValueMust(
		PoliciesType{
			basetypes.ObjectType{
				AttrTypes: PoliciesValue{}.AttributeTypes(ctx),
			},
		},
		v.Policies.Elements(),
	)

	if v.Policies.IsNull() {
		policies = types.ListNull(
			PoliciesType{
				basetypes.ObjectType{
					AttrTypes: PoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Policies.IsUnknown() {
		policies = types.ListUnknown(
			PoliciesType{
				basetypes.ObjectType{
					AttrTypes: PoliciesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	prefixSets := types.ListValueMust(
		PrefixSetsType{
			basetypes.ObjectType{
				AttrTypes: PrefixSetsValue{}.AttributeTypes(ctx),
			},
		},
		v.PrefixSets.Elements(),
	)

	if v.PrefixSets.IsNull() {
		prefixSets = types.ListNull(
			PrefixSetsType{
				basetypes.ObjectType{
					AttrTypes: PrefixSetsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.PrefixSets.IsUnknown() {
		prefixSets = types.ListUnknown(
			PrefixSetsType{
				basetypes.ObjectType{
					AttrTypes: PrefixSetsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"policies": basetypes.ListType{
			ElemType: PoliciesValue{}.Type(ctx),
		},
		"prefix_sets": basetypes.ListType{
			ElemType: PrefixSetsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"policies":    policies,
			"prefix_sets": prefixSets,
		})

	return objVal, diags
}

func (v RoutingPoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(RoutingPoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Policies.Equal(other.Policies) {
		return false
	}

	if !v.PrefixSets.Equal(other.PrefixSets) {
		return false
	}

	return true
}

func (v RoutingPoliciesValue) Type(ctx context.Context) attr.Type {
	return RoutingPoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RoutingPoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"policies": basetypes.ListType{
			ElemType: PoliciesValue{}.Type(ctx),
		},
		"prefix_sets": basetypes.ListType{
			ElemType: PrefixSetsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PoliciesType{}

type PoliciesType struct {
	basetypes.ObjectType
}

func (t PoliciesType) Equal(o attr.Type) bool {
	other, ok := o.(PoliciesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PoliciesType) String() string {
	return "PoliciesType"
}

func (t PoliciesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec9Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_9 is missing from object`)

		return nil, diags
	}

	spec9Val, ok := spec9Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_9 expected to be basetypes.ObjectValue, was: %T`, spec9Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PoliciesValue{
		Name:  nameVal,
		Spec9: spec9Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPoliciesValueNull() PoliciesValue {
	return PoliciesValue{
		state: attr.ValueStateNull,
	}
}

func NewPoliciesValueUnknown() PoliciesValue {
	return PoliciesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPoliciesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PoliciesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PoliciesValue Attribute Value",
				"While creating a PoliciesValue value, a missing attribute value was detected. "+
					"A PoliciesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PoliciesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PoliciesValue Attribute Type",
				"While creating a PoliciesValue value, an invalid attribute value was detected. "+
					"A PoliciesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PoliciesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PoliciesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PoliciesValue Attribute Value",
				"While creating a PoliciesValue value, an extra attribute value was detected. "+
					"A PoliciesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PoliciesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPoliciesValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPoliciesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec9Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_9 is missing from object`)

		return NewPoliciesValueUnknown(), diags
	}

	spec9Val, ok := spec9Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_9 expected to be basetypes.ObjectValue, was: %T`, spec9Attribute))
	}

	if diags.HasError() {
		return NewPoliciesValueUnknown(), diags
	}

	return PoliciesValue{
		Name:  nameVal,
		Spec9: spec9Val,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPoliciesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PoliciesValue {
	object, diags := NewPoliciesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPoliciesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PoliciesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPoliciesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPoliciesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPoliciesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPoliciesValueMust(PoliciesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PoliciesType) ValueType(ctx context.Context) attr.Value {
	return PoliciesValue{}
}

var _ basetypes.ObjectValuable = PoliciesValue{}

type PoliciesValue struct {
	Name  basetypes.StringValue `tfsdk:"name"`
	Spec9 basetypes.ObjectValue `tfsdk:"spec"`
	state attr.ValueState
}

func (v PoliciesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec9Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Spec9.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PoliciesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PoliciesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PoliciesValue) String() string {
	return "PoliciesValue"
}

func (v PoliciesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spec9 basetypes.ObjectValue

	if v.Spec9.IsNull() {
		spec9 = types.ObjectNull(
			Spec9Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec9.IsUnknown() {
		spec9 = types.ObjectUnknown(
			Spec9Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec9.IsNull() && !v.Spec9.IsUnknown() {
		spec9 = types.ObjectValueMust(
			Spec9Value{}.AttributeTypes(ctx),
			v.Spec9.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec9Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"spec": spec9,
		})

	return objVal, diags
}

func (v PoliciesValue) Equal(o attr.Value) bool {
	other, ok := o.(PoliciesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Spec9.Equal(other.Spec9) {
		return false
	}

	return true
}

func (v PoliciesValue) Type(ctx context.Context) attr.Type {
	return PoliciesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PoliciesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec9Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Spec9Type{}

type Spec9Type struct {
	basetypes.ObjectType
}

func (t Spec9Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec9Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec9Type) String() string {
	return "Spec9Type"
}

func (t Spec9Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configuredNameAttribute, ok := attributes["configured_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_name is missing from object`)

		return nil, diags
	}

	configuredNameVal, ok := configuredNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_name expected to be basetypes.StringValue, was: %T`, configuredNameAttribute))
	}

	defaultActionAttribute, ok := attributes["default_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_action is missing from object`)

		return nil, diags
	}

	defaultActionVal, ok := defaultActionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_action expected to be basetypes.ObjectValue, was: %T`, defaultActionAttribute))
	}

	statementAttribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement is missing from object`)

		return nil, diags
	}

	statementVal, ok := statementAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement expected to be basetypes.ListValue, was: %T`, statementAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec9Value{
		ConfiguredName: configuredNameVal,
		DefaultAction:  defaultActionVal,
		Statement:      statementVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSpec9ValueNull() Spec9Value {
	return Spec9Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec9ValueUnknown() Spec9Value {
	return Spec9Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec9Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec9Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec9Value Attribute Value",
				"While creating a Spec9Value value, a missing attribute value was detected. "+
					"A Spec9Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec9Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec9Value Attribute Type",
				"While creating a Spec9Value value, an invalid attribute value was detected. "+
					"A Spec9Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec9Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec9Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec9Value Attribute Value",
				"While creating a Spec9Value value, an extra attribute value was detected. "+
					"A Spec9Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec9Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec9ValueUnknown(), diags
	}

	configuredNameAttribute, ok := attributes["configured_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_name is missing from object`)

		return NewSpec9ValueUnknown(), diags
	}

	configuredNameVal, ok := configuredNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_name expected to be basetypes.StringValue, was: %T`, configuredNameAttribute))
	}

	defaultActionAttribute, ok := attributes["default_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`default_action is missing from object`)

		return NewSpec9ValueUnknown(), diags
	}

	defaultActionVal, ok := defaultActionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`default_action expected to be basetypes.ObjectValue, was: %T`, defaultActionAttribute))
	}

	statementAttribute, ok := attributes["statement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`statement is missing from object`)

		return NewSpec9ValueUnknown(), diags
	}

	statementVal, ok := statementAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`statement expected to be basetypes.ListValue, was: %T`, statementAttribute))
	}

	if diags.HasError() {
		return NewSpec9ValueUnknown(), diags
	}

	return Spec9Value{
		ConfiguredName: configuredNameVal,
		DefaultAction:  defaultActionVal,
		Statement:      statementVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSpec9ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec9Value {
	object, diags := NewSpec9Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec9ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec9Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec9ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec9ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec9ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec9ValueMust(Spec9Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec9Type) ValueType(ctx context.Context) attr.Value {
	return Spec9Value{}
}

var _ basetypes.ObjectValuable = Spec9Value{}

type Spec9Value struct {
	ConfiguredName basetypes.StringValue `tfsdk:"configured_name"`
	DefaultAction  basetypes.ObjectValue `tfsdk:"default_action"`
	Statement      basetypes.ListValue   `tfsdk:"statement"`
	state          attr.ValueState
}

func (v Spec9Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["configured_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["default_action"] = basetypes.ObjectType{
		AttrTypes: DefaultActionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["statement"] = basetypes.ListType{
		ElemType: StatementValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.ConfiguredName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configured_name"] = val

		val, err = v.DefaultAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["default_action"] = val

		val, err = v.Statement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["statement"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec9Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec9Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec9Value) String() string {
	return "Spec9Value"
}

func (v Spec9Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var defaultAction basetypes.ObjectValue

	if v.DefaultAction.IsNull() {
		defaultAction = types.ObjectNull(
			DefaultActionValue{}.AttributeTypes(ctx),
		)
	}

	if v.DefaultAction.IsUnknown() {
		defaultAction = types.ObjectUnknown(
			DefaultActionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DefaultAction.IsNull() && !v.DefaultAction.IsUnknown() {
		defaultAction = types.ObjectValueMust(
			DefaultActionValue{}.AttributeTypes(ctx),
			v.DefaultAction.Attributes(),
		)
	}

	statement := types.ListValueMust(
		StatementType{
			basetypes.ObjectType{
				AttrTypes: StatementValue{}.AttributeTypes(ctx),
			},
		},
		v.Statement.Elements(),
	)

	if v.Statement.IsNull() {
		statement = types.ListNull(
			StatementType{
				basetypes.ObjectType{
					AttrTypes: StatementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Statement.IsUnknown() {
		statement = types.ListUnknown(
			StatementType{
				basetypes.ObjectType{
					AttrTypes: StatementValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"configured_name": basetypes.StringType{},
		"default_action": basetypes.ObjectType{
			AttrTypes: DefaultActionValue{}.AttributeTypes(ctx),
		},
		"statement": basetypes.ListType{
			ElemType: StatementValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"configured_name": v.ConfiguredName,
			"default_action":  defaultAction,
			"statement":       statement,
		})

	return objVal, diags
}

func (v Spec9Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec9Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConfiguredName.Equal(other.ConfiguredName) {
		return false
	}

	if !v.DefaultAction.Equal(other.DefaultAction) {
		return false
	}

	if !v.Statement.Equal(other.Statement) {
		return false
	}

	return true
}

func (v Spec9Value) Type(ctx context.Context) attr.Type {
	return Spec9Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec9Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"configured_name": basetypes.StringType{},
		"default_action": basetypes.ObjectType{
			AttrTypes: DefaultActionValue{}.AttributeTypes(ctx),
		},
		"statement": basetypes.ListType{
			ElemType: StatementValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DefaultActionType{}

type DefaultActionType struct {
	basetypes.ObjectType
}

func (t DefaultActionType) Equal(o attr.Type) bool {
	other, ok := o.(DefaultActionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DefaultActionType) String() string {
	return "DefaultActionType"
}

func (t DefaultActionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bgp1Attribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_1 is missing from object`)

		return nil, diags
	}

	bgp1Val, ok := bgp1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_1 expected to be basetypes.ObjectValue, was: %T`, bgp1Attribute))
	}

	policyResultAttribute, ok := attributes["policy_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_result is missing from object`)

		return nil, diags
	}

	policyResultVal, ok := policyResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_result expected to be basetypes.StringValue, was: %T`, policyResultAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return nil, diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ObjectValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DefaultActionValue{
		Bgp1:         bgp1Val,
		PolicyResult: policyResultVal,
		Tags:         tagsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDefaultActionValueNull() DefaultActionValue {
	return DefaultActionValue{
		state: attr.ValueStateNull,
	}
}

func NewDefaultActionValueUnknown() DefaultActionValue {
	return DefaultActionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDefaultActionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DefaultActionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DefaultActionValue Attribute Value",
				"While creating a DefaultActionValue value, a missing attribute value was detected. "+
					"A DefaultActionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DefaultActionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DefaultActionValue Attribute Type",
				"While creating a DefaultActionValue value, an invalid attribute value was detected. "+
					"A DefaultActionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DefaultActionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DefaultActionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DefaultActionValue Attribute Value",
				"While creating a DefaultActionValue value, an extra attribute value was detected. "+
					"A DefaultActionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DefaultActionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDefaultActionValueUnknown(), diags
	}

	bgp1Attribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_1 is missing from object`)

		return NewDefaultActionValueUnknown(), diags
	}

	bgp1Val, ok := bgp1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_1 expected to be basetypes.ObjectValue, was: %T`, bgp1Attribute))
	}

	policyResultAttribute, ok := attributes["policy_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_result is missing from object`)

		return NewDefaultActionValueUnknown(), diags
	}

	policyResultVal, ok := policyResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_result expected to be basetypes.StringValue, was: %T`, policyResultAttribute))
	}

	tagsAttribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags is missing from object`)

		return NewDefaultActionValueUnknown(), diags
	}

	tagsVal, ok := tagsAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags expected to be basetypes.ObjectValue, was: %T`, tagsAttribute))
	}

	if diags.HasError() {
		return NewDefaultActionValueUnknown(), diags
	}

	return DefaultActionValue{
		Bgp1:         bgp1Val,
		PolicyResult: policyResultVal,
		Tags:         tagsVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewDefaultActionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DefaultActionValue {
	object, diags := NewDefaultActionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDefaultActionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DefaultActionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDefaultActionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDefaultActionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDefaultActionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDefaultActionValueMust(DefaultActionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DefaultActionType) ValueType(ctx context.Context) attr.Value {
	return DefaultActionValue{}
}

var _ basetypes.ObjectValuable = DefaultActionValue{}

type DefaultActionValue struct {
	Bgp1         basetypes.ObjectValue `tfsdk:"bgp"`
	PolicyResult basetypes.StringValue `tfsdk:"policy_result"`
	Tags         basetypes.ObjectValue `tfsdk:"tags"`
	state        attr.ValueState
}

func (v DefaultActionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["bgp"] = basetypes.ObjectType{
		AttrTypes: Bgp1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["policy_result"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ObjectType{
		AttrTypes: TagsValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Bgp1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp"] = val

		val, err = v.PolicyResult.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_result"] = val

		val, err = v.Tags.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DefaultActionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DefaultActionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DefaultActionValue) String() string {
	return "DefaultActionValue"
}

func (v DefaultActionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bgp1 basetypes.ObjectValue

	if v.Bgp1.IsNull() {
		bgp1 = types.ObjectNull(
			Bgp1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Bgp1.IsUnknown() {
		bgp1 = types.ObjectUnknown(
			Bgp1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Bgp1.IsNull() && !v.Bgp1.IsUnknown() {
		bgp1 = types.ObjectValueMust(
			Bgp1Value{}.AttributeTypes(ctx),
			v.Bgp1.Attributes(),
		)
	}

	var tags basetypes.ObjectValue

	if v.Tags.IsNull() {
		tags = types.ObjectNull(
			TagsValue{}.AttributeTypes(ctx),
		)
	}

	if v.Tags.IsUnknown() {
		tags = types.ObjectUnknown(
			TagsValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Tags.IsNull() && !v.Tags.IsUnknown() {
		tags = types.ObjectValueMust(
			TagsValue{}.AttributeTypes(ctx),
			v.Tags.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: Bgp1Value{}.AttributeTypes(ctx),
		},
		"policy_result": basetypes.StringType{},
		"tags": basetypes.ObjectType{
			AttrTypes: TagsValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bgp":           bgp1,
			"policy_result": v.PolicyResult,
			"tags":          tags,
		})

	return objVal, diags
}

func (v DefaultActionValue) Equal(o attr.Value) bool {
	other, ok := o.(DefaultActionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bgp1.Equal(other.Bgp1) {
		return false
	}

	if !v.PolicyResult.Equal(other.PolicyResult) {
		return false
	}

	if !v.Tags.Equal(other.Tags) {
		return false
	}

	return true
}

func (v DefaultActionValue) Type(ctx context.Context) attr.Type {
	return DefaultActionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DefaultActionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: Bgp1Value{}.AttributeTypes(ctx),
		},
		"policy_result": basetypes.StringType{},
		"tags": basetypes.ObjectType{
			AttrTypes: TagsValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Bgp1Type{}

type Bgp1Type struct {
	basetypes.ObjectType
}

func (t Bgp1Type) Equal(o attr.Type) bool {
	other, ok := o.(Bgp1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Bgp1Type) String() string {
	return "Bgp1Type"
}

func (t Bgp1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathPrependAttribute, ok := attributes["as_path_prepend"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_prepend is missing from object`)

		return nil, diags
	}

	asPathPrependVal, ok := asPathPrependAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_prepend expected to be basetypes.Int64Value, was: %T`, asPathPrependAttribute))
	}

	asPathRemoveAttribute, ok := attributes["as_path_remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_remove is missing from object`)

		return nil, diags
	}

	asPathRemoveVal, ok := asPathRemoveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_remove expected to be basetypes.BoolValue, was: %T`, asPathRemoveAttribute))
	}

	asPathReplaceAttribute, ok := attributes["as_path_replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_replace is missing from object`)

		return nil, diags
	}

	asPathReplaceVal, ok := asPathReplaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_replace expected to be basetypes.ListValue, was: %T`, asPathReplaceAttribute))
	}

	communitySetAttribute, ok := attributes["community_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_set is missing from object`)

		return nil, diags
	}

	communitySetVal, ok := communitySetAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_set expected to be basetypes.ObjectValue, was: %T`, communitySetAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return nil, diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	medAttribute, ok := attributes["med"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`med is missing from object`)

		return nil, diags
	}

	medVal, ok := medAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`med expected to be basetypes.ObjectValue, was: %T`, medAttribute))
	}

	setOriginAttribute, ok := attributes["set_origin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`set_origin is missing from object`)

		return nil, diags
	}

	setOriginVal, ok := setOriginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`set_origin expected to be basetypes.StringValue, was: %T`, setOriginAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Bgp1Value{
		AsPathPrepend:   asPathPrependVal,
		AsPathRemove:    asPathRemoveVal,
		AsPathReplace:   asPathReplaceVal,
		CommunitySet:    communitySetVal,
		LocalPreference: localPreferenceVal,
		Med:             medVal,
		SetOrigin:       setOriginVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBgp1ValueNull() Bgp1Value {
	return Bgp1Value{
		state: attr.ValueStateNull,
	}
}

func NewBgp1ValueUnknown() Bgp1Value {
	return Bgp1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBgp1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Bgp1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Bgp1Value Attribute Value",
				"While creating a Bgp1Value value, a missing attribute value was detected. "+
					"A Bgp1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Bgp1Value Attribute Type",
				"While creating a Bgp1Value value, an invalid attribute value was detected. "+
					"A Bgp1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Bgp1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Bgp1Value Attribute Value",
				"While creating a Bgp1Value value, an extra attribute value was detected. "+
					"A Bgp1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Bgp1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgp1ValueUnknown(), diags
	}

	asPathPrependAttribute, ok := attributes["as_path_prepend"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_prepend is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	asPathPrependVal, ok := asPathPrependAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_prepend expected to be basetypes.Int64Value, was: %T`, asPathPrependAttribute))
	}

	asPathRemoveAttribute, ok := attributes["as_path_remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_remove is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	asPathRemoveVal, ok := asPathRemoveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_remove expected to be basetypes.BoolValue, was: %T`, asPathRemoveAttribute))
	}

	asPathReplaceAttribute, ok := attributes["as_path_replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_replace is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	asPathReplaceVal, ok := asPathReplaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_replace expected to be basetypes.ListValue, was: %T`, asPathReplaceAttribute))
	}

	communitySetAttribute, ok := attributes["community_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_set is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	communitySetVal, ok := communitySetAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_set expected to be basetypes.ObjectValue, was: %T`, communitySetAttribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	medAttribute, ok := attributes["med"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`med is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	medVal, ok := medAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`med expected to be basetypes.ObjectValue, was: %T`, medAttribute))
	}

	setOriginAttribute, ok := attributes["set_origin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`set_origin is missing from object`)

		return NewBgp1ValueUnknown(), diags
	}

	setOriginVal, ok := setOriginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`set_origin expected to be basetypes.StringValue, was: %T`, setOriginAttribute))
	}

	if diags.HasError() {
		return NewBgp1ValueUnknown(), diags
	}

	return Bgp1Value{
		AsPathPrepend:   asPathPrependVal,
		AsPathRemove:    asPathRemoveVal,
		AsPathReplace:   asPathReplaceVal,
		CommunitySet:    communitySetVal,
		LocalPreference: localPreferenceVal,
		Med:             medVal,
		SetOrigin:       setOriginVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBgp1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Bgp1Value {
	object, diags := NewBgp1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgp1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Bgp1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgp1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgp1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgp1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgp1ValueMust(Bgp1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Bgp1Type) ValueType(ctx context.Context) attr.Value {
	return Bgp1Value{}
}

var _ basetypes.ObjectValuable = Bgp1Value{}

type Bgp1Value struct {
	AsPathPrepend   basetypes.Int64Value  `tfsdk:"as_path_prepend"`
	AsPathRemove    basetypes.BoolValue   `tfsdk:"as_path_remove"`
	AsPathReplace   basetypes.ListValue   `tfsdk:"as_path_replace"`
	CommunitySet    basetypes.ObjectValue `tfsdk:"community_set"`
	LocalPreference basetypes.Int64Value  `tfsdk:"local_preference"`
	Med             basetypes.ObjectValue `tfsdk:"med"`
	SetOrigin       basetypes.StringValue `tfsdk:"set_origin"`
	state           attr.ValueState
}

func (v Bgp1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["as_path_prepend"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["as_path_remove"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["as_path_replace"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["community_set"] = basetypes.ObjectType{
		AttrTypes: CommunitySetValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["local_preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["med"] = basetypes.ObjectType{
		AttrTypes: MedValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["set_origin"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AsPathPrepend.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_prepend"] = val

		val, err = v.AsPathRemove.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_remove"] = val

		val, err = v.AsPathReplace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_replace"] = val

		val, err = v.CommunitySet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_set"] = val

		val, err = v.LocalPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_preference"] = val

		val, err = v.Med.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["med"] = val

		val, err = v.SetOrigin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["set_origin"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Bgp1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Bgp1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Bgp1Value) String() string {
	return "Bgp1Value"
}

func (v Bgp1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var communitySet basetypes.ObjectValue

	if v.CommunitySet.IsNull() {
		communitySet = types.ObjectNull(
			CommunitySetValue{}.AttributeTypes(ctx),
		)
	}

	if v.CommunitySet.IsUnknown() {
		communitySet = types.ObjectUnknown(
			CommunitySetValue{}.AttributeTypes(ctx),
		)
	}

	if !v.CommunitySet.IsNull() && !v.CommunitySet.IsUnknown() {
		communitySet = types.ObjectValueMust(
			CommunitySetValue{}.AttributeTypes(ctx),
			v.CommunitySet.Attributes(),
		)
	}

	var med basetypes.ObjectValue

	if v.Med.IsNull() {
		med = types.ObjectNull(
			MedValue{}.AttributeTypes(ctx),
		)
	}

	if v.Med.IsUnknown() {
		med = types.ObjectUnknown(
			MedValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Med.IsNull() && !v.Med.IsUnknown() {
		med = types.ObjectValueMust(
			MedValue{}.AttributeTypes(ctx),
			v.Med.Attributes(),
		)
	}

	var asPathReplaceVal basetypes.ListValue
	switch {
	case v.AsPathReplace.IsUnknown():
		asPathReplaceVal = types.ListUnknown(types.Int64Type)
	case v.AsPathReplace.IsNull():
		asPathReplaceVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		asPathReplaceVal, d = types.ListValue(types.Int64Type, v.AsPathReplace.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_prepend": basetypes.Int64Type{},
			"as_path_remove":  basetypes.BoolType{},
			"as_path_replace": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"community_set": basetypes.ObjectType{
				AttrTypes: CommunitySetValue{}.AttributeTypes(ctx),
			},
			"local_preference": basetypes.Int64Type{},
			"med": basetypes.ObjectType{
				AttrTypes: MedValue{}.AttributeTypes(ctx),
			},
			"set_origin": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"as_path_prepend": basetypes.Int64Type{},
		"as_path_remove":  basetypes.BoolType{},
		"as_path_replace": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"community_set": basetypes.ObjectType{
			AttrTypes: CommunitySetValue{}.AttributeTypes(ctx),
		},
		"local_preference": basetypes.Int64Type{},
		"med": basetypes.ObjectType{
			AttrTypes: MedValue{}.AttributeTypes(ctx),
		},
		"set_origin": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path_prepend":  v.AsPathPrepend,
			"as_path_remove":   v.AsPathRemove,
			"as_path_replace":  asPathReplaceVal,
			"community_set":    communitySet,
			"local_preference": v.LocalPreference,
			"med":              med,
			"set_origin":       v.SetOrigin,
		})

	return objVal, diags
}

func (v Bgp1Value) Equal(o attr.Value) bool {
	other, ok := o.(Bgp1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPathPrepend.Equal(other.AsPathPrepend) {
		return false
	}

	if !v.AsPathRemove.Equal(other.AsPathRemove) {
		return false
	}

	if !v.AsPathReplace.Equal(other.AsPathReplace) {
		return false
	}

	if !v.CommunitySet.Equal(other.CommunitySet) {
		return false
	}

	if !v.LocalPreference.Equal(other.LocalPreference) {
		return false
	}

	if !v.Med.Equal(other.Med) {
		return false
	}

	if !v.SetOrigin.Equal(other.SetOrigin) {
		return false
	}

	return true
}

func (v Bgp1Value) Type(ctx context.Context) attr.Type {
	return Bgp1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Bgp1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path_prepend": basetypes.Int64Type{},
		"as_path_remove":  basetypes.BoolType{},
		"as_path_replace": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"community_set": basetypes.ObjectType{
			AttrTypes: CommunitySetValue{}.AttributeTypes(ctx),
		},
		"local_preference": basetypes.Int64Type{},
		"med": basetypes.ObjectType{
			AttrTypes: MedValue{}.AttributeTypes(ctx),
		},
		"set_origin": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CommunitySetType{}

type CommunitySetType struct {
	basetypes.ObjectType
}

func (t CommunitySetType) Equal(o attr.Type) bool {
	other, ok := o.(CommunitySetType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CommunitySetType) String() string {
	return "CommunitySetType"
}

func (t CommunitySetType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addAttribute, ok := attributes["add"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add is missing from object`)

		return nil, diags
	}

	addVal, ok := addAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add expected to be basetypes.ListValue, was: %T`, addAttribute))
	}

	removeAttribute, ok := attributes["remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove is missing from object`)

		return nil, diags
	}

	removeVal, ok := removeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove expected to be basetypes.ListValue, was: %T`, removeAttribute))
	}

	replaceAttribute, ok := attributes["replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replace is missing from object`)

		return nil, diags
	}

	replaceVal, ok := replaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replace expected to be basetypes.ListValue, was: %T`, replaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CommunitySetValue{
		Add:     addVal,
		Remove:  removeVal,
		Replace: replaceVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCommunitySetValueNull() CommunitySetValue {
	return CommunitySetValue{
		state: attr.ValueStateNull,
	}
}

func NewCommunitySetValueUnknown() CommunitySetValue {
	return CommunitySetValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCommunitySetValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CommunitySetValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CommunitySetValue Attribute Value",
				"While creating a CommunitySetValue value, a missing attribute value was detected. "+
					"A CommunitySetValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CommunitySetValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CommunitySetValue Attribute Type",
				"While creating a CommunitySetValue value, an invalid attribute value was detected. "+
					"A CommunitySetValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CommunitySetValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CommunitySetValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CommunitySetValue Attribute Value",
				"While creating a CommunitySetValue value, an extra attribute value was detected. "+
					"A CommunitySetValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CommunitySetValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCommunitySetValueUnknown(), diags
	}

	addAttribute, ok := attributes["add"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add is missing from object`)

		return NewCommunitySetValueUnknown(), diags
	}

	addVal, ok := addAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add expected to be basetypes.ListValue, was: %T`, addAttribute))
	}

	removeAttribute, ok := attributes["remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove is missing from object`)

		return NewCommunitySetValueUnknown(), diags
	}

	removeVal, ok := removeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove expected to be basetypes.ListValue, was: %T`, removeAttribute))
	}

	replaceAttribute, ok := attributes["replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replace is missing from object`)

		return NewCommunitySetValueUnknown(), diags
	}

	replaceVal, ok := replaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replace expected to be basetypes.ListValue, was: %T`, replaceAttribute))
	}

	if diags.HasError() {
		return NewCommunitySetValueUnknown(), diags
	}

	return CommunitySetValue{
		Add:     addVal,
		Remove:  removeVal,
		Replace: replaceVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCommunitySetValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CommunitySetValue {
	object, diags := NewCommunitySetValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCommunitySetValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CommunitySetType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCommunitySetValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCommunitySetValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCommunitySetValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCommunitySetValueMust(CommunitySetValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CommunitySetType) ValueType(ctx context.Context) attr.Value {
	return CommunitySetValue{}
}

var _ basetypes.ObjectValuable = CommunitySetValue{}

type CommunitySetValue struct {
	Add     basetypes.ListValue `tfsdk:"add"`
	Remove  basetypes.ListValue `tfsdk:"remove"`
	Replace basetypes.ListValue `tfsdk:"replace"`
	state   attr.ValueState
}

func (v CommunitySetValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["add"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["remove"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["replace"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Add.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["add"] = val

		val, err = v.Remove.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove"] = val

		val, err = v.Replace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["replace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CommunitySetValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CommunitySetValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CommunitySetValue) String() string {
	return "CommunitySetValue"
}

func (v CommunitySetValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var addVal basetypes.ListValue
	switch {
	case v.Add.IsUnknown():
		addVal = types.ListUnknown(types.StringType)
	case v.Add.IsNull():
		addVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		addVal, d = types.ListValue(types.StringType, v.Add.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"replace": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var removeVal basetypes.ListValue
	switch {
	case v.Remove.IsUnknown():
		removeVal = types.ListUnknown(types.StringType)
	case v.Remove.IsNull():
		removeVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		removeVal, d = types.ListValue(types.StringType, v.Remove.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"replace": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var replaceVal basetypes.ListValue
	switch {
	case v.Replace.IsUnknown():
		replaceVal = types.ListUnknown(types.StringType)
	case v.Replace.IsNull():
		replaceVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		replaceVal, d = types.ListValue(types.StringType, v.Replace.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"replace": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"add": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remove": basetypes.ListType{
			ElemType: types.StringType,
		},
		"replace": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"add":     addVal,
			"remove":  removeVal,
			"replace": replaceVal,
		})

	return objVal, diags
}

func (v CommunitySetValue) Equal(o attr.Value) bool {
	other, ok := o.(CommunitySetValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Add.Equal(other.Add) {
		return false
	}

	if !v.Remove.Equal(other.Remove) {
		return false
	}

	if !v.Replace.Equal(other.Replace) {
		return false
	}

	return true
}

func (v CommunitySetValue) Type(ctx context.Context) attr.Type {
	return CommunitySetType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CommunitySetValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"add": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remove": basetypes.ListType{
			ElemType: types.StringType,
		},
		"replace": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = MedType{}

type MedType struct {
	basetypes.ObjectType
}

func (t MedType) Equal(o attr.Type) bool {
	other, ok := o.(MedType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MedType) String() string {
	return "MedType"
}

func (t MedType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numericalValueAttribute, ok := attributes["numerical_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`numerical_value is missing from object`)

		return nil, diags
	}

	numericalValueVal, ok := numericalValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`numerical_value expected to be basetypes.Int64Value, was: %T`, numericalValueAttribute))
	}

	operationAttribute, ok := attributes["operation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operation is missing from object`)

		return nil, diags
	}

	operationVal, ok := operationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operation expected to be basetypes.StringValue, was: %T`, operationAttribute))
	}

	valueTypeAttribute, ok := attributes["value_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value_type is missing from object`)

		return nil, diags
	}

	valueTypeVal, ok := valueTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value_type expected to be basetypes.StringValue, was: %T`, valueTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MedValue{
		NumericalValue: numericalValueVal,
		Operation:      operationVal,
		ValueType:      valueTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewMedValueNull() MedValue {
	return MedValue{
		state: attr.ValueStateNull,
	}
}

func NewMedValueUnknown() MedValue {
	return MedValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMedValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MedValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MedValue Attribute Value",
				"While creating a MedValue value, a missing attribute value was detected. "+
					"A MedValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MedValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MedValue Attribute Type",
				"While creating a MedValue value, an invalid attribute value was detected. "+
					"A MedValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MedValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MedValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MedValue Attribute Value",
				"While creating a MedValue value, an extra attribute value was detected. "+
					"A MedValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MedValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMedValueUnknown(), diags
	}

	numericalValueAttribute, ok := attributes["numerical_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`numerical_value is missing from object`)

		return NewMedValueUnknown(), diags
	}

	numericalValueVal, ok := numericalValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`numerical_value expected to be basetypes.Int64Value, was: %T`, numericalValueAttribute))
	}

	operationAttribute, ok := attributes["operation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operation is missing from object`)

		return NewMedValueUnknown(), diags
	}

	operationVal, ok := operationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operation expected to be basetypes.StringValue, was: %T`, operationAttribute))
	}

	valueTypeAttribute, ok := attributes["value_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value_type is missing from object`)

		return NewMedValueUnknown(), diags
	}

	valueTypeVal, ok := valueTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value_type expected to be basetypes.StringValue, was: %T`, valueTypeAttribute))
	}

	if diags.HasError() {
		return NewMedValueUnknown(), diags
	}

	return MedValue{
		NumericalValue: numericalValueVal,
		Operation:      operationVal,
		ValueType:      valueTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewMedValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MedValue {
	object, diags := NewMedValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMedValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MedType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMedValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMedValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMedValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMedValueMust(MedValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MedType) ValueType(ctx context.Context) attr.Value {
	return MedValue{}
}

var _ basetypes.ObjectValuable = MedValue{}

type MedValue struct {
	NumericalValue basetypes.Int64Value  `tfsdk:"numerical_value"`
	Operation      basetypes.StringValue `tfsdk:"operation"`
	ValueType      basetypes.StringValue `tfsdk:"value_type"`
	state          attr.ValueState
}

func (v MedValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["numerical_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["operation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.NumericalValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["numerical_value"] = val

		val, err = v.Operation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operation"] = val

		val, err = v.ValueType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MedValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MedValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MedValue) String() string {
	return "MedValue"
}

func (v MedValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"numerical_value": basetypes.Int64Type{},
		"operation":       basetypes.StringType{},
		"value_type":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"numerical_value": v.NumericalValue,
			"operation":       v.Operation,
			"value_type":      v.ValueType,
		})

	return objVal, diags
}

func (v MedValue) Equal(o attr.Value) bool {
	other, ok := o.(MedValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumericalValue.Equal(other.NumericalValue) {
		return false
	}

	if !v.Operation.Equal(other.Operation) {
		return false
	}

	if !v.ValueType.Equal(other.ValueType) {
		return false
	}

	return true
}

func (v MedValue) Type(ctx context.Context) attr.Type {
	return MedType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MedValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"numerical_value": basetypes.Int64Type{},
		"operation":       basetypes.StringType{},
		"value_type":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TagsType{}

type TagsType struct {
	basetypes.ObjectType
}

func (t TagsType) Equal(o attr.Type) bool {
	other, ok := o.(TagsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TagsType) String() string {
	return "TagsType"
}

func (t TagsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	tagSetAttribute, ok := attributes["tag_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag_set is missing from object`)

		return nil, diags
	}

	tagSetVal, ok := tagSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag_set expected to be basetypes.StringValue, was: %T`, tagSetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TagsValue{
		TagSet: tagSetVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTagsValueNull() TagsValue {
	return TagsValue{
		state: attr.ValueStateNull,
	}
}

func NewTagsValueUnknown() TagsValue {
	return TagsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTagsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TagsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TagsValue Attribute Value",
				"While creating a TagsValue value, a missing attribute value was detected. "+
					"A TagsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TagsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TagsValue Attribute Type",
				"While creating a TagsValue value, an invalid attribute value was detected. "+
					"A TagsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TagsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TagsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TagsValue Attribute Value",
				"While creating a TagsValue value, an extra attribute value was detected. "+
					"A TagsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TagsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTagsValueUnknown(), diags
	}

	tagSetAttribute, ok := attributes["tag_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag_set is missing from object`)

		return NewTagsValueUnknown(), diags
	}

	tagSetVal, ok := tagSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag_set expected to be basetypes.StringValue, was: %T`, tagSetAttribute))
	}

	if diags.HasError() {
		return NewTagsValueUnknown(), diags
	}

	return TagsValue{
		TagSet: tagSetVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTagsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TagsValue {
	object, diags := NewTagsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTagsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TagsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTagsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTagsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTagsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTagsValueMust(TagsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TagsType) ValueType(ctx context.Context) attr.Value {
	return TagsValue{}
}

var _ basetypes.ObjectValuable = TagsValue{}

type TagsValue struct {
	TagSet basetypes.StringValue `tfsdk:"tag_set"`
	state  attr.ValueState
}

func (v TagsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["tag_set"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.TagSet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tag_set"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TagsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TagsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TagsValue) String() string {
	return "TagsValue"
}

func (v TagsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"tag_set": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"tag_set": v.TagSet,
		})

	return objVal, diags
}

func (v TagsValue) Equal(o attr.Value) bool {
	other, ok := o.(TagsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.TagSet.Equal(other.TagSet) {
		return false
	}

	return true
}

func (v TagsValue) Type(ctx context.Context) attr.Type {
	return TagsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TagsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"tag_set": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = StatementType{}

type StatementType struct {
	basetypes.ObjectType
}

func (t StatementType) Equal(o attr.Type) bool {
	other, ok := o.(StatementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatementType) String() string {
	return "StatementType"
}

func (t StatementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.ObjectValue, was: %T`, actionAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return nil, diags
	}

	matchVal, ok := matchAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.ObjectValue, was: %T`, matchAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatementValue{
		Action: actionVal,
		Match:  matchVal,
		Name:   nameVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewStatementValueNull() StatementValue {
	return StatementValue{
		state: attr.ValueStateNull,
	}
}

func NewStatementValueUnknown() StatementValue {
	return StatementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatementValue Attribute Value",
				"While creating a StatementValue value, a missing attribute value was detected. "+
					"A StatementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatementValue Attribute Type",
				"While creating a StatementValue value, an invalid attribute value was detected. "+
					"A StatementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatementValue Attribute Value",
				"While creating a StatementValue value, an extra attribute value was detected. "+
					"A StatementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatementValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.ObjectValue, was: %T`, actionAttribute))
	}

	matchAttribute, ok := attributes["match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	matchVal, ok := matchAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match expected to be basetypes.ObjectValue, was: %T`, matchAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewStatementValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	if diags.HasError() {
		return NewStatementValueUnknown(), diags
	}

	return StatementValue{
		Action: actionVal,
		Match:  matchVal,
		Name:   nameVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewStatementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatementValue {
	object, diags := NewStatementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatementValueMust(StatementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatementType) ValueType(ctx context.Context) attr.Value {
	return StatementValue{}
}

var _ basetypes.ObjectValuable = StatementValue{}

type StatementValue struct {
	Action basetypes.ObjectValue `tfsdk:"action"`
	Match  basetypes.ObjectValue `tfsdk:"match"`
	Name   basetypes.StringValue `tfsdk:"name"`
	state  attr.ValueState
}

func (v StatementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.ObjectType{
		AttrTypes: ActionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["match"] = basetypes.ObjectType{
		AttrTypes: MatchValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.Match.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatementValue) String() string {
	return "StatementValue"
}

func (v StatementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var action basetypes.ObjectValue

	if v.Action.IsNull() {
		action = types.ObjectNull(
			ActionValue{}.AttributeTypes(ctx),
		)
	}

	if v.Action.IsUnknown() {
		action = types.ObjectUnknown(
			ActionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Action.IsNull() && !v.Action.IsUnknown() {
		action = types.ObjectValueMust(
			ActionValue{}.AttributeTypes(ctx),
			v.Action.Attributes(),
		)
	}

	var match basetypes.ObjectValue

	if v.Match.IsNull() {
		match = types.ObjectNull(
			MatchValue{}.AttributeTypes(ctx),
		)
	}

	if v.Match.IsUnknown() {
		match = types.ObjectUnknown(
			MatchValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Match.IsNull() && !v.Match.IsUnknown() {
		match = types.ObjectValueMust(
			MatchValue{}.AttributeTypes(ctx),
			v.Match.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"action": basetypes.ObjectType{
			AttrTypes: ActionValue{}.AttributeTypes(ctx),
		},
		"match": basetypes.ObjectType{
			AttrTypes: MatchValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action": action,
			"match":  match,
			"name":   v.Name,
		})

	return objVal, diags
}

func (v StatementValue) Equal(o attr.Value) bool {
	other, ok := o.(StatementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.Match.Equal(other.Match) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	return true
}

func (v StatementValue) Type(ctx context.Context) attr.Type {
	return StatementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action": basetypes.ObjectType{
			AttrTypes: ActionValue{}.AttributeTypes(ctx),
		},
		"match": basetypes.ObjectType{
			AttrTypes: MatchValue{}.AttributeTypes(ctx),
		},
		"name": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ActionType{}

type ActionType struct {
	basetypes.ObjectType
}

func (t ActionType) Equal(o attr.Type) bool {
	other, ok := o.(ActionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ActionType) String() string {
	return "ActionType"
}

func (t ActionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bgp2Attribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_2 is missing from object`)

		return nil, diags
	}

	bgp2Val, ok := bgp2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_2 expected to be basetypes.ObjectValue, was: %T`, bgp2Attribute))
	}

	policyResultAttribute, ok := attributes["policy_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_result is missing from object`)

		return nil, diags
	}

	policyResultVal, ok := policyResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_result expected to be basetypes.StringValue, was: %T`, policyResultAttribute))
	}

	tags1Attribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags_1 is missing from object`)

		return nil, diags
	}

	tags1Val, ok := tags1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags_1 expected to be basetypes.ObjectValue, was: %T`, tags1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ActionValue{
		Bgp2:         bgp2Val,
		PolicyResult: policyResultVal,
		Tags1:        tags1Val,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewActionValueNull() ActionValue {
	return ActionValue{
		state: attr.ValueStateNull,
	}
}

func NewActionValueUnknown() ActionValue {
	return ActionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewActionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ActionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ActionValue Attribute Value",
				"While creating a ActionValue value, a missing attribute value was detected. "+
					"A ActionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ActionValue Attribute Type",
				"While creating a ActionValue value, an invalid attribute value was detected. "+
					"A ActionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ActionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ActionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ActionValue Attribute Value",
				"While creating a ActionValue value, an extra attribute value was detected. "+
					"A ActionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ActionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewActionValueUnknown(), diags
	}

	bgp2Attribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_2 is missing from object`)

		return NewActionValueUnknown(), diags
	}

	bgp2Val, ok := bgp2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_2 expected to be basetypes.ObjectValue, was: %T`, bgp2Attribute))
	}

	policyResultAttribute, ok := attributes["policy_result"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`policy_result is missing from object`)

		return NewActionValueUnknown(), diags
	}

	policyResultVal, ok := policyResultAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`policy_result expected to be basetypes.StringValue, was: %T`, policyResultAttribute))
	}

	tags1Attribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags_1 is missing from object`)

		return NewActionValueUnknown(), diags
	}

	tags1Val, ok := tags1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags_1 expected to be basetypes.ObjectValue, was: %T`, tags1Attribute))
	}

	if diags.HasError() {
		return NewActionValueUnknown(), diags
	}

	return ActionValue{
		Bgp2:         bgp2Val,
		PolicyResult: policyResultVal,
		Tags1:        tags1Val,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewActionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ActionValue {
	object, diags := NewActionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewActionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ActionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewActionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewActionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewActionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewActionValueMust(ActionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ActionType) ValueType(ctx context.Context) attr.Value {
	return ActionValue{}
}

var _ basetypes.ObjectValuable = ActionValue{}

type ActionValue struct {
	Bgp2         basetypes.ObjectValue `tfsdk:"bgp"`
	PolicyResult basetypes.StringValue `tfsdk:"policy_result"`
	Tags1        basetypes.ObjectValue `tfsdk:"tags"`
	state        attr.ValueState
}

func (v ActionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["bgp"] = basetypes.ObjectType{
		AttrTypes: Bgp2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["policy_result"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ObjectType{
		AttrTypes: Tags1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Bgp2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp"] = val

		val, err = v.PolicyResult.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["policy_result"] = val

		val, err = v.Tags1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ActionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ActionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ActionValue) String() string {
	return "ActionValue"
}

func (v ActionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bgp2 basetypes.ObjectValue

	if v.Bgp2.IsNull() {
		bgp2 = types.ObjectNull(
			Bgp2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Bgp2.IsUnknown() {
		bgp2 = types.ObjectUnknown(
			Bgp2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Bgp2.IsNull() && !v.Bgp2.IsUnknown() {
		bgp2 = types.ObjectValueMust(
			Bgp2Value{}.AttributeTypes(ctx),
			v.Bgp2.Attributes(),
		)
	}

	var tags1 basetypes.ObjectValue

	if v.Tags1.IsNull() {
		tags1 = types.ObjectNull(
			Tags1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Tags1.IsUnknown() {
		tags1 = types.ObjectUnknown(
			Tags1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Tags1.IsNull() && !v.Tags1.IsUnknown() {
		tags1 = types.ObjectValueMust(
			Tags1Value{}.AttributeTypes(ctx),
			v.Tags1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: Bgp2Value{}.AttributeTypes(ctx),
		},
		"policy_result": basetypes.StringType{},
		"tags": basetypes.ObjectType{
			AttrTypes: Tags1Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bgp":           bgp2,
			"policy_result": v.PolicyResult,
			"tags":          tags1,
		})

	return objVal, diags
}

func (v ActionValue) Equal(o attr.Value) bool {
	other, ok := o.(ActionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bgp2.Equal(other.Bgp2) {
		return false
	}

	if !v.PolicyResult.Equal(other.PolicyResult) {
		return false
	}

	if !v.Tags1.Equal(other.Tags1) {
		return false
	}

	return true
}

func (v ActionValue) Type(ctx context.Context) attr.Type {
	return ActionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ActionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: Bgp2Value{}.AttributeTypes(ctx),
		},
		"policy_result": basetypes.StringType{},
		"tags": basetypes.ObjectType{
			AttrTypes: Tags1Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Bgp2Type{}

type Bgp2Type struct {
	basetypes.ObjectType
}

func (t Bgp2Type) Equal(o attr.Type) bool {
	other, ok := o.(Bgp2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Bgp2Type) String() string {
	return "Bgp2Type"
}

func (t Bgp2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathPrependAttribute, ok := attributes["as_path_prepend"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_prepend is missing from object`)

		return nil, diags
	}

	asPathPrependVal, ok := asPathPrependAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_prepend expected to be basetypes.Int64Value, was: %T`, asPathPrependAttribute))
	}

	asPathRemoveAttribute, ok := attributes["as_path_remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_remove is missing from object`)

		return nil, diags
	}

	asPathRemoveVal, ok := asPathRemoveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_remove expected to be basetypes.BoolValue, was: %T`, asPathRemoveAttribute))
	}

	asPathReplaceAttribute, ok := attributes["as_path_replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_replace is missing from object`)

		return nil, diags
	}

	asPathReplaceVal, ok := asPathReplaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_replace expected to be basetypes.ListValue, was: %T`, asPathReplaceAttribute))
	}

	communitySet1Attribute, ok := attributes["community_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_set_1 is missing from object`)

		return nil, diags
	}

	communitySet1Val, ok := communitySet1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_set_1 expected to be basetypes.ObjectValue, was: %T`, communitySet1Attribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return nil, diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	med1Attribute, ok := attributes["med"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`med_1 is missing from object`)

		return nil, diags
	}

	med1Val, ok := med1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`med_1 expected to be basetypes.ObjectValue, was: %T`, med1Attribute))
	}

	setOriginAttribute, ok := attributes["set_origin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`set_origin is missing from object`)

		return nil, diags
	}

	setOriginVal, ok := setOriginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`set_origin expected to be basetypes.StringValue, was: %T`, setOriginAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Bgp2Value{
		AsPathPrepend:   asPathPrependVal,
		AsPathRemove:    asPathRemoveVal,
		AsPathReplace:   asPathReplaceVal,
		CommunitySet1:   communitySet1Val,
		LocalPreference: localPreferenceVal,
		Med1:            med1Val,
		SetOrigin:       setOriginVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBgp2ValueNull() Bgp2Value {
	return Bgp2Value{
		state: attr.ValueStateNull,
	}
}

func NewBgp2ValueUnknown() Bgp2Value {
	return Bgp2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBgp2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Bgp2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Bgp2Value Attribute Value",
				"While creating a Bgp2Value value, a missing attribute value was detected. "+
					"A Bgp2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Bgp2Value Attribute Type",
				"While creating a Bgp2Value value, an invalid attribute value was detected. "+
					"A Bgp2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Bgp2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Bgp2Value Attribute Value",
				"While creating a Bgp2Value value, an extra attribute value was detected. "+
					"A Bgp2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Bgp2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgp2ValueUnknown(), diags
	}

	asPathPrependAttribute, ok := attributes["as_path_prepend"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_prepend is missing from object`)

		return NewBgp2ValueUnknown(), diags
	}

	asPathPrependVal, ok := asPathPrependAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_prepend expected to be basetypes.Int64Value, was: %T`, asPathPrependAttribute))
	}

	asPathRemoveAttribute, ok := attributes["as_path_remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_remove is missing from object`)

		return NewBgp2ValueUnknown(), diags
	}

	asPathRemoveVal, ok := asPathRemoveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_remove expected to be basetypes.BoolValue, was: %T`, asPathRemoveAttribute))
	}

	asPathReplaceAttribute, ok := attributes["as_path_replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_replace is missing from object`)

		return NewBgp2ValueUnknown(), diags
	}

	asPathReplaceVal, ok := asPathReplaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_replace expected to be basetypes.ListValue, was: %T`, asPathReplaceAttribute))
	}

	communitySet1Attribute, ok := attributes["community_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_set_1 is missing from object`)

		return NewBgp2ValueUnknown(), diags
	}

	communitySet1Val, ok := communitySet1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_set_1 expected to be basetypes.ObjectValue, was: %T`, communitySet1Attribute))
	}

	localPreferenceAttribute, ok := attributes["local_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_preference is missing from object`)

		return NewBgp2ValueUnknown(), diags
	}

	localPreferenceVal, ok := localPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_preference expected to be basetypes.Int64Value, was: %T`, localPreferenceAttribute))
	}

	med1Attribute, ok := attributes["med"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`med_1 is missing from object`)

		return NewBgp2ValueUnknown(), diags
	}

	med1Val, ok := med1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`med_1 expected to be basetypes.ObjectValue, was: %T`, med1Attribute))
	}

	setOriginAttribute, ok := attributes["set_origin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`set_origin is missing from object`)

		return NewBgp2ValueUnknown(), diags
	}

	setOriginVal, ok := setOriginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`set_origin expected to be basetypes.StringValue, was: %T`, setOriginAttribute))
	}

	if diags.HasError() {
		return NewBgp2ValueUnknown(), diags
	}

	return Bgp2Value{
		AsPathPrepend:   asPathPrependVal,
		AsPathRemove:    asPathRemoveVal,
		AsPathReplace:   asPathReplaceVal,
		CommunitySet1:   communitySet1Val,
		LocalPreference: localPreferenceVal,
		Med1:            med1Val,
		SetOrigin:       setOriginVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewBgp2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Bgp2Value {
	object, diags := NewBgp2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgp2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Bgp2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgp2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgp2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgp2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgp2ValueMust(Bgp2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Bgp2Type) ValueType(ctx context.Context) attr.Value {
	return Bgp2Value{}
}

var _ basetypes.ObjectValuable = Bgp2Value{}

type Bgp2Value struct {
	AsPathPrepend   basetypes.Int64Value  `tfsdk:"as_path_prepend"`
	AsPathRemove    basetypes.BoolValue   `tfsdk:"as_path_remove"`
	AsPathReplace   basetypes.ListValue   `tfsdk:"as_path_replace"`
	CommunitySet1   basetypes.ObjectValue `tfsdk:"community_set"`
	LocalPreference basetypes.Int64Value  `tfsdk:"local_preference"`
	Med1            basetypes.ObjectValue `tfsdk:"med"`
	SetOrigin       basetypes.StringValue `tfsdk:"set_origin"`
	state           attr.ValueState
}

func (v Bgp2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 7)

	var val tftypes.Value
	var err error

	attrTypes["as_path_prepend"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["as_path_remove"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["as_path_replace"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)
	attrTypes["community_set"] = basetypes.ObjectType{
		AttrTypes: CommunitySet1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["local_preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["med"] = basetypes.ObjectType{
		AttrTypes: Med1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["set_origin"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 7)

		val, err = v.AsPathPrepend.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_prepend"] = val

		val, err = v.AsPathRemove.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_remove"] = val

		val, err = v.AsPathReplace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_replace"] = val

		val, err = v.CommunitySet1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_set"] = val

		val, err = v.LocalPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_preference"] = val

		val, err = v.Med1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["med"] = val

		val, err = v.SetOrigin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["set_origin"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Bgp2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Bgp2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Bgp2Value) String() string {
	return "Bgp2Value"
}

func (v Bgp2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var communitySet1 basetypes.ObjectValue

	if v.CommunitySet1.IsNull() {
		communitySet1 = types.ObjectNull(
			CommunitySet1Value{}.AttributeTypes(ctx),
		)
	}

	if v.CommunitySet1.IsUnknown() {
		communitySet1 = types.ObjectUnknown(
			CommunitySet1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.CommunitySet1.IsNull() && !v.CommunitySet1.IsUnknown() {
		communitySet1 = types.ObjectValueMust(
			CommunitySet1Value{}.AttributeTypes(ctx),
			v.CommunitySet1.Attributes(),
		)
	}

	var med1 basetypes.ObjectValue

	if v.Med1.IsNull() {
		med1 = types.ObjectNull(
			Med1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Med1.IsUnknown() {
		med1 = types.ObjectUnknown(
			Med1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Med1.IsNull() && !v.Med1.IsUnknown() {
		med1 = types.ObjectValueMust(
			Med1Value{}.AttributeTypes(ctx),
			v.Med1.Attributes(),
		)
	}

	var asPathReplaceVal basetypes.ListValue
	switch {
	case v.AsPathReplace.IsUnknown():
		asPathReplaceVal = types.ListUnknown(types.Int64Type)
	case v.AsPathReplace.IsNull():
		asPathReplaceVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		asPathReplaceVal, d = types.ListValue(types.Int64Type, v.AsPathReplace.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_prepend": basetypes.Int64Type{},
			"as_path_remove":  basetypes.BoolType{},
			"as_path_replace": basetypes.ListType{
				ElemType: types.Int64Type,
			},
			"community_set": basetypes.ObjectType{
				AttrTypes: CommunitySet1Value{}.AttributeTypes(ctx),
			},
			"local_preference": basetypes.Int64Type{},
			"med": basetypes.ObjectType{
				AttrTypes: Med1Value{}.AttributeTypes(ctx),
			},
			"set_origin": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"as_path_prepend": basetypes.Int64Type{},
		"as_path_remove":  basetypes.BoolType{},
		"as_path_replace": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"community_set": basetypes.ObjectType{
			AttrTypes: CommunitySet1Value{}.AttributeTypes(ctx),
		},
		"local_preference": basetypes.Int64Type{},
		"med": basetypes.ObjectType{
			AttrTypes: Med1Value{}.AttributeTypes(ctx),
		},
		"set_origin": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path_prepend":  v.AsPathPrepend,
			"as_path_remove":   v.AsPathRemove,
			"as_path_replace":  asPathReplaceVal,
			"community_set":    communitySet1,
			"local_preference": v.LocalPreference,
			"med":              med1,
			"set_origin":       v.SetOrigin,
		})

	return objVal, diags
}

func (v Bgp2Value) Equal(o attr.Value) bool {
	other, ok := o.(Bgp2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPathPrepend.Equal(other.AsPathPrepend) {
		return false
	}

	if !v.AsPathRemove.Equal(other.AsPathRemove) {
		return false
	}

	if !v.AsPathReplace.Equal(other.AsPathReplace) {
		return false
	}

	if !v.CommunitySet1.Equal(other.CommunitySet1) {
		return false
	}

	if !v.LocalPreference.Equal(other.LocalPreference) {
		return false
	}

	if !v.Med1.Equal(other.Med1) {
		return false
	}

	if !v.SetOrigin.Equal(other.SetOrigin) {
		return false
	}

	return true
}

func (v Bgp2Value) Type(ctx context.Context) attr.Type {
	return Bgp2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Bgp2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path_prepend": basetypes.Int64Type{},
		"as_path_remove":  basetypes.BoolType{},
		"as_path_replace": basetypes.ListType{
			ElemType: types.Int64Type,
		},
		"community_set": basetypes.ObjectType{
			AttrTypes: CommunitySet1Value{}.AttributeTypes(ctx),
		},
		"local_preference": basetypes.Int64Type{},
		"med": basetypes.ObjectType{
			AttrTypes: Med1Value{}.AttributeTypes(ctx),
		},
		"set_origin": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CommunitySet1Type{}

type CommunitySet1Type struct {
	basetypes.ObjectType
}

func (t CommunitySet1Type) Equal(o attr.Type) bool {
	other, ok := o.(CommunitySet1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CommunitySet1Type) String() string {
	return "CommunitySet1Type"
}

func (t CommunitySet1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	addAttribute, ok := attributes["add"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add is missing from object`)

		return nil, diags
	}

	addVal, ok := addAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add expected to be basetypes.ListValue, was: %T`, addAttribute))
	}

	removeAttribute, ok := attributes["remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove is missing from object`)

		return nil, diags
	}

	removeVal, ok := removeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove expected to be basetypes.ListValue, was: %T`, removeAttribute))
	}

	replaceAttribute, ok := attributes["replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replace is missing from object`)

		return nil, diags
	}

	replaceVal, ok := replaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replace expected to be basetypes.ListValue, was: %T`, replaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CommunitySet1Value{
		Add:     addVal,
		Remove:  removeVal,
		Replace: replaceVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCommunitySet1ValueNull() CommunitySet1Value {
	return CommunitySet1Value{
		state: attr.ValueStateNull,
	}
}

func NewCommunitySet1ValueUnknown() CommunitySet1Value {
	return CommunitySet1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewCommunitySet1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CommunitySet1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CommunitySet1Value Attribute Value",
				"While creating a CommunitySet1Value value, a missing attribute value was detected. "+
					"A CommunitySet1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CommunitySet1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CommunitySet1Value Attribute Type",
				"While creating a CommunitySet1Value value, an invalid attribute value was detected. "+
					"A CommunitySet1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CommunitySet1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CommunitySet1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CommunitySet1Value Attribute Value",
				"While creating a CommunitySet1Value value, an extra attribute value was detected. "+
					"A CommunitySet1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CommunitySet1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCommunitySet1ValueUnknown(), diags
	}

	addAttribute, ok := attributes["add"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`add is missing from object`)

		return NewCommunitySet1ValueUnknown(), diags
	}

	addVal, ok := addAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`add expected to be basetypes.ListValue, was: %T`, addAttribute))
	}

	removeAttribute, ok := attributes["remove"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remove is missing from object`)

		return NewCommunitySet1ValueUnknown(), diags
	}

	removeVal, ok := removeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remove expected to be basetypes.ListValue, was: %T`, removeAttribute))
	}

	replaceAttribute, ok := attributes["replace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`replace is missing from object`)

		return NewCommunitySet1ValueUnknown(), diags
	}

	replaceVal, ok := replaceAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`replace expected to be basetypes.ListValue, was: %T`, replaceAttribute))
	}

	if diags.HasError() {
		return NewCommunitySet1ValueUnknown(), diags
	}

	return CommunitySet1Value{
		Add:     addVal,
		Remove:  removeVal,
		Replace: replaceVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewCommunitySet1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CommunitySet1Value {
	object, diags := NewCommunitySet1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCommunitySet1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CommunitySet1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCommunitySet1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCommunitySet1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCommunitySet1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCommunitySet1ValueMust(CommunitySet1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t CommunitySet1Type) ValueType(ctx context.Context) attr.Value {
	return CommunitySet1Value{}
}

var _ basetypes.ObjectValuable = CommunitySet1Value{}

type CommunitySet1Value struct {
	Add     basetypes.ListValue `tfsdk:"add"`
	Remove  basetypes.ListValue `tfsdk:"remove"`
	Replace basetypes.ListValue `tfsdk:"replace"`
	state   attr.ValueState
}

func (v CommunitySet1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["add"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["remove"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["replace"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Add.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["add"] = val

		val, err = v.Remove.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remove"] = val

		val, err = v.Replace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["replace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CommunitySet1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CommunitySet1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CommunitySet1Value) String() string {
	return "CommunitySet1Value"
}

func (v CommunitySet1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var addVal basetypes.ListValue
	switch {
	case v.Add.IsUnknown():
		addVal = types.ListUnknown(types.StringType)
	case v.Add.IsNull():
		addVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		addVal, d = types.ListValue(types.StringType, v.Add.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"replace": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var removeVal basetypes.ListValue
	switch {
	case v.Remove.IsUnknown():
		removeVal = types.ListUnknown(types.StringType)
	case v.Remove.IsNull():
		removeVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		removeVal, d = types.ListValue(types.StringType, v.Remove.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"replace": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var replaceVal basetypes.ListValue
	switch {
	case v.Replace.IsUnknown():
		replaceVal = types.ListUnknown(types.StringType)
	case v.Replace.IsNull():
		replaceVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		replaceVal, d = types.ListValue(types.StringType, v.Replace.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"add": basetypes.ListType{
				ElemType: types.StringType,
			},
			"remove": basetypes.ListType{
				ElemType: types.StringType,
			},
			"replace": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"add": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remove": basetypes.ListType{
			ElemType: types.StringType,
		},
		"replace": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"add":     addVal,
			"remove":  removeVal,
			"replace": replaceVal,
		})

	return objVal, diags
}

func (v CommunitySet1Value) Equal(o attr.Value) bool {
	other, ok := o.(CommunitySet1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Add.Equal(other.Add) {
		return false
	}

	if !v.Remove.Equal(other.Remove) {
		return false
	}

	if !v.Replace.Equal(other.Replace) {
		return false
	}

	return true
}

func (v CommunitySet1Value) Type(ctx context.Context) attr.Type {
	return CommunitySet1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CommunitySet1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"add": basetypes.ListType{
			ElemType: types.StringType,
		},
		"remove": basetypes.ListType{
			ElemType: types.StringType,
		},
		"replace": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Med1Type{}

type Med1Type struct {
	basetypes.ObjectType
}

func (t Med1Type) Equal(o attr.Type) bool {
	other, ok := o.(Med1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Med1Type) String() string {
	return "Med1Type"
}

func (t Med1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	numericalValueAttribute, ok := attributes["numerical_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`numerical_value is missing from object`)

		return nil, diags
	}

	numericalValueVal, ok := numericalValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`numerical_value expected to be basetypes.Int64Value, was: %T`, numericalValueAttribute))
	}

	operationAttribute, ok := attributes["operation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operation is missing from object`)

		return nil, diags
	}

	operationVal, ok := operationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operation expected to be basetypes.StringValue, was: %T`, operationAttribute))
	}

	valueTypeAttribute, ok := attributes["value_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value_type is missing from object`)

		return nil, diags
	}

	valueTypeVal, ok := valueTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value_type expected to be basetypes.StringValue, was: %T`, valueTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Med1Value{
		NumericalValue: numericalValueVal,
		Operation:      operationVal,
		ValueType:      valueTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewMed1ValueNull() Med1Value {
	return Med1Value{
		state: attr.ValueStateNull,
	}
}

func NewMed1ValueUnknown() Med1Value {
	return Med1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewMed1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Med1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Med1Value Attribute Value",
				"While creating a Med1Value value, a missing attribute value was detected. "+
					"A Med1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Med1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Med1Value Attribute Type",
				"While creating a Med1Value value, an invalid attribute value was detected. "+
					"A Med1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Med1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Med1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Med1Value Attribute Value",
				"While creating a Med1Value value, an extra attribute value was detected. "+
					"A Med1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Med1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMed1ValueUnknown(), diags
	}

	numericalValueAttribute, ok := attributes["numerical_value"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`numerical_value is missing from object`)

		return NewMed1ValueUnknown(), diags
	}

	numericalValueVal, ok := numericalValueAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`numerical_value expected to be basetypes.Int64Value, was: %T`, numericalValueAttribute))
	}

	operationAttribute, ok := attributes["operation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operation is missing from object`)

		return NewMed1ValueUnknown(), diags
	}

	operationVal, ok := operationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operation expected to be basetypes.StringValue, was: %T`, operationAttribute))
	}

	valueTypeAttribute, ok := attributes["value_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value_type is missing from object`)

		return NewMed1ValueUnknown(), diags
	}

	valueTypeVal, ok := valueTypeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value_type expected to be basetypes.StringValue, was: %T`, valueTypeAttribute))
	}

	if diags.HasError() {
		return NewMed1ValueUnknown(), diags
	}

	return Med1Value{
		NumericalValue: numericalValueVal,
		Operation:      operationVal,
		ValueType:      valueTypeVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewMed1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Med1Value {
	object, diags := NewMed1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMed1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Med1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMed1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMed1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMed1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMed1ValueMust(Med1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Med1Type) ValueType(ctx context.Context) attr.Value {
	return Med1Value{}
}

var _ basetypes.ObjectValuable = Med1Value{}

type Med1Value struct {
	NumericalValue basetypes.Int64Value  `tfsdk:"numerical_value"`
	Operation      basetypes.StringValue `tfsdk:"operation"`
	ValueType      basetypes.StringValue `tfsdk:"value_type"`
	state          attr.ValueState
}

func (v Med1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["numerical_value"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["operation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value_type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.NumericalValue.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["numerical_value"] = val

		val, err = v.Operation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operation"] = val

		val, err = v.ValueType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Med1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Med1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Med1Value) String() string {
	return "Med1Value"
}

func (v Med1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"numerical_value": basetypes.Int64Type{},
		"operation":       basetypes.StringType{},
		"value_type":      basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"numerical_value": v.NumericalValue,
			"operation":       v.Operation,
			"value_type":      v.ValueType,
		})

	return objVal, diags
}

func (v Med1Value) Equal(o attr.Value) bool {
	other, ok := o.(Med1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.NumericalValue.Equal(other.NumericalValue) {
		return false
	}

	if !v.Operation.Equal(other.Operation) {
		return false
	}

	if !v.ValueType.Equal(other.ValueType) {
		return false
	}

	return true
}

func (v Med1Value) Type(ctx context.Context) attr.Type {
	return Med1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Med1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"numerical_value": basetypes.Int64Type{},
		"operation":       basetypes.StringType{},
		"value_type":      basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Tags1Type{}

type Tags1Type struct {
	basetypes.ObjectType
}

func (t Tags1Type) Equal(o attr.Type) bool {
	other, ok := o.(Tags1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Tags1Type) String() string {
	return "Tags1Type"
}

func (t Tags1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	tagSetAttribute, ok := attributes["tag_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag_set is missing from object`)

		return nil, diags
	}

	tagSetVal, ok := tagSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag_set expected to be basetypes.StringValue, was: %T`, tagSetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Tags1Value{
		TagSet: tagSetVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTags1ValueNull() Tags1Value {
	return Tags1Value{
		state: attr.ValueStateNull,
	}
}

func NewTags1ValueUnknown() Tags1Value {
	return Tags1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewTags1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Tags1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Tags1Value Attribute Value",
				"While creating a Tags1Value value, a missing attribute value was detected. "+
					"A Tags1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Tags1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Tags1Value Attribute Type",
				"While creating a Tags1Value value, an invalid attribute value was detected. "+
					"A Tags1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Tags1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Tags1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Tags1Value Attribute Value",
				"While creating a Tags1Value value, an extra attribute value was detected. "+
					"A Tags1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Tags1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTags1ValueUnknown(), diags
	}

	tagSetAttribute, ok := attributes["tag_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag_set is missing from object`)

		return NewTags1ValueUnknown(), diags
	}

	tagSetVal, ok := tagSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag_set expected to be basetypes.StringValue, was: %T`, tagSetAttribute))
	}

	if diags.HasError() {
		return NewTags1ValueUnknown(), diags
	}

	return Tags1Value{
		TagSet: tagSetVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTags1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Tags1Value {
	object, diags := NewTags1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTags1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Tags1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTags1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTags1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTags1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTags1ValueMust(Tags1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Tags1Type) ValueType(ctx context.Context) attr.Value {
	return Tags1Value{}
}

var _ basetypes.ObjectValuable = Tags1Value{}

type Tags1Value struct {
	TagSet basetypes.StringValue `tfsdk:"tag_set"`
	state  attr.ValueState
}

func (v Tags1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["tag_set"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.TagSet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tag_set"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Tags1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Tags1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Tags1Value) String() string {
	return "Tags1Value"
}

func (v Tags1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"tag_set": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"tag_set": v.TagSet,
		})

	return objVal, diags
}

func (v Tags1Value) Equal(o attr.Value) bool {
	other, ok := o.(Tags1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.TagSet.Equal(other.TagSet) {
		return false
	}

	return true
}

func (v Tags1Value) Type(ctx context.Context) attr.Type {
	return Tags1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Tags1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"tag_set": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MatchType{}

type MatchType struct {
	basetypes.ObjectType
}

func (t MatchType) Equal(o attr.Type) bool {
	other, ok := o.(MatchType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MatchType) String() string {
	return "MatchType"
}

func (t MatchType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bgp3Attribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_3 is missing from object`)

		return nil, diags
	}

	bgp3Val, ok := bgp3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_3 expected to be basetypes.ObjectValue, was: %T`, bgp3Attribute))
	}

	familyAttribute, ok := attributes["family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family is missing from object`)

		return nil, diags
	}

	familyVal, ok := familyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family expected to be basetypes.ListValue, was: %T`, familyAttribute))
	}

	prefixSetAttribute, ok := attributes["prefix_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_set is missing from object`)

		return nil, diags
	}

	prefixSetVal, ok := prefixSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_set expected to be basetypes.StringValue, was: %T`, prefixSetAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return nil, diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	tags2Attribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags_2 is missing from object`)

		return nil, diags
	}

	tags2Val, ok := tags2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags_2 expected to be basetypes.ObjectValue, was: %T`, tags2Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MatchValue{
		Bgp3:      bgp3Val,
		Family:    familyVal,
		PrefixSet: prefixSetVal,
		Protocol:  protocolVal,
		Tags2:     tags2Val,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewMatchValueNull() MatchValue {
	return MatchValue{
		state: attr.ValueStateNull,
	}
}

func NewMatchValueUnknown() MatchValue {
	return MatchValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMatchValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MatchValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MatchValue Attribute Value",
				"While creating a MatchValue value, a missing attribute value was detected. "+
					"A MatchValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MatchValue Attribute Type",
				"While creating a MatchValue value, an invalid attribute value was detected. "+
					"A MatchValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MatchValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MatchValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MatchValue Attribute Value",
				"While creating a MatchValue value, an extra attribute value was detected. "+
					"A MatchValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MatchValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMatchValueUnknown(), diags
	}

	bgp3Attribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_3 is missing from object`)

		return NewMatchValueUnknown(), diags
	}

	bgp3Val, ok := bgp3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_3 expected to be basetypes.ObjectValue, was: %T`, bgp3Attribute))
	}

	familyAttribute, ok := attributes["family"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`family is missing from object`)

		return NewMatchValueUnknown(), diags
	}

	familyVal, ok := familyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`family expected to be basetypes.ListValue, was: %T`, familyAttribute))
	}

	prefixSetAttribute, ok := attributes["prefix_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_set is missing from object`)

		return NewMatchValueUnknown(), diags
	}

	prefixSetVal, ok := prefixSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_set expected to be basetypes.StringValue, was: %T`, prefixSetAttribute))
	}

	protocolAttribute, ok := attributes["protocol"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`protocol is missing from object`)

		return NewMatchValueUnknown(), diags
	}

	protocolVal, ok := protocolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`protocol expected to be basetypes.StringValue, was: %T`, protocolAttribute))
	}

	tags2Attribute, ok := attributes["tags"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tags_2 is missing from object`)

		return NewMatchValueUnknown(), diags
	}

	tags2Val, ok := tags2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tags_2 expected to be basetypes.ObjectValue, was: %T`, tags2Attribute))
	}

	if diags.HasError() {
		return NewMatchValueUnknown(), diags
	}

	return MatchValue{
		Bgp3:      bgp3Val,
		Family:    familyVal,
		PrefixSet: prefixSetVal,
		Protocol:  protocolVal,
		Tags2:     tags2Val,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewMatchValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MatchValue {
	object, diags := NewMatchValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMatchValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MatchType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMatchValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMatchValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMatchValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMatchValueMust(MatchValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MatchType) ValueType(ctx context.Context) attr.Value {
	return MatchValue{}
}

var _ basetypes.ObjectValuable = MatchValue{}

type MatchValue struct {
	Bgp3      basetypes.ObjectValue `tfsdk:"bgp"`
	Family    basetypes.ListValue   `tfsdk:"family"`
	PrefixSet basetypes.StringValue `tfsdk:"prefix_set"`
	Protocol  basetypes.StringValue `tfsdk:"protocol"`
	Tags2     basetypes.ObjectValue `tfsdk:"tags"`
	state     attr.ValueState
}

func (v MatchValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["bgp"] = basetypes.ObjectType{
		AttrTypes: Bgp3Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["family"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["prefix_set"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["protocol"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tags"] = basetypes.ObjectType{
		AttrTypes: Tags2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Bgp3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp"] = val

		val, err = v.Family.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["family"] = val

		val, err = v.PrefixSet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix_set"] = val

		val, err = v.Protocol.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["protocol"] = val

		val, err = v.Tags2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tags"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MatchValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MatchValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MatchValue) String() string {
	return "MatchValue"
}

func (v MatchValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bgp3 basetypes.ObjectValue

	if v.Bgp3.IsNull() {
		bgp3 = types.ObjectNull(
			Bgp3Value{}.AttributeTypes(ctx),
		)
	}

	if v.Bgp3.IsUnknown() {
		bgp3 = types.ObjectUnknown(
			Bgp3Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Bgp3.IsNull() && !v.Bgp3.IsUnknown() {
		bgp3 = types.ObjectValueMust(
			Bgp3Value{}.AttributeTypes(ctx),
			v.Bgp3.Attributes(),
		)
	}

	var tags2 basetypes.ObjectValue

	if v.Tags2.IsNull() {
		tags2 = types.ObjectNull(
			Tags2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Tags2.IsUnknown() {
		tags2 = types.ObjectUnknown(
			Tags2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Tags2.IsNull() && !v.Tags2.IsUnknown() {
		tags2 = types.ObjectValueMust(
			Tags2Value{}.AttributeTypes(ctx),
			v.Tags2.Attributes(),
		)
	}

	var familyVal basetypes.ListValue
	switch {
	case v.Family.IsUnknown():
		familyVal = types.ListUnknown(types.StringType)
	case v.Family.IsNull():
		familyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		familyVal, d = types.ListValue(types.StringType, v.Family.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bgp": basetypes.ObjectType{
				AttrTypes: Bgp3Value{}.AttributeTypes(ctx),
			},
			"family": basetypes.ListType{
				ElemType: types.StringType,
			},
			"prefix_set": basetypes.StringType{},
			"protocol":   basetypes.StringType{},
			"tags": basetypes.ObjectType{
				AttrTypes: Tags2Value{}.AttributeTypes(ctx),
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: Bgp3Value{}.AttributeTypes(ctx),
		},
		"family": basetypes.ListType{
			ElemType: types.StringType,
		},
		"prefix_set": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
		"tags": basetypes.ObjectType{
			AttrTypes: Tags2Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bgp":        bgp3,
			"family":     familyVal,
			"prefix_set": v.PrefixSet,
			"protocol":   v.Protocol,
			"tags":       tags2,
		})

	return objVal, diags
}

func (v MatchValue) Equal(o attr.Value) bool {
	other, ok := o.(MatchValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bgp3.Equal(other.Bgp3) {
		return false
	}

	if !v.Family.Equal(other.Family) {
		return false
	}

	if !v.PrefixSet.Equal(other.PrefixSet) {
		return false
	}

	if !v.Protocol.Equal(other.Protocol) {
		return false
	}

	if !v.Tags2.Equal(other.Tags2) {
		return false
	}

	return true
}

func (v MatchValue) Type(ctx context.Context) attr.Type {
	return MatchType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MatchValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: Bgp3Value{}.AttributeTypes(ctx),
		},
		"family": basetypes.ListType{
			ElemType: types.StringType,
		},
		"prefix_set": basetypes.StringType{},
		"protocol":   basetypes.StringType{},
		"tags": basetypes.ObjectType{
			AttrTypes: Tags2Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Bgp3Type{}

type Bgp3Type struct {
	basetypes.ObjectType
}

func (t Bgp3Type) Equal(o attr.Type) bool {
	other, ok := o.(Bgp3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Bgp3Type) String() string {
	return "Bgp3Type"
}

func (t Bgp3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathMatchAttribute, ok := attributes["as_path_match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_match is missing from object`)

		return nil, diags
	}

	asPathMatchVal, ok := asPathMatchAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_match expected to be basetypes.ObjectValue, was: %T`, asPathMatchAttribute))
	}

	communitySetAttribute, ok := attributes["community_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_set is missing from object`)

		return nil, diags
	}

	communitySetVal, ok := communitySetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_set expected to be basetypes.StringValue, was: %T`, communitySetAttribute))
	}

	evpnRouteTypeAttribute, ok := attributes["evpn_route_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_route_type is missing from object`)

		return nil, diags
	}

	evpnRouteTypeVal, ok := evpnRouteTypeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_route_type expected to be basetypes.ListValue, was: %T`, evpnRouteTypeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Bgp3Value{
		AsPathMatch:   asPathMatchVal,
		CommunitySet:  communitySetVal,
		EvpnRouteType: evpnRouteTypeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewBgp3ValueNull() Bgp3Value {
	return Bgp3Value{
		state: attr.ValueStateNull,
	}
}

func NewBgp3ValueUnknown() Bgp3Value {
	return Bgp3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBgp3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Bgp3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Bgp3Value Attribute Value",
				"While creating a Bgp3Value value, a missing attribute value was detected. "+
					"A Bgp3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Bgp3Value Attribute Type",
				"While creating a Bgp3Value value, an invalid attribute value was detected. "+
					"A Bgp3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Bgp3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Bgp3Value Attribute Value",
				"While creating a Bgp3Value value, an extra attribute value was detected. "+
					"A Bgp3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Bgp3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgp3ValueUnknown(), diags
	}

	asPathMatchAttribute, ok := attributes["as_path_match"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_match is missing from object`)

		return NewBgp3ValueUnknown(), diags
	}

	asPathMatchVal, ok := asPathMatchAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_match expected to be basetypes.ObjectValue, was: %T`, asPathMatchAttribute))
	}

	communitySetAttribute, ok := attributes["community_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`community_set is missing from object`)

		return NewBgp3ValueUnknown(), diags
	}

	communitySetVal, ok := communitySetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`community_set expected to be basetypes.StringValue, was: %T`, communitySetAttribute))
	}

	evpnRouteTypeAttribute, ok := attributes["evpn_route_type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn_route_type is missing from object`)

		return NewBgp3ValueUnknown(), diags
	}

	evpnRouteTypeVal, ok := evpnRouteTypeAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn_route_type expected to be basetypes.ListValue, was: %T`, evpnRouteTypeAttribute))
	}

	if diags.HasError() {
		return NewBgp3ValueUnknown(), diags
	}

	return Bgp3Value{
		AsPathMatch:   asPathMatchVal,
		CommunitySet:  communitySetVal,
		EvpnRouteType: evpnRouteTypeVal,
		state:         attr.ValueStateKnown,
	}, diags
}

func NewBgp3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Bgp3Value {
	object, diags := NewBgp3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgp3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Bgp3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgp3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgp3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgp3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgp3ValueMust(Bgp3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Bgp3Type) ValueType(ctx context.Context) attr.Value {
	return Bgp3Value{}
}

var _ basetypes.ObjectValuable = Bgp3Value{}

type Bgp3Value struct {
	AsPathMatch   basetypes.ObjectValue `tfsdk:"as_path_match"`
	CommunitySet  basetypes.StringValue `tfsdk:"community_set"`
	EvpnRouteType basetypes.ListValue   `tfsdk:"evpn_route_type"`
	state         attr.ValueState
}

func (v Bgp3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["as_path_match"] = basetypes.ObjectType{
		AttrTypes: AsPathMatchValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["community_set"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["evpn_route_type"] = basetypes.ListType{
		ElemType: types.Int64Type,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AsPathMatch.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_match"] = val

		val, err = v.CommunitySet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["community_set"] = val

		val, err = v.EvpnRouteType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpn_route_type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Bgp3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Bgp3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Bgp3Value) String() string {
	return "Bgp3Value"
}

func (v Bgp3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var asPathMatch basetypes.ObjectValue

	if v.AsPathMatch.IsNull() {
		asPathMatch = types.ObjectNull(
			AsPathMatchValue{}.AttributeTypes(ctx),
		)
	}

	if v.AsPathMatch.IsUnknown() {
		asPathMatch = types.ObjectUnknown(
			AsPathMatchValue{}.AttributeTypes(ctx),
		)
	}

	if !v.AsPathMatch.IsNull() && !v.AsPathMatch.IsUnknown() {
		asPathMatch = types.ObjectValueMust(
			AsPathMatchValue{}.AttributeTypes(ctx),
			v.AsPathMatch.Attributes(),
		)
	}

	var evpnRouteTypeVal basetypes.ListValue
	switch {
	case v.EvpnRouteType.IsUnknown():
		evpnRouteTypeVal = types.ListUnknown(types.Int64Type)
	case v.EvpnRouteType.IsNull():
		evpnRouteTypeVal = types.ListNull(types.Int64Type)
	default:
		var d diag.Diagnostics
		evpnRouteTypeVal, d = types.ListValue(types.Int64Type, v.EvpnRouteType.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"as_path_match": basetypes.ObjectType{
				AttrTypes: AsPathMatchValue{}.AttributeTypes(ctx),
			},
			"community_set": basetypes.StringType{},
			"evpn_route_type": basetypes.ListType{
				ElemType: types.Int64Type,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"as_path_match": basetypes.ObjectType{
			AttrTypes: AsPathMatchValue{}.AttributeTypes(ctx),
		},
		"community_set": basetypes.StringType{},
		"evpn_route_type": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path_match":   asPathMatch,
			"community_set":   v.CommunitySet,
			"evpn_route_type": evpnRouteTypeVal,
		})

	return objVal, diags
}

func (v Bgp3Value) Equal(o attr.Value) bool {
	other, ok := o.(Bgp3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPathMatch.Equal(other.AsPathMatch) {
		return false
	}

	if !v.CommunitySet.Equal(other.CommunitySet) {
		return false
	}

	if !v.EvpnRouteType.Equal(other.EvpnRouteType) {
		return false
	}

	return true
}

func (v Bgp3Value) Type(ctx context.Context) attr.Type {
	return Bgp3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Bgp3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path_match": basetypes.ObjectType{
			AttrTypes: AsPathMatchValue{}.AttributeTypes(ctx),
		},
		"community_set": basetypes.StringType{},
		"evpn_route_type": basetypes.ListType{
			ElemType: types.Int64Type,
		},
	}
}

var _ basetypes.ObjectTypable = AsPathMatchType{}

type AsPathMatchType struct {
	basetypes.ObjectType
}

func (t AsPathMatchType) Equal(o attr.Type) bool {
	other, ok := o.(AsPathMatchType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t AsPathMatchType) String() string {
	return "AsPathMatchType"
}

func (t AsPathMatchType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	asPathExpressionAttribute, ok := attributes["as_path_expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_expression is missing from object`)

		return nil, diags
	}

	asPathExpressionVal, ok := asPathExpressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_expression expected to be basetypes.StringValue, was: %T`, asPathExpressionAttribute))
	}

	asPathSetAttribute, ok := attributes["as_path_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_set is missing from object`)

		return nil, diags
	}

	asPathSetVal, ok := asPathSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_set expected to be basetypes.StringValue, was: %T`, asPathSetAttribute))
	}

	matchSetOptionsAttribute, ok := attributes["match_set_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_set_options is missing from object`)

		return nil, diags
	}

	matchSetOptionsVal, ok := matchSetOptionsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_set_options expected to be basetypes.StringValue, was: %T`, matchSetOptionsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return AsPathMatchValue{
		AsPathExpression: asPathExpressionVal,
		AsPathSet:        asPathSetVal,
		MatchSetOptions:  matchSetOptionsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAsPathMatchValueNull() AsPathMatchValue {
	return AsPathMatchValue{
		state: attr.ValueStateNull,
	}
}

func NewAsPathMatchValueUnknown() AsPathMatchValue {
	return AsPathMatchValue{
		state: attr.ValueStateUnknown,
	}
}

func NewAsPathMatchValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (AsPathMatchValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing AsPathMatchValue Attribute Value",
				"While creating a AsPathMatchValue value, a missing attribute value was detected. "+
					"A AsPathMatchValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsPathMatchValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid AsPathMatchValue Attribute Type",
				"While creating a AsPathMatchValue value, an invalid attribute value was detected. "+
					"A AsPathMatchValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("AsPathMatchValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("AsPathMatchValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra AsPathMatchValue Attribute Value",
				"While creating a AsPathMatchValue value, an extra attribute value was detected. "+
					"A AsPathMatchValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra AsPathMatchValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewAsPathMatchValueUnknown(), diags
	}

	asPathExpressionAttribute, ok := attributes["as_path_expression"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_expression is missing from object`)

		return NewAsPathMatchValueUnknown(), diags
	}

	asPathExpressionVal, ok := asPathExpressionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_expression expected to be basetypes.StringValue, was: %T`, asPathExpressionAttribute))
	}

	asPathSetAttribute, ok := attributes["as_path_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`as_path_set is missing from object`)

		return NewAsPathMatchValueUnknown(), diags
	}

	asPathSetVal, ok := asPathSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`as_path_set expected to be basetypes.StringValue, was: %T`, asPathSetAttribute))
	}

	matchSetOptionsAttribute, ok := attributes["match_set_options"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`match_set_options is missing from object`)

		return NewAsPathMatchValueUnknown(), diags
	}

	matchSetOptionsVal, ok := matchSetOptionsAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`match_set_options expected to be basetypes.StringValue, was: %T`, matchSetOptionsAttribute))
	}

	if diags.HasError() {
		return NewAsPathMatchValueUnknown(), diags
	}

	return AsPathMatchValue{
		AsPathExpression: asPathExpressionVal,
		AsPathSet:        asPathSetVal,
		MatchSetOptions:  matchSetOptionsVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewAsPathMatchValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) AsPathMatchValue {
	object, diags := NewAsPathMatchValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewAsPathMatchValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t AsPathMatchType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewAsPathMatchValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewAsPathMatchValueUnknown(), nil
	}

	if in.IsNull() {
		return NewAsPathMatchValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewAsPathMatchValueMust(AsPathMatchValue{}.AttributeTypes(ctx), attributes), nil
}

func (t AsPathMatchType) ValueType(ctx context.Context) attr.Value {
	return AsPathMatchValue{}
}

var _ basetypes.ObjectValuable = AsPathMatchValue{}

type AsPathMatchValue struct {
	AsPathExpression basetypes.StringValue `tfsdk:"as_path_expression"`
	AsPathSet        basetypes.StringValue `tfsdk:"as_path_set"`
	MatchSetOptions  basetypes.StringValue `tfsdk:"match_set_options"`
	state            attr.ValueState
}

func (v AsPathMatchValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["as_path_expression"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["as_path_set"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["match_set_options"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AsPathExpression.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_expression"] = val

		val, err = v.AsPathSet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["as_path_set"] = val

		val, err = v.MatchSetOptions.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["match_set_options"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v AsPathMatchValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v AsPathMatchValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v AsPathMatchValue) String() string {
	return "AsPathMatchValue"
}

func (v AsPathMatchValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"as_path_expression": basetypes.StringType{},
		"as_path_set":        basetypes.StringType{},
		"match_set_options":  basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"as_path_expression": v.AsPathExpression,
			"as_path_set":        v.AsPathSet,
			"match_set_options":  v.MatchSetOptions,
		})

	return objVal, diags
}

func (v AsPathMatchValue) Equal(o attr.Value) bool {
	other, ok := o.(AsPathMatchValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AsPathExpression.Equal(other.AsPathExpression) {
		return false
	}

	if !v.AsPathSet.Equal(other.AsPathSet) {
		return false
	}

	if !v.MatchSetOptions.Equal(other.MatchSetOptions) {
		return false
	}

	return true
}

func (v AsPathMatchValue) Type(ctx context.Context) attr.Type {
	return AsPathMatchType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v AsPathMatchValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"as_path_expression": basetypes.StringType{},
		"as_path_set":        basetypes.StringType{},
		"match_set_options":  basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Tags2Type{}

type Tags2Type struct {
	basetypes.ObjectType
}

func (t Tags2Type) Equal(o attr.Type) bool {
	other, ok := o.(Tags2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Tags2Type) String() string {
	return "Tags2Type"
}

func (t Tags2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	tagSetAttribute, ok := attributes["tag_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag_set is missing from object`)

		return nil, diags
	}

	tagSetVal, ok := tagSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag_set expected to be basetypes.StringValue, was: %T`, tagSetAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Tags2Value{
		TagSet: tagSetVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTags2ValueNull() Tags2Value {
	return Tags2Value{
		state: attr.ValueStateNull,
	}
}

func NewTags2ValueUnknown() Tags2Value {
	return Tags2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewTags2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Tags2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Tags2Value Attribute Value",
				"While creating a Tags2Value value, a missing attribute value was detected. "+
					"A Tags2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Tags2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Tags2Value Attribute Type",
				"While creating a Tags2Value value, an invalid attribute value was detected. "+
					"A Tags2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Tags2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Tags2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Tags2Value Attribute Value",
				"While creating a Tags2Value value, an extra attribute value was detected. "+
					"A Tags2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Tags2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTags2ValueUnknown(), diags
	}

	tagSetAttribute, ok := attributes["tag_set"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tag_set is missing from object`)

		return NewTags2ValueUnknown(), diags
	}

	tagSetVal, ok := tagSetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tag_set expected to be basetypes.StringValue, was: %T`, tagSetAttribute))
	}

	if diags.HasError() {
		return NewTags2ValueUnknown(), diags
	}

	return Tags2Value{
		TagSet: tagSetVal,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewTags2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Tags2Value {
	object, diags := NewTags2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTags2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Tags2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTags2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTags2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTags2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTags2ValueMust(Tags2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Tags2Type) ValueType(ctx context.Context) attr.Value {
	return Tags2Value{}
}

var _ basetypes.ObjectValuable = Tags2Value{}

type Tags2Value struct {
	TagSet basetypes.StringValue `tfsdk:"tag_set"`
	state  attr.ValueState
}

func (v Tags2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["tag_set"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.TagSet.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tag_set"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Tags2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Tags2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Tags2Value) String() string {
	return "Tags2Value"
}

func (v Tags2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"tag_set": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"tag_set": v.TagSet,
		})

	return objVal, diags
}

func (v Tags2Value) Equal(o attr.Value) bool {
	other, ok := o.(Tags2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.TagSet.Equal(other.TagSet) {
		return false
	}

	return true
}

func (v Tags2Value) Type(ctx context.Context) attr.Type {
	return Tags2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Tags2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"tag_set": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = PrefixSetsType{}

type PrefixSetsType struct {
	basetypes.ObjectType
}

func (t PrefixSetsType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixSetsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixSetsType) String() string {
	return "PrefixSetsType"
}

func (t PrefixSetsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec10Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_10 is missing from object`)

		return nil, diags
	}

	spec10Val, ok := spec10Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_10 expected to be basetypes.ObjectValue, was: %T`, spec10Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixSetsValue{
		Name:   nameVal,
		Spec10: spec10Val,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewPrefixSetsValueNull() PrefixSetsValue {
	return PrefixSetsValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixSetsValueUnknown() PrefixSetsValue {
	return PrefixSetsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixSetsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixSetsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixSetsValue Attribute Value",
				"While creating a PrefixSetsValue value, a missing attribute value was detected. "+
					"A PrefixSetsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixSetsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixSetsValue Attribute Type",
				"While creating a PrefixSetsValue value, an invalid attribute value was detected. "+
					"A PrefixSetsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixSetsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixSetsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixSetsValue Attribute Value",
				"While creating a PrefixSetsValue value, an extra attribute value was detected. "+
					"A PrefixSetsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixSetsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixSetsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewPrefixSetsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec10Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_10 is missing from object`)

		return NewPrefixSetsValueUnknown(), diags
	}

	spec10Val, ok := spec10Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_10 expected to be basetypes.ObjectValue, was: %T`, spec10Attribute))
	}

	if diags.HasError() {
		return NewPrefixSetsValueUnknown(), diags
	}

	return PrefixSetsValue{
		Name:   nameVal,
		Spec10: spec10Val,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewPrefixSetsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixSetsValue {
	object, diags := NewPrefixSetsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixSetsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixSetsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixSetsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixSetsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixSetsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixSetsValueMust(PrefixSetsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixSetsType) ValueType(ctx context.Context) attr.Value {
	return PrefixSetsValue{}
}

var _ basetypes.ObjectValuable = PrefixSetsValue{}

type PrefixSetsValue struct {
	Name   basetypes.StringValue `tfsdk:"name"`
	Spec10 basetypes.ObjectValue `tfsdk:"spec"`
	state  attr.ValueState
}

func (v PrefixSetsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec10Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Spec10.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixSetsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixSetsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixSetsValue) String() string {
	return "PrefixSetsValue"
}

func (v PrefixSetsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spec10 basetypes.ObjectValue

	if v.Spec10.IsNull() {
		spec10 = types.ObjectNull(
			Spec10Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec10.IsUnknown() {
		spec10 = types.ObjectUnknown(
			Spec10Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec10.IsNull() && !v.Spec10.IsUnknown() {
		spec10 = types.ObjectValueMust(
			Spec10Value{}.AttributeTypes(ctx),
			v.Spec10.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec10Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"spec": spec10,
		})

	return objVal, diags
}

func (v PrefixSetsValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixSetsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Spec10.Equal(other.Spec10) {
		return false
	}

	return true
}

func (v PrefixSetsValue) Type(ctx context.Context) attr.Type {
	return PrefixSetsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixSetsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec10Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Spec10Type{}

type Spec10Type struct {
	basetypes.ObjectType
}

func (t Spec10Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec10Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec10Type) String() string {
	return "Spec10Type"
}

func (t Spec10Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configuredNameAttribute, ok := attributes["configured_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_name is missing from object`)

		return nil, diags
	}

	configuredNameVal, ok := configuredNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_name expected to be basetypes.StringValue, was: %T`, configuredNameAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.ListValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec10Value{
		ConfiguredName: configuredNameVal,
		Prefix:         prefixVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSpec10ValueNull() Spec10Value {
	return Spec10Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec10ValueUnknown() Spec10Value {
	return Spec10Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec10Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec10Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec10Value Attribute Value",
				"While creating a Spec10Value value, a missing attribute value was detected. "+
					"A Spec10Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec10Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec10Value Attribute Type",
				"While creating a Spec10Value value, an invalid attribute value was detected. "+
					"A Spec10Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec10Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec10Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec10Value Attribute Value",
				"While creating a Spec10Value value, an extra attribute value was detected. "+
					"A Spec10Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec10Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec10ValueUnknown(), diags
	}

	configuredNameAttribute, ok := attributes["configured_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_name is missing from object`)

		return NewSpec10ValueUnknown(), diags
	}

	configuredNameVal, ok := configuredNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_name expected to be basetypes.StringValue, was: %T`, configuredNameAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewSpec10ValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.ListValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return NewSpec10ValueUnknown(), diags
	}

	return Spec10Value{
		ConfiguredName: configuredNameVal,
		Prefix:         prefixVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSpec10ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec10Value {
	object, diags := NewSpec10Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec10ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec10Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec10ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec10ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec10ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec10ValueMust(Spec10Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec10Type) ValueType(ctx context.Context) attr.Value {
	return Spec10Value{}
}

var _ basetypes.ObjectValuable = Spec10Value{}

type Spec10Value struct {
	ConfiguredName basetypes.StringValue `tfsdk:"configured_name"`
	Prefix         basetypes.ListValue   `tfsdk:"prefix"`
	state          attr.ValueState
}

func (v Spec10Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["configured_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.ListType{
		ElemType: PrefixValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ConfiguredName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configured_name"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec10Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec10Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec10Value) String() string {
	return "Spec10Value"
}

func (v Spec10Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	prefix := types.ListValueMust(
		PrefixType{
			basetypes.ObjectType{
				AttrTypes: PrefixValue{}.AttributeTypes(ctx),
			},
		},
		v.Prefix.Elements(),
	)

	if v.Prefix.IsNull() {
		prefix = types.ListNull(
			PrefixType{
				basetypes.ObjectType{
					AttrTypes: PrefixValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Prefix.IsUnknown() {
		prefix = types.ListUnknown(
			PrefixType{
				basetypes.ObjectType{
					AttrTypes: PrefixValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"configured_name": basetypes.StringType{},
		"prefix": basetypes.ListType{
			ElemType: PrefixValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"configured_name": v.ConfiguredName,
			"prefix":          prefix,
		})

	return objVal, diags
}

func (v Spec10Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec10Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConfiguredName.Equal(other.ConfiguredName) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	return true
}

func (v Spec10Value) Type(ctx context.Context) attr.Type {
	return Spec10Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec10Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"configured_name": basetypes.StringType{},
		"prefix": basetypes.ListType{
			ElemType: PrefixValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = PrefixType{}

type PrefixType struct {
	basetypes.ObjectType
}

func (t PrefixType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixType) String() string {
	return "PrefixType"
}

func (t PrefixType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	endRangeAttribute, ok := attributes["end_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end_range is missing from object`)

		return nil, diags
	}

	endRangeVal, ok := endRangeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end_range expected to be basetypes.Int64Value, was: %T`, endRangeAttribute))
	}

	exactAttribute, ok := attributes["exact"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exact is missing from object`)

		return nil, diags
	}

	exactVal, ok := exactAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exact expected to be basetypes.BoolValue, was: %T`, exactAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	startRangeAttribute, ok := attributes["start_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_range is missing from object`)

		return nil, diags
	}

	startRangeVal, ok := startRangeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_range expected to be basetypes.Int64Value, was: %T`, startRangeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixValue{
		EndRange:   endRangeVal,
		Exact:      exactVal,
		Prefix:     prefixVal,
		StartRange: startRangeVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPrefixValueNull() PrefixValue {
	return PrefixValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixValueUnknown() PrefixValue {
	return PrefixValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixValue Attribute Value",
				"While creating a PrefixValue value, a missing attribute value was detected. "+
					"A PrefixValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixValue Attribute Type",
				"While creating a PrefixValue value, an invalid attribute value was detected. "+
					"A PrefixValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixValue Attribute Value",
				"While creating a PrefixValue value, an extra attribute value was detected. "+
					"A PrefixValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixValueUnknown(), diags
	}

	endRangeAttribute, ok := attributes["end_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`end_range is missing from object`)

		return NewPrefixValueUnknown(), diags
	}

	endRangeVal, ok := endRangeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`end_range expected to be basetypes.Int64Value, was: %T`, endRangeAttribute))
	}

	exactAttribute, ok := attributes["exact"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`exact is missing from object`)

		return NewPrefixValueUnknown(), diags
	}

	exactVal, ok := exactAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`exact expected to be basetypes.BoolValue, was: %T`, exactAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewPrefixValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	startRangeAttribute, ok := attributes["start_range"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`start_range is missing from object`)

		return NewPrefixValueUnknown(), diags
	}

	startRangeVal, ok := startRangeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`start_range expected to be basetypes.Int64Value, was: %T`, startRangeAttribute))
	}

	if diags.HasError() {
		return NewPrefixValueUnknown(), diags
	}

	return PrefixValue{
		EndRange:   endRangeVal,
		Exact:      exactVal,
		Prefix:     prefixVal,
		StartRange: startRangeVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewPrefixValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixValue {
	object, diags := NewPrefixValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixValueMust(PrefixValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixType) ValueType(ctx context.Context) attr.Value {
	return PrefixValue{}
}

var _ basetypes.ObjectValuable = PrefixValue{}

type PrefixValue struct {
	EndRange   basetypes.Int64Value  `tfsdk:"end_range"`
	Exact      basetypes.BoolValue   `tfsdk:"exact"`
	Prefix     basetypes.StringValue `tfsdk:"prefix"`
	StartRange basetypes.Int64Value  `tfsdk:"start_range"`
	state      attr.ValueState
}

func (v PrefixValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["end_range"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["exact"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["start_range"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.EndRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["end_range"] = val

		val, err = v.Exact.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["exact"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.StartRange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["start_range"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixValue) String() string {
	return "PrefixValue"
}

func (v PrefixValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"end_range":   basetypes.Int64Type{},
		"exact":       basetypes.BoolType{},
		"prefix":      basetypes.StringType{},
		"start_range": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"end_range":   v.EndRange,
			"exact":       v.Exact,
			"prefix":      v.Prefix,
			"start_range": v.StartRange,
		})

	return objVal, diags
}

func (v PrefixValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.EndRange.Equal(other.EndRange) {
		return false
	}

	if !v.Exact.Equal(other.Exact) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.StartRange.Equal(other.StartRange) {
		return false
	}

	return true
}

func (v PrefixValue) Type(ctx context.Context) attr.Type {
	return PrefixType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"end_range":   basetypes.Int64Type{},
		"exact":       basetypes.BoolType{},
		"prefix":      basetypes.StringType{},
		"start_range": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = StaticRoutesType{}

type StaticRoutesType struct {
	basetypes.ObjectType
}

func (t StaticRoutesType) Equal(o attr.Type) bool {
	other, ok := o.(StaticRoutesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StaticRoutesType) String() string {
	return "StaticRoutesType"
}

func (t StaticRoutesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec11Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_11 is missing from object`)

		return nil, diags
	}

	spec11Val, ok := spec11Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_11 expected to be basetypes.ObjectValue, was: %T`, spec11Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StaticRoutesValue{
		Name:   nameVal,
		Spec11: spec11Val,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewStaticRoutesValueNull() StaticRoutesValue {
	return StaticRoutesValue{
		state: attr.ValueStateNull,
	}
}

func NewStaticRoutesValueUnknown() StaticRoutesValue {
	return StaticRoutesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStaticRoutesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StaticRoutesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StaticRoutesValue Attribute Value",
				"While creating a StaticRoutesValue value, a missing attribute value was detected. "+
					"A StaticRoutesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticRoutesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StaticRoutesValue Attribute Type",
				"While creating a StaticRoutesValue value, an invalid attribute value was detected. "+
					"A StaticRoutesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticRoutesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StaticRoutesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StaticRoutesValue Attribute Value",
				"While creating a StaticRoutesValue value, an extra attribute value was detected. "+
					"A StaticRoutesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StaticRoutesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStaticRoutesValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewStaticRoutesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec11Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_11 is missing from object`)

		return NewStaticRoutesValueUnknown(), diags
	}

	spec11Val, ok := spec11Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_11 expected to be basetypes.ObjectValue, was: %T`, spec11Attribute))
	}

	if diags.HasError() {
		return NewStaticRoutesValueUnknown(), diags
	}

	return StaticRoutesValue{
		Name:   nameVal,
		Spec11: spec11Val,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewStaticRoutesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StaticRoutesValue {
	object, diags := NewStaticRoutesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStaticRoutesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StaticRoutesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStaticRoutesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStaticRoutesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStaticRoutesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStaticRoutesValueMust(StaticRoutesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StaticRoutesType) ValueType(ctx context.Context) attr.Value {
	return StaticRoutesValue{}
}

var _ basetypes.ObjectValuable = StaticRoutesValue{}

type StaticRoutesValue struct {
	Name   basetypes.StringValue `tfsdk:"name"`
	Spec11 basetypes.ObjectValue `tfsdk:"spec"`
	state  attr.ValueState
}

func (v StaticRoutesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec11Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Spec11.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StaticRoutesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StaticRoutesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StaticRoutesValue) String() string {
	return "StaticRoutesValue"
}

func (v StaticRoutesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spec11 basetypes.ObjectValue

	if v.Spec11.IsNull() {
		spec11 = types.ObjectNull(
			Spec11Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec11.IsUnknown() {
		spec11 = types.ObjectUnknown(
			Spec11Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec11.IsNull() && !v.Spec11.IsUnknown() {
		spec11 = types.ObjectValueMust(
			Spec11Value{}.AttributeTypes(ctx),
			v.Spec11.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec11Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"spec": spec11,
		})

	return objVal, diags
}

func (v StaticRoutesValue) Equal(o attr.Value) bool {
	other, ok := o.(StaticRoutesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Spec11.Equal(other.Spec11) {
		return false
	}

	return true
}

func (v StaticRoutesValue) Type(ctx context.Context) attr.Type {
	return StaticRoutesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StaticRoutesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec11Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Spec11Type{}

type Spec11Type struct {
	basetypes.ObjectType
}

func (t Spec11Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec11Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec11Type) String() string {
	return "Spec11Type"
}

func (t Spec11Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	configuredNameAttribute, ok := attributes["configured_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_name is missing from object`)

		return nil, diags
	}

	configuredNameVal, ok := configuredNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_name expected to be basetypes.StringValue, was: %T`, configuredNameAttribute))
	}

	nexthopGroupAttribute, ok := attributes["nexthop_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nexthop_group is missing from object`)

		return nil, diags
	}

	nexthopGroupVal, ok := nexthopGroupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nexthop_group expected to be basetypes.ObjectValue, was: %T`, nexthopGroupAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return nil, diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return nil, diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	prefixesAttribute, ok := attributes["prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefixes is missing from object`)

		return nil, diags
	}

	prefixesVal, ok := prefixesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefixes expected to be basetypes.ListValue, was: %T`, prefixesAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return nil, diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec11Value{
		ConfiguredName: configuredNameVal,
		NexthopGroup:   nexthopGroupVal,
		Nodes:          nodesVal,
		Preference:     preferenceVal,
		Prefixes:       prefixesVal,
		Router:         routerVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSpec11ValueNull() Spec11Value {
	return Spec11Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec11ValueUnknown() Spec11Value {
	return Spec11Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec11Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec11Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec11Value Attribute Value",
				"While creating a Spec11Value value, a missing attribute value was detected. "+
					"A Spec11Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec11Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec11Value Attribute Type",
				"While creating a Spec11Value value, an invalid attribute value was detected. "+
					"A Spec11Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec11Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec11Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec11Value Attribute Value",
				"While creating a Spec11Value value, an extra attribute value was detected. "+
					"A Spec11Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec11Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec11ValueUnknown(), diags
	}

	configuredNameAttribute, ok := attributes["configured_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_name is missing from object`)

		return NewSpec11ValueUnknown(), diags
	}

	configuredNameVal, ok := configuredNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_name expected to be basetypes.StringValue, was: %T`, configuredNameAttribute))
	}

	nexthopGroupAttribute, ok := attributes["nexthop_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nexthop_group is missing from object`)

		return NewSpec11ValueUnknown(), diags
	}

	nexthopGroupVal, ok := nexthopGroupAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nexthop_group expected to be basetypes.ObjectValue, was: %T`, nexthopGroupAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return NewSpec11ValueUnknown(), diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	preferenceAttribute, ok := attributes["preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preference is missing from object`)

		return NewSpec11ValueUnknown(), diags
	}

	preferenceVal, ok := preferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preference expected to be basetypes.Int64Value, was: %T`, preferenceAttribute))
	}

	prefixesAttribute, ok := attributes["prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefixes is missing from object`)

		return NewSpec11ValueUnknown(), diags
	}

	prefixesVal, ok := prefixesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefixes expected to be basetypes.ListValue, was: %T`, prefixesAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return NewSpec11ValueUnknown(), diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	if diags.HasError() {
		return NewSpec11ValueUnknown(), diags
	}

	return Spec11Value{
		ConfiguredName: configuredNameVal,
		NexthopGroup:   nexthopGroupVal,
		Nodes:          nodesVal,
		Preference:     preferenceVal,
		Prefixes:       prefixesVal,
		Router:         routerVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewSpec11ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec11Value {
	object, diags := NewSpec11Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec11ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec11Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec11ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec11ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec11ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec11ValueMust(Spec11Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec11Type) ValueType(ctx context.Context) attr.Value {
	return Spec11Value{}
}

var _ basetypes.ObjectValuable = Spec11Value{}

type Spec11Value struct {
	ConfiguredName basetypes.StringValue `tfsdk:"configured_name"`
	NexthopGroup   basetypes.ObjectValue `tfsdk:"nexthop_group"`
	Nodes          basetypes.ListValue   `tfsdk:"nodes"`
	Preference     basetypes.Int64Value  `tfsdk:"preference"`
	Prefixes       basetypes.ListValue   `tfsdk:"prefixes"`
	Router         basetypes.StringValue `tfsdk:"router"`
	state          attr.ValueState
}

func (v Spec11Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["configured_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["nexthop_group"] = basetypes.ObjectType{
		AttrTypes: NexthopGroupValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["nodes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prefixes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["router"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.ConfiguredName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configured_name"] = val

		val, err = v.NexthopGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nexthop_group"] = val

		val, err = v.Nodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nodes"] = val

		val, err = v.Preference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preference"] = val

		val, err = v.Prefixes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefixes"] = val

		val, err = v.Router.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec11Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec11Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec11Value) String() string {
	return "Spec11Value"
}

func (v Spec11Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var nexthopGroup basetypes.ObjectValue

	if v.NexthopGroup.IsNull() {
		nexthopGroup = types.ObjectNull(
			NexthopGroupValue{}.AttributeTypes(ctx),
		)
	}

	if v.NexthopGroup.IsUnknown() {
		nexthopGroup = types.ObjectUnknown(
			NexthopGroupValue{}.AttributeTypes(ctx),
		)
	}

	if !v.NexthopGroup.IsNull() && !v.NexthopGroup.IsUnknown() {
		nexthopGroup = types.ObjectValueMust(
			NexthopGroupValue{}.AttributeTypes(ctx),
			v.NexthopGroup.Attributes(),
		)
	}

	var nodesVal basetypes.ListValue
	switch {
	case v.Nodes.IsUnknown():
		nodesVal = types.ListUnknown(types.StringType)
	case v.Nodes.IsNull():
		nodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodesVal, d = types.ListValue(types.StringType, v.Nodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"configured_name": basetypes.StringType{},
			"nexthop_group": basetypes.ObjectType{
				AttrTypes: NexthopGroupValue{}.AttributeTypes(ctx),
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"preference": basetypes.Int64Type{},
			"prefixes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"router": basetypes.StringType{},
		}), diags
	}

	var prefixesVal basetypes.ListValue
	switch {
	case v.Prefixes.IsUnknown():
		prefixesVal = types.ListUnknown(types.StringType)
	case v.Prefixes.IsNull():
		prefixesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		prefixesVal, d = types.ListValue(types.StringType, v.Prefixes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"configured_name": basetypes.StringType{},
			"nexthop_group": basetypes.ObjectType{
				AttrTypes: NexthopGroupValue{}.AttributeTypes(ctx),
			},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"preference": basetypes.Int64Type{},
			"prefixes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"router": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"configured_name": basetypes.StringType{},
		"nexthop_group": basetypes.ObjectType{
			AttrTypes: NexthopGroupValue{}.AttributeTypes(ctx),
		},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"preference": basetypes.Int64Type{},
		"prefixes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"router": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"configured_name": v.ConfiguredName,
			"nexthop_group":   nexthopGroup,
			"nodes":           nodesVal,
			"preference":      v.Preference,
			"prefixes":        prefixesVal,
			"router":          v.Router,
		})

	return objVal, diags
}

func (v Spec11Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec11Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ConfiguredName.Equal(other.ConfiguredName) {
		return false
	}

	if !v.NexthopGroup.Equal(other.NexthopGroup) {
		return false
	}

	if !v.Nodes.Equal(other.Nodes) {
		return false
	}

	if !v.Preference.Equal(other.Preference) {
		return false
	}

	if !v.Prefixes.Equal(other.Prefixes) {
		return false
	}

	if !v.Router.Equal(other.Router) {
		return false
	}

	return true
}

func (v Spec11Value) Type(ctx context.Context) attr.Type {
	return Spec11Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec11Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"configured_name": basetypes.StringType{},
		"nexthop_group": basetypes.ObjectType{
			AttrTypes: NexthopGroupValue{}.AttributeTypes(ctx),
		},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"preference": basetypes.Int64Type{},
		"prefixes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"router": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NexthopGroupType{}

type NexthopGroupType struct {
	basetypes.ObjectType
}

func (t NexthopGroupType) Equal(o attr.Type) bool {
	other, ok := o.(NexthopGroupType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NexthopGroupType) String() string {
	return "NexthopGroupType"
}

func (t NexthopGroupType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bfd1Attribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_1 is missing from object`)

		return nil, diags
	}

	bfd1Val, ok := bfd1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_1 expected to be basetypes.ObjectValue, was: %T`, bfd1Attribute))
	}

	blackholeAttribute, ok := attributes["blackhole"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blackhole is missing from object`)

		return nil, diags
	}

	blackholeVal, ok := blackholeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blackhole expected to be basetypes.BoolValue, was: %T`, blackholeAttribute))
	}

	blackholeSendIcmpAttribute, ok := attributes["blackhole_send_icmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blackhole_send_icmp is missing from object`)

		return nil, diags
	}

	blackholeSendIcmpVal, ok := blackholeSendIcmpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blackhole_send_icmp expected to be basetypes.BoolValue, was: %T`, blackholeSendIcmpAttribute))
	}

	nexthopsAttribute, ok := attributes["nexthops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nexthops is missing from object`)

		return nil, diags
	}

	nexthopsVal, ok := nexthopsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nexthops expected to be basetypes.ListValue, was: %T`, nexthopsAttribute))
	}

	resolveAttribute, ok := attributes["resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resolve is missing from object`)

		return nil, diags
	}

	resolveVal, ok := resolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resolve expected to be basetypes.BoolValue, was: %T`, resolveAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NexthopGroupValue{
		Bfd1:              bfd1Val,
		Blackhole:         blackholeVal,
		BlackholeSendIcmp: blackholeSendIcmpVal,
		Nexthops:          nexthopsVal,
		Resolve:           resolveVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNexthopGroupValueNull() NexthopGroupValue {
	return NexthopGroupValue{
		state: attr.ValueStateNull,
	}
}

func NewNexthopGroupValueUnknown() NexthopGroupValue {
	return NexthopGroupValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNexthopGroupValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NexthopGroupValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NexthopGroupValue Attribute Value",
				"While creating a NexthopGroupValue value, a missing attribute value was detected. "+
					"A NexthopGroupValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NexthopGroupValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NexthopGroupValue Attribute Type",
				"While creating a NexthopGroupValue value, an invalid attribute value was detected. "+
					"A NexthopGroupValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NexthopGroupValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NexthopGroupValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NexthopGroupValue Attribute Value",
				"While creating a NexthopGroupValue value, an extra attribute value was detected. "+
					"A NexthopGroupValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NexthopGroupValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNexthopGroupValueUnknown(), diags
	}

	bfd1Attribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_1 is missing from object`)

		return NewNexthopGroupValueUnknown(), diags
	}

	bfd1Val, ok := bfd1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_1 expected to be basetypes.ObjectValue, was: %T`, bfd1Attribute))
	}

	blackholeAttribute, ok := attributes["blackhole"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blackhole is missing from object`)

		return NewNexthopGroupValueUnknown(), diags
	}

	blackholeVal, ok := blackholeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blackhole expected to be basetypes.BoolValue, was: %T`, blackholeAttribute))
	}

	blackholeSendIcmpAttribute, ok := attributes["blackhole_send_icmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`blackhole_send_icmp is missing from object`)

		return NewNexthopGroupValueUnknown(), diags
	}

	blackholeSendIcmpVal, ok := blackholeSendIcmpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`blackhole_send_icmp expected to be basetypes.BoolValue, was: %T`, blackholeSendIcmpAttribute))
	}

	nexthopsAttribute, ok := attributes["nexthops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nexthops is missing from object`)

		return NewNexthopGroupValueUnknown(), diags
	}

	nexthopsVal, ok := nexthopsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nexthops expected to be basetypes.ListValue, was: %T`, nexthopsAttribute))
	}

	resolveAttribute, ok := attributes["resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resolve is missing from object`)

		return NewNexthopGroupValueUnknown(), diags
	}

	resolveVal, ok := resolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resolve expected to be basetypes.BoolValue, was: %T`, resolveAttribute))
	}

	if diags.HasError() {
		return NewNexthopGroupValueUnknown(), diags
	}

	return NexthopGroupValue{
		Bfd1:              bfd1Val,
		Blackhole:         blackholeVal,
		BlackholeSendIcmp: blackholeSendIcmpVal,
		Nexthops:          nexthopsVal,
		Resolve:           resolveVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewNexthopGroupValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NexthopGroupValue {
	object, diags := NewNexthopGroupValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNexthopGroupValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NexthopGroupType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNexthopGroupValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNexthopGroupValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNexthopGroupValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNexthopGroupValueMust(NexthopGroupValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NexthopGroupType) ValueType(ctx context.Context) attr.Value {
	return NexthopGroupValue{}
}

var _ basetypes.ObjectValuable = NexthopGroupValue{}

type NexthopGroupValue struct {
	Bfd1              basetypes.ObjectValue `tfsdk:"bfd"`
	Blackhole         basetypes.BoolValue   `tfsdk:"blackhole"`
	BlackholeSendIcmp basetypes.BoolValue   `tfsdk:"blackhole_send_icmp"`
	Nexthops          basetypes.ListValue   `tfsdk:"nexthops"`
	Resolve           basetypes.BoolValue   `tfsdk:"resolve"`
	state             attr.ValueState
}

func (v NexthopGroupValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["bfd"] = basetypes.ObjectType{
		AttrTypes: Bfd1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["blackhole"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["blackhole_send_icmp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["nexthops"] = basetypes.ListType{
		ElemType: NexthopsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["resolve"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Bfd1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.Blackhole.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blackhole"] = val

		val, err = v.BlackholeSendIcmp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["blackhole_send_icmp"] = val

		val, err = v.Nexthops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nexthops"] = val

		val, err = v.Resolve.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resolve"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NexthopGroupValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NexthopGroupValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NexthopGroupValue) String() string {
	return "NexthopGroupValue"
}

func (v NexthopGroupValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bfd1 basetypes.ObjectValue

	if v.Bfd1.IsNull() {
		bfd1 = types.ObjectNull(
			Bfd1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Bfd1.IsUnknown() {
		bfd1 = types.ObjectUnknown(
			Bfd1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Bfd1.IsNull() && !v.Bfd1.IsUnknown() {
		bfd1 = types.ObjectValueMust(
			Bfd1Value{}.AttributeTypes(ctx),
			v.Bfd1.Attributes(),
		)
	}

	nexthops := types.ListValueMust(
		NexthopsType{
			basetypes.ObjectType{
				AttrTypes: NexthopsValue{}.AttributeTypes(ctx),
			},
		},
		v.Nexthops.Elements(),
	)

	if v.Nexthops.IsNull() {
		nexthops = types.ListNull(
			NexthopsType{
				basetypes.ObjectType{
					AttrTypes: NexthopsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Nexthops.IsUnknown() {
		nexthops = types.ListUnknown(
			NexthopsType{
				basetypes.ObjectType{
					AttrTypes: NexthopsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: Bfd1Value{}.AttributeTypes(ctx),
		},
		"blackhole":           basetypes.BoolType{},
		"blackhole_send_icmp": basetypes.BoolType{},
		"nexthops": basetypes.ListType{
			ElemType: NexthopsValue{}.Type(ctx),
		},
		"resolve": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bfd":                 bfd1,
			"blackhole":           v.Blackhole,
			"blackhole_send_icmp": v.BlackholeSendIcmp,
			"nexthops":            nexthops,
			"resolve":             v.Resolve,
		})

	return objVal, diags
}

func (v NexthopGroupValue) Equal(o attr.Value) bool {
	other, ok := o.(NexthopGroupValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bfd1.Equal(other.Bfd1) {
		return false
	}

	if !v.Blackhole.Equal(other.Blackhole) {
		return false
	}

	if !v.BlackholeSendIcmp.Equal(other.BlackholeSendIcmp) {
		return false
	}

	if !v.Nexthops.Equal(other.Nexthops) {
		return false
	}

	if !v.Resolve.Equal(other.Resolve) {
		return false
	}

	return true
}

func (v NexthopGroupValue) Type(ctx context.Context) attr.Type {
	return NexthopGroupType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NexthopGroupValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: Bfd1Value{}.AttributeTypes(ctx),
		},
		"blackhole":           basetypes.BoolType{},
		"blackhole_send_icmp": basetypes.BoolType{},
		"nexthops": basetypes.ListType{
			ElemType: NexthopsValue{}.Type(ctx),
		},
		"resolve": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Bfd1Type{}

type Bfd1Type struct {
	basetypes.ObjectType
}

func (t Bfd1Type) Equal(o attr.Type) bool {
	other, ok := o.(Bfd1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Bfd1Type) String() string {
	return "Bfd1Type"
}

func (t Bfd1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	localAddressAttribute, ok := attributes["local_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_address is missing from object`)

		return nil, diags
	}

	localAddressVal, ok := localAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_address expected to be basetypes.StringValue, was: %T`, localAddressAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Bfd1Value{
		Enabled:      enabledVal,
		LocalAddress: localAddressVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewBfd1ValueNull() Bfd1Value {
	return Bfd1Value{
		state: attr.ValueStateNull,
	}
}

func NewBfd1ValueUnknown() Bfd1Value {
	return Bfd1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBfd1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Bfd1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Bfd1Value Attribute Value",
				"While creating a Bfd1Value value, a missing attribute value was detected. "+
					"A Bfd1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bfd1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Bfd1Value Attribute Type",
				"While creating a Bfd1Value value, an invalid attribute value was detected. "+
					"A Bfd1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bfd1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Bfd1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Bfd1Value Attribute Value",
				"While creating a Bfd1Value value, an extra attribute value was detected. "+
					"A Bfd1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Bfd1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBfd1ValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBfd1ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	localAddressAttribute, ok := attributes["local_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_address is missing from object`)

		return NewBfd1ValueUnknown(), diags
	}

	localAddressVal, ok := localAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_address expected to be basetypes.StringValue, was: %T`, localAddressAttribute))
	}

	if diags.HasError() {
		return NewBfd1ValueUnknown(), diags
	}

	return Bfd1Value{
		Enabled:      enabledVal,
		LocalAddress: localAddressVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewBfd1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Bfd1Value {
	object, diags := NewBfd1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBfd1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Bfd1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBfd1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBfd1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBfd1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBfd1ValueMust(Bfd1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Bfd1Type) ValueType(ctx context.Context) attr.Value {
	return Bfd1Value{}
}

var _ basetypes.ObjectValuable = Bfd1Value{}

type Bfd1Value struct {
	Enabled      basetypes.BoolValue   `tfsdk:"enabled"`
	LocalAddress basetypes.StringValue `tfsdk:"local_address"`
	state        attr.ValueState
}

func (v Bfd1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["local_address"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.LocalAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_address"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Bfd1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Bfd1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Bfd1Value) String() string {
	return "Bfd1Value"
}

func (v Bfd1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":       basetypes.BoolType{},
		"local_address": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":       v.Enabled,
			"local_address": v.LocalAddress,
		})

	return objVal, diags
}

func (v Bfd1Value) Equal(o attr.Value) bool {
	other, ok := o.(Bfd1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.LocalAddress.Equal(other.LocalAddress) {
		return false
	}

	return true
}

func (v Bfd1Value) Type(ctx context.Context) attr.Type {
	return Bfd1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Bfd1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":       basetypes.BoolType{},
		"local_address": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = NexthopsType{}

type NexthopsType struct {
	basetypes.ObjectType
}

func (t NexthopsType) Equal(o attr.Type) bool {
	other, ok := o.(NexthopsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t NexthopsType) String() string {
	return "NexthopsType"
}

func (t NexthopsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bfd2Attribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_2 is missing from object`)

		return nil, diags
	}

	bfd2Val, ok := bfd2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_2 expected to be basetypes.ObjectValue, was: %T`, bfd2Attribute))
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return nil, diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	resolveAttribute, ok := attributes["resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resolve is missing from object`)

		return nil, diags
	}

	resolveVal, ok := resolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resolve expected to be basetypes.BoolValue, was: %T`, resolveAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return NexthopsValue{
		Bfd2:     bfd2Val,
		IpPrefix: ipPrefixVal,
		Resolve:  resolveVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewNexthopsValueNull() NexthopsValue {
	return NexthopsValue{
		state: attr.ValueStateNull,
	}
}

func NewNexthopsValueUnknown() NexthopsValue {
	return NexthopsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewNexthopsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (NexthopsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing NexthopsValue Attribute Value",
				"While creating a NexthopsValue value, a missing attribute value was detected. "+
					"A NexthopsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NexthopsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid NexthopsValue Attribute Type",
				"While creating a NexthopsValue value, an invalid attribute value was detected. "+
					"A NexthopsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("NexthopsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("NexthopsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra NexthopsValue Attribute Value",
				"While creating a NexthopsValue value, an extra attribute value was detected. "+
					"A NexthopsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra NexthopsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewNexthopsValueUnknown(), diags
	}

	bfd2Attribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_2 is missing from object`)

		return NewNexthopsValueUnknown(), diags
	}

	bfd2Val, ok := bfd2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_2 expected to be basetypes.ObjectValue, was: %T`, bfd2Attribute))
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return NewNexthopsValueUnknown(), diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	resolveAttribute, ok := attributes["resolve"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`resolve is missing from object`)

		return NewNexthopsValueUnknown(), diags
	}

	resolveVal, ok := resolveAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`resolve expected to be basetypes.BoolValue, was: %T`, resolveAttribute))
	}

	if diags.HasError() {
		return NewNexthopsValueUnknown(), diags
	}

	return NexthopsValue{
		Bfd2:     bfd2Val,
		IpPrefix: ipPrefixVal,
		Resolve:  resolveVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewNexthopsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) NexthopsValue {
	object, diags := NewNexthopsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewNexthopsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t NexthopsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewNexthopsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewNexthopsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewNexthopsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewNexthopsValueMust(NexthopsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t NexthopsType) ValueType(ctx context.Context) attr.Value {
	return NexthopsValue{}
}

var _ basetypes.ObjectValuable = NexthopsValue{}

type NexthopsValue struct {
	Bfd2     basetypes.ObjectValue `tfsdk:"bfd"`
	IpPrefix basetypes.StringValue `tfsdk:"ip_prefix"`
	Resolve  basetypes.BoolValue   `tfsdk:"resolve"`
	state    attr.ValueState
}

func (v NexthopsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["bfd"] = basetypes.ObjectType{
		AttrTypes: Bfd2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["resolve"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Bfd2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.IpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_prefix"] = val

		val, err = v.Resolve.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["resolve"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v NexthopsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v NexthopsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v NexthopsValue) String() string {
	return "NexthopsValue"
}

func (v NexthopsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bfd2 basetypes.ObjectValue

	if v.Bfd2.IsNull() {
		bfd2 = types.ObjectNull(
			Bfd2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Bfd2.IsUnknown() {
		bfd2 = types.ObjectUnknown(
			Bfd2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Bfd2.IsNull() && !v.Bfd2.IsUnknown() {
		bfd2 = types.ObjectValueMust(
			Bfd2Value{}.AttributeTypes(ctx),
			v.Bfd2.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: Bfd2Value{}.AttributeTypes(ctx),
		},
		"ip_prefix": basetypes.StringType{},
		"resolve":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bfd":       bfd2,
			"ip_prefix": v.IpPrefix,
			"resolve":   v.Resolve,
		})

	return objVal, diags
}

func (v NexthopsValue) Equal(o attr.Value) bool {
	other, ok := o.(NexthopsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bfd2.Equal(other.Bfd2) {
		return false
	}

	if !v.IpPrefix.Equal(other.IpPrefix) {
		return false
	}

	if !v.Resolve.Equal(other.Resolve) {
		return false
	}

	return true
}

func (v NexthopsValue) Type(ctx context.Context) attr.Type {
	return NexthopsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v NexthopsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bfd": basetypes.ObjectType{
			AttrTypes: Bfd2Value{}.AttributeTypes(ctx),
		},
		"ip_prefix": basetypes.StringType{},
		"resolve":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Bfd2Type{}

type Bfd2Type struct {
	basetypes.ObjectType
}

func (t Bfd2Type) Equal(o attr.Type) bool {
	other, ok := o.(Bfd2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Bfd2Type) String() string {
	return "Bfd2Type"
}

func (t Bfd2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	localAddressAttribute, ok := attributes["local_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_address is missing from object`)

		return nil, diags
	}

	localAddressVal, ok := localAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_address expected to be basetypes.StringValue, was: %T`, localAddressAttribute))
	}

	localDiscriminatorAttribute, ok := attributes["local_discriminator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_discriminator is missing from object`)

		return nil, diags
	}

	localDiscriminatorVal, ok := localDiscriminatorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_discriminator expected to be basetypes.Int64Value, was: %T`, localDiscriminatorAttribute))
	}

	remoteDiscriminatorAttribute, ok := attributes["remote_discriminator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_discriminator is missing from object`)

		return nil, diags
	}

	remoteDiscriminatorVal, ok := remoteDiscriminatorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_discriminator expected to be basetypes.Int64Value, was: %T`, remoteDiscriminatorAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Bfd2Value{
		Enabled:             enabledVal,
		LocalAddress:        localAddressVal,
		LocalDiscriminator:  localDiscriminatorVal,
		RemoteDiscriminator: remoteDiscriminatorVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewBfd2ValueNull() Bfd2Value {
	return Bfd2Value{
		state: attr.ValueStateNull,
	}
}

func NewBfd2ValueUnknown() Bfd2Value {
	return Bfd2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBfd2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Bfd2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Bfd2Value Attribute Value",
				"While creating a Bfd2Value value, a missing attribute value was detected. "+
					"A Bfd2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bfd2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Bfd2Value Attribute Type",
				"While creating a Bfd2Value value, an invalid attribute value was detected. "+
					"A Bfd2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bfd2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Bfd2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Bfd2Value Attribute Value",
				"While creating a Bfd2Value value, an extra attribute value was detected. "+
					"A Bfd2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Bfd2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBfd2ValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBfd2ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	localAddressAttribute, ok := attributes["local_address"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_address is missing from object`)

		return NewBfd2ValueUnknown(), diags
	}

	localAddressVal, ok := localAddressAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_address expected to be basetypes.StringValue, was: %T`, localAddressAttribute))
	}

	localDiscriminatorAttribute, ok := attributes["local_discriminator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`local_discriminator is missing from object`)

		return NewBfd2ValueUnknown(), diags
	}

	localDiscriminatorVal, ok := localDiscriminatorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`local_discriminator expected to be basetypes.Int64Value, was: %T`, localDiscriminatorAttribute))
	}

	remoteDiscriminatorAttribute, ok := attributes["remote_discriminator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`remote_discriminator is missing from object`)

		return NewBfd2ValueUnknown(), diags
	}

	remoteDiscriminatorVal, ok := remoteDiscriminatorAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`remote_discriminator expected to be basetypes.Int64Value, was: %T`, remoteDiscriminatorAttribute))
	}

	if diags.HasError() {
		return NewBfd2ValueUnknown(), diags
	}

	return Bfd2Value{
		Enabled:             enabledVal,
		LocalAddress:        localAddressVal,
		LocalDiscriminator:  localDiscriminatorVal,
		RemoteDiscriminator: remoteDiscriminatorVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewBfd2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Bfd2Value {
	object, diags := NewBfd2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBfd2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Bfd2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBfd2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBfd2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBfd2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBfd2ValueMust(Bfd2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Bfd2Type) ValueType(ctx context.Context) attr.Value {
	return Bfd2Value{}
}

var _ basetypes.ObjectValuable = Bfd2Value{}

type Bfd2Value struct {
	Enabled             basetypes.BoolValue   `tfsdk:"enabled"`
	LocalAddress        basetypes.StringValue `tfsdk:"local_address"`
	LocalDiscriminator  basetypes.Int64Value  `tfsdk:"local_discriminator"`
	RemoteDiscriminator basetypes.Int64Value  `tfsdk:"remote_discriminator"`
	state               attr.ValueState
}

func (v Bfd2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["local_address"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["local_discriminator"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["remote_discriminator"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.LocalAddress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_address"] = val

		val, err = v.LocalDiscriminator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["local_discriminator"] = val

		val, err = v.RemoteDiscriminator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["remote_discriminator"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Bfd2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Bfd2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Bfd2Value) String() string {
	return "Bfd2Value"
}

func (v Bfd2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":              basetypes.BoolType{},
		"local_address":        basetypes.StringType{},
		"local_discriminator":  basetypes.Int64Type{},
		"remote_discriminator": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":              v.Enabled,
			"local_address":        v.LocalAddress,
			"local_discriminator":  v.LocalDiscriminator,
			"remote_discriminator": v.RemoteDiscriminator,
		})

	return objVal, diags
}

func (v Bfd2Value) Equal(o attr.Value) bool {
	other, ok := o.(Bfd2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.LocalAddress.Equal(other.LocalAddress) {
		return false
	}

	if !v.LocalDiscriminator.Equal(other.LocalDiscriminator) {
		return false
	}

	if !v.RemoteDiscriminator.Equal(other.RemoteDiscriminator) {
		return false
	}

	return true
}

func (v Bfd2Value) Type(ctx context.Context) attr.Type {
	return Bfd2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Bfd2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":              basetypes.BoolType{},
		"local_address":        basetypes.StringType{},
		"local_discriminator":  basetypes.Int64Type{},
		"remote_discriminator": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = RoutedInterfacesType{}

type RoutedInterfacesType struct {
	basetypes.ObjectType
}

func (t RoutedInterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(RoutedInterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RoutedInterfacesType) String() string {
	return "RoutedInterfacesType"
}

func (t RoutedInterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec12Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_12 is missing from object`)

		return nil, diags
	}

	spec12Val, ok := spec12Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_12 expected to be basetypes.ObjectValue, was: %T`, spec12Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RoutedInterfacesValue{
		Name:   nameVal,
		Spec12: spec12Val,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewRoutedInterfacesValueNull() RoutedInterfacesValue {
	return RoutedInterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewRoutedInterfacesValueUnknown() RoutedInterfacesValue {
	return RoutedInterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRoutedInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RoutedInterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RoutedInterfacesValue Attribute Value",
				"While creating a RoutedInterfacesValue value, a missing attribute value was detected. "+
					"A RoutedInterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutedInterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RoutedInterfacesValue Attribute Type",
				"While creating a RoutedInterfacesValue value, an invalid attribute value was detected. "+
					"A RoutedInterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutedInterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RoutedInterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RoutedInterfacesValue Attribute Value",
				"While creating a RoutedInterfacesValue value, an extra attribute value was detected. "+
					"A RoutedInterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RoutedInterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRoutedInterfacesValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewRoutedInterfacesValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec12Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_12 is missing from object`)

		return NewRoutedInterfacesValueUnknown(), diags
	}

	spec12Val, ok := spec12Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_12 expected to be basetypes.ObjectValue, was: %T`, spec12Attribute))
	}

	if diags.HasError() {
		return NewRoutedInterfacesValueUnknown(), diags
	}

	return RoutedInterfacesValue{
		Name:   nameVal,
		Spec12: spec12Val,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewRoutedInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RoutedInterfacesValue {
	object, diags := NewRoutedInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRoutedInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RoutedInterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRoutedInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRoutedInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRoutedInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRoutedInterfacesValueMust(RoutedInterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RoutedInterfacesType) ValueType(ctx context.Context) attr.Value {
	return RoutedInterfacesValue{}
}

var _ basetypes.ObjectValuable = RoutedInterfacesValue{}

type RoutedInterfacesValue struct {
	Name   basetypes.StringValue `tfsdk:"name"`
	Spec12 basetypes.ObjectValue `tfsdk:"spec"`
	state  attr.ValueState
}

func (v RoutedInterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec12Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Spec12.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RoutedInterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RoutedInterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RoutedInterfacesValue) String() string {
	return "RoutedInterfacesValue"
}

func (v RoutedInterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spec12 basetypes.ObjectValue

	if v.Spec12.IsNull() {
		spec12 = types.ObjectNull(
			Spec12Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec12.IsUnknown() {
		spec12 = types.ObjectUnknown(
			Spec12Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec12.IsNull() && !v.Spec12.IsUnknown() {
		spec12 = types.ObjectValueMust(
			Spec12Value{}.AttributeTypes(ctx),
			v.Spec12.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec12Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"spec": spec12,
		})

	return objVal, diags
}

func (v RoutedInterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(RoutedInterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Spec12.Equal(other.Spec12) {
		return false
	}

	return true
}

func (v RoutedInterfacesValue) Type(ctx context.Context) attr.Type {
	return RoutedInterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RoutedInterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec12Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Spec12Type{}

type Spec12Type struct {
	basetypes.ObjectType
}

func (t Spec12Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec12Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec12Type) String() string {
	return "Spec12Type"
}

func (t Spec12Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	arpTimeoutAttribute, ok := attributes["arp_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_timeout is missing from object`)

		return nil, diags
	}

	arpTimeoutVal, ok := arpTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_timeout expected to be basetypes.Int64Value, was: %T`, arpTimeoutAttribute))
	}

	bfd3Attribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_3 is missing from object`)

		return nil, diags
	}

	bfd3Val, ok := bfd3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_3 expected to be basetypes.ObjectValue, was: %T`, bfd3Attribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egress3Attribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_3 is missing from object`)

		return nil, diags
	}

	egress3Val, ok := egress3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_3 expected to be basetypes.ObjectValue, was: %T`, egress3Attribute))
	}

	hostRoutePopulate1Attribute, ok := attributes["host_route_populate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_route_populate_1 is missing from object`)

		return nil, diags
	}

	hostRoutePopulate1Val, ok := hostRoutePopulate1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_route_populate_1 expected to be basetypes.ObjectValue, was: %T`, hostRoutePopulate1Attribute))
	}

	ingress3Attribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_3 is missing from object`)

		return nil, diags
	}

	ingress3Val, ok := ingress3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_3 expected to be basetypes.ObjectValue, was: %T`, ingress3Attribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return nil, diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	ipv4AddressesAttribute, ok := attributes["ipv4_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses is missing from object`)

		return nil, diags
	}

	ipv4AddressesVal, ok := ipv4AddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses expected to be basetypes.ListValue, was: %T`, ipv4AddressesAttribute))
	}

	ipv4Parameters1Attribute, ok := attributes["ipv4_parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_parameters_1 is missing from object`)

		return nil, diags
	}

	ipv4Parameters1Val, ok := ipv4Parameters1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_parameters_1 expected to be basetypes.ObjectValue, was: %T`, ipv4Parameters1Attribute))
	}

	ipv6AddressesAttribute, ok := attributes["ipv6_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_addresses is missing from object`)

		return nil, diags
	}

	ipv6AddressesVal, ok := ipv6AddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_addresses expected to be basetypes.ListValue, was: %T`, ipv6AddressesAttribute))
	}

	ipv6RouterAdvertisement1Attribute, ok := attributes["ipv6_router_advertisement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_router_advertisement_1 is missing from object`)

		return nil, diags
	}

	ipv6RouterAdvertisement1Val, ok := ipv6RouterAdvertisement1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_router_advertisement_1 expected to be basetypes.ObjectValue, was: %T`, ipv6RouterAdvertisement1Attribute))
	}

	l3proxyArpnd1Attribute, ok := attributes["l3proxy_arpnd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3proxy_arpnd_1 is missing from object`)

		return nil, diags
	}

	l3proxyArpnd1Val, ok := l3proxyArpnd1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3proxy_arpnd_1 expected to be basetypes.ObjectValue, was: %T`, l3proxyArpnd1Attribute))
	}

	learnUnsolicitedAttribute, ok := attributes["learn_unsolicited"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`learn_unsolicited is missing from object`)

		return nil, diags
	}

	learnUnsolicitedVal, ok := learnUnsolicitedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`learn_unsolicited expected to be basetypes.StringValue, was: %T`, learnUnsolicitedAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return nil, diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return nil, diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	vlanPoolAttribute, ok := attributes["vlan_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_pool is missing from object`)

		return nil, diags
	}

	vlanPoolVal, ok := vlanPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_pool expected to be basetypes.StringValue, was: %T`, vlanPoolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec12Value{
		ArpTimeout:               arpTimeoutVal,
		Bfd3:                     bfd3Val,
		Description:              descriptionVal,
		Egress3:                  egress3Val,
		HostRoutePopulate1:       hostRoutePopulate1Val,
		Ingress3:                 ingress3Val,
		Interface:                interfaceVal,
		IpMtu:                    ipMtuVal,
		Ipv4Addresses:            ipv4AddressesVal,
		Ipv4Parameters1:          ipv4Parameters1Val,
		Ipv6Addresses:            ipv6AddressesVal,
		Ipv6RouterAdvertisement1: ipv6RouterAdvertisement1Val,
		L3proxyArpnd1:            l3proxyArpnd1Val,
		LearnUnsolicited:         learnUnsolicitedVal,
		Router:                   routerVal,
		Unnumbered:               unnumberedVal,
		VlanId:                   vlanIdVal,
		VlanPool:                 vlanPoolVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewSpec12ValueNull() Spec12Value {
	return Spec12Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec12ValueUnknown() Spec12Value {
	return Spec12Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec12Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec12Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec12Value Attribute Value",
				"While creating a Spec12Value value, a missing attribute value was detected. "+
					"A Spec12Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec12Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec12Value Attribute Type",
				"While creating a Spec12Value value, an invalid attribute value was detected. "+
					"A Spec12Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec12Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec12Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec12Value Attribute Value",
				"While creating a Spec12Value value, an extra attribute value was detected. "+
					"A Spec12Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec12Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec12ValueUnknown(), diags
	}

	arpTimeoutAttribute, ok := attributes["arp_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_timeout is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	arpTimeoutVal, ok := arpTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_timeout expected to be basetypes.Int64Value, was: %T`, arpTimeoutAttribute))
	}

	bfd3Attribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd_3 is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	bfd3Val, ok := bfd3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd_3 expected to be basetypes.ObjectValue, was: %T`, bfd3Attribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egress3Attribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_3 is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	egress3Val, ok := egress3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_3 expected to be basetypes.ObjectValue, was: %T`, egress3Attribute))
	}

	hostRoutePopulate1Attribute, ok := attributes["host_route_populate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`host_route_populate_1 is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	hostRoutePopulate1Val, ok := hostRoutePopulate1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`host_route_populate_1 expected to be basetypes.ObjectValue, was: %T`, hostRoutePopulate1Attribute))
	}

	ingress3Attribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_3 is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	ingress3Val, ok := ingress3Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_3 expected to be basetypes.ObjectValue, was: %T`, ingress3Attribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	ipv4AddressesAttribute, ok := attributes["ipv4_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_addresses is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	ipv4AddressesVal, ok := ipv4AddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_addresses expected to be basetypes.ListValue, was: %T`, ipv4AddressesAttribute))
	}

	ipv4Parameters1Attribute, ok := attributes["ipv4_parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_parameters_1 is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	ipv4Parameters1Val, ok := ipv4Parameters1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_parameters_1 expected to be basetypes.ObjectValue, was: %T`, ipv4Parameters1Attribute))
	}

	ipv6AddressesAttribute, ok := attributes["ipv6_addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_addresses is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	ipv6AddressesVal, ok := ipv6AddressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_addresses expected to be basetypes.ListValue, was: %T`, ipv6AddressesAttribute))
	}

	ipv6RouterAdvertisement1Attribute, ok := attributes["ipv6_router_advertisement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_router_advertisement_1 is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	ipv6RouterAdvertisement1Val, ok := ipv6RouterAdvertisement1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_router_advertisement_1 expected to be basetypes.ObjectValue, was: %T`, ipv6RouterAdvertisement1Attribute))
	}

	l3proxyArpnd1Attribute, ok := attributes["l3proxy_arpnd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3proxy_arpnd_1 is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	l3proxyArpnd1Val, ok := l3proxyArpnd1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3proxy_arpnd_1 expected to be basetypes.ObjectValue, was: %T`, l3proxyArpnd1Attribute))
	}

	learnUnsolicitedAttribute, ok := attributes["learn_unsolicited"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`learn_unsolicited is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	learnUnsolicitedVal, ok := learnUnsolicitedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`learn_unsolicited expected to be basetypes.StringValue, was: %T`, learnUnsolicitedAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	vlanPoolAttribute, ok := attributes["vlan_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_pool is missing from object`)

		return NewSpec12ValueUnknown(), diags
	}

	vlanPoolVal, ok := vlanPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_pool expected to be basetypes.StringValue, was: %T`, vlanPoolAttribute))
	}

	if diags.HasError() {
		return NewSpec12ValueUnknown(), diags
	}

	return Spec12Value{
		ArpTimeout:               arpTimeoutVal,
		Bfd3:                     bfd3Val,
		Description:              descriptionVal,
		Egress3:                  egress3Val,
		HostRoutePopulate1:       hostRoutePopulate1Val,
		Ingress3:                 ingress3Val,
		Interface:                interfaceVal,
		IpMtu:                    ipMtuVal,
		Ipv4Addresses:            ipv4AddressesVal,
		Ipv4Parameters1:          ipv4Parameters1Val,
		Ipv6Addresses:            ipv6AddressesVal,
		Ipv6RouterAdvertisement1: ipv6RouterAdvertisement1Val,
		L3proxyArpnd1:            l3proxyArpnd1Val,
		LearnUnsolicited:         learnUnsolicitedVal,
		Router:                   routerVal,
		Unnumbered:               unnumberedVal,
		VlanId:                   vlanIdVal,
		VlanPool:                 vlanPoolVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewSpec12ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec12Value {
	object, diags := NewSpec12Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec12ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec12Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec12ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec12ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec12ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec12ValueMust(Spec12Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec12Type) ValueType(ctx context.Context) attr.Value {
	return Spec12Value{}
}

var _ basetypes.ObjectValuable = Spec12Value{}

type Spec12Value struct {
	ArpTimeout               basetypes.Int64Value  `tfsdk:"arp_timeout"`
	Bfd3                     basetypes.ObjectValue `tfsdk:"bfd"`
	Description              basetypes.StringValue `tfsdk:"description"`
	Egress3                  basetypes.ObjectValue `tfsdk:"egress"`
	HostRoutePopulate1       basetypes.ObjectValue `tfsdk:"host_route_populate"`
	Ingress3                 basetypes.ObjectValue `tfsdk:"ingress"`
	Interface                basetypes.StringValue `tfsdk:"interface"`
	IpMtu                    basetypes.Int64Value  `tfsdk:"ip_mtu"`
	Ipv4Addresses            basetypes.ListValue   `tfsdk:"ipv4_addresses"`
	Ipv4Parameters1          basetypes.ObjectValue `tfsdk:"ipv4_parameters"`
	Ipv6Addresses            basetypes.ListValue   `tfsdk:"ipv6_addresses"`
	Ipv6RouterAdvertisement1 basetypes.ObjectValue `tfsdk:"ipv6_router_advertisement"`
	L3proxyArpnd1            basetypes.ObjectValue `tfsdk:"l3proxy_arpnd"`
	LearnUnsolicited         basetypes.StringValue `tfsdk:"learn_unsolicited"`
	Router                   basetypes.StringValue `tfsdk:"router"`
	Unnumbered               basetypes.StringValue `tfsdk:"unnumbered"`
	VlanId                   basetypes.StringValue `tfsdk:"vlan_id"`
	VlanPool                 basetypes.StringValue `tfsdk:"vlan_pool"`
	state                    attr.ValueState
}

func (v Spec12Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 18)

	var val tftypes.Value
	var err error

	attrTypes["arp_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["bfd"] = basetypes.ObjectType{
		AttrTypes: Bfd3Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["egress"] = basetypes.ObjectType{
		AttrTypes: Egress3Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["host_route_populate"] = basetypes.ObjectType{
		AttrTypes: HostRoutePopulate1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ingress"] = basetypes.ObjectType{
		AttrTypes: Ingress3Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ipv4_addresses"] = basetypes.ListType{
		ElemType: Ipv4AddressesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv4_parameters"] = basetypes.ObjectType{
		AttrTypes: Ipv4Parameters1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6_addresses"] = basetypes.ListType{
		ElemType: Ipv6AddressesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6_router_advertisement"] = basetypes.ObjectType{
		AttrTypes: Ipv6RouterAdvertisement1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["l3proxy_arpnd"] = basetypes.ObjectType{
		AttrTypes: L3proxyArpnd1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["learn_unsolicited"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["router"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["unnumbered"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_pool"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 18)

		val, err = v.ArpTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_timeout"] = val

		val, err = v.Bfd3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Egress3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress"] = val

		val, err = v.HostRoutePopulate1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["host_route_populate"] = val

		val, err = v.Ingress3.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.IpMtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_mtu"] = val

		val, err = v.Ipv4Addresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_addresses"] = val

		val, err = v.Ipv4Parameters1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_parameters"] = val

		val, err = v.Ipv6Addresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_addresses"] = val

		val, err = v.Ipv6RouterAdvertisement1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_router_advertisement"] = val

		val, err = v.L3proxyArpnd1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3proxy_arpnd"] = val

		val, err = v.LearnUnsolicited.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["learn_unsolicited"] = val

		val, err = v.Router.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router"] = val

		val, err = v.Unnumbered.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unnumbered"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		val, err = v.VlanPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_pool"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec12Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec12Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec12Value) String() string {
	return "Spec12Value"
}

func (v Spec12Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bfd3 basetypes.ObjectValue

	if v.Bfd3.IsNull() {
		bfd3 = types.ObjectNull(
			Bfd3Value{}.AttributeTypes(ctx),
		)
	}

	if v.Bfd3.IsUnknown() {
		bfd3 = types.ObjectUnknown(
			Bfd3Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Bfd3.IsNull() && !v.Bfd3.IsUnknown() {
		bfd3 = types.ObjectValueMust(
			Bfd3Value{}.AttributeTypes(ctx),
			v.Bfd3.Attributes(),
		)
	}

	var egress3 basetypes.ObjectValue

	if v.Egress3.IsNull() {
		egress3 = types.ObjectNull(
			Egress3Value{}.AttributeTypes(ctx),
		)
	}

	if v.Egress3.IsUnknown() {
		egress3 = types.ObjectUnknown(
			Egress3Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Egress3.IsNull() && !v.Egress3.IsUnknown() {
		egress3 = types.ObjectValueMust(
			Egress3Value{}.AttributeTypes(ctx),
			v.Egress3.Attributes(),
		)
	}

	var hostRoutePopulate1 basetypes.ObjectValue

	if v.HostRoutePopulate1.IsNull() {
		hostRoutePopulate1 = types.ObjectNull(
			HostRoutePopulate1Value{}.AttributeTypes(ctx),
		)
	}

	if v.HostRoutePopulate1.IsUnknown() {
		hostRoutePopulate1 = types.ObjectUnknown(
			HostRoutePopulate1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.HostRoutePopulate1.IsNull() && !v.HostRoutePopulate1.IsUnknown() {
		hostRoutePopulate1 = types.ObjectValueMust(
			HostRoutePopulate1Value{}.AttributeTypes(ctx),
			v.HostRoutePopulate1.Attributes(),
		)
	}

	var ingress3 basetypes.ObjectValue

	if v.Ingress3.IsNull() {
		ingress3 = types.ObjectNull(
			Ingress3Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ingress3.IsUnknown() {
		ingress3 = types.ObjectUnknown(
			Ingress3Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ingress3.IsNull() && !v.Ingress3.IsUnknown() {
		ingress3 = types.ObjectValueMust(
			Ingress3Value{}.AttributeTypes(ctx),
			v.Ingress3.Attributes(),
		)
	}

	ipv4Addresses := types.ListValueMust(
		Ipv4AddressesType{
			basetypes.ObjectType{
				AttrTypes: Ipv4AddressesValue{}.AttributeTypes(ctx),
			},
		},
		v.Ipv4Addresses.Elements(),
	)

	if v.Ipv4Addresses.IsNull() {
		ipv4Addresses = types.ListNull(
			Ipv4AddressesType{
				basetypes.ObjectType{
					AttrTypes: Ipv4AddressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ipv4Addresses.IsUnknown() {
		ipv4Addresses = types.ListUnknown(
			Ipv4AddressesType{
				basetypes.ObjectType{
					AttrTypes: Ipv4AddressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var ipv4Parameters1 basetypes.ObjectValue

	if v.Ipv4Parameters1.IsNull() {
		ipv4Parameters1 = types.ObjectNull(
			Ipv4Parameters1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv4Parameters1.IsUnknown() {
		ipv4Parameters1 = types.ObjectUnknown(
			Ipv4Parameters1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv4Parameters1.IsNull() && !v.Ipv4Parameters1.IsUnknown() {
		ipv4Parameters1 = types.ObjectValueMust(
			Ipv4Parameters1Value{}.AttributeTypes(ctx),
			v.Ipv4Parameters1.Attributes(),
		)
	}

	ipv6Addresses := types.ListValueMust(
		Ipv6AddressesType{
			basetypes.ObjectType{
				AttrTypes: Ipv6AddressesValue{}.AttributeTypes(ctx),
			},
		},
		v.Ipv6Addresses.Elements(),
	)

	if v.Ipv6Addresses.IsNull() {
		ipv6Addresses = types.ListNull(
			Ipv6AddressesType{
				basetypes.ObjectType{
					AttrTypes: Ipv6AddressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ipv6Addresses.IsUnknown() {
		ipv6Addresses = types.ListUnknown(
			Ipv6AddressesType{
				basetypes.ObjectType{
					AttrTypes: Ipv6AddressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var ipv6RouterAdvertisement1 basetypes.ObjectValue

	if v.Ipv6RouterAdvertisement1.IsNull() {
		ipv6RouterAdvertisement1 = types.ObjectNull(
			Ipv6RouterAdvertisement1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv6RouterAdvertisement1.IsUnknown() {
		ipv6RouterAdvertisement1 = types.ObjectUnknown(
			Ipv6RouterAdvertisement1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv6RouterAdvertisement1.IsNull() && !v.Ipv6RouterAdvertisement1.IsUnknown() {
		ipv6RouterAdvertisement1 = types.ObjectValueMust(
			Ipv6RouterAdvertisement1Value{}.AttributeTypes(ctx),
			v.Ipv6RouterAdvertisement1.Attributes(),
		)
	}

	var l3proxyArpnd1 basetypes.ObjectValue

	if v.L3proxyArpnd1.IsNull() {
		l3proxyArpnd1 = types.ObjectNull(
			L3proxyArpnd1Value{}.AttributeTypes(ctx),
		)
	}

	if v.L3proxyArpnd1.IsUnknown() {
		l3proxyArpnd1 = types.ObjectUnknown(
			L3proxyArpnd1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.L3proxyArpnd1.IsNull() && !v.L3proxyArpnd1.IsUnknown() {
		l3proxyArpnd1 = types.ObjectValueMust(
			L3proxyArpnd1Value{}.AttributeTypes(ctx),
			v.L3proxyArpnd1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"arp_timeout": basetypes.Int64Type{},
		"bfd": basetypes.ObjectType{
			AttrTypes: Bfd3Value{}.AttributeTypes(ctx),
		},
		"description": basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: Egress3Value{}.AttributeTypes(ctx),
		},
		"host_route_populate": basetypes.ObjectType{
			AttrTypes: HostRoutePopulate1Value{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: Ingress3Value{}.AttributeTypes(ctx),
		},
		"interface": basetypes.StringType{},
		"ip_mtu":    basetypes.Int64Type{},
		"ipv4_addresses": basetypes.ListType{
			ElemType: Ipv4AddressesValue{}.Type(ctx),
		},
		"ipv4_parameters": basetypes.ObjectType{
			AttrTypes: Ipv4Parameters1Value{}.AttributeTypes(ctx),
		},
		"ipv6_addresses": basetypes.ListType{
			ElemType: Ipv6AddressesValue{}.Type(ctx),
		},
		"ipv6_router_advertisement": basetypes.ObjectType{
			AttrTypes: Ipv6RouterAdvertisement1Value{}.AttributeTypes(ctx),
		},
		"l3proxy_arpnd": basetypes.ObjectType{
			AttrTypes: L3proxyArpnd1Value{}.AttributeTypes(ctx),
		},
		"learn_unsolicited": basetypes.StringType{},
		"router":            basetypes.StringType{},
		"unnumbered":        basetypes.StringType{},
		"vlan_id":           basetypes.StringType{},
		"vlan_pool":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"arp_timeout":               v.ArpTimeout,
			"bfd":                       bfd3,
			"description":               v.Description,
			"egress":                    egress3,
			"host_route_populate":       hostRoutePopulate1,
			"ingress":                   ingress3,
			"interface":                 v.Interface,
			"ip_mtu":                    v.IpMtu,
			"ipv4_addresses":            ipv4Addresses,
			"ipv4_parameters":           ipv4Parameters1,
			"ipv6_addresses":            ipv6Addresses,
			"ipv6_router_advertisement": ipv6RouterAdvertisement1,
			"l3proxy_arpnd":             l3proxyArpnd1,
			"learn_unsolicited":         v.LearnUnsolicited,
			"router":                    v.Router,
			"unnumbered":                v.Unnumbered,
			"vlan_id":                   v.VlanId,
			"vlan_pool":                 v.VlanPool,
		})

	return objVal, diags
}

func (v Spec12Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec12Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ArpTimeout.Equal(other.ArpTimeout) {
		return false
	}

	if !v.Bfd3.Equal(other.Bfd3) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Egress3.Equal(other.Egress3) {
		return false
	}

	if !v.HostRoutePopulate1.Equal(other.HostRoutePopulate1) {
		return false
	}

	if !v.Ingress3.Equal(other.Ingress3) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.IpMtu.Equal(other.IpMtu) {
		return false
	}

	if !v.Ipv4Addresses.Equal(other.Ipv4Addresses) {
		return false
	}

	if !v.Ipv4Parameters1.Equal(other.Ipv4Parameters1) {
		return false
	}

	if !v.Ipv6Addresses.Equal(other.Ipv6Addresses) {
		return false
	}

	if !v.Ipv6RouterAdvertisement1.Equal(other.Ipv6RouterAdvertisement1) {
		return false
	}

	if !v.L3proxyArpnd1.Equal(other.L3proxyArpnd1) {
		return false
	}

	if !v.LearnUnsolicited.Equal(other.LearnUnsolicited) {
		return false
	}

	if !v.Router.Equal(other.Router) {
		return false
	}

	if !v.Unnumbered.Equal(other.Unnumbered) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	if !v.VlanPool.Equal(other.VlanPool) {
		return false
	}

	return true
}

func (v Spec12Value) Type(ctx context.Context) attr.Type {
	return Spec12Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec12Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"arp_timeout": basetypes.Int64Type{},
		"bfd": basetypes.ObjectType{
			AttrTypes: Bfd3Value{}.AttributeTypes(ctx),
		},
		"description": basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: Egress3Value{}.AttributeTypes(ctx),
		},
		"host_route_populate": basetypes.ObjectType{
			AttrTypes: HostRoutePopulate1Value{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: Ingress3Value{}.AttributeTypes(ctx),
		},
		"interface": basetypes.StringType{},
		"ip_mtu":    basetypes.Int64Type{},
		"ipv4_addresses": basetypes.ListType{
			ElemType: Ipv4AddressesValue{}.Type(ctx),
		},
		"ipv4_parameters": basetypes.ObjectType{
			AttrTypes: Ipv4Parameters1Value{}.AttributeTypes(ctx),
		},
		"ipv6_addresses": basetypes.ListType{
			ElemType: Ipv6AddressesValue{}.Type(ctx),
		},
		"ipv6_router_advertisement": basetypes.ObjectType{
			AttrTypes: Ipv6RouterAdvertisement1Value{}.AttributeTypes(ctx),
		},
		"l3proxy_arpnd": basetypes.ObjectType{
			AttrTypes: L3proxyArpnd1Value{}.AttributeTypes(ctx),
		},
		"learn_unsolicited": basetypes.StringType{},
		"router":            basetypes.StringType{},
		"unnumbered":        basetypes.StringType{},
		"vlan_id":           basetypes.StringType{},
		"vlan_pool":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Bfd3Type{}

type Bfd3Type struct {
	basetypes.ObjectType
}

func (t Bfd3Type) Equal(o attr.Type) bool {
	other, ok := o.(Bfd3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Bfd3Type) String() string {
	return "Bfd3Type"
}

func (t Bfd3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return nil, diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return nil, diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return nil, diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return nil, diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return nil, diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Bfd3Value{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfd3ValueNull() Bfd3Value {
	return Bfd3Value{
		state: attr.ValueStateNull,
	}
}

func NewBfd3ValueUnknown() Bfd3Value {
	return Bfd3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBfd3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Bfd3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Bfd3Value Attribute Value",
				"While creating a Bfd3Value value, a missing attribute value was detected. "+
					"A Bfd3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bfd3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Bfd3Value Attribute Type",
				"While creating a Bfd3Value value, an invalid attribute value was detected. "+
					"A Bfd3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bfd3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Bfd3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Bfd3Value Attribute Value",
				"While creating a Bfd3Value value, an extra attribute value was detected. "+
					"A Bfd3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Bfd3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBfd3ValueUnknown(), diags
	}

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return NewBfd3ValueUnknown(), diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return NewBfd3ValueUnknown(), diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBfd3ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return NewBfd3ValueUnknown(), diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return NewBfd3ValueUnknown(), diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return NewBfd3ValueUnknown(), diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return NewBfd3ValueUnknown(), diags
	}

	return Bfd3Value{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfd3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Bfd3Value {
	object, diags := NewBfd3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBfd3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Bfd3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBfd3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBfd3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBfd3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBfd3ValueMust(Bfd3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Bfd3Type) ValueType(ctx context.Context) attr.Value {
	return Bfd3Value{}
}

var _ basetypes.ObjectValuable = Bfd3Value{}

type Bfd3Value struct {
	DesiredMinTransmitInt  basetypes.Int64Value `tfsdk:"desired_min_transmit_int"`
	DetectionMultiplier    basetypes.Int64Value `tfsdk:"detection_multiplier"`
	Enabled                basetypes.BoolValue  `tfsdk:"enabled"`
	MinEchoReceiveInterval basetypes.Int64Value `tfsdk:"min_echo_receive_interval"`
	RequiredMinReceive     basetypes.Int64Value `tfsdk:"required_min_receive"`
	Ttl                    basetypes.Int64Value `tfsdk:"ttl"`
	state                  attr.ValueState
}

func (v Bfd3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["desired_min_transmit_int"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["detection_multiplier"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["min_echo_receive_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["required_min_receive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ttl"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.DesiredMinTransmitInt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_min_transmit_int"] = val

		val, err = v.DetectionMultiplier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["detection_multiplier"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.MinEchoReceiveInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_echo_receive_interval"] = val

		val, err = v.RequiredMinReceive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required_min_receive"] = val

		val, err = v.Ttl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ttl"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Bfd3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Bfd3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Bfd3Value) String() string {
	return "Bfd3Value"
}

func (v Bfd3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"desired_min_transmit_int":  v.DesiredMinTransmitInt,
			"detection_multiplier":      v.DetectionMultiplier,
			"enabled":                   v.Enabled,
			"min_echo_receive_interval": v.MinEchoReceiveInterval,
			"required_min_receive":      v.RequiredMinReceive,
			"ttl":                       v.Ttl,
		})

	return objVal, diags
}

func (v Bfd3Value) Equal(o attr.Value) bool {
	other, ok := o.(Bfd3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DesiredMinTransmitInt.Equal(other.DesiredMinTransmitInt) {
		return false
	}

	if !v.DetectionMultiplier.Equal(other.DetectionMultiplier) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.MinEchoReceiveInterval.Equal(other.MinEchoReceiveInterval) {
		return false
	}

	if !v.RequiredMinReceive.Equal(other.RequiredMinReceive) {
		return false
	}

	if !v.Ttl.Equal(other.Ttl) {
		return false
	}

	return true
}

func (v Bfd3Value) Type(ctx context.Context) attr.Type {
	return Bfd3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Bfd3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Egress3Type{}

type Egress3Type struct {
	basetypes.ObjectType
}

func (t Egress3Type) Equal(o attr.Type) bool {
	other, ok := o.(Egress3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Egress3Type) String() string {
	return "Egress3Type"
}

func (t Egress3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Egress3Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgress3ValueNull() Egress3Value {
	return Egress3Value{
		state: attr.ValueStateNull,
	}
}

func NewEgress3ValueUnknown() Egress3Value {
	return Egress3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewEgress3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Egress3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Egress3Value Attribute Value",
				"While creating a Egress3Value value, a missing attribute value was detected. "+
					"A Egress3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Egress3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Egress3Value Attribute Type",
				"While creating a Egress3Value value, an invalid attribute value was detected. "+
					"A Egress3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Egress3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Egress3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Egress3Value Attribute Value",
				"While creating a Egress3Value value, an extra attribute value was detected. "+
					"A Egress3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Egress3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEgress3ValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewEgress3ValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewEgress3ValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewEgress3ValueUnknown(), diags
	}

	return Egress3Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgress3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Egress3Value {
	object, diags := NewEgress3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEgress3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Egress3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEgress3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEgress3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEgress3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEgress3ValueMust(Egress3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Egress3Type) ValueType(ctx context.Context) attr.Value {
	return Egress3Value{}
}

var _ basetypes.ObjectValuable = Egress3Value{}

type Egress3Value struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v Egress3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Egress3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Egress3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Egress3Value) String() string {
	return "Egress3Value"
}

func (v Egress3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v Egress3Value) Equal(o attr.Value) bool {
	other, ok := o.(Egress3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v Egress3Value) Type(ctx context.Context) attr.Type {
	return Egress3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Egress3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = HostRoutePopulate1Type{}

type HostRoutePopulate1Type struct {
	basetypes.ObjectType
}

func (t HostRoutePopulate1Type) Equal(o attr.Type) bool {
	other, ok := o.(HostRoutePopulate1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t HostRoutePopulate1Type) String() string {
	return "HostRoutePopulate1Type"
}

func (t HostRoutePopulate1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dynamicAttribute, ok := attributes["dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic is missing from object`)

		return nil, diags
	}

	dynamicVal, ok := dynamicAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic expected to be basetypes.ObjectValue, was: %T`, dynamicAttribute))
	}

	evpnAttribute, ok := attributes["evpn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn is missing from object`)

		return nil, diags
	}

	evpnVal, ok := evpnAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn expected to be basetypes.ObjectValue, was: %T`, evpnAttribute))
	}

	staticAttribute, ok := attributes["static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static is missing from object`)

		return nil, diags
	}

	staticVal, ok := staticAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static expected to be basetypes.ObjectValue, was: %T`, staticAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return HostRoutePopulate1Value{
		Dynamic: dynamicVal,
		Evpn:    evpnVal,
		Static:  staticVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewHostRoutePopulate1ValueNull() HostRoutePopulate1Value {
	return HostRoutePopulate1Value{
		state: attr.ValueStateNull,
	}
}

func NewHostRoutePopulate1ValueUnknown() HostRoutePopulate1Value {
	return HostRoutePopulate1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewHostRoutePopulate1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (HostRoutePopulate1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing HostRoutePopulate1Value Attribute Value",
				"While creating a HostRoutePopulate1Value value, a missing attribute value was detected. "+
					"A HostRoutePopulate1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HostRoutePopulate1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid HostRoutePopulate1Value Attribute Type",
				"While creating a HostRoutePopulate1Value value, an invalid attribute value was detected. "+
					"A HostRoutePopulate1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("HostRoutePopulate1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("HostRoutePopulate1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra HostRoutePopulate1Value Attribute Value",
				"While creating a HostRoutePopulate1Value value, an extra attribute value was detected. "+
					"A HostRoutePopulate1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra HostRoutePopulate1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewHostRoutePopulate1ValueUnknown(), diags
	}

	dynamicAttribute, ok := attributes["dynamic"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic is missing from object`)

		return NewHostRoutePopulate1ValueUnknown(), diags
	}

	dynamicVal, ok := dynamicAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic expected to be basetypes.ObjectValue, was: %T`, dynamicAttribute))
	}

	evpnAttribute, ok := attributes["evpn"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evpn is missing from object`)

		return NewHostRoutePopulate1ValueUnknown(), diags
	}

	evpnVal, ok := evpnAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evpn expected to be basetypes.ObjectValue, was: %T`, evpnAttribute))
	}

	staticAttribute, ok := attributes["static"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`static is missing from object`)

		return NewHostRoutePopulate1ValueUnknown(), diags
	}

	staticVal, ok := staticAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`static expected to be basetypes.ObjectValue, was: %T`, staticAttribute))
	}

	if diags.HasError() {
		return NewHostRoutePopulate1ValueUnknown(), diags
	}

	return HostRoutePopulate1Value{
		Dynamic: dynamicVal,
		Evpn:    evpnVal,
		Static:  staticVal,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewHostRoutePopulate1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) HostRoutePopulate1Value {
	object, diags := NewHostRoutePopulate1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewHostRoutePopulate1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t HostRoutePopulate1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewHostRoutePopulate1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewHostRoutePopulate1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewHostRoutePopulate1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewHostRoutePopulate1ValueMust(HostRoutePopulate1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t HostRoutePopulate1Type) ValueType(ctx context.Context) attr.Value {
	return HostRoutePopulate1Value{}
}

var _ basetypes.ObjectValuable = HostRoutePopulate1Value{}

type HostRoutePopulate1Value struct {
	Dynamic basetypes.ObjectValue `tfsdk:"dynamic"`
	Evpn    basetypes.ObjectValue `tfsdk:"evpn"`
	Static  basetypes.ObjectValue `tfsdk:"static"`
	state   attr.ValueState
}

func (v HostRoutePopulate1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["dynamic"] = basetypes.ObjectType{
		AttrTypes: DynamicValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["evpn"] = basetypes.ObjectType{
		AttrTypes: EvpnValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["static"] = basetypes.ObjectType{
		AttrTypes: StaticValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Dynamic.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic"] = val

		val, err = v.Evpn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evpn"] = val

		val, err = v.Static.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["static"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v HostRoutePopulate1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v HostRoutePopulate1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v HostRoutePopulate1Value) String() string {
	return "HostRoutePopulate1Value"
}

func (v HostRoutePopulate1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var dynamic basetypes.ObjectValue

	if v.Dynamic.IsNull() {
		dynamic = types.ObjectNull(
			DynamicValue{}.AttributeTypes(ctx),
		)
	}

	if v.Dynamic.IsUnknown() {
		dynamic = types.ObjectUnknown(
			DynamicValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Dynamic.IsNull() && !v.Dynamic.IsUnknown() {
		dynamic = types.ObjectValueMust(
			DynamicValue{}.AttributeTypes(ctx),
			v.Dynamic.Attributes(),
		)
	}

	var evpn basetypes.ObjectValue

	if v.Evpn.IsNull() {
		evpn = types.ObjectNull(
			EvpnValue{}.AttributeTypes(ctx),
		)
	}

	if v.Evpn.IsUnknown() {
		evpn = types.ObjectUnknown(
			EvpnValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Evpn.IsNull() && !v.Evpn.IsUnknown() {
		evpn = types.ObjectValueMust(
			EvpnValue{}.AttributeTypes(ctx),
			v.Evpn.Attributes(),
		)
	}

	var static basetypes.ObjectValue

	if v.Static.IsNull() {
		static = types.ObjectNull(
			StaticValue{}.AttributeTypes(ctx),
		)
	}

	if v.Static.IsUnknown() {
		static = types.ObjectUnknown(
			StaticValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Static.IsNull() && !v.Static.IsUnknown() {
		static = types.ObjectValueMust(
			StaticValue{}.AttributeTypes(ctx),
			v.Static.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"dynamic": basetypes.ObjectType{
			AttrTypes: DynamicValue{}.AttributeTypes(ctx),
		},
		"evpn": basetypes.ObjectType{
			AttrTypes: EvpnValue{}.AttributeTypes(ctx),
		},
		"static": basetypes.ObjectType{
			AttrTypes: StaticValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dynamic": dynamic,
			"evpn":    evpn,
			"static":  static,
		})

	return objVal, diags
}

func (v HostRoutePopulate1Value) Equal(o attr.Value) bool {
	other, ok := o.(HostRoutePopulate1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Dynamic.Equal(other.Dynamic) {
		return false
	}

	if !v.Evpn.Equal(other.Evpn) {
		return false
	}

	if !v.Static.Equal(other.Static) {
		return false
	}

	return true
}

func (v HostRoutePopulate1Value) Type(ctx context.Context) attr.Type {
	return HostRoutePopulate1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v HostRoutePopulate1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dynamic": basetypes.ObjectType{
			AttrTypes: DynamicValue{}.AttributeTypes(ctx),
		},
		"evpn": basetypes.ObjectType{
			AttrTypes: EvpnValue{}.AttributeTypes(ctx),
		},
		"static": basetypes.ObjectType{
			AttrTypes: StaticValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DynamicType{}

type DynamicType struct {
	basetypes.ObjectType
}

func (t DynamicType) Equal(o attr.Type) bool {
	other, ok := o.(DynamicType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DynamicType) String() string {
	return "DynamicType"
}

func (t DynamicType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	datapathProgrammingAttribute, ok := attributes["datapath_programming"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datapath_programming is missing from object`)

		return nil, diags
	}

	datapathProgrammingVal, ok := datapathProgrammingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datapath_programming expected to be basetypes.BoolValue, was: %T`, datapathProgrammingAttribute))
	}

	populateAttribute, ok := attributes["populate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`populate is missing from object`)

		return nil, diags
	}

	populateVal, ok := populateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`populate expected to be basetypes.BoolValue, was: %T`, populateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DynamicValue{
		DatapathProgramming: datapathProgrammingVal,
		Populate:            populateVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDynamicValueNull() DynamicValue {
	return DynamicValue{
		state: attr.ValueStateNull,
	}
}

func NewDynamicValueUnknown() DynamicValue {
	return DynamicValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDynamicValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DynamicValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DynamicValue Attribute Value",
				"While creating a DynamicValue value, a missing attribute value was detected. "+
					"A DynamicValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DynamicValue Attribute Type",
				"While creating a DynamicValue value, an invalid attribute value was detected. "+
					"A DynamicValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DynamicValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DynamicValue Attribute Value",
				"While creating a DynamicValue value, an extra attribute value was detected. "+
					"A DynamicValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DynamicValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDynamicValueUnknown(), diags
	}

	datapathProgrammingAttribute, ok := attributes["datapath_programming"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datapath_programming is missing from object`)

		return NewDynamicValueUnknown(), diags
	}

	datapathProgrammingVal, ok := datapathProgrammingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datapath_programming expected to be basetypes.BoolValue, was: %T`, datapathProgrammingAttribute))
	}

	populateAttribute, ok := attributes["populate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`populate is missing from object`)

		return NewDynamicValueUnknown(), diags
	}

	populateVal, ok := populateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`populate expected to be basetypes.BoolValue, was: %T`, populateAttribute))
	}

	if diags.HasError() {
		return NewDynamicValueUnknown(), diags
	}

	return DynamicValue{
		DatapathProgramming: datapathProgrammingVal,
		Populate:            populateVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewDynamicValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DynamicValue {
	object, diags := NewDynamicValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDynamicValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DynamicType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDynamicValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDynamicValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDynamicValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDynamicValueMust(DynamicValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DynamicType) ValueType(ctx context.Context) attr.Value {
	return DynamicValue{}
}

var _ basetypes.ObjectValuable = DynamicValue{}

type DynamicValue struct {
	DatapathProgramming basetypes.BoolValue `tfsdk:"datapath_programming"`
	Populate            basetypes.BoolValue `tfsdk:"populate"`
	state               attr.ValueState
}

func (v DynamicValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["datapath_programming"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["populate"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.DatapathProgramming.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["datapath_programming"] = val

		val, err = v.Populate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["populate"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DynamicValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DynamicValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DynamicValue) String() string {
	return "DynamicValue"
}

func (v DynamicValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"datapath_programming": basetypes.BoolType{},
		"populate":             basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"datapath_programming": v.DatapathProgramming,
			"populate":             v.Populate,
		})

	return objVal, diags
}

func (v DynamicValue) Equal(o attr.Value) bool {
	other, ok := o.(DynamicValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DatapathProgramming.Equal(other.DatapathProgramming) {
		return false
	}

	if !v.Populate.Equal(other.Populate) {
		return false
	}

	return true
}

func (v DynamicValue) Type(ctx context.Context) attr.Type {
	return DynamicType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DynamicValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"datapath_programming": basetypes.BoolType{},
		"populate":             basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = EvpnType{}

type EvpnType struct {
	basetypes.ObjectType
}

func (t EvpnType) Equal(o attr.Type) bool {
	other, ok := o.(EvpnType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EvpnType) String() string {
	return "EvpnType"
}

func (t EvpnType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	datapathProgrammingAttribute, ok := attributes["datapath_programming"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datapath_programming is missing from object`)

		return nil, diags
	}

	datapathProgrammingVal, ok := datapathProgrammingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datapath_programming expected to be basetypes.BoolValue, was: %T`, datapathProgrammingAttribute))
	}

	populateAttribute, ok := attributes["populate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`populate is missing from object`)

		return nil, diags
	}

	populateVal, ok := populateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`populate expected to be basetypes.BoolValue, was: %T`, populateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EvpnValue{
		DatapathProgramming: datapathProgrammingVal,
		Populate:            populateVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewEvpnValueNull() EvpnValue {
	return EvpnValue{
		state: attr.ValueStateNull,
	}
}

func NewEvpnValueUnknown() EvpnValue {
	return EvpnValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEvpnValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EvpnValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EvpnValue Attribute Value",
				"While creating a EvpnValue value, a missing attribute value was detected. "+
					"A EvpnValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvpnValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EvpnValue Attribute Type",
				"While creating a EvpnValue value, an invalid attribute value was detected. "+
					"A EvpnValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EvpnValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EvpnValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EvpnValue Attribute Value",
				"While creating a EvpnValue value, an extra attribute value was detected. "+
					"A EvpnValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EvpnValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEvpnValueUnknown(), diags
	}

	datapathProgrammingAttribute, ok := attributes["datapath_programming"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datapath_programming is missing from object`)

		return NewEvpnValueUnknown(), diags
	}

	datapathProgrammingVal, ok := datapathProgrammingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datapath_programming expected to be basetypes.BoolValue, was: %T`, datapathProgrammingAttribute))
	}

	populateAttribute, ok := attributes["populate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`populate is missing from object`)

		return NewEvpnValueUnknown(), diags
	}

	populateVal, ok := populateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`populate expected to be basetypes.BoolValue, was: %T`, populateAttribute))
	}

	if diags.HasError() {
		return NewEvpnValueUnknown(), diags
	}

	return EvpnValue{
		DatapathProgramming: datapathProgrammingVal,
		Populate:            populateVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewEvpnValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EvpnValue {
	object, diags := NewEvpnValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEvpnValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EvpnType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEvpnValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEvpnValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEvpnValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEvpnValueMust(EvpnValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EvpnType) ValueType(ctx context.Context) attr.Value {
	return EvpnValue{}
}

var _ basetypes.ObjectValuable = EvpnValue{}

type EvpnValue struct {
	DatapathProgramming basetypes.BoolValue `tfsdk:"datapath_programming"`
	Populate            basetypes.BoolValue `tfsdk:"populate"`
	state               attr.ValueState
}

func (v EvpnValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["datapath_programming"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["populate"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.DatapathProgramming.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["datapath_programming"] = val

		val, err = v.Populate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["populate"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EvpnValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EvpnValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EvpnValue) String() string {
	return "EvpnValue"
}

func (v EvpnValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"datapath_programming": basetypes.BoolType{},
		"populate":             basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"datapath_programming": v.DatapathProgramming,
			"populate":             v.Populate,
		})

	return objVal, diags
}

func (v EvpnValue) Equal(o attr.Value) bool {
	other, ok := o.(EvpnValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DatapathProgramming.Equal(other.DatapathProgramming) {
		return false
	}

	if !v.Populate.Equal(other.Populate) {
		return false
	}

	return true
}

func (v EvpnValue) Type(ctx context.Context) attr.Type {
	return EvpnType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EvpnValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"datapath_programming": basetypes.BoolType{},
		"populate":             basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = StaticType{}

type StaticType struct {
	basetypes.ObjectType
}

func (t StaticType) Equal(o attr.Type) bool {
	other, ok := o.(StaticType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StaticType) String() string {
	return "StaticType"
}

func (t StaticType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	datapathProgrammingAttribute, ok := attributes["datapath_programming"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datapath_programming is missing from object`)

		return nil, diags
	}

	datapathProgrammingVal, ok := datapathProgrammingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datapath_programming expected to be basetypes.BoolValue, was: %T`, datapathProgrammingAttribute))
	}

	populateAttribute, ok := attributes["populate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`populate is missing from object`)

		return nil, diags
	}

	populateVal, ok := populateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`populate expected to be basetypes.BoolValue, was: %T`, populateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StaticValue{
		DatapathProgramming: datapathProgrammingVal,
		Populate:            populateVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewStaticValueNull() StaticValue {
	return StaticValue{
		state: attr.ValueStateNull,
	}
}

func NewStaticValueUnknown() StaticValue {
	return StaticValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStaticValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StaticValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StaticValue Attribute Value",
				"While creating a StaticValue value, a missing attribute value was detected. "+
					"A StaticValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StaticValue Attribute Type",
				"While creating a StaticValue value, an invalid attribute value was detected. "+
					"A StaticValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StaticValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StaticValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StaticValue Attribute Value",
				"While creating a StaticValue value, an extra attribute value was detected. "+
					"A StaticValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StaticValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStaticValueUnknown(), diags
	}

	datapathProgrammingAttribute, ok := attributes["datapath_programming"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`datapath_programming is missing from object`)

		return NewStaticValueUnknown(), diags
	}

	datapathProgrammingVal, ok := datapathProgrammingAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`datapath_programming expected to be basetypes.BoolValue, was: %T`, datapathProgrammingAttribute))
	}

	populateAttribute, ok := attributes["populate"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`populate is missing from object`)

		return NewStaticValueUnknown(), diags
	}

	populateVal, ok := populateAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`populate expected to be basetypes.BoolValue, was: %T`, populateAttribute))
	}

	if diags.HasError() {
		return NewStaticValueUnknown(), diags
	}

	return StaticValue{
		DatapathProgramming: datapathProgrammingVal,
		Populate:            populateVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewStaticValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StaticValue {
	object, diags := NewStaticValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStaticValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StaticType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStaticValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStaticValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStaticValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStaticValueMust(StaticValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StaticType) ValueType(ctx context.Context) attr.Value {
	return StaticValue{}
}

var _ basetypes.ObjectValuable = StaticValue{}

type StaticValue struct {
	DatapathProgramming basetypes.BoolValue `tfsdk:"datapath_programming"`
	Populate            basetypes.BoolValue `tfsdk:"populate"`
	state               attr.ValueState
}

func (v StaticValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["datapath_programming"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["populate"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.DatapathProgramming.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["datapath_programming"] = val

		val, err = v.Populate.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["populate"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StaticValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StaticValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StaticValue) String() string {
	return "StaticValue"
}

func (v StaticValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"datapath_programming": basetypes.BoolType{},
		"populate":             basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"datapath_programming": v.DatapathProgramming,
			"populate":             v.Populate,
		})

	return objVal, diags
}

func (v StaticValue) Equal(o attr.Value) bool {
	other, ok := o.(StaticValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DatapathProgramming.Equal(other.DatapathProgramming) {
		return false
	}

	if !v.Populate.Equal(other.Populate) {
		return false
	}

	return true
}

func (v StaticValue) Type(ctx context.Context) attr.Type {
	return StaticType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StaticValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"datapath_programming": basetypes.BoolType{},
		"populate":             basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ingress3Type{}

type Ingress3Type struct {
	basetypes.ObjectType
}

func (t Ingress3Type) Equal(o attr.Type) bool {
	other, ok := o.(Ingress3Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ingress3Type) String() string {
	return "Ingress3Type"
}

func (t Ingress3Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ingress3Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngress3ValueNull() Ingress3Value {
	return Ingress3Value{
		state: attr.ValueStateNull,
	}
}

func NewIngress3ValueUnknown() Ingress3Value {
	return Ingress3Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIngress3Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ingress3Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ingress3Value Attribute Value",
				"While creating a Ingress3Value value, a missing attribute value was detected. "+
					"A Ingress3Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ingress3Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ingress3Value Attribute Type",
				"While creating a Ingress3Value value, an invalid attribute value was detected. "+
					"A Ingress3Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ingress3Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ingress3Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ingress3Value Attribute Value",
				"While creating a Ingress3Value value, an extra attribute value was detected. "+
					"A Ingress3Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ingress3Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIngress3ValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewIngress3ValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewIngress3ValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewIngress3ValueUnknown(), diags
	}

	return Ingress3Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngress3ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ingress3Value {
	object, diags := NewIngress3Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIngress3ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ingress3Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIngress3ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIngress3ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIngress3ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIngress3ValueMust(Ingress3Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ingress3Type) ValueType(ctx context.Context) attr.Value {
	return Ingress3Value{}
}

var _ basetypes.ObjectValuable = Ingress3Value{}

type Ingress3Value struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v Ingress3Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ingress3Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ingress3Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ingress3Value) String() string {
	return "Ingress3Value"
}

func (v Ingress3Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v Ingress3Value) Equal(o attr.Value) bool {
	other, ok := o.(Ingress3Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v Ingress3Value) Type(ctx context.Context) attr.Type {
	return Ingress3Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ingress3Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Ipv4AddressesType{}

type Ipv4AddressesType struct {
	basetypes.ObjectType
}

func (t Ipv4AddressesType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4AddressesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4AddressesType) String() string {
	return "Ipv4AddressesType"
}

func (t Ipv4AddressesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return nil, diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4AddressesValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv4AddressesValueNull() Ipv4AddressesValue {
	return Ipv4AddressesValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv4AddressesValueUnknown() Ipv4AddressesValue {
	return Ipv4AddressesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4AddressesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4AddressesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4AddressesValue Attribute Value",
				"While creating a Ipv4AddressesValue value, a missing attribute value was detected. "+
					"A Ipv4AddressesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4AddressesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4AddressesValue Attribute Type",
				"While creating a Ipv4AddressesValue value, an invalid attribute value was detected. "+
					"A Ipv4AddressesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4AddressesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4AddressesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4AddressesValue Attribute Value",
				"While creating a Ipv4AddressesValue value, an extra attribute value was detected. "+
					"A Ipv4AddressesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4AddressesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4AddressesValueUnknown(), diags
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return NewIpv4AddressesValueUnknown(), diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewIpv4AddressesValueUnknown(), diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return NewIpv4AddressesValueUnknown(), diags
	}

	return Ipv4AddressesValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv4AddressesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4AddressesValue {
	object, diags := NewIpv4AddressesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4AddressesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4AddressesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4AddressesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4AddressesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4AddressesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4AddressesValueMust(Ipv4AddressesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4AddressesType) ValueType(ctx context.Context) attr.Value {
	return Ipv4AddressesValue{}
}

var _ basetypes.ObjectValuable = Ipv4AddressesValue{}

type Ipv4AddressesValue struct {
	IpPrefix basetypes.StringValue `tfsdk:"ip_prefix"`
	Primary  basetypes.BoolValue   `tfsdk:"primary"`
	state    attr.ValueState
}

func (v Ipv4AddressesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_prefix"] = val

		val, err = v.Primary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4AddressesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4AddressesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4AddressesValue) String() string {
	return "Ipv4AddressesValue"
}

func (v Ipv4AddressesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_prefix": v.IpPrefix,
			"primary":   v.Primary,
		})

	return objVal, diags
}

func (v Ipv4AddressesValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4AddressesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpPrefix.Equal(other.IpPrefix) {
		return false
	}

	if !v.Primary.Equal(other.Primary) {
		return false
	}

	return true
}

func (v Ipv4AddressesValue) Type(ctx context.Context) attr.Type {
	return Ipv4AddressesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4AddressesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ipv4Parameters1Type{}

type Ipv4Parameters1Type struct {
	basetypes.ObjectType
}

func (t Ipv4Parameters1Type) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4Parameters1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4Parameters1Type) String() string {
	return "Ipv4Parameters1Type"
}

func (t Ipv4Parameters1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	directedBroadcastAttribute, ok := attributes["directed_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`directed_broadcast is missing from object`)

		return nil, diags
	}

	directedBroadcastVal, ok := directedBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`directed_broadcast expected to be basetypes.BoolValue, was: %T`, directedBroadcastAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4Parameters1Value{
		DirectedBroadcast: directedBroadcastVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewIpv4Parameters1ValueNull() Ipv4Parameters1Value {
	return Ipv4Parameters1Value{
		state: attr.ValueStateNull,
	}
}

func NewIpv4Parameters1ValueUnknown() Ipv4Parameters1Value {
	return Ipv4Parameters1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4Parameters1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4Parameters1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4Parameters1Value Attribute Value",
				"While creating a Ipv4Parameters1Value value, a missing attribute value was detected. "+
					"A Ipv4Parameters1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4Parameters1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4Parameters1Value Attribute Type",
				"While creating a Ipv4Parameters1Value value, an invalid attribute value was detected. "+
					"A Ipv4Parameters1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4Parameters1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4Parameters1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4Parameters1Value Attribute Value",
				"While creating a Ipv4Parameters1Value value, an extra attribute value was detected. "+
					"A Ipv4Parameters1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4Parameters1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4Parameters1ValueUnknown(), diags
	}

	directedBroadcastAttribute, ok := attributes["directed_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`directed_broadcast is missing from object`)

		return NewIpv4Parameters1ValueUnknown(), diags
	}

	directedBroadcastVal, ok := directedBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`directed_broadcast expected to be basetypes.BoolValue, was: %T`, directedBroadcastAttribute))
	}

	if diags.HasError() {
		return NewIpv4Parameters1ValueUnknown(), diags
	}

	return Ipv4Parameters1Value{
		DirectedBroadcast: directedBroadcastVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewIpv4Parameters1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4Parameters1Value {
	object, diags := NewIpv4Parameters1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4Parameters1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4Parameters1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4Parameters1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4Parameters1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4Parameters1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4Parameters1ValueMust(Ipv4Parameters1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4Parameters1Type) ValueType(ctx context.Context) attr.Value {
	return Ipv4Parameters1Value{}
}

var _ basetypes.ObjectValuable = Ipv4Parameters1Value{}

type Ipv4Parameters1Value struct {
	DirectedBroadcast basetypes.BoolValue `tfsdk:"directed_broadcast"`
	state             attr.ValueState
}

func (v Ipv4Parameters1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["directed_broadcast"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.DirectedBroadcast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["directed_broadcast"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4Parameters1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4Parameters1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4Parameters1Value) String() string {
	return "Ipv4Parameters1Value"
}

func (v Ipv4Parameters1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"directed_broadcast": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"directed_broadcast": v.DirectedBroadcast,
		})

	return objVal, diags
}

func (v Ipv4Parameters1Value) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4Parameters1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DirectedBroadcast.Equal(other.DirectedBroadcast) {
		return false
	}

	return true
}

func (v Ipv4Parameters1Value) Type(ctx context.Context) attr.Type {
	return Ipv4Parameters1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4Parameters1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"directed_broadcast": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ipv6AddressesType{}

type Ipv6AddressesType struct {
	basetypes.ObjectType
}

func (t Ipv6AddressesType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6AddressesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6AddressesType) String() string {
	return "Ipv6AddressesType"
}

func (t Ipv6AddressesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return nil, diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6AddressesValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv6AddressesValueNull() Ipv6AddressesValue {
	return Ipv6AddressesValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv6AddressesValueUnknown() Ipv6AddressesValue {
	return Ipv6AddressesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6AddressesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6AddressesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6AddressesValue Attribute Value",
				"While creating a Ipv6AddressesValue value, a missing attribute value was detected. "+
					"A Ipv6AddressesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6AddressesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6AddressesValue Attribute Type",
				"While creating a Ipv6AddressesValue value, an invalid attribute value was detected. "+
					"A Ipv6AddressesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6AddressesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6AddressesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6AddressesValue Attribute Value",
				"While creating a Ipv6AddressesValue value, an extra attribute value was detected. "+
					"A Ipv6AddressesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6AddressesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6AddressesValueUnknown(), diags
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return NewIpv6AddressesValueUnknown(), diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewIpv6AddressesValueUnknown(), diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return NewIpv6AddressesValueUnknown(), diags
	}

	return Ipv6AddressesValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv6AddressesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6AddressesValue {
	object, diags := NewIpv6AddressesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6AddressesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6AddressesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6AddressesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6AddressesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6AddressesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6AddressesValueMust(Ipv6AddressesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6AddressesType) ValueType(ctx context.Context) attr.Value {
	return Ipv6AddressesValue{}
}

var _ basetypes.ObjectValuable = Ipv6AddressesValue{}

type Ipv6AddressesValue struct {
	IpPrefix basetypes.StringValue `tfsdk:"ip_prefix"`
	Primary  basetypes.BoolValue   `tfsdk:"primary"`
	state    attr.ValueState
}

func (v Ipv6AddressesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_prefix"] = val

		val, err = v.Primary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6AddressesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6AddressesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6AddressesValue) String() string {
	return "Ipv6AddressesValue"
}

func (v Ipv6AddressesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_prefix": v.IpPrefix,
			"primary":   v.Primary,
		})

	return objVal, diags
}

func (v Ipv6AddressesValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6AddressesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpPrefix.Equal(other.IpPrefix) {
		return false
	}

	if !v.Primary.Equal(other.Primary) {
		return false
	}

	return true
}

func (v Ipv6AddressesValue) Type(ctx context.Context) attr.Type {
	return Ipv6AddressesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6AddressesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ipv6RouterAdvertisement1Type{}

type Ipv6RouterAdvertisement1Type struct {
	basetypes.ObjectType
}

func (t Ipv6RouterAdvertisement1Type) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6RouterAdvertisement1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6RouterAdvertisement1Type) String() string {
	return "Ipv6RouterAdvertisement1Type"
}

func (t Ipv6RouterAdvertisement1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	currentHopLimitAttribute, ok := attributes["current_hop_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_hop_limit is missing from object`)

		return nil, diags
	}

	currentHopLimitVal, ok := currentHopLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_hop_limit expected to be basetypes.Int64Value, was: %T`, currentHopLimitAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return nil, diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	managedConfigurationFlagAttribute, ok := attributes["managed_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_configuration_flag is missing from object`)

		return nil, diags
	}

	managedConfigurationFlagVal, ok := managedConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_configuration_flag expected to be basetypes.BoolValue, was: %T`, managedConfigurationFlagAttribute))
	}

	maxAdvertisementIntervalAttribute, ok := attributes["max_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_advertisement_interval is missing from object`)

		return nil, diags
	}

	maxAdvertisementIntervalVal, ok := maxAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_advertisement_interval expected to be basetypes.Int64Value, was: %T`, maxAdvertisementIntervalAttribute))
	}

	minAdvertisementIntervalAttribute, ok := attributes["min_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_advertisement_interval is missing from object`)

		return nil, diags
	}

	minAdvertisementIntervalVal, ok := minAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minAdvertisementIntervalAttribute))
	}

	otherConfigurationFlagAttribute, ok := attributes["other_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_configuration_flag is missing from object`)

		return nil, diags
	}

	otherConfigurationFlagVal, ok := otherConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_configuration_flag expected to be basetypes.BoolValue, was: %T`, otherConfigurationFlagAttribute))
	}

	prefixes1Attribute, ok := attributes["prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefixes_1 is missing from object`)

		return nil, diags
	}

	prefixes1Val, ok := prefixes1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefixes_1 expected to be basetypes.ListValue, was: %T`, prefixes1Attribute))
	}

	reachableTimeAttribute, ok := attributes["reachable_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reachable_time is missing from object`)

		return nil, diags
	}

	reachableTimeVal, ok := reachableTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reachable_time expected to be basetypes.Int64Value, was: %T`, reachableTimeAttribute))
	}

	retransmitTimeAttribute, ok := attributes["retransmit_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retransmit_time is missing from object`)

		return nil, diags
	}

	retransmitTimeVal, ok := retransmitTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retransmit_time expected to be basetypes.Int64Value, was: %T`, retransmitTimeAttribute))
	}

	routerLifetimeAttribute, ok := attributes["router_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_lifetime is missing from object`)

		return nil, diags
	}

	routerLifetimeVal, ok := routerLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_lifetime expected to be basetypes.Int64Value, was: %T`, routerLifetimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6RouterAdvertisement1Value{
		CurrentHopLimit:          currentHopLimitVal,
		Enabled:                  enabledVal,
		IpMtu:                    ipMtuVal,
		ManagedConfigurationFlag: managedConfigurationFlagVal,
		MaxAdvertisementInterval: maxAdvertisementIntervalVal,
		MinAdvertisementInterval: minAdvertisementIntervalVal,
		OtherConfigurationFlag:   otherConfigurationFlagVal,
		Prefixes1:                prefixes1Val,
		ReachableTime:            reachableTimeVal,
		RetransmitTime:           retransmitTimeVal,
		RouterLifetime:           routerLifetimeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewIpv6RouterAdvertisement1ValueNull() Ipv6RouterAdvertisement1Value {
	return Ipv6RouterAdvertisement1Value{
		state: attr.ValueStateNull,
	}
}

func NewIpv6RouterAdvertisement1ValueUnknown() Ipv6RouterAdvertisement1Value {
	return Ipv6RouterAdvertisement1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6RouterAdvertisement1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6RouterAdvertisement1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6RouterAdvertisement1Value Attribute Value",
				"While creating a Ipv6RouterAdvertisement1Value value, a missing attribute value was detected. "+
					"A Ipv6RouterAdvertisement1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6RouterAdvertisement1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6RouterAdvertisement1Value Attribute Type",
				"While creating a Ipv6RouterAdvertisement1Value value, an invalid attribute value was detected. "+
					"A Ipv6RouterAdvertisement1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6RouterAdvertisement1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6RouterAdvertisement1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6RouterAdvertisement1Value Attribute Value",
				"While creating a Ipv6RouterAdvertisement1Value value, an extra attribute value was detected. "+
					"A Ipv6RouterAdvertisement1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6RouterAdvertisement1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6RouterAdvertisement1ValueUnknown(), diags
	}

	currentHopLimitAttribute, ok := attributes["current_hop_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_hop_limit is missing from object`)

		return NewIpv6RouterAdvertisement1ValueUnknown(), diags
	}

	currentHopLimitVal, ok := currentHopLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_hop_limit expected to be basetypes.Int64Value, was: %T`, currentHopLimitAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv6RouterAdvertisement1ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return NewIpv6RouterAdvertisement1ValueUnknown(), diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	managedConfigurationFlagAttribute, ok := attributes["managed_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_configuration_flag is missing from object`)

		return NewIpv6RouterAdvertisement1ValueUnknown(), diags
	}

	managedConfigurationFlagVal, ok := managedConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_configuration_flag expected to be basetypes.BoolValue, was: %T`, managedConfigurationFlagAttribute))
	}

	maxAdvertisementIntervalAttribute, ok := attributes["max_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_advertisement_interval is missing from object`)

		return NewIpv6RouterAdvertisement1ValueUnknown(), diags
	}

	maxAdvertisementIntervalVal, ok := maxAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_advertisement_interval expected to be basetypes.Int64Value, was: %T`, maxAdvertisementIntervalAttribute))
	}

	minAdvertisementIntervalAttribute, ok := attributes["min_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_advertisement_interval is missing from object`)

		return NewIpv6RouterAdvertisement1ValueUnknown(), diags
	}

	minAdvertisementIntervalVal, ok := minAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minAdvertisementIntervalAttribute))
	}

	otherConfigurationFlagAttribute, ok := attributes["other_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_configuration_flag is missing from object`)

		return NewIpv6RouterAdvertisement1ValueUnknown(), diags
	}

	otherConfigurationFlagVal, ok := otherConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_configuration_flag expected to be basetypes.BoolValue, was: %T`, otherConfigurationFlagAttribute))
	}

	prefixes1Attribute, ok := attributes["prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefixes_1 is missing from object`)

		return NewIpv6RouterAdvertisement1ValueUnknown(), diags
	}

	prefixes1Val, ok := prefixes1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefixes_1 expected to be basetypes.ListValue, was: %T`, prefixes1Attribute))
	}

	reachableTimeAttribute, ok := attributes["reachable_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reachable_time is missing from object`)

		return NewIpv6RouterAdvertisement1ValueUnknown(), diags
	}

	reachableTimeVal, ok := reachableTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reachable_time expected to be basetypes.Int64Value, was: %T`, reachableTimeAttribute))
	}

	retransmitTimeAttribute, ok := attributes["retransmit_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retransmit_time is missing from object`)

		return NewIpv6RouterAdvertisement1ValueUnknown(), diags
	}

	retransmitTimeVal, ok := retransmitTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retransmit_time expected to be basetypes.Int64Value, was: %T`, retransmitTimeAttribute))
	}

	routerLifetimeAttribute, ok := attributes["router_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_lifetime is missing from object`)

		return NewIpv6RouterAdvertisement1ValueUnknown(), diags
	}

	routerLifetimeVal, ok := routerLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_lifetime expected to be basetypes.Int64Value, was: %T`, routerLifetimeAttribute))
	}

	if diags.HasError() {
		return NewIpv6RouterAdvertisement1ValueUnknown(), diags
	}

	return Ipv6RouterAdvertisement1Value{
		CurrentHopLimit:          currentHopLimitVal,
		Enabled:                  enabledVal,
		IpMtu:                    ipMtuVal,
		ManagedConfigurationFlag: managedConfigurationFlagVal,
		MaxAdvertisementInterval: maxAdvertisementIntervalVal,
		MinAdvertisementInterval: minAdvertisementIntervalVal,
		OtherConfigurationFlag:   otherConfigurationFlagVal,
		Prefixes1:                prefixes1Val,
		ReachableTime:            reachableTimeVal,
		RetransmitTime:           retransmitTimeVal,
		RouterLifetime:           routerLifetimeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewIpv6RouterAdvertisement1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6RouterAdvertisement1Value {
	object, diags := NewIpv6RouterAdvertisement1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6RouterAdvertisement1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6RouterAdvertisement1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6RouterAdvertisement1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6RouterAdvertisement1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6RouterAdvertisement1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6RouterAdvertisement1ValueMust(Ipv6RouterAdvertisement1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6RouterAdvertisement1Type) ValueType(ctx context.Context) attr.Value {
	return Ipv6RouterAdvertisement1Value{}
}

var _ basetypes.ObjectValuable = Ipv6RouterAdvertisement1Value{}

type Ipv6RouterAdvertisement1Value struct {
	CurrentHopLimit          basetypes.Int64Value `tfsdk:"current_hop_limit"`
	Enabled                  basetypes.BoolValue  `tfsdk:"enabled"`
	IpMtu                    basetypes.Int64Value `tfsdk:"ip_mtu"`
	ManagedConfigurationFlag basetypes.BoolValue  `tfsdk:"managed_configuration_flag"`
	MaxAdvertisementInterval basetypes.Int64Value `tfsdk:"max_advertisement_interval"`
	MinAdvertisementInterval basetypes.Int64Value `tfsdk:"min_advertisement_interval"`
	OtherConfigurationFlag   basetypes.BoolValue  `tfsdk:"other_configuration_flag"`
	Prefixes1                basetypes.ListValue  `tfsdk:"prefixes"`
	ReachableTime            basetypes.Int64Value `tfsdk:"reachable_time"`
	RetransmitTime           basetypes.Int64Value `tfsdk:"retransmit_time"`
	RouterLifetime           basetypes.Int64Value `tfsdk:"router_lifetime"`
	state                    attr.ValueState
}

func (v Ipv6RouterAdvertisement1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["current_hop_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ip_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_configuration_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["other_configuration_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefixes"] = basetypes.ListType{
		ElemType: Prefixes1Value{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["reachable_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["retransmit_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["router_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.CurrentHopLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_hop_limit"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.IpMtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_mtu"] = val

		val, err = v.ManagedConfigurationFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_configuration_flag"] = val

		val, err = v.MaxAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_advertisement_interval"] = val

		val, err = v.MinAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_advertisement_interval"] = val

		val, err = v.OtherConfigurationFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["other_configuration_flag"] = val

		val, err = v.Prefixes1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefixes"] = val

		val, err = v.ReachableTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reachable_time"] = val

		val, err = v.RetransmitTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["retransmit_time"] = val

		val, err = v.RouterLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router_lifetime"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6RouterAdvertisement1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6RouterAdvertisement1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6RouterAdvertisement1Value) String() string {
	return "Ipv6RouterAdvertisement1Value"
}

func (v Ipv6RouterAdvertisement1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	prefixes1 := types.ListValueMust(
		Prefixes1Type{
			basetypes.ObjectType{
				AttrTypes: Prefixes1Value{}.AttributeTypes(ctx),
			},
		},
		v.Prefixes1.Elements(),
	)

	if v.Prefixes1.IsNull() {
		prefixes1 = types.ListNull(
			Prefixes1Type{
				basetypes.ObjectType{
					AttrTypes: Prefixes1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Prefixes1.IsUnknown() {
		prefixes1 = types.ListUnknown(
			Prefixes1Type{
				basetypes.ObjectType{
					AttrTypes: Prefixes1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"current_hop_limit":          basetypes.Int64Type{},
		"enabled":                    basetypes.BoolType{},
		"ip_mtu":                     basetypes.Int64Type{},
		"managed_configuration_flag": basetypes.BoolType{},
		"max_advertisement_interval": basetypes.Int64Type{},
		"min_advertisement_interval": basetypes.Int64Type{},
		"other_configuration_flag":   basetypes.BoolType{},
		"prefixes": basetypes.ListType{
			ElemType: Prefixes1Value{}.Type(ctx),
		},
		"reachable_time":  basetypes.Int64Type{},
		"retransmit_time": basetypes.Int64Type{},
		"router_lifetime": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"current_hop_limit":          v.CurrentHopLimit,
			"enabled":                    v.Enabled,
			"ip_mtu":                     v.IpMtu,
			"managed_configuration_flag": v.ManagedConfigurationFlag,
			"max_advertisement_interval": v.MaxAdvertisementInterval,
			"min_advertisement_interval": v.MinAdvertisementInterval,
			"other_configuration_flag":   v.OtherConfigurationFlag,
			"prefixes":                   prefixes1,
			"reachable_time":             v.ReachableTime,
			"retransmit_time":            v.RetransmitTime,
			"router_lifetime":            v.RouterLifetime,
		})

	return objVal, diags
}

func (v Ipv6RouterAdvertisement1Value) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6RouterAdvertisement1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CurrentHopLimit.Equal(other.CurrentHopLimit) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.IpMtu.Equal(other.IpMtu) {
		return false
	}

	if !v.ManagedConfigurationFlag.Equal(other.ManagedConfigurationFlag) {
		return false
	}

	if !v.MaxAdvertisementInterval.Equal(other.MaxAdvertisementInterval) {
		return false
	}

	if !v.MinAdvertisementInterval.Equal(other.MinAdvertisementInterval) {
		return false
	}

	if !v.OtherConfigurationFlag.Equal(other.OtherConfigurationFlag) {
		return false
	}

	if !v.Prefixes1.Equal(other.Prefixes1) {
		return false
	}

	if !v.ReachableTime.Equal(other.ReachableTime) {
		return false
	}

	if !v.RetransmitTime.Equal(other.RetransmitTime) {
		return false
	}

	if !v.RouterLifetime.Equal(other.RouterLifetime) {
		return false
	}

	return true
}

func (v Ipv6RouterAdvertisement1Value) Type(ctx context.Context) attr.Type {
	return Ipv6RouterAdvertisement1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6RouterAdvertisement1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"current_hop_limit":          basetypes.Int64Type{},
		"enabled":                    basetypes.BoolType{},
		"ip_mtu":                     basetypes.Int64Type{},
		"managed_configuration_flag": basetypes.BoolType{},
		"max_advertisement_interval": basetypes.Int64Type{},
		"min_advertisement_interval": basetypes.Int64Type{},
		"other_configuration_flag":   basetypes.BoolType{},
		"prefixes": basetypes.ListType{
			ElemType: Prefixes1Value{}.Type(ctx),
		},
		"reachable_time":  basetypes.Int64Type{},
		"retransmit_time": basetypes.Int64Type{},
		"router_lifetime": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Prefixes1Type{}

type Prefixes1Type struct {
	basetypes.ObjectType
}

func (t Prefixes1Type) Equal(o attr.Type) bool {
	other, ok := o.(Prefixes1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Prefixes1Type) String() string {
	return "Prefixes1Type"
}

func (t Prefixes1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousFlagAttribute, ok := attributes["autonomous_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_flag is missing from object`)

		return nil, diags
	}

	autonomousFlagVal, ok := autonomousFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_flag expected to be basetypes.BoolValue, was: %T`, autonomousFlagAttribute))
	}

	onLinkFlagAttribute, ok := attributes["on_link_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_link_flag is missing from object`)

		return nil, diags
	}

	onLinkFlagVal, ok := onLinkFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_link_flag expected to be basetypes.BoolValue, was: %T`, onLinkFlagAttribute))
	}

	preferredLifetimeAttribute, ok := attributes["preferred_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_lifetime is missing from object`)

		return nil, diags
	}

	preferredLifetimeVal, ok := preferredLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_lifetime expected to be basetypes.Int64Value, was: %T`, preferredLifetimeAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	validLifetimeAttribute, ok := attributes["valid_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`valid_lifetime is missing from object`)

		return nil, diags
	}

	validLifetimeVal, ok := validLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`valid_lifetime expected to be basetypes.Int64Value, was: %T`, validLifetimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Prefixes1Value{
		AutonomousFlag:    autonomousFlagVal,
		OnLinkFlag:        onLinkFlagVal,
		PreferredLifetime: preferredLifetimeVal,
		Prefix:            prefixVal,
		ValidLifetime:     validLifetimeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixes1ValueNull() Prefixes1Value {
	return Prefixes1Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefixes1ValueUnknown() Prefixes1Value {
	return Prefixes1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixes1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Prefixes1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Prefixes1Value Attribute Value",
				"While creating a Prefixes1Value value, a missing attribute value was detected. "+
					"A Prefixes1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Prefixes1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Prefixes1Value Attribute Type",
				"While creating a Prefixes1Value value, an invalid attribute value was detected. "+
					"A Prefixes1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Prefixes1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Prefixes1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Prefixes1Value Attribute Value",
				"While creating a Prefixes1Value value, an extra attribute value was detected. "+
					"A Prefixes1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Prefixes1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixes1ValueUnknown(), diags
	}

	autonomousFlagAttribute, ok := attributes["autonomous_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_flag is missing from object`)

		return NewPrefixes1ValueUnknown(), diags
	}

	autonomousFlagVal, ok := autonomousFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_flag expected to be basetypes.BoolValue, was: %T`, autonomousFlagAttribute))
	}

	onLinkFlagAttribute, ok := attributes["on_link_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_link_flag is missing from object`)

		return NewPrefixes1ValueUnknown(), diags
	}

	onLinkFlagVal, ok := onLinkFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_link_flag expected to be basetypes.BoolValue, was: %T`, onLinkFlagAttribute))
	}

	preferredLifetimeAttribute, ok := attributes["preferred_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_lifetime is missing from object`)

		return NewPrefixes1ValueUnknown(), diags
	}

	preferredLifetimeVal, ok := preferredLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_lifetime expected to be basetypes.Int64Value, was: %T`, preferredLifetimeAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewPrefixes1ValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	validLifetimeAttribute, ok := attributes["valid_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`valid_lifetime is missing from object`)

		return NewPrefixes1ValueUnknown(), diags
	}

	validLifetimeVal, ok := validLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`valid_lifetime expected to be basetypes.Int64Value, was: %T`, validLifetimeAttribute))
	}

	if diags.HasError() {
		return NewPrefixes1ValueUnknown(), diags
	}

	return Prefixes1Value{
		AutonomousFlag:    autonomousFlagVal,
		OnLinkFlag:        onLinkFlagVal,
		PreferredLifetime: preferredLifetimeVal,
		Prefix:            prefixVal,
		ValidLifetime:     validLifetimeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixes1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Prefixes1Value {
	object, diags := NewPrefixes1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixes1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Prefixes1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixes1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixes1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixes1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixes1ValueMust(Prefixes1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Prefixes1Type) ValueType(ctx context.Context) attr.Value {
	return Prefixes1Value{}
}

var _ basetypes.ObjectValuable = Prefixes1Value{}

type Prefixes1Value struct {
	AutonomousFlag    basetypes.BoolValue   `tfsdk:"autonomous_flag"`
	OnLinkFlag        basetypes.BoolValue   `tfsdk:"on_link_flag"`
	PreferredLifetime basetypes.Int64Value  `tfsdk:"preferred_lifetime"`
	Prefix            basetypes.StringValue `tfsdk:"prefix"`
	ValidLifetime     basetypes.Int64Value  `tfsdk:"valid_lifetime"`
	state             attr.ValueState
}

func (v Prefixes1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["on_link_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["preferred_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["valid_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AutonomousFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_flag"] = val

		val, err = v.OnLinkFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["on_link_flag"] = val

		val, err = v.PreferredLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preferred_lifetime"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.ValidLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["valid_lifetime"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Prefixes1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Prefixes1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Prefixes1Value) String() string {
	return "Prefixes1Value"
}

func (v Prefixes1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"autonomous_flag":    basetypes.BoolType{},
		"on_link_flag":       basetypes.BoolType{},
		"preferred_lifetime": basetypes.Int64Type{},
		"prefix":             basetypes.StringType{},
		"valid_lifetime":     basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_flag":    v.AutonomousFlag,
			"on_link_flag":       v.OnLinkFlag,
			"preferred_lifetime": v.PreferredLifetime,
			"prefix":             v.Prefix,
			"valid_lifetime":     v.ValidLifetime,
		})

	return objVal, diags
}

func (v Prefixes1Value) Equal(o attr.Value) bool {
	other, ok := o.(Prefixes1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousFlag.Equal(other.AutonomousFlag) {
		return false
	}

	if !v.OnLinkFlag.Equal(other.OnLinkFlag) {
		return false
	}

	if !v.PreferredLifetime.Equal(other.PreferredLifetime) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.ValidLifetime.Equal(other.ValidLifetime) {
		return false
	}

	return true
}

func (v Prefixes1Value) Type(ctx context.Context) attr.Type {
	return Prefixes1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Prefixes1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_flag":    basetypes.BoolType{},
		"on_link_flag":       basetypes.BoolType{},
		"preferred_lifetime": basetypes.Int64Type{},
		"prefix":             basetypes.StringType{},
		"valid_lifetime":     basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = L3proxyArpnd1Type{}

type L3proxyArpnd1Type struct {
	basetypes.ObjectType
}

func (t L3proxyArpnd1Type) Equal(o attr.Type) bool {
	other, ok := o.(L3proxyArpnd1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t L3proxyArpnd1Type) String() string {
	return "L3proxyArpnd1Type"
}

func (t L3proxyArpnd1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return nil, diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.BoolValue, was: %T`, proxyArpAttribute))
	}

	proxyNdAttribute, ok := attributes["proxy_nd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_nd is missing from object`)

		return nil, diags
	}

	proxyNdVal, ok := proxyNdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_nd expected to be basetypes.BoolValue, was: %T`, proxyNdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return L3proxyArpnd1Value{
		ProxyArp: proxyArpVal,
		ProxyNd:  proxyNdVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewL3proxyArpnd1ValueNull() L3proxyArpnd1Value {
	return L3proxyArpnd1Value{
		state: attr.ValueStateNull,
	}
}

func NewL3proxyArpnd1ValueUnknown() L3proxyArpnd1Value {
	return L3proxyArpnd1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewL3proxyArpnd1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (L3proxyArpnd1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing L3proxyArpnd1Value Attribute Value",
				"While creating a L3proxyArpnd1Value value, a missing attribute value was detected. "+
					"A L3proxyArpnd1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3proxyArpnd1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid L3proxyArpnd1Value Attribute Type",
				"While creating a L3proxyArpnd1Value value, an invalid attribute value was detected. "+
					"A L3proxyArpnd1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3proxyArpnd1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("L3proxyArpnd1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra L3proxyArpnd1Value Attribute Value",
				"While creating a L3proxyArpnd1Value value, an extra attribute value was detected. "+
					"A L3proxyArpnd1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra L3proxyArpnd1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewL3proxyArpnd1ValueUnknown(), diags
	}

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return NewL3proxyArpnd1ValueUnknown(), diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.BoolValue, was: %T`, proxyArpAttribute))
	}

	proxyNdAttribute, ok := attributes["proxy_nd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_nd is missing from object`)

		return NewL3proxyArpnd1ValueUnknown(), diags
	}

	proxyNdVal, ok := proxyNdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_nd expected to be basetypes.BoolValue, was: %T`, proxyNdAttribute))
	}

	if diags.HasError() {
		return NewL3proxyArpnd1ValueUnknown(), diags
	}

	return L3proxyArpnd1Value{
		ProxyArp: proxyArpVal,
		ProxyNd:  proxyNdVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewL3proxyArpnd1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) L3proxyArpnd1Value {
	object, diags := NewL3proxyArpnd1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewL3proxyArpnd1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t L3proxyArpnd1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewL3proxyArpnd1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewL3proxyArpnd1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewL3proxyArpnd1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewL3proxyArpnd1ValueMust(L3proxyArpnd1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t L3proxyArpnd1Type) ValueType(ctx context.Context) attr.Value {
	return L3proxyArpnd1Value{}
}

var _ basetypes.ObjectValuable = L3proxyArpnd1Value{}

type L3proxyArpnd1Value struct {
	ProxyArp basetypes.BoolValue `tfsdk:"proxy_arp"`
	ProxyNd  basetypes.BoolValue `tfsdk:"proxy_nd"`
	state    attr.ValueState
}

func (v L3proxyArpnd1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["proxy_arp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["proxy_nd"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ProxyArp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_arp"] = val

		val, err = v.ProxyNd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_nd"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v L3proxyArpnd1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v L3proxyArpnd1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v L3proxyArpnd1Value) String() string {
	return "L3proxyArpnd1Value"
}

func (v L3proxyArpnd1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"proxy_arp": basetypes.BoolType{},
		"proxy_nd":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"proxy_arp": v.ProxyArp,
			"proxy_nd":  v.ProxyNd,
		})

	return objVal, diags
}

func (v L3proxyArpnd1Value) Equal(o attr.Value) bool {
	other, ok := o.(L3proxyArpnd1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ProxyArp.Equal(other.ProxyArp) {
		return false
	}

	if !v.ProxyNd.Equal(other.ProxyNd) {
		return false
	}

	return true
}

func (v L3proxyArpnd1Value) Type(ctx context.Context) attr.Type {
	return L3proxyArpnd1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v L3proxyArpnd1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"proxy_arp": basetypes.BoolType{},
		"proxy_nd":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = RoutersType{}

type RoutersType struct {
	basetypes.ObjectType
}

func (t RoutersType) Equal(o attr.Type) bool {
	other, ok := o.(RoutersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RoutersType) String() string {
	return "RoutersType"
}

func (t RoutersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec13Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_13 is missing from object`)

		return nil, diags
	}

	spec13Val, ok := spec13Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_13 expected to be basetypes.ObjectValue, was: %T`, spec13Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RoutersValue{
		Name:   nameVal,
		Spec13: spec13Val,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewRoutersValueNull() RoutersValue {
	return RoutersValue{
		state: attr.ValueStateNull,
	}
}

func NewRoutersValueUnknown() RoutersValue {
	return RoutersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRoutersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RoutersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RoutersValue Attribute Value",
				"While creating a RoutersValue value, a missing attribute value was detected. "+
					"A RoutersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RoutersValue Attribute Type",
				"While creating a RoutersValue value, an invalid attribute value was detected. "+
					"A RoutersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RoutersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RoutersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RoutersValue Attribute Value",
				"While creating a RoutersValue value, an extra attribute value was detected. "+
					"A RoutersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RoutersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRoutersValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewRoutersValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec13Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_13 is missing from object`)

		return NewRoutersValueUnknown(), diags
	}

	spec13Val, ok := spec13Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_13 expected to be basetypes.ObjectValue, was: %T`, spec13Attribute))
	}

	if diags.HasError() {
		return NewRoutersValueUnknown(), diags
	}

	return RoutersValue{
		Name:   nameVal,
		Spec13: spec13Val,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewRoutersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RoutersValue {
	object, diags := NewRoutersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRoutersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RoutersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRoutersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRoutersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRoutersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRoutersValueMust(RoutersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RoutersType) ValueType(ctx context.Context) attr.Value {
	return RoutersValue{}
}

var _ basetypes.ObjectValuable = RoutersValue{}

type RoutersValue struct {
	Name   basetypes.StringValue `tfsdk:"name"`
	Spec13 basetypes.ObjectValue `tfsdk:"spec"`
	state  attr.ValueState
}

func (v RoutersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec13Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Spec13.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RoutersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RoutersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RoutersValue) String() string {
	return "RoutersValue"
}

func (v RoutersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spec13 basetypes.ObjectValue

	if v.Spec13.IsNull() {
		spec13 = types.ObjectNull(
			Spec13Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec13.IsUnknown() {
		spec13 = types.ObjectUnknown(
			Spec13Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec13.IsNull() && !v.Spec13.IsUnknown() {
		spec13 = types.ObjectValueMust(
			Spec13Value{}.AttributeTypes(ctx),
			v.Spec13.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec13Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"spec": spec13,
		})

	return objVal, diags
}

func (v RoutersValue) Equal(o attr.Value) bool {
	other, ok := o.(RoutersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Spec13.Equal(other.Spec13) {
		return false
	}

	return true
}

func (v RoutersValue) Type(ctx context.Context) attr.Type {
	return RoutersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RoutersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec13Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Spec13Type{}

type Spec13Type struct {
	basetypes.ObjectType
}

func (t Spec13Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec13Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec13Type) String() string {
	return "Spec13Type"
}

func (t Spec13Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bgp4Attribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_4 is missing from object`)

		return nil, diags
	}

	bgp4Val, ok := bgp4Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_4 expected to be basetypes.ObjectValue, was: %T`, bgp4Attribute))
	}

	configuredNameAttribute, ok := attributes["configured_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_name is missing from object`)

		return nil, diags
	}

	configuredNameVal, ok := configuredNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_name expected to be basetypes.StringValue, was: %T`, configuredNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	ecmpAttribute, ok := attributes["ecmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecmp is missing from object`)

		return nil, diags
	}

	ecmpVal, ok := ecmpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecmp expected to be basetypes.Int64Value, was: %T`, ecmpAttribute))
	}

	eviAttribute, ok := attributes["evi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi is missing from object`)

		return nil, diags
	}

	eviVal, ok := eviAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi expected to be basetypes.Int64Value, was: %T`, eviAttribute))
	}

	eviPoolAttribute, ok := attributes["evi_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi_pool is missing from object`)

		return nil, diags
	}

	eviPoolVal, ok := eviPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi_pool expected to be basetypes.StringValue, was: %T`, eviPoolAttribute))
	}

	exportTargetAttribute, ok := attributes["export_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_target is missing from object`)

		return nil, diags
	}

	exportTargetVal, ok := exportTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_target expected to be basetypes.StringValue, was: %T`, exportTargetAttribute))
	}

	importTargetAttribute, ok := attributes["import_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_target is missing from object`)

		return nil, diags
	}

	importTargetVal, ok := importTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_target expected to be basetypes.StringValue, was: %T`, importTargetAttribute))
	}

	ipLoadBalancingAttribute, ok := attributes["ip_load_balancing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_load_balancing is missing from object`)

		return nil, diags
	}

	ipLoadBalancingVal, ok := ipLoadBalancingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_load_balancing expected to be basetypes.ObjectValue, was: %T`, ipLoadBalancingAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return nil, diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.ListValue, was: %T`, nodeSelectorAttribute))
	}

	routeLeakingAttribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking is missing from object`)

		return nil, diags
	}

	routeLeakingVal, ok := routeLeakingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking expected to be basetypes.ObjectValue, was: %T`, routeLeakingAttribute))
	}

	routerIdAttribute, ok := attributes["router_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_id is missing from object`)

		return nil, diags
	}

	routerIdVal, ok := routerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_id expected to be basetypes.StringValue, was: %T`, routerIdAttribute))
	}

	tunnelIndexPoolAttribute, ok := attributes["tunnel_index_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_index_pool is missing from object`)

		return nil, diags
	}

	tunnelIndexPoolVal, ok := tunnelIndexPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_index_pool expected to be basetypes.StringValue, was: %T`, tunnelIndexPoolAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vniAttribute, ok := attributes["vni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni is missing from object`)

		return nil, diags
	}

	vniVal, ok := vniAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni expected to be basetypes.Int64Value, was: %T`, vniAttribute))
	}

	vniPoolAttribute, ok := attributes["vni_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni_pool is missing from object`)

		return nil, diags
	}

	vniPoolVal, ok := vniPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni_pool expected to be basetypes.StringValue, was: %T`, vniPoolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec13Value{
		Bgp4:            bgp4Val,
		ConfiguredName:  configuredNameVal,
		Description:     descriptionVal,
		Ecmp:            ecmpVal,
		Evi:             eviVal,
		EviPool:         eviPoolVal,
		ExportTarget:    exportTargetVal,
		ImportTarget:    importTargetVal,
		IpLoadBalancing: ipLoadBalancingVal,
		NodeSelector:    nodeSelectorVal,
		RouteLeaking:    routeLeakingVal,
		RouterId:        routerIdVal,
		TunnelIndexPool: tunnelIndexPoolVal,
		Spec13Type:      typeVal,
		Vni:             vniVal,
		VniPool:         vniPoolVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSpec13ValueNull() Spec13Value {
	return Spec13Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec13ValueUnknown() Spec13Value {
	return Spec13Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec13Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec13Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec13Value Attribute Value",
				"While creating a Spec13Value value, a missing attribute value was detected. "+
					"A Spec13Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec13Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec13Value Attribute Type",
				"While creating a Spec13Value value, an invalid attribute value was detected. "+
					"A Spec13Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec13Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec13Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec13Value Attribute Value",
				"While creating a Spec13Value value, an extra attribute value was detected. "+
					"A Spec13Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec13Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec13ValueUnknown(), diags
	}

	bgp4Attribute, ok := attributes["bgp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bgp_4 is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	bgp4Val, ok := bgp4Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bgp_4 expected to be basetypes.ObjectValue, was: %T`, bgp4Attribute))
	}

	configuredNameAttribute, ok := attributes["configured_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`configured_name is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	configuredNameVal, ok := configuredNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`configured_name expected to be basetypes.StringValue, was: %T`, configuredNameAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	ecmpAttribute, ok := attributes["ecmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ecmp is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	ecmpVal, ok := ecmpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ecmp expected to be basetypes.Int64Value, was: %T`, ecmpAttribute))
	}

	eviAttribute, ok := attributes["evi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	eviVal, ok := eviAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi expected to be basetypes.Int64Value, was: %T`, eviAttribute))
	}

	eviPoolAttribute, ok := attributes["evi_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi_pool is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	eviPoolVal, ok := eviPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi_pool expected to be basetypes.StringValue, was: %T`, eviPoolAttribute))
	}

	exportTargetAttribute, ok := attributes["export_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_target is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	exportTargetVal, ok := exportTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_target expected to be basetypes.StringValue, was: %T`, exportTargetAttribute))
	}

	importTargetAttribute, ok := attributes["import_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_target is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	importTargetVal, ok := importTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_target expected to be basetypes.StringValue, was: %T`, importTargetAttribute))
	}

	ipLoadBalancingAttribute, ok := attributes["ip_load_balancing"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_load_balancing is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	ipLoadBalancingVal, ok := ipLoadBalancingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_load_balancing expected to be basetypes.ObjectValue, was: %T`, ipLoadBalancingAttribute))
	}

	nodeSelectorAttribute, ok := attributes["node_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_selector is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	nodeSelectorVal, ok := nodeSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_selector expected to be basetypes.ListValue, was: %T`, nodeSelectorAttribute))
	}

	routeLeakingAttribute, ok := attributes["route_leaking"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`route_leaking is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	routeLeakingVal, ok := routeLeakingAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`route_leaking expected to be basetypes.ObjectValue, was: %T`, routeLeakingAttribute))
	}

	routerIdAttribute, ok := attributes["router_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_id is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	routerIdVal, ok := routerIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_id expected to be basetypes.StringValue, was: %T`, routerIdAttribute))
	}

	tunnelIndexPoolAttribute, ok := attributes["tunnel_index_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_index_pool is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	tunnelIndexPoolVal, ok := tunnelIndexPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_index_pool expected to be basetypes.StringValue, was: %T`, tunnelIndexPoolAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vniAttribute, ok := attributes["vni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	vniVal, ok := vniAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni expected to be basetypes.Int64Value, was: %T`, vniAttribute))
	}

	vniPoolAttribute, ok := attributes["vni_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni_pool is missing from object`)

		return NewSpec13ValueUnknown(), diags
	}

	vniPoolVal, ok := vniPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni_pool expected to be basetypes.StringValue, was: %T`, vniPoolAttribute))
	}

	if diags.HasError() {
		return NewSpec13ValueUnknown(), diags
	}

	return Spec13Value{
		Bgp4:            bgp4Val,
		ConfiguredName:  configuredNameVal,
		Description:     descriptionVal,
		Ecmp:            ecmpVal,
		Evi:             eviVal,
		EviPool:         eviPoolVal,
		ExportTarget:    exportTargetVal,
		ImportTarget:    importTargetVal,
		IpLoadBalancing: ipLoadBalancingVal,
		NodeSelector:    nodeSelectorVal,
		RouteLeaking:    routeLeakingVal,
		RouterId:        routerIdVal,
		TunnelIndexPool: tunnelIndexPoolVal,
		Spec13Type:      typeVal,
		Vni:             vniVal,
		VniPool:         vniPoolVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewSpec13ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec13Value {
	object, diags := NewSpec13Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec13ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec13Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec13ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec13ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec13ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec13ValueMust(Spec13Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec13Type) ValueType(ctx context.Context) attr.Value {
	return Spec13Value{}
}

var _ basetypes.ObjectValuable = Spec13Value{}

type Spec13Value struct {
	Bgp4            basetypes.ObjectValue `tfsdk:"bgp"`
	ConfiguredName  basetypes.StringValue `tfsdk:"configured_name"`
	Description     basetypes.StringValue `tfsdk:"description"`
	Ecmp            basetypes.Int64Value  `tfsdk:"ecmp"`
	Evi             basetypes.Int64Value  `tfsdk:"evi"`
	EviPool         basetypes.StringValue `tfsdk:"evi_pool"`
	ExportTarget    basetypes.StringValue `tfsdk:"export_target"`
	ImportTarget    basetypes.StringValue `tfsdk:"import_target"`
	IpLoadBalancing basetypes.ObjectValue `tfsdk:"ip_load_balancing"`
	NodeSelector    basetypes.ListValue   `tfsdk:"node_selector"`
	RouteLeaking    basetypes.ObjectValue `tfsdk:"route_leaking"`
	RouterId        basetypes.StringValue `tfsdk:"router_id"`
	TunnelIndexPool basetypes.StringValue `tfsdk:"tunnel_index_pool"`
	Spec13Type      basetypes.StringValue `tfsdk:"type"`
	Vni             basetypes.Int64Value  `tfsdk:"vni"`
	VniPool         basetypes.StringValue `tfsdk:"vni_pool"`
	state           attr.ValueState
}

func (v Spec13Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["bgp"] = basetypes.ObjectType{
		AttrTypes: Bgp4Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["configured_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ecmp"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["evi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["evi_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["export_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_load_balancing"] = basetypes.ObjectType{
		AttrTypes: IpLoadBalancingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["node_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["route_leaking"] = basetypes.ObjectType{
		AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["router_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tunnel_index_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vni"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vni_pool"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.Bgp4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bgp"] = val

		val, err = v.ConfiguredName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["configured_name"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Ecmp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ecmp"] = val

		val, err = v.Evi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evi"] = val

		val, err = v.EviPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evi_pool"] = val

		val, err = v.ExportTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_target"] = val

		val, err = v.ImportTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_target"] = val

		val, err = v.IpLoadBalancing.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_load_balancing"] = val

		val, err = v.NodeSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_selector"] = val

		val, err = v.RouteLeaking.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["route_leaking"] = val

		val, err = v.RouterId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router_id"] = val

		val, err = v.TunnelIndexPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tunnel_index_pool"] = val

		val, err = v.Spec13Type.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Vni.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vni"] = val

		val, err = v.VniPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vni_pool"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec13Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec13Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec13Value) String() string {
	return "Spec13Value"
}

func (v Spec13Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bgp4 basetypes.ObjectValue

	if v.Bgp4.IsNull() {
		bgp4 = types.ObjectNull(
			Bgp4Value{}.AttributeTypes(ctx),
		)
	}

	if v.Bgp4.IsUnknown() {
		bgp4 = types.ObjectUnknown(
			Bgp4Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Bgp4.IsNull() && !v.Bgp4.IsUnknown() {
		bgp4 = types.ObjectValueMust(
			Bgp4Value{}.AttributeTypes(ctx),
			v.Bgp4.Attributes(),
		)
	}

	var ipLoadBalancing basetypes.ObjectValue

	if v.IpLoadBalancing.IsNull() {
		ipLoadBalancing = types.ObjectNull(
			IpLoadBalancingValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpLoadBalancing.IsUnknown() {
		ipLoadBalancing = types.ObjectUnknown(
			IpLoadBalancingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpLoadBalancing.IsNull() && !v.IpLoadBalancing.IsUnknown() {
		ipLoadBalancing = types.ObjectValueMust(
			IpLoadBalancingValue{}.AttributeTypes(ctx),
			v.IpLoadBalancing.Attributes(),
		)
	}

	var routeLeaking basetypes.ObjectValue

	if v.RouteLeaking.IsNull() {
		routeLeaking = types.ObjectNull(
			RouteLeakingValue{}.AttributeTypes(ctx),
		)
	}

	if v.RouteLeaking.IsUnknown() {
		routeLeaking = types.ObjectUnknown(
			RouteLeakingValue{}.AttributeTypes(ctx),
		)
	}

	if !v.RouteLeaking.IsNull() && !v.RouteLeaking.IsUnknown() {
		routeLeaking = types.ObjectValueMust(
			RouteLeakingValue{}.AttributeTypes(ctx),
			v.RouteLeaking.Attributes(),
		)
	}

	var nodeSelectorVal basetypes.ListValue
	switch {
	case v.NodeSelector.IsUnknown():
		nodeSelectorVal = types.ListUnknown(types.StringType)
	case v.NodeSelector.IsNull():
		nodeSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodeSelectorVal, d = types.ListValue(types.StringType, v.NodeSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bgp": basetypes.ObjectType{
				AttrTypes: Bgp4Value{}.AttributeTypes(ctx),
			},
			"configured_name": basetypes.StringType{},
			"description":     basetypes.StringType{},
			"ecmp":            basetypes.Int64Type{},
			"evi":             basetypes.Int64Type{},
			"evi_pool":        basetypes.StringType{},
			"export_target":   basetypes.StringType{},
			"import_target":   basetypes.StringType{},
			"ip_load_balancing": basetypes.ObjectType{
				AttrTypes: IpLoadBalancingValue{}.AttributeTypes(ctx),
			},
			"node_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"route_leaking": basetypes.ObjectType{
				AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
			},
			"router_id":         basetypes.StringType{},
			"tunnel_index_pool": basetypes.StringType{},
			"type":              basetypes.StringType{},
			"vni":               basetypes.Int64Type{},
			"vni_pool":          basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: Bgp4Value{}.AttributeTypes(ctx),
		},
		"configured_name": basetypes.StringType{},
		"description":     basetypes.StringType{},
		"ecmp":            basetypes.Int64Type{},
		"evi":             basetypes.Int64Type{},
		"evi_pool":        basetypes.StringType{},
		"export_target":   basetypes.StringType{},
		"import_target":   basetypes.StringType{},
		"ip_load_balancing": basetypes.ObjectType{
			AttrTypes: IpLoadBalancingValue{}.AttributeTypes(ctx),
		},
		"node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
		},
		"router_id":         basetypes.StringType{},
		"tunnel_index_pool": basetypes.StringType{},
		"type":              basetypes.StringType{},
		"vni":               basetypes.Int64Type{},
		"vni_pool":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bgp":               bgp4,
			"configured_name":   v.ConfiguredName,
			"description":       v.Description,
			"ecmp":              v.Ecmp,
			"evi":               v.Evi,
			"evi_pool":          v.EviPool,
			"export_target":     v.ExportTarget,
			"import_target":     v.ImportTarget,
			"ip_load_balancing": ipLoadBalancing,
			"node_selector":     nodeSelectorVal,
			"route_leaking":     routeLeaking,
			"router_id":         v.RouterId,
			"tunnel_index_pool": v.TunnelIndexPool,
			"type":              v.Spec13Type,
			"vni":               v.Vni,
			"vni_pool":          v.VniPool,
		})

	return objVal, diags
}

func (v Spec13Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec13Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Bgp4.Equal(other.Bgp4) {
		return false
	}

	if !v.ConfiguredName.Equal(other.ConfiguredName) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Ecmp.Equal(other.Ecmp) {
		return false
	}

	if !v.Evi.Equal(other.Evi) {
		return false
	}

	if !v.EviPool.Equal(other.EviPool) {
		return false
	}

	if !v.ExportTarget.Equal(other.ExportTarget) {
		return false
	}

	if !v.ImportTarget.Equal(other.ImportTarget) {
		return false
	}

	if !v.IpLoadBalancing.Equal(other.IpLoadBalancing) {
		return false
	}

	if !v.NodeSelector.Equal(other.NodeSelector) {
		return false
	}

	if !v.RouteLeaking.Equal(other.RouteLeaking) {
		return false
	}

	if !v.RouterId.Equal(other.RouterId) {
		return false
	}

	if !v.TunnelIndexPool.Equal(other.TunnelIndexPool) {
		return false
	}

	if !v.Spec13Type.Equal(other.Spec13Type) {
		return false
	}

	if !v.Vni.Equal(other.Vni) {
		return false
	}

	if !v.VniPool.Equal(other.VniPool) {
		return false
	}

	return true
}

func (v Spec13Value) Type(ctx context.Context) attr.Type {
	return Spec13Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec13Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bgp": basetypes.ObjectType{
			AttrTypes: Bgp4Value{}.AttributeTypes(ctx),
		},
		"configured_name": basetypes.StringType{},
		"description":     basetypes.StringType{},
		"ecmp":            basetypes.Int64Type{},
		"evi":             basetypes.Int64Type{},
		"evi_pool":        basetypes.StringType{},
		"export_target":   basetypes.StringType{},
		"import_target":   basetypes.StringType{},
		"ip_load_balancing": basetypes.ObjectType{
			AttrTypes: IpLoadBalancingValue{}.AttributeTypes(ctx),
		},
		"node_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"route_leaking": basetypes.ObjectType{
			AttrTypes: RouteLeakingValue{}.AttributeTypes(ctx),
		},
		"router_id":         basetypes.StringType{},
		"tunnel_index_pool": basetypes.StringType{},
		"type":              basetypes.StringType{},
		"vni":               basetypes.Int64Type{},
		"vni_pool":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Bgp4Type{}

type Bgp4Type struct {
	basetypes.ObjectType
}

func (t Bgp4Type) Equal(o attr.Type) bool {
	other, ok := o.(Bgp4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Bgp4Type) String() string {
	return "Bgp4Type"
}

func (t Bgp4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return nil, diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	ebgpPreferenceAttribute, ok := attributes["ebgp_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebgp_preference is missing from object`)

		return nil, diags
	}

	ebgpPreferenceVal, ok := ebgpPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebgp_preference expected to be basetypes.Int64Value, was: %T`, ebgpPreferenceAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	ibgpPreferenceAttribute, ok := attributes["ibgp_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibgp_preference is missing from object`)

		return nil, diags
	}

	ibgpPreferenceVal, ok := ibgpPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibgp_preference expected to be basetypes.Int64Value, was: %T`, ibgpPreferenceAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	ipAliasNexthopsAttribute, ok := attributes["ip_alias_nexthops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_alias_nexthops is missing from object`)

		return nil, diags
	}

	ipAliasNexthopsVal, ok := ipAliasNexthopsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_alias_nexthops expected to be basetypes.ListValue, was: %T`, ipAliasNexthopsAttribute))
	}

	ipv4Unicast2Attribute, ok := attributes["ipv4_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_unicast_2 is missing from object`)

		return nil, diags
	}

	ipv4Unicast2Val, ok := ipv4Unicast2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_unicast_2 expected to be basetypes.ObjectValue, was: %T`, ipv4Unicast2Attribute))
	}

	ipv6Unicast2Attribute, ok := attributes["ipv6_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_unicast_2 is missing from object`)

		return nil, diags
	}

	ipv6Unicast2Val, ok := ipv6Unicast2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_unicast_2 expected to be basetypes.ObjectValue, was: %T`, ipv6Unicast2Attribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return nil, diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	minWaitToAdvertiseAttribute, ok := attributes["min_wait_to_advertise"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_wait_to_advertise is missing from object`)

		return nil, diags
	}

	minWaitToAdvertiseVal, ok := minWaitToAdvertiseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_wait_to_advertise expected to be basetypes.Int64Value, was: %T`, minWaitToAdvertiseAttribute))
	}

	rapidWithdrawlAttribute, ok := attributes["rapid_withdrawl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rapid_withdrawl is missing from object`)

		return nil, diags
	}

	rapidWithdrawlVal, ok := rapidWithdrawlAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rapid_withdrawl expected to be basetypes.BoolValue, was: %T`, rapidWithdrawlAttribute))
	}

	waitForFibInstallAttribute, ok := attributes["wait_for_fib_install"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wait_for_fib_install is missing from object`)

		return nil, diags
	}

	waitForFibInstallVal, ok := waitForFibInstallAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wait_for_fib_install expected to be basetypes.BoolValue, was: %T`, waitForFibInstallAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Bgp4Value{
		AutonomousSystem:   autonomousSystemVal,
		EbgpPreference:     ebgpPreferenceVal,
		Enabled:            enabledVal,
		ExportPolicy:       exportPolicyVal,
		IbgpPreference:     ibgpPreferenceVal,
		ImportPolicy:       importPolicyVal,
		IpAliasNexthops:    ipAliasNexthopsVal,
		Ipv4Unicast2:       ipv4Unicast2Val,
		Ipv6Unicast2:       ipv6Unicast2Val,
		Keychain:           keychainVal,
		MinWaitToAdvertise: minWaitToAdvertiseVal,
		RapidWithdrawl:     rapidWithdrawlVal,
		WaitForFibInstall:  waitForFibInstallVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewBgp4ValueNull() Bgp4Value {
	return Bgp4Value{
		state: attr.ValueStateNull,
	}
}

func NewBgp4ValueUnknown() Bgp4Value {
	return Bgp4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewBgp4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Bgp4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Bgp4Value Attribute Value",
				"While creating a Bgp4Value value, a missing attribute value was detected. "+
					"A Bgp4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Bgp4Value Attribute Type",
				"While creating a Bgp4Value value, an invalid attribute value was detected. "+
					"A Bgp4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Bgp4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Bgp4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Bgp4Value Attribute Value",
				"While creating a Bgp4Value value, an extra attribute value was detected. "+
					"A Bgp4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Bgp4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBgp4ValueUnknown(), diags
	}

	autonomousSystemAttribute, ok := attributes["autonomous_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_system is missing from object`)

		return NewBgp4ValueUnknown(), diags
	}

	autonomousSystemVal, ok := autonomousSystemAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_system expected to be basetypes.Int64Value, was: %T`, autonomousSystemAttribute))
	}

	ebgpPreferenceAttribute, ok := attributes["ebgp_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ebgp_preference is missing from object`)

		return NewBgp4ValueUnknown(), diags
	}

	ebgpPreferenceVal, ok := ebgpPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ebgp_preference expected to be basetypes.Int64Value, was: %T`, ebgpPreferenceAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBgp4ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewBgp4ValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.ListValue, was: %T`, exportPolicyAttribute))
	}

	ibgpPreferenceAttribute, ok := attributes["ibgp_preference"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ibgp_preference is missing from object`)

		return NewBgp4ValueUnknown(), diags
	}

	ibgpPreferenceVal, ok := ibgpPreferenceAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ibgp_preference expected to be basetypes.Int64Value, was: %T`, ibgpPreferenceAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewBgp4ValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.ListValue, was: %T`, importPolicyAttribute))
	}

	ipAliasNexthopsAttribute, ok := attributes["ip_alias_nexthops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_alias_nexthops is missing from object`)

		return NewBgp4ValueUnknown(), diags
	}

	ipAliasNexthopsVal, ok := ipAliasNexthopsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_alias_nexthops expected to be basetypes.ListValue, was: %T`, ipAliasNexthopsAttribute))
	}

	ipv4Unicast2Attribute, ok := attributes["ipv4_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4_unicast_2 is missing from object`)

		return NewBgp4ValueUnknown(), diags
	}

	ipv4Unicast2Val, ok := ipv4Unicast2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4_unicast_2 expected to be basetypes.ObjectValue, was: %T`, ipv4Unicast2Attribute))
	}

	ipv6Unicast2Attribute, ok := attributes["ipv6_unicast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6_unicast_2 is missing from object`)

		return NewBgp4ValueUnknown(), diags
	}

	ipv6Unicast2Val, ok := ipv6Unicast2Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6_unicast_2 expected to be basetypes.ObjectValue, was: %T`, ipv6Unicast2Attribute))
	}

	keychainAttribute, ok := attributes["keychain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`keychain is missing from object`)

		return NewBgp4ValueUnknown(), diags
	}

	keychainVal, ok := keychainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`keychain expected to be basetypes.StringValue, was: %T`, keychainAttribute))
	}

	minWaitToAdvertiseAttribute, ok := attributes["min_wait_to_advertise"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_wait_to_advertise is missing from object`)

		return NewBgp4ValueUnknown(), diags
	}

	minWaitToAdvertiseVal, ok := minWaitToAdvertiseAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_wait_to_advertise expected to be basetypes.Int64Value, was: %T`, minWaitToAdvertiseAttribute))
	}

	rapidWithdrawlAttribute, ok := attributes["rapid_withdrawl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rapid_withdrawl is missing from object`)

		return NewBgp4ValueUnknown(), diags
	}

	rapidWithdrawlVal, ok := rapidWithdrawlAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rapid_withdrawl expected to be basetypes.BoolValue, was: %T`, rapidWithdrawlAttribute))
	}

	waitForFibInstallAttribute, ok := attributes["wait_for_fib_install"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wait_for_fib_install is missing from object`)

		return NewBgp4ValueUnknown(), diags
	}

	waitForFibInstallVal, ok := waitForFibInstallAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wait_for_fib_install expected to be basetypes.BoolValue, was: %T`, waitForFibInstallAttribute))
	}

	if diags.HasError() {
		return NewBgp4ValueUnknown(), diags
	}

	return Bgp4Value{
		AutonomousSystem:   autonomousSystemVal,
		EbgpPreference:     ebgpPreferenceVal,
		Enabled:            enabledVal,
		ExportPolicy:       exportPolicyVal,
		IbgpPreference:     ibgpPreferenceVal,
		ImportPolicy:       importPolicyVal,
		IpAliasNexthops:    ipAliasNexthopsVal,
		Ipv4Unicast2:       ipv4Unicast2Val,
		Ipv6Unicast2:       ipv6Unicast2Val,
		Keychain:           keychainVal,
		MinWaitToAdvertise: minWaitToAdvertiseVal,
		RapidWithdrawl:     rapidWithdrawlVal,
		WaitForFibInstall:  waitForFibInstallVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewBgp4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Bgp4Value {
	object, diags := NewBgp4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBgp4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Bgp4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBgp4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBgp4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBgp4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBgp4ValueMust(Bgp4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Bgp4Type) ValueType(ctx context.Context) attr.Value {
	return Bgp4Value{}
}

var _ basetypes.ObjectValuable = Bgp4Value{}

type Bgp4Value struct {
	AutonomousSystem   basetypes.Int64Value  `tfsdk:"autonomous_system"`
	EbgpPreference     basetypes.Int64Value  `tfsdk:"ebgp_preference"`
	Enabled            basetypes.BoolValue   `tfsdk:"enabled"`
	ExportPolicy       basetypes.ListValue   `tfsdk:"export_policy"`
	IbgpPreference     basetypes.Int64Value  `tfsdk:"ibgp_preference"`
	ImportPolicy       basetypes.ListValue   `tfsdk:"import_policy"`
	IpAliasNexthops    basetypes.ListValue   `tfsdk:"ip_alias_nexthops"`
	Ipv4Unicast2       basetypes.ObjectValue `tfsdk:"ipv4_unicast"`
	Ipv6Unicast2       basetypes.ObjectValue `tfsdk:"ipv6_unicast"`
	Keychain           basetypes.StringValue `tfsdk:"keychain"`
	MinWaitToAdvertise basetypes.Int64Value  `tfsdk:"min_wait_to_advertise"`
	RapidWithdrawl     basetypes.BoolValue   `tfsdk:"rapid_withdrawl"`
	WaitForFibInstall  basetypes.BoolValue   `tfsdk:"wait_for_fib_install"`
	state              attr.ValueState
}

func (v Bgp4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 13)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_system"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ebgp_preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["export_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["ibgp_preference"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["ip_alias_nexthops"] = basetypes.ListType{
		ElemType: IpAliasNexthopsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv4_unicast"] = basetypes.ObjectType{
		AttrTypes: Ipv4Unicast2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6_unicast"] = basetypes.ObjectType{
		AttrTypes: Ipv6Unicast2Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["keychain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["min_wait_to_advertise"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["rapid_withdrawl"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["wait_for_fib_install"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 13)

		val, err = v.AutonomousSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_system"] = val

		val, err = v.EbgpPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ebgp_preference"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.IbgpPreference.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ibgp_preference"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		val, err = v.IpAliasNexthops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_alias_nexthops"] = val

		val, err = v.Ipv4Unicast2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4_unicast"] = val

		val, err = v.Ipv6Unicast2.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6_unicast"] = val

		val, err = v.Keychain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["keychain"] = val

		val, err = v.MinWaitToAdvertise.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_wait_to_advertise"] = val

		val, err = v.RapidWithdrawl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rapid_withdrawl"] = val

		val, err = v.WaitForFibInstall.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wait_for_fib_install"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Bgp4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Bgp4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Bgp4Value) String() string {
	return "Bgp4Value"
}

func (v Bgp4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	ipAliasNexthops := types.ListValueMust(
		IpAliasNexthopsType{
			basetypes.ObjectType{
				AttrTypes: IpAliasNexthopsValue{}.AttributeTypes(ctx),
			},
		},
		v.IpAliasNexthops.Elements(),
	)

	if v.IpAliasNexthops.IsNull() {
		ipAliasNexthops = types.ListNull(
			IpAliasNexthopsType{
				basetypes.ObjectType{
					AttrTypes: IpAliasNexthopsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.IpAliasNexthops.IsUnknown() {
		ipAliasNexthops = types.ListUnknown(
			IpAliasNexthopsType{
				basetypes.ObjectType{
					AttrTypes: IpAliasNexthopsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var ipv4Unicast2 basetypes.ObjectValue

	if v.Ipv4Unicast2.IsNull() {
		ipv4Unicast2 = types.ObjectNull(
			Ipv4Unicast2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv4Unicast2.IsUnknown() {
		ipv4Unicast2 = types.ObjectUnknown(
			Ipv4Unicast2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv4Unicast2.IsNull() && !v.Ipv4Unicast2.IsUnknown() {
		ipv4Unicast2 = types.ObjectValueMust(
			Ipv4Unicast2Value{}.AttributeTypes(ctx),
			v.Ipv4Unicast2.Attributes(),
		)
	}

	var ipv6Unicast2 basetypes.ObjectValue

	if v.Ipv6Unicast2.IsNull() {
		ipv6Unicast2 = types.ObjectNull(
			Ipv6Unicast2Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv6Unicast2.IsUnknown() {
		ipv6Unicast2 = types.ObjectUnknown(
			Ipv6Unicast2Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv6Unicast2.IsNull() && !v.Ipv6Unicast2.IsUnknown() {
		ipv6Unicast2 = types.ObjectValueMust(
			Ipv6Unicast2Value{}.AttributeTypes(ctx),
			v.Ipv6Unicast2.Attributes(),
		)
	}

	var exportPolicyVal basetypes.ListValue
	switch {
	case v.ExportPolicy.IsUnknown():
		exportPolicyVal = types.ListUnknown(types.StringType)
	case v.ExportPolicy.IsNull():
		exportPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		exportPolicyVal, d = types.ListValue(types.StringType, v.ExportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"autonomous_system": basetypes.Int64Type{},
			"ebgp_preference":   basetypes.Int64Type{},
			"enabled":           basetypes.BoolType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"ibgp_preference": basetypes.Int64Type{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"ip_alias_nexthops": basetypes.ListType{
				ElemType: IpAliasNexthopsValue{}.Type(ctx),
			},
			"ipv4_unicast": basetypes.ObjectType{
				AttrTypes: Ipv4Unicast2Value{}.AttributeTypes(ctx),
			},
			"ipv6_unicast": basetypes.ObjectType{
				AttrTypes: Ipv6Unicast2Value{}.AttributeTypes(ctx),
			},
			"keychain":              basetypes.StringType{},
			"min_wait_to_advertise": basetypes.Int64Type{},
			"rapid_withdrawl":       basetypes.BoolType{},
			"wait_for_fib_install":  basetypes.BoolType{},
		}), diags
	}

	var importPolicyVal basetypes.ListValue
	switch {
	case v.ImportPolicy.IsUnknown():
		importPolicyVal = types.ListUnknown(types.StringType)
	case v.ImportPolicy.IsNull():
		importPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		importPolicyVal, d = types.ListValue(types.StringType, v.ImportPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"autonomous_system": basetypes.Int64Type{},
			"ebgp_preference":   basetypes.Int64Type{},
			"enabled":           basetypes.BoolType{},
			"export_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"ibgp_preference": basetypes.Int64Type{},
			"import_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
			"ip_alias_nexthops": basetypes.ListType{
				ElemType: IpAliasNexthopsValue{}.Type(ctx),
			},
			"ipv4_unicast": basetypes.ObjectType{
				AttrTypes: Ipv4Unicast2Value{}.AttributeTypes(ctx),
			},
			"ipv6_unicast": basetypes.ObjectType{
				AttrTypes: Ipv6Unicast2Value{}.AttributeTypes(ctx),
			},
			"keychain":              basetypes.StringType{},
			"min_wait_to_advertise": basetypes.Int64Type{},
			"rapid_withdrawl":       basetypes.BoolType{},
			"wait_for_fib_install":  basetypes.BoolType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"ebgp_preference":   basetypes.Int64Type{},
		"enabled":           basetypes.BoolType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"ibgp_preference": basetypes.Int64Type{},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"ip_alias_nexthops": basetypes.ListType{
			ElemType: IpAliasNexthopsValue{}.Type(ctx),
		},
		"ipv4_unicast": basetypes.ObjectType{
			AttrTypes: Ipv4Unicast2Value{}.AttributeTypes(ctx),
		},
		"ipv6_unicast": basetypes.ObjectType{
			AttrTypes: Ipv6Unicast2Value{}.AttributeTypes(ctx),
		},
		"keychain":              basetypes.StringType{},
		"min_wait_to_advertise": basetypes.Int64Type{},
		"rapid_withdrawl":       basetypes.BoolType{},
		"wait_for_fib_install":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_system":     v.AutonomousSystem,
			"ebgp_preference":       v.EbgpPreference,
			"enabled":               v.Enabled,
			"export_policy":         exportPolicyVal,
			"ibgp_preference":       v.IbgpPreference,
			"import_policy":         importPolicyVal,
			"ip_alias_nexthops":     ipAliasNexthops,
			"ipv4_unicast":          ipv4Unicast2,
			"ipv6_unicast":          ipv6Unicast2,
			"keychain":              v.Keychain,
			"min_wait_to_advertise": v.MinWaitToAdvertise,
			"rapid_withdrawl":       v.RapidWithdrawl,
			"wait_for_fib_install":  v.WaitForFibInstall,
		})

	return objVal, diags
}

func (v Bgp4Value) Equal(o attr.Value) bool {
	other, ok := o.(Bgp4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousSystem.Equal(other.AutonomousSystem) {
		return false
	}

	if !v.EbgpPreference.Equal(other.EbgpPreference) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.IbgpPreference.Equal(other.IbgpPreference) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	if !v.IpAliasNexthops.Equal(other.IpAliasNexthops) {
		return false
	}

	if !v.Ipv4Unicast2.Equal(other.Ipv4Unicast2) {
		return false
	}

	if !v.Ipv6Unicast2.Equal(other.Ipv6Unicast2) {
		return false
	}

	if !v.Keychain.Equal(other.Keychain) {
		return false
	}

	if !v.MinWaitToAdvertise.Equal(other.MinWaitToAdvertise) {
		return false
	}

	if !v.RapidWithdrawl.Equal(other.RapidWithdrawl) {
		return false
	}

	if !v.WaitForFibInstall.Equal(other.WaitForFibInstall) {
		return false
	}

	return true
}

func (v Bgp4Value) Type(ctx context.Context) attr.Type {
	return Bgp4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Bgp4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_system": basetypes.Int64Type{},
		"ebgp_preference":   basetypes.Int64Type{},
		"enabled":           basetypes.BoolType{},
		"export_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"ibgp_preference": basetypes.Int64Type{},
		"import_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
		"ip_alias_nexthops": basetypes.ListType{
			ElemType: IpAliasNexthopsValue{}.Type(ctx),
		},
		"ipv4_unicast": basetypes.ObjectType{
			AttrTypes: Ipv4Unicast2Value{}.AttributeTypes(ctx),
		},
		"ipv6_unicast": basetypes.ObjectType{
			AttrTypes: Ipv6Unicast2Value{}.AttributeTypes(ctx),
		},
		"keychain":              basetypes.StringType{},
		"min_wait_to_advertise": basetypes.Int64Type{},
		"rapid_withdrawl":       basetypes.BoolType{},
		"wait_for_fib_install":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = IpAliasNexthopsType{}

type IpAliasNexthopsType struct {
	basetypes.ObjectType
}

func (t IpAliasNexthopsType) Equal(o attr.Type) bool {
	other, ok := o.(IpAliasNexthopsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpAliasNexthopsType) String() string {
	return "IpAliasNexthopsType"
}

func (t IpAliasNexthopsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	esiAttribute, ok := attributes["esi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esi is missing from object`)

		return nil, diags
	}

	esiVal, ok := esiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esi expected to be basetypes.StringValue, was: %T`, esiAttribute))
	}

	nextHopAttribute, ok := attributes["next_hop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_hop is missing from object`)

		return nil, diags
	}

	nextHopVal, ok := nextHopAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_hop expected to be basetypes.StringValue, was: %T`, nextHopAttribute))
	}

	preferredActiveNodeAttribute, ok := attributes["preferred_active_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_active_node is missing from object`)

		return nil, diags
	}

	preferredActiveNodeVal, ok := preferredActiveNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_active_node expected to be basetypes.StringValue, was: %T`, preferredActiveNodeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpAliasNexthopsValue{
		Esi:                 esiVal,
		NextHop:             nextHopVal,
		PreferredActiveNode: preferredActiveNodeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewIpAliasNexthopsValueNull() IpAliasNexthopsValue {
	return IpAliasNexthopsValue{
		state: attr.ValueStateNull,
	}
}

func NewIpAliasNexthopsValueUnknown() IpAliasNexthopsValue {
	return IpAliasNexthopsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpAliasNexthopsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpAliasNexthopsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpAliasNexthopsValue Attribute Value",
				"While creating a IpAliasNexthopsValue value, a missing attribute value was detected. "+
					"A IpAliasNexthopsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpAliasNexthopsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpAliasNexthopsValue Attribute Type",
				"While creating a IpAliasNexthopsValue value, an invalid attribute value was detected. "+
					"A IpAliasNexthopsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpAliasNexthopsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpAliasNexthopsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpAliasNexthopsValue Attribute Value",
				"While creating a IpAliasNexthopsValue value, an extra attribute value was detected. "+
					"A IpAliasNexthopsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpAliasNexthopsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpAliasNexthopsValueUnknown(), diags
	}

	esiAttribute, ok := attributes["esi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`esi is missing from object`)

		return NewIpAliasNexthopsValueUnknown(), diags
	}

	esiVal, ok := esiAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`esi expected to be basetypes.StringValue, was: %T`, esiAttribute))
	}

	nextHopAttribute, ok := attributes["next_hop"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`next_hop is missing from object`)

		return NewIpAliasNexthopsValueUnknown(), diags
	}

	nextHopVal, ok := nextHopAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`next_hop expected to be basetypes.StringValue, was: %T`, nextHopAttribute))
	}

	preferredActiveNodeAttribute, ok := attributes["preferred_active_node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_active_node is missing from object`)

		return NewIpAliasNexthopsValueUnknown(), diags
	}

	preferredActiveNodeVal, ok := preferredActiveNodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_active_node expected to be basetypes.StringValue, was: %T`, preferredActiveNodeAttribute))
	}

	if diags.HasError() {
		return NewIpAliasNexthopsValueUnknown(), diags
	}

	return IpAliasNexthopsValue{
		Esi:                 esiVal,
		NextHop:             nextHopVal,
		PreferredActiveNode: preferredActiveNodeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewIpAliasNexthopsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpAliasNexthopsValue {
	object, diags := NewIpAliasNexthopsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpAliasNexthopsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpAliasNexthopsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpAliasNexthopsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpAliasNexthopsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpAliasNexthopsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpAliasNexthopsValueMust(IpAliasNexthopsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpAliasNexthopsType) ValueType(ctx context.Context) attr.Value {
	return IpAliasNexthopsValue{}
}

var _ basetypes.ObjectValuable = IpAliasNexthopsValue{}

type IpAliasNexthopsValue struct {
	Esi                 basetypes.StringValue `tfsdk:"esi"`
	NextHop             basetypes.StringValue `tfsdk:"next_hop"`
	PreferredActiveNode basetypes.StringValue `tfsdk:"preferred_active_node"`
	state               attr.ValueState
}

func (v IpAliasNexthopsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["esi"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["next_hop"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["preferred_active_node"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Esi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["esi"] = val

		val, err = v.NextHop.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["next_hop"] = val

		val, err = v.PreferredActiveNode.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preferred_active_node"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpAliasNexthopsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpAliasNexthopsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpAliasNexthopsValue) String() string {
	return "IpAliasNexthopsValue"
}

func (v IpAliasNexthopsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"esi":                   basetypes.StringType{},
		"next_hop":              basetypes.StringType{},
		"preferred_active_node": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"esi":                   v.Esi,
			"next_hop":              v.NextHop,
			"preferred_active_node": v.PreferredActiveNode,
		})

	return objVal, diags
}

func (v IpAliasNexthopsValue) Equal(o attr.Value) bool {
	other, ok := o.(IpAliasNexthopsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Esi.Equal(other.Esi) {
		return false
	}

	if !v.NextHop.Equal(other.NextHop) {
		return false
	}

	if !v.PreferredActiveNode.Equal(other.PreferredActiveNode) {
		return false
	}

	return true
}

func (v IpAliasNexthopsValue) Type(ctx context.Context) attr.Type {
	return IpAliasNexthopsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpAliasNexthopsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"esi":                   basetypes.StringType{},
		"next_hop":              basetypes.StringType{},
		"preferred_active_node": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Ipv4Unicast2Type{}

type Ipv4Unicast2Type struct {
	basetypes.ObjectType
}

func (t Ipv4Unicast2Type) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4Unicast2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4Unicast2Type) String() string {
	return "Ipv4Unicast2Type"
}

func (t Ipv4Unicast2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	advertiseIpv6NextHopsAttribute, ok := attributes["advertise_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6_next_hops is missing from object`)

		return nil, diags
	}

	advertiseIpv6NextHopsVal, ok := advertiseIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6NextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	multipathAttribute, ok := attributes["multipath"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multipath is missing from object`)

		return nil, diags
	}

	multipathVal, ok := multipathAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multipath expected to be basetypes.ObjectValue, was: %T`, multipathAttribute))
	}

	receiveIpv6NextHopsAttribute, ok := attributes["receive_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receive_ipv6_next_hops is missing from object`)

		return nil, diags
	}

	receiveIpv6NextHopsVal, ok := receiveIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receive_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, receiveIpv6NextHopsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4Unicast2Value{
		AdvertiseIpv6NextHops: advertiseIpv6NextHopsVal,
		Enabled:               enabledVal,
		Multipath:             multipathVal,
		ReceiveIpv6NextHops:   receiveIpv6NextHopsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIpv4Unicast2ValueNull() Ipv4Unicast2Value {
	return Ipv4Unicast2Value{
		state: attr.ValueStateNull,
	}
}

func NewIpv4Unicast2ValueUnknown() Ipv4Unicast2Value {
	return Ipv4Unicast2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4Unicast2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4Unicast2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4Unicast2Value Attribute Value",
				"While creating a Ipv4Unicast2Value value, a missing attribute value was detected. "+
					"A Ipv4Unicast2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4Unicast2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4Unicast2Value Attribute Type",
				"While creating a Ipv4Unicast2Value value, an invalid attribute value was detected. "+
					"A Ipv4Unicast2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4Unicast2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4Unicast2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4Unicast2Value Attribute Value",
				"While creating a Ipv4Unicast2Value value, an extra attribute value was detected. "+
					"A Ipv4Unicast2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4Unicast2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4Unicast2ValueUnknown(), diags
	}

	advertiseIpv6NextHopsAttribute, ok := attributes["advertise_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`advertise_ipv6_next_hops is missing from object`)

		return NewIpv4Unicast2ValueUnknown(), diags
	}

	advertiseIpv6NextHopsVal, ok := advertiseIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`advertise_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, advertiseIpv6NextHopsAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv4Unicast2ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	multipathAttribute, ok := attributes["multipath"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multipath is missing from object`)

		return NewIpv4Unicast2ValueUnknown(), diags
	}

	multipathVal, ok := multipathAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multipath expected to be basetypes.ObjectValue, was: %T`, multipathAttribute))
	}

	receiveIpv6NextHopsAttribute, ok := attributes["receive_ipv6_next_hops"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`receive_ipv6_next_hops is missing from object`)

		return NewIpv4Unicast2ValueUnknown(), diags
	}

	receiveIpv6NextHopsVal, ok := receiveIpv6NextHopsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`receive_ipv6_next_hops expected to be basetypes.BoolValue, was: %T`, receiveIpv6NextHopsAttribute))
	}

	if diags.HasError() {
		return NewIpv4Unicast2ValueUnknown(), diags
	}

	return Ipv4Unicast2Value{
		AdvertiseIpv6NextHops: advertiseIpv6NextHopsVal,
		Enabled:               enabledVal,
		Multipath:             multipathVal,
		ReceiveIpv6NextHops:   receiveIpv6NextHopsVal,
		state:                 attr.ValueStateKnown,
	}, diags
}

func NewIpv4Unicast2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4Unicast2Value {
	object, diags := NewIpv4Unicast2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4Unicast2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4Unicast2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4Unicast2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4Unicast2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4Unicast2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4Unicast2ValueMust(Ipv4Unicast2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4Unicast2Type) ValueType(ctx context.Context) attr.Value {
	return Ipv4Unicast2Value{}
}

var _ basetypes.ObjectValuable = Ipv4Unicast2Value{}

type Ipv4Unicast2Value struct {
	AdvertiseIpv6NextHops basetypes.BoolValue   `tfsdk:"advertise_ipv6_next_hops"`
	Enabled               basetypes.BoolValue   `tfsdk:"enabled"`
	Multipath             basetypes.ObjectValue `tfsdk:"multipath"`
	ReceiveIpv6NextHops   basetypes.BoolValue   `tfsdk:"receive_ipv6_next_hops"`
	state                 attr.ValueState
}

func (v Ipv4Unicast2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["advertise_ipv6_next_hops"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["multipath"] = basetypes.ObjectType{
		AttrTypes: MultipathValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["receive_ipv6_next_hops"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.AdvertiseIpv6NextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["advertise_ipv6_next_hops"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Multipath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multipath"] = val

		val, err = v.ReceiveIpv6NextHops.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["receive_ipv6_next_hops"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4Unicast2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4Unicast2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4Unicast2Value) String() string {
	return "Ipv4Unicast2Value"
}

func (v Ipv4Unicast2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var multipath basetypes.ObjectValue

	if v.Multipath.IsNull() {
		multipath = types.ObjectNull(
			MultipathValue{}.AttributeTypes(ctx),
		)
	}

	if v.Multipath.IsUnknown() {
		multipath = types.ObjectUnknown(
			MultipathValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Multipath.IsNull() && !v.Multipath.IsUnknown() {
		multipath = types.ObjectValueMust(
			MultipathValue{}.AttributeTypes(ctx),
			v.Multipath.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"advertise_ipv6_next_hops": basetypes.BoolType{},
		"enabled":                  basetypes.BoolType{},
		"multipath": basetypes.ObjectType{
			AttrTypes: MultipathValue{}.AttributeTypes(ctx),
		},
		"receive_ipv6_next_hops": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"advertise_ipv6_next_hops": v.AdvertiseIpv6NextHops,
			"enabled":                  v.Enabled,
			"multipath":                multipath,
			"receive_ipv6_next_hops":   v.ReceiveIpv6NextHops,
		})

	return objVal, diags
}

func (v Ipv4Unicast2Value) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4Unicast2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AdvertiseIpv6NextHops.Equal(other.AdvertiseIpv6NextHops) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Multipath.Equal(other.Multipath) {
		return false
	}

	if !v.ReceiveIpv6NextHops.Equal(other.ReceiveIpv6NextHops) {
		return false
	}

	return true
}

func (v Ipv4Unicast2Value) Type(ctx context.Context) attr.Type {
	return Ipv4Unicast2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4Unicast2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"advertise_ipv6_next_hops": basetypes.BoolType{},
		"enabled":                  basetypes.BoolType{},
		"multipath": basetypes.ObjectType{
			AttrTypes: MultipathValue{}.AttributeTypes(ctx),
		},
		"receive_ipv6_next_hops": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = MultipathType{}

type MultipathType struct {
	basetypes.ObjectType
}

func (t MultipathType) Equal(o attr.Type) bool {
	other, ok := o.(MultipathType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MultipathType) String() string {
	return "MultipathType"
}

func (t MultipathType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowMultipleAsAttribute, ok := attributes["allow_multiple_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_as is missing from object`)

		return nil, diags
	}

	allowMultipleAsVal, ok := allowMultipleAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_as expected to be basetypes.BoolValue, was: %T`, allowMultipleAsAttribute))
	}

	maxAllowedPathsAttribute, ok := attributes["max_allowed_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_allowed_paths is missing from object`)

		return nil, diags
	}

	maxAllowedPathsVal, ok := maxAllowedPathsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_allowed_paths expected to be basetypes.Int64Value, was: %T`, maxAllowedPathsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MultipathValue{
		AllowMultipleAs: allowMultipleAsVal,
		MaxAllowedPaths: maxAllowedPathsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewMultipathValueNull() MultipathValue {
	return MultipathValue{
		state: attr.ValueStateNull,
	}
}

func NewMultipathValueUnknown() MultipathValue {
	return MultipathValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMultipathValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MultipathValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MultipathValue Attribute Value",
				"While creating a MultipathValue value, a missing attribute value was detected. "+
					"A MultipathValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MultipathValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MultipathValue Attribute Type",
				"While creating a MultipathValue value, an invalid attribute value was detected. "+
					"A MultipathValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MultipathValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MultipathValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MultipathValue Attribute Value",
				"While creating a MultipathValue value, an extra attribute value was detected. "+
					"A MultipathValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MultipathValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMultipathValueUnknown(), diags
	}

	allowMultipleAsAttribute, ok := attributes["allow_multiple_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_as is missing from object`)

		return NewMultipathValueUnknown(), diags
	}

	allowMultipleAsVal, ok := allowMultipleAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_as expected to be basetypes.BoolValue, was: %T`, allowMultipleAsAttribute))
	}

	maxAllowedPathsAttribute, ok := attributes["max_allowed_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_allowed_paths is missing from object`)

		return NewMultipathValueUnknown(), diags
	}

	maxAllowedPathsVal, ok := maxAllowedPathsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_allowed_paths expected to be basetypes.Int64Value, was: %T`, maxAllowedPathsAttribute))
	}

	if diags.HasError() {
		return NewMultipathValueUnknown(), diags
	}

	return MultipathValue{
		AllowMultipleAs: allowMultipleAsVal,
		MaxAllowedPaths: maxAllowedPathsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewMultipathValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MultipathValue {
	object, diags := NewMultipathValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMultipathValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MultipathType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMultipathValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMultipathValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMultipathValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMultipathValueMust(MultipathValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MultipathType) ValueType(ctx context.Context) attr.Value {
	return MultipathValue{}
}

var _ basetypes.ObjectValuable = MultipathValue{}

type MultipathValue struct {
	AllowMultipleAs basetypes.BoolValue  `tfsdk:"allow_multiple_as"`
	MaxAllowedPaths basetypes.Int64Value `tfsdk:"max_allowed_paths"`
	state           attr.ValueState
}

func (v MultipathValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["allow_multiple_as"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_allowed_paths"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AllowMultipleAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_multiple_as"] = val

		val, err = v.MaxAllowedPaths.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_allowed_paths"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MultipathValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MultipathValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MultipathValue) String() string {
	return "MultipathValue"
}

func (v MultipathValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"allow_multiple_as": basetypes.BoolType{},
		"max_allowed_paths": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_multiple_as": v.AllowMultipleAs,
			"max_allowed_paths": v.MaxAllowedPaths,
		})

	return objVal, diags
}

func (v MultipathValue) Equal(o attr.Value) bool {
	other, ok := o.(MultipathValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowMultipleAs.Equal(other.AllowMultipleAs) {
		return false
	}

	if !v.MaxAllowedPaths.Equal(other.MaxAllowedPaths) {
		return false
	}

	return true
}

func (v MultipathValue) Type(ctx context.Context) attr.Type {
	return MultipathType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MultipathValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_multiple_as": basetypes.BoolType{},
		"max_allowed_paths": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = Ipv6Unicast2Type{}

type Ipv6Unicast2Type struct {
	basetypes.ObjectType
}

func (t Ipv6Unicast2Type) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6Unicast2Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6Unicast2Type) String() string {
	return "Ipv6Unicast2Type"
}

func (t Ipv6Unicast2Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	multipath1Attribute, ok := attributes["multipath"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multipath_1 is missing from object`)

		return nil, diags
	}

	multipath1Val, ok := multipath1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multipath_1 expected to be basetypes.ObjectValue, was: %T`, multipath1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6Unicast2Value{
		Enabled:    enabledVal,
		Multipath1: multipath1Val,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpv6Unicast2ValueNull() Ipv6Unicast2Value {
	return Ipv6Unicast2Value{
		state: attr.ValueStateNull,
	}
}

func NewIpv6Unicast2ValueUnknown() Ipv6Unicast2Value {
	return Ipv6Unicast2Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6Unicast2Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6Unicast2Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6Unicast2Value Attribute Value",
				"While creating a Ipv6Unicast2Value value, a missing attribute value was detected. "+
					"A Ipv6Unicast2Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6Unicast2Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6Unicast2Value Attribute Type",
				"While creating a Ipv6Unicast2Value value, an invalid attribute value was detected. "+
					"A Ipv6Unicast2Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6Unicast2Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6Unicast2Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6Unicast2Value Attribute Value",
				"While creating a Ipv6Unicast2Value value, an extra attribute value was detected. "+
					"A Ipv6Unicast2Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6Unicast2Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6Unicast2ValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv6Unicast2ValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	multipath1Attribute, ok := attributes["multipath"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`multipath_1 is missing from object`)

		return NewIpv6Unicast2ValueUnknown(), diags
	}

	multipath1Val, ok := multipath1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`multipath_1 expected to be basetypes.ObjectValue, was: %T`, multipath1Attribute))
	}

	if diags.HasError() {
		return NewIpv6Unicast2ValueUnknown(), diags
	}

	return Ipv6Unicast2Value{
		Enabled:    enabledVal,
		Multipath1: multipath1Val,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewIpv6Unicast2ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6Unicast2Value {
	object, diags := NewIpv6Unicast2Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6Unicast2ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6Unicast2Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6Unicast2ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6Unicast2ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6Unicast2ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6Unicast2ValueMust(Ipv6Unicast2Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6Unicast2Type) ValueType(ctx context.Context) attr.Value {
	return Ipv6Unicast2Value{}
}

var _ basetypes.ObjectValuable = Ipv6Unicast2Value{}

type Ipv6Unicast2Value struct {
	Enabled    basetypes.BoolValue   `tfsdk:"enabled"`
	Multipath1 basetypes.ObjectValue `tfsdk:"multipath"`
	state      attr.ValueState
}

func (v Ipv6Unicast2Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["multipath"] = basetypes.ObjectType{
		AttrTypes: Multipath1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Multipath1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["multipath"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6Unicast2Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6Unicast2Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6Unicast2Value) String() string {
	return "Ipv6Unicast2Value"
}

func (v Ipv6Unicast2Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var multipath1 basetypes.ObjectValue

	if v.Multipath1.IsNull() {
		multipath1 = types.ObjectNull(
			Multipath1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Multipath1.IsUnknown() {
		multipath1 = types.ObjectUnknown(
			Multipath1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Multipath1.IsNull() && !v.Multipath1.IsUnknown() {
		multipath1 = types.ObjectValueMust(
			Multipath1Value{}.AttributeTypes(ctx),
			v.Multipath1.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"multipath": basetypes.ObjectType{
			AttrTypes: Multipath1Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":   v.Enabled,
			"multipath": multipath1,
		})

	return objVal, diags
}

func (v Ipv6Unicast2Value) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6Unicast2Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Multipath1.Equal(other.Multipath1) {
		return false
	}

	return true
}

func (v Ipv6Unicast2Value) Type(ctx context.Context) attr.Type {
	return Ipv6Unicast2Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6Unicast2Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled": basetypes.BoolType{},
		"multipath": basetypes.ObjectType{
			AttrTypes: Multipath1Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Multipath1Type{}

type Multipath1Type struct {
	basetypes.ObjectType
}

func (t Multipath1Type) Equal(o attr.Type) bool {
	other, ok := o.(Multipath1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Multipath1Type) String() string {
	return "Multipath1Type"
}

func (t Multipath1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowMultipleAsAttribute, ok := attributes["allow_multiple_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_as is missing from object`)

		return nil, diags
	}

	allowMultipleAsVal, ok := allowMultipleAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_as expected to be basetypes.BoolValue, was: %T`, allowMultipleAsAttribute))
	}

	maxAllowedPathsAttribute, ok := attributes["max_allowed_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_allowed_paths is missing from object`)

		return nil, diags
	}

	maxAllowedPathsVal, ok := maxAllowedPathsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_allowed_paths expected to be basetypes.Int64Value, was: %T`, maxAllowedPathsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Multipath1Value{
		AllowMultipleAs: allowMultipleAsVal,
		MaxAllowedPaths: maxAllowedPathsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewMultipath1ValueNull() Multipath1Value {
	return Multipath1Value{
		state: attr.ValueStateNull,
	}
}

func NewMultipath1ValueUnknown() Multipath1Value {
	return Multipath1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewMultipath1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Multipath1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Multipath1Value Attribute Value",
				"While creating a Multipath1Value value, a missing attribute value was detected. "+
					"A Multipath1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Multipath1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Multipath1Value Attribute Type",
				"While creating a Multipath1Value value, an invalid attribute value was detected. "+
					"A Multipath1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Multipath1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Multipath1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Multipath1Value Attribute Value",
				"While creating a Multipath1Value value, an extra attribute value was detected. "+
					"A Multipath1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Multipath1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMultipath1ValueUnknown(), diags
	}

	allowMultipleAsAttribute, ok := attributes["allow_multiple_as"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_multiple_as is missing from object`)

		return NewMultipath1ValueUnknown(), diags
	}

	allowMultipleAsVal, ok := allowMultipleAsAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_multiple_as expected to be basetypes.BoolValue, was: %T`, allowMultipleAsAttribute))
	}

	maxAllowedPathsAttribute, ok := attributes["max_allowed_paths"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_allowed_paths is missing from object`)

		return NewMultipath1ValueUnknown(), diags
	}

	maxAllowedPathsVal, ok := maxAllowedPathsAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_allowed_paths expected to be basetypes.Int64Value, was: %T`, maxAllowedPathsAttribute))
	}

	if diags.HasError() {
		return NewMultipath1ValueUnknown(), diags
	}

	return Multipath1Value{
		AllowMultipleAs: allowMultipleAsVal,
		MaxAllowedPaths: maxAllowedPathsVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewMultipath1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Multipath1Value {
	object, diags := NewMultipath1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMultipath1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Multipath1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMultipath1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMultipath1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMultipath1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMultipath1ValueMust(Multipath1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Multipath1Type) ValueType(ctx context.Context) attr.Value {
	return Multipath1Value{}
}

var _ basetypes.ObjectValuable = Multipath1Value{}

type Multipath1Value struct {
	AllowMultipleAs basetypes.BoolValue  `tfsdk:"allow_multiple_as"`
	MaxAllowedPaths basetypes.Int64Value `tfsdk:"max_allowed_paths"`
	state           attr.ValueState
}

func (v Multipath1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["allow_multiple_as"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_allowed_paths"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.AllowMultipleAs.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_multiple_as"] = val

		val, err = v.MaxAllowedPaths.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_allowed_paths"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Multipath1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Multipath1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Multipath1Value) String() string {
	return "Multipath1Value"
}

func (v Multipath1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"allow_multiple_as": basetypes.BoolType{},
		"max_allowed_paths": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_multiple_as": v.AllowMultipleAs,
			"max_allowed_paths": v.MaxAllowedPaths,
		})

	return objVal, diags
}

func (v Multipath1Value) Equal(o attr.Value) bool {
	other, ok := o.(Multipath1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowMultipleAs.Equal(other.AllowMultipleAs) {
		return false
	}

	if !v.MaxAllowedPaths.Equal(other.MaxAllowedPaths) {
		return false
	}

	return true
}

func (v Multipath1Value) Type(ctx context.Context) attr.Type {
	return Multipath1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Multipath1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_multiple_as": basetypes.BoolType{},
		"max_allowed_paths": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = IpLoadBalancingType{}

type IpLoadBalancingType struct {
	basetypes.ObjectType
}

func (t IpLoadBalancingType) Equal(o attr.Type) bool {
	other, ok := o.(IpLoadBalancingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpLoadBalancingType) String() string {
	return "IpLoadBalancingType"
}

func (t IpLoadBalancingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	prefix1Attribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_1 is missing from object`)

		return nil, diags
	}

	prefix1Val, ok := prefix1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_1 expected to be basetypes.ListValue, was: %T`, prefix1Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpLoadBalancingValue{
		Prefix1: prefix1Val,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewIpLoadBalancingValueNull() IpLoadBalancingValue {
	return IpLoadBalancingValue{
		state: attr.ValueStateNull,
	}
}

func NewIpLoadBalancingValueUnknown() IpLoadBalancingValue {
	return IpLoadBalancingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpLoadBalancingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpLoadBalancingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpLoadBalancingValue Attribute Value",
				"While creating a IpLoadBalancingValue value, a missing attribute value was detected. "+
					"A IpLoadBalancingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpLoadBalancingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpLoadBalancingValue Attribute Type",
				"While creating a IpLoadBalancingValue value, an invalid attribute value was detected. "+
					"A IpLoadBalancingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpLoadBalancingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpLoadBalancingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpLoadBalancingValue Attribute Value",
				"While creating a IpLoadBalancingValue value, an extra attribute value was detected. "+
					"A IpLoadBalancingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpLoadBalancingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpLoadBalancingValueUnknown(), diags
	}

	prefix1Attribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix_1 is missing from object`)

		return NewIpLoadBalancingValueUnknown(), diags
	}

	prefix1Val, ok := prefix1Attribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix_1 expected to be basetypes.ListValue, was: %T`, prefix1Attribute))
	}

	if diags.HasError() {
		return NewIpLoadBalancingValueUnknown(), diags
	}

	return IpLoadBalancingValue{
		Prefix1: prefix1Val,
		state:   attr.ValueStateKnown,
	}, diags
}

func NewIpLoadBalancingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpLoadBalancingValue {
	object, diags := NewIpLoadBalancingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpLoadBalancingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpLoadBalancingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpLoadBalancingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpLoadBalancingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpLoadBalancingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpLoadBalancingValueMust(IpLoadBalancingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpLoadBalancingType) ValueType(ctx context.Context) attr.Value {
	return IpLoadBalancingValue{}
}

var _ basetypes.ObjectValuable = IpLoadBalancingValue{}

type IpLoadBalancingValue struct {
	Prefix1 basetypes.ListValue `tfsdk:"prefix"`
	state   attr.ValueState
}

func (v IpLoadBalancingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["prefix"] = basetypes.ListType{
		ElemType: Prefix1Value{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.Prefix1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpLoadBalancingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpLoadBalancingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpLoadBalancingValue) String() string {
	return "IpLoadBalancingValue"
}

func (v IpLoadBalancingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	prefix1 := types.ListValueMust(
		Prefix1Type{
			basetypes.ObjectType{
				AttrTypes: Prefix1Value{}.AttributeTypes(ctx),
			},
		},
		v.Prefix1.Elements(),
	)

	if v.Prefix1.IsNull() {
		prefix1 = types.ListNull(
			Prefix1Type{
				basetypes.ObjectType{
					AttrTypes: Prefix1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Prefix1.IsUnknown() {
		prefix1 = types.ListUnknown(
			Prefix1Type{
				basetypes.ObjectType{
					AttrTypes: Prefix1Value{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"prefix": basetypes.ListType{
			ElemType: Prefix1Value{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"prefix": prefix1,
		})

	return objVal, diags
}

func (v IpLoadBalancingValue) Equal(o attr.Value) bool {
	other, ok := o.(IpLoadBalancingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Prefix1.Equal(other.Prefix1) {
		return false
	}

	return true
}

func (v IpLoadBalancingValue) Type(ctx context.Context) attr.Type {
	return IpLoadBalancingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpLoadBalancingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"prefix": basetypes.ListType{
			ElemType: Prefix1Value{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Prefix1Type{}

type Prefix1Type struct {
	basetypes.ObjectType
}

func (t Prefix1Type) Equal(o attr.Type) bool {
	other, ok := o.(Prefix1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Prefix1Type) String() string {
	return "Prefix1Type"
}

func (t Prefix1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	hashBucketsPerPathAttribute, ok := attributes["hash_buckets_per_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hash_buckets_per_path is missing from object`)

		return nil, diags
	}

	hashBucketsPerPathVal, ok := hashBucketsPerPathAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hash_buckets_per_path expected to be basetypes.Int64Value, was: %T`, hashBucketsPerPathAttribute))
	}

	maxEcmpAttribute, ok := attributes["max_ecmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_ecmp is missing from object`)

		return nil, diags
	}

	maxEcmpVal, ok := maxEcmpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_ecmp expected to be basetypes.Int64Value, was: %T`, maxEcmpAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Prefix1Value{
		HashBucketsPerPath: hashBucketsPerPathVal,
		MaxEcmp:            maxEcmpVal,
		Prefix:             prefixVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPrefix1ValueNull() Prefix1Value {
	return Prefix1Value{
		state: attr.ValueStateNull,
	}
}

func NewPrefix1ValueUnknown() Prefix1Value {
	return Prefix1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefix1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Prefix1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Prefix1Value Attribute Value",
				"While creating a Prefix1Value value, a missing attribute value was detected. "+
					"A Prefix1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Prefix1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Prefix1Value Attribute Type",
				"While creating a Prefix1Value value, an invalid attribute value was detected. "+
					"A Prefix1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Prefix1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Prefix1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Prefix1Value Attribute Value",
				"While creating a Prefix1Value value, an extra attribute value was detected. "+
					"A Prefix1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Prefix1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefix1ValueUnknown(), diags
	}

	hashBucketsPerPathAttribute, ok := attributes["hash_buckets_per_path"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hash_buckets_per_path is missing from object`)

		return NewPrefix1ValueUnknown(), diags
	}

	hashBucketsPerPathVal, ok := hashBucketsPerPathAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hash_buckets_per_path expected to be basetypes.Int64Value, was: %T`, hashBucketsPerPathAttribute))
	}

	maxEcmpAttribute, ok := attributes["max_ecmp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_ecmp is missing from object`)

		return NewPrefix1ValueUnknown(), diags
	}

	maxEcmpVal, ok := maxEcmpAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_ecmp expected to be basetypes.Int64Value, was: %T`, maxEcmpAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewPrefix1ValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	if diags.HasError() {
		return NewPrefix1ValueUnknown(), diags
	}

	return Prefix1Value{
		HashBucketsPerPath: hashBucketsPerPathVal,
		MaxEcmp:            maxEcmpVal,
		Prefix:             prefixVal,
		state:              attr.ValueStateKnown,
	}, diags
}

func NewPrefix1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Prefix1Value {
	object, diags := NewPrefix1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefix1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Prefix1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefix1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefix1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefix1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefix1ValueMust(Prefix1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Prefix1Type) ValueType(ctx context.Context) attr.Value {
	return Prefix1Value{}
}

var _ basetypes.ObjectValuable = Prefix1Value{}

type Prefix1Value struct {
	HashBucketsPerPath basetypes.Int64Value  `tfsdk:"hash_buckets_per_path"`
	MaxEcmp            basetypes.Int64Value  `tfsdk:"max_ecmp"`
	Prefix             basetypes.StringValue `tfsdk:"prefix"`
	state              attr.ValueState
}

func (v Prefix1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["hash_buckets_per_path"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["max_ecmp"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.HashBucketsPerPath.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hash_buckets_per_path"] = val

		val, err = v.MaxEcmp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_ecmp"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Prefix1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Prefix1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Prefix1Value) String() string {
	return "Prefix1Value"
}

func (v Prefix1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"hash_buckets_per_path": basetypes.Int64Type{},
		"max_ecmp":              basetypes.Int64Type{},
		"prefix":                basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"hash_buckets_per_path": v.HashBucketsPerPath,
			"max_ecmp":              v.MaxEcmp,
			"prefix":                v.Prefix,
		})

	return objVal, diags
}

func (v Prefix1Value) Equal(o attr.Value) bool {
	other, ok := o.(Prefix1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.HashBucketsPerPath.Equal(other.HashBucketsPerPath) {
		return false
	}

	if !v.MaxEcmp.Equal(other.MaxEcmp) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	return true
}

func (v Prefix1Value) Type(ctx context.Context) attr.Type {
	return Prefix1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Prefix1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"hash_buckets_per_path": basetypes.Int64Type{},
		"max_ecmp":              basetypes.Int64Type{},
		"prefix":                basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RouteLeakingType{}

type RouteLeakingType struct {
	basetypes.ObjectType
}

func (t RouteLeakingType) Equal(o attr.Type) bool {
	other, ok := o.(RouteLeakingType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RouteLeakingType) String() string {
	return "RouteLeakingType"
}

func (t RouteLeakingType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return nil, diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return nil, diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RouteLeakingValue{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeakingValueNull() RouteLeakingValue {
	return RouteLeakingValue{
		state: attr.ValueStateNull,
	}
}

func NewRouteLeakingValueUnknown() RouteLeakingValue {
	return RouteLeakingValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRouteLeakingValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RouteLeakingValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RouteLeakingValue Attribute Value",
				"While creating a RouteLeakingValue value, a missing attribute value was detected. "+
					"A RouteLeakingValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeakingValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RouteLeakingValue Attribute Type",
				"While creating a RouteLeakingValue value, an invalid attribute value was detected. "+
					"A RouteLeakingValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RouteLeakingValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RouteLeakingValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RouteLeakingValue Attribute Value",
				"While creating a RouteLeakingValue value, an extra attribute value was detected. "+
					"A RouteLeakingValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RouteLeakingValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRouteLeakingValueUnknown(), diags
	}

	exportPolicyAttribute, ok := attributes["export_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_policy is missing from object`)

		return NewRouteLeakingValueUnknown(), diags
	}

	exportPolicyVal, ok := exportPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_policy expected to be basetypes.StringValue, was: %T`, exportPolicyAttribute))
	}

	importPolicyAttribute, ok := attributes["import_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_policy is missing from object`)

		return NewRouteLeakingValueUnknown(), diags
	}

	importPolicyVal, ok := importPolicyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_policy expected to be basetypes.StringValue, was: %T`, importPolicyAttribute))
	}

	if diags.HasError() {
		return NewRouteLeakingValueUnknown(), diags
	}

	return RouteLeakingValue{
		ExportPolicy: exportPolicyVal,
		ImportPolicy: importPolicyVal,
		state:        attr.ValueStateKnown,
	}, diags
}

func NewRouteLeakingValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RouteLeakingValue {
	object, diags := NewRouteLeakingValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRouteLeakingValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RouteLeakingType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRouteLeakingValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRouteLeakingValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRouteLeakingValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRouteLeakingValueMust(RouteLeakingValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RouteLeakingType) ValueType(ctx context.Context) attr.Value {
	return RouteLeakingValue{}
}

var _ basetypes.ObjectValuable = RouteLeakingValue{}

type RouteLeakingValue struct {
	ExportPolicy basetypes.StringValue `tfsdk:"export_policy"`
	ImportPolicy basetypes.StringValue `tfsdk:"import_policy"`
	state        attr.ValueState
}

func (v RouteLeakingValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["export_policy"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_policy"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ExportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_policy"] = val

		val, err = v.ImportPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RouteLeakingValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RouteLeakingValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RouteLeakingValue) String() string {
	return "RouteLeakingValue"
}

func (v RouteLeakingValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"export_policy": v.ExportPolicy,
			"import_policy": v.ImportPolicy,
		})

	return objVal, diags
}

func (v RouteLeakingValue) Equal(o attr.Value) bool {
	other, ok := o.(RouteLeakingValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExportPolicy.Equal(other.ExportPolicy) {
		return false
	}

	if !v.ImportPolicy.Equal(other.ImportPolicy) {
		return false
	}

	return true
}

func (v RouteLeakingValue) Type(ctx context.Context) attr.Type {
	return RouteLeakingType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RouteLeakingValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"export_policy": basetypes.StringType{},
		"import_policy": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = VlansType{}

type VlansType struct {
	basetypes.ObjectType
}

func (t VlansType) Equal(o attr.Type) bool {
	other, ok := o.(VlansType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t VlansType) String() string {
	return "VlansType"
}

func (t VlansType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec14Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_14 is missing from object`)

		return nil, diags
	}

	spec14Val, ok := spec14Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_14 expected to be basetypes.ObjectValue, was: %T`, spec14Attribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return VlansValue{
		Name:   nameVal,
		Spec14: spec14Val,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewVlansValueNull() VlansValue {
	return VlansValue{
		state: attr.ValueStateNull,
	}
}

func NewVlansValueUnknown() VlansValue {
	return VlansValue{
		state: attr.ValueStateUnknown,
	}
}

func NewVlansValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (VlansValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing VlansValue Attribute Value",
				"While creating a VlansValue value, a missing attribute value was detected. "+
					"A VlansValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VlansValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid VlansValue Attribute Type",
				"While creating a VlansValue value, an invalid attribute value was detected. "+
					"A VlansValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("VlansValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("VlansValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra VlansValue Attribute Value",
				"While creating a VlansValue value, an extra attribute value was detected. "+
					"A VlansValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra VlansValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewVlansValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewVlansValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	spec14Attribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec_14 is missing from object`)

		return NewVlansValueUnknown(), diags
	}

	spec14Val, ok := spec14Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec_14 expected to be basetypes.ObjectValue, was: %T`, spec14Attribute))
	}

	if diags.HasError() {
		return NewVlansValueUnknown(), diags
	}

	return VlansValue{
		Name:   nameVal,
		Spec14: spec14Val,
		state:  attr.ValueStateKnown,
	}, diags
}

func NewVlansValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) VlansValue {
	object, diags := NewVlansValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewVlansValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t VlansType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewVlansValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewVlansValueUnknown(), nil
	}

	if in.IsNull() {
		return NewVlansValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewVlansValueMust(VlansValue{}.AttributeTypes(ctx), attributes), nil
}

func (t VlansType) ValueType(ctx context.Context) attr.Value {
	return VlansValue{}
}

var _ basetypes.ObjectValuable = VlansValue{}

type VlansValue struct {
	Name   basetypes.StringValue `tfsdk:"name"`
	Spec14 basetypes.ObjectValue `tfsdk:"spec"`
	state  attr.ValueState
}

func (v VlansValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: Spec14Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Spec14.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v VlansValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v VlansValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v VlansValue) String() string {
	return "VlansValue"
}

func (v VlansValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var spec14 basetypes.ObjectValue

	if v.Spec14.IsNull() {
		spec14 = types.ObjectNull(
			Spec14Value{}.AttributeTypes(ctx),
		)
	}

	if v.Spec14.IsUnknown() {
		spec14 = types.ObjectUnknown(
			Spec14Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec14.IsNull() && !v.Spec14.IsUnknown() {
		spec14 = types.ObjectValueMust(
			Spec14Value{}.AttributeTypes(ctx),
			v.Spec14.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec14Value{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"name": v.Name,
			"spec": spec14,
		})

	return objVal, diags
}

func (v VlansValue) Equal(o attr.Value) bool {
	other, ok := o.(VlansValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Spec14.Equal(other.Spec14) {
		return false
	}

	return true
}

func (v VlansValue) Type(ctx context.Context) attr.Type {
	return VlansType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v VlansValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"spec": basetypes.ObjectType{
			AttrTypes: Spec14Value{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = Spec14Type{}

type Spec14Type struct {
	basetypes.ObjectType
}

func (t Spec14Type) Equal(o attr.Type) bool {
	other, ok := o.(Spec14Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Spec14Type) String() string {
	return "Spec14Type"
}

func (t Spec14Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	bridgeDomainAttribute, ok := attributes["bridge_domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_domain is missing from object`)

		return nil, diags
	}

	bridgeDomainVal, ok := bridgeDomainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_domain expected to be basetypes.StringValue, was: %T`, bridgeDomainAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egress4Attribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_4 is missing from object`)

		return nil, diags
	}

	egress4Val, ok := egress4Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_4 expected to be basetypes.ObjectValue, was: %T`, egress4Attribute))
	}

	ingress4Attribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_4 is missing from object`)

		return nil, diags
	}

	ingress4Val, ok := ingress4Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_4 expected to be basetypes.ObjectValue, was: %T`, ingress4Attribute))
	}

	interfaceSelectorAttribute, ok := attributes["interface_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_selector is missing from object`)

		return nil, diags
	}

	interfaceSelectorVal, ok := interfaceSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_selector expected to be basetypes.ListValue, was: %T`, interfaceSelectorAttribute))
	}

	l2MtuAttribute, ok := attributes["l2_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2_mtu is missing from object`)

		return nil, diags
	}

	l2MtuVal, ok := l2MtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2_mtu expected to be basetypes.Int64Value, was: %T`, l2MtuAttribute))
	}

	macDuplicationDetectionActionAttribute, ok := attributes["mac_duplication_detection_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_duplication_detection_action is missing from object`)

		return nil, diags
	}

	macDuplicationDetectionActionVal, ok := macDuplicationDetectionActionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_duplication_detection_action expected to be basetypes.StringValue, was: %T`, macDuplicationDetectionActionAttribute))
	}

	splitHorizonGroupAttribute, ok := attributes["split_horizon_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`split_horizon_group is missing from object`)

		return nil, diags
	}

	splitHorizonGroupVal, ok := splitHorizonGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`split_horizon_group expected to be basetypes.StringValue, was: %T`, splitHorizonGroupAttribute))
	}

	uplink1Attribute, ok := attributes["uplink"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_1 is missing from object`)

		return nil, diags
	}

	uplink1Val, ok := uplink1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_1 expected to be basetypes.ObjectValue, was: %T`, uplink1Attribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	vlanPoolAttribute, ok := attributes["vlan_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_pool is missing from object`)

		return nil, diags
	}

	vlanPoolVal, ok := vlanPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_pool expected to be basetypes.StringValue, was: %T`, vlanPoolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Spec14Value{
		BridgeDomain:                  bridgeDomainVal,
		Description:                   descriptionVal,
		Egress4:                       egress4Val,
		Ingress4:                      ingress4Val,
		InterfaceSelector:             interfaceSelectorVal,
		L2Mtu:                         l2MtuVal,
		MacDuplicationDetectionAction: macDuplicationDetectionActionVal,
		SplitHorizonGroup:             splitHorizonGroupVal,
		Uplink1:                       uplink1Val,
		VlanId:                        vlanIdVal,
		VlanPool:                      vlanPoolVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSpec14ValueNull() Spec14Value {
	return Spec14Value{
		state: attr.ValueStateNull,
	}
}

func NewSpec14ValueUnknown() Spec14Value {
	return Spec14Value{
		state: attr.ValueStateUnknown,
	}
}

func NewSpec14Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Spec14Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Spec14Value Attribute Value",
				"While creating a Spec14Value value, a missing attribute value was detected. "+
					"A Spec14Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec14Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Spec14Value Attribute Type",
				"While creating a Spec14Value value, an invalid attribute value was detected. "+
					"A Spec14Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Spec14Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Spec14Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Spec14Value Attribute Value",
				"While creating a Spec14Value value, an extra attribute value was detected. "+
					"A Spec14Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Spec14Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpec14ValueUnknown(), diags
	}

	bridgeDomainAttribute, ok := attributes["bridge_domain"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bridge_domain is missing from object`)

		return NewSpec14ValueUnknown(), diags
	}

	bridgeDomainVal, ok := bridgeDomainAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bridge_domain expected to be basetypes.StringValue, was: %T`, bridgeDomainAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpec14ValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egress4Attribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_4 is missing from object`)

		return NewSpec14ValueUnknown(), diags
	}

	egress4Val, ok := egress4Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_4 expected to be basetypes.ObjectValue, was: %T`, egress4Attribute))
	}

	ingress4Attribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_4 is missing from object`)

		return NewSpec14ValueUnknown(), diags
	}

	ingress4Val, ok := ingress4Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_4 expected to be basetypes.ObjectValue, was: %T`, ingress4Attribute))
	}

	interfaceSelectorAttribute, ok := attributes["interface_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_selector is missing from object`)

		return NewSpec14ValueUnknown(), diags
	}

	interfaceSelectorVal, ok := interfaceSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_selector expected to be basetypes.ListValue, was: %T`, interfaceSelectorAttribute))
	}

	l2MtuAttribute, ok := attributes["l2_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2_mtu is missing from object`)

		return NewSpec14ValueUnknown(), diags
	}

	l2MtuVal, ok := l2MtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2_mtu expected to be basetypes.Int64Value, was: %T`, l2MtuAttribute))
	}

	macDuplicationDetectionActionAttribute, ok := attributes["mac_duplication_detection_action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_duplication_detection_action is missing from object`)

		return NewSpec14ValueUnknown(), diags
	}

	macDuplicationDetectionActionVal, ok := macDuplicationDetectionActionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_duplication_detection_action expected to be basetypes.StringValue, was: %T`, macDuplicationDetectionActionAttribute))
	}

	splitHorizonGroupAttribute, ok := attributes["split_horizon_group"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`split_horizon_group is missing from object`)

		return NewSpec14ValueUnknown(), diags
	}

	splitHorizonGroupVal, ok := splitHorizonGroupAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`split_horizon_group expected to be basetypes.StringValue, was: %T`, splitHorizonGroupAttribute))
	}

	uplink1Attribute, ok := attributes["uplink"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_1 is missing from object`)

		return NewSpec14ValueUnknown(), diags
	}

	uplink1Val, ok := uplink1Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_1 expected to be basetypes.ObjectValue, was: %T`, uplink1Attribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewSpec14ValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	vlanPoolAttribute, ok := attributes["vlan_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_pool is missing from object`)

		return NewSpec14ValueUnknown(), diags
	}

	vlanPoolVal, ok := vlanPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_pool expected to be basetypes.StringValue, was: %T`, vlanPoolAttribute))
	}

	if diags.HasError() {
		return NewSpec14ValueUnknown(), diags
	}

	return Spec14Value{
		BridgeDomain:                  bridgeDomainVal,
		Description:                   descriptionVal,
		Egress4:                       egress4Val,
		Ingress4:                      ingress4Val,
		InterfaceSelector:             interfaceSelectorVal,
		L2Mtu:                         l2MtuVal,
		MacDuplicationDetectionAction: macDuplicationDetectionActionVal,
		SplitHorizonGroup:             splitHorizonGroupVal,
		Uplink1:                       uplink1Val,
		VlanId:                        vlanIdVal,
		VlanPool:                      vlanPoolVal,
		state:                         attr.ValueStateKnown,
	}, diags
}

func NewSpec14ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Spec14Value {
	object, diags := NewSpec14Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpec14ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Spec14Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpec14ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpec14ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpec14ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpec14ValueMust(Spec14Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Spec14Type) ValueType(ctx context.Context) attr.Value {
	return Spec14Value{}
}

var _ basetypes.ObjectValuable = Spec14Value{}

type Spec14Value struct {
	BridgeDomain                  basetypes.StringValue `tfsdk:"bridge_domain"`
	Description                   basetypes.StringValue `tfsdk:"description"`
	Egress4                       basetypes.ObjectValue `tfsdk:"egress"`
	Ingress4                      basetypes.ObjectValue `tfsdk:"ingress"`
	InterfaceSelector             basetypes.ListValue   `tfsdk:"interface_selector"`
	L2Mtu                         basetypes.Int64Value  `tfsdk:"l2_mtu"`
	MacDuplicationDetectionAction basetypes.StringValue `tfsdk:"mac_duplication_detection_action"`
	SplitHorizonGroup             basetypes.StringValue `tfsdk:"split_horizon_group"`
	Uplink1                       basetypes.ObjectValue `tfsdk:"uplink"`
	VlanId                        basetypes.StringValue `tfsdk:"vlan_id"`
	VlanPool                      basetypes.StringValue `tfsdk:"vlan_pool"`
	state                         attr.ValueState
}

func (v Spec14Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["bridge_domain"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["egress"] = basetypes.ObjectType{
		AttrTypes: Egress4Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ingress"] = basetypes.ObjectType{
		AttrTypes: Ingress4Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["interface_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["l2_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mac_duplication_detection_action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["split_horizon_group"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uplink"] = basetypes.ObjectType{
		AttrTypes: Uplink1Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_pool"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.BridgeDomain.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bridge_domain"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Egress4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress"] = val

		val, err = v.Ingress4.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress"] = val

		val, err = v.InterfaceSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_selector"] = val

		val, err = v.L2Mtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l2_mtu"] = val

		val, err = v.MacDuplicationDetectionAction.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_duplication_detection_action"] = val

		val, err = v.SplitHorizonGroup.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["split_horizon_group"] = val

		val, err = v.Uplink1.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uplink"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		val, err = v.VlanPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_pool"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Spec14Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Spec14Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Spec14Value) String() string {
	return "Spec14Value"
}

func (v Spec14Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var egress4 basetypes.ObjectValue

	if v.Egress4.IsNull() {
		egress4 = types.ObjectNull(
			Egress4Value{}.AttributeTypes(ctx),
		)
	}

	if v.Egress4.IsUnknown() {
		egress4 = types.ObjectUnknown(
			Egress4Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Egress4.IsNull() && !v.Egress4.IsUnknown() {
		egress4 = types.ObjectValueMust(
			Egress4Value{}.AttributeTypes(ctx),
			v.Egress4.Attributes(),
		)
	}

	var ingress4 basetypes.ObjectValue

	if v.Ingress4.IsNull() {
		ingress4 = types.ObjectNull(
			Ingress4Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ingress4.IsUnknown() {
		ingress4 = types.ObjectUnknown(
			Ingress4Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ingress4.IsNull() && !v.Ingress4.IsUnknown() {
		ingress4 = types.ObjectValueMust(
			Ingress4Value{}.AttributeTypes(ctx),
			v.Ingress4.Attributes(),
		)
	}

	var uplink1 basetypes.ObjectValue

	if v.Uplink1.IsNull() {
		uplink1 = types.ObjectNull(
			Uplink1Value{}.AttributeTypes(ctx),
		)
	}

	if v.Uplink1.IsUnknown() {
		uplink1 = types.ObjectUnknown(
			Uplink1Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Uplink1.IsNull() && !v.Uplink1.IsUnknown() {
		uplink1 = types.ObjectValueMust(
			Uplink1Value{}.AttributeTypes(ctx),
			v.Uplink1.Attributes(),
		)
	}

	var interfaceSelectorVal basetypes.ListValue
	switch {
	case v.InterfaceSelector.IsUnknown():
		interfaceSelectorVal = types.ListUnknown(types.StringType)
	case v.InterfaceSelector.IsNull():
		interfaceSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		interfaceSelectorVal, d = types.ListValue(types.StringType, v.InterfaceSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"bridge_domain": basetypes.StringType{},
			"description":   basetypes.StringType{},
			"egress": basetypes.ObjectType{
				AttrTypes: Egress4Value{}.AttributeTypes(ctx),
			},
			"ingress": basetypes.ObjectType{
				AttrTypes: Ingress4Value{}.AttributeTypes(ctx),
			},
			"interface_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"l2_mtu":                           basetypes.Int64Type{},
			"mac_duplication_detection_action": basetypes.StringType{},
			"split_horizon_group":              basetypes.StringType{},
			"uplink": basetypes.ObjectType{
				AttrTypes: Uplink1Value{}.AttributeTypes(ctx),
			},
			"vlan_id":   basetypes.StringType{},
			"vlan_pool": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"bridge_domain": basetypes.StringType{},
		"description":   basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: Egress4Value{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: Ingress4Value{}.AttributeTypes(ctx),
		},
		"interface_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"l2_mtu":                           basetypes.Int64Type{},
		"mac_duplication_detection_action": basetypes.StringType{},
		"split_horizon_group":              basetypes.StringType{},
		"uplink": basetypes.ObjectType{
			AttrTypes: Uplink1Value{}.AttributeTypes(ctx),
		},
		"vlan_id":   basetypes.StringType{},
		"vlan_pool": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"bridge_domain":                    v.BridgeDomain,
			"description":                      v.Description,
			"egress":                           egress4,
			"ingress":                          ingress4,
			"interface_selector":               interfaceSelectorVal,
			"l2_mtu":                           v.L2Mtu,
			"mac_duplication_detection_action": v.MacDuplicationDetectionAction,
			"split_horizon_group":              v.SplitHorizonGroup,
			"uplink":                           uplink1,
			"vlan_id":                          v.VlanId,
			"vlan_pool":                        v.VlanPool,
		})

	return objVal, diags
}

func (v Spec14Value) Equal(o attr.Value) bool {
	other, ok := o.(Spec14Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.BridgeDomain.Equal(other.BridgeDomain) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Egress4.Equal(other.Egress4) {
		return false
	}

	if !v.Ingress4.Equal(other.Ingress4) {
		return false
	}

	if !v.InterfaceSelector.Equal(other.InterfaceSelector) {
		return false
	}

	if !v.L2Mtu.Equal(other.L2Mtu) {
		return false
	}

	if !v.MacDuplicationDetectionAction.Equal(other.MacDuplicationDetectionAction) {
		return false
	}

	if !v.SplitHorizonGroup.Equal(other.SplitHorizonGroup) {
		return false
	}

	if !v.Uplink1.Equal(other.Uplink1) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	if !v.VlanPool.Equal(other.VlanPool) {
		return false
	}

	return true
}

func (v Spec14Value) Type(ctx context.Context) attr.Type {
	return Spec14Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Spec14Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"bridge_domain": basetypes.StringType{},
		"description":   basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: Egress4Value{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: Ingress4Value{}.AttributeTypes(ctx),
		},
		"interface_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"l2_mtu":                           basetypes.Int64Type{},
		"mac_duplication_detection_action": basetypes.StringType{},
		"split_horizon_group":              basetypes.StringType{},
		"uplink": basetypes.ObjectType{
			AttrTypes: Uplink1Value{}.AttributeTypes(ctx),
		},
		"vlan_id":   basetypes.StringType{},
		"vlan_pool": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Egress4Type{}

type Egress4Type struct {
	basetypes.ObjectType
}

func (t Egress4Type) Equal(o attr.Type) bool {
	other, ok := o.(Egress4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Egress4Type) String() string {
	return "Egress4Type"
}

func (t Egress4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Egress4Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgress4ValueNull() Egress4Value {
	return Egress4Value{
		state: attr.ValueStateNull,
	}
}

func NewEgress4ValueUnknown() Egress4Value {
	return Egress4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewEgress4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Egress4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Egress4Value Attribute Value",
				"While creating a Egress4Value value, a missing attribute value was detected. "+
					"A Egress4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Egress4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Egress4Value Attribute Type",
				"While creating a Egress4Value value, an invalid attribute value was detected. "+
					"A Egress4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Egress4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Egress4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Egress4Value Attribute Value",
				"While creating a Egress4Value value, an extra attribute value was detected. "+
					"A Egress4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Egress4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEgress4ValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewEgress4ValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewEgress4ValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewEgress4ValueUnknown(), diags
	}

	return Egress4Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgress4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Egress4Value {
	object, diags := NewEgress4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEgress4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Egress4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEgress4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEgress4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEgress4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEgress4ValueMust(Egress4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Egress4Type) ValueType(ctx context.Context) attr.Value {
	return Egress4Value{}
}

var _ basetypes.ObjectValuable = Egress4Value{}

type Egress4Value struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v Egress4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Egress4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Egress4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Egress4Value) String() string {
	return "Egress4Value"
}

func (v Egress4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v Egress4Value) Equal(o attr.Value) bool {
	other, ok := o.(Egress4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v Egress4Value) Type(ctx context.Context) attr.Type {
	return Egress4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Egress4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Ingress4Type{}

type Ingress4Type struct {
	basetypes.ObjectType
}

func (t Ingress4Type) Equal(o attr.Type) bool {
	other, ok := o.(Ingress4Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ingress4Type) String() string {
	return "Ingress4Type"
}

func (t Ingress4Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ingress4Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngress4ValueNull() Ingress4Value {
	return Ingress4Value{
		state: attr.ValueStateNull,
	}
}

func NewIngress4ValueUnknown() Ingress4Value {
	return Ingress4Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIngress4Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ingress4Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ingress4Value Attribute Value",
				"While creating a Ingress4Value value, a missing attribute value was detected. "+
					"A Ingress4Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ingress4Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ingress4Value Attribute Type",
				"While creating a Ingress4Value value, an invalid attribute value was detected. "+
					"A Ingress4Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ingress4Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ingress4Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ingress4Value Attribute Value",
				"While creating a Ingress4Value value, an extra attribute value was detected. "+
					"A Ingress4Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ingress4Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIngress4ValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewIngress4ValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewIngress4ValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewIngress4ValueUnknown(), diags
	}

	return Ingress4Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngress4ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ingress4Value {
	object, diags := NewIngress4Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIngress4ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ingress4Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIngress4ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIngress4ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIngress4ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIngress4ValueMust(Ingress4Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ingress4Type) ValueType(ctx context.Context) attr.Value {
	return Ingress4Value{}
}

var _ basetypes.ObjectValuable = Ingress4Value{}

type Ingress4Value struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v Ingress4Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ingress4Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ingress4Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ingress4Value) String() string {
	return "Ingress4Value"
}

func (v Ingress4Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v Ingress4Value) Equal(o attr.Value) bool {
	other, ok := o.(Ingress4Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v Ingress4Value) Type(ctx context.Context) attr.Type {
	return Ingress4Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ingress4Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Uplink1Type{}

type Uplink1Type struct {
	basetypes.ObjectType
}

func (t Uplink1Type) Equal(o attr.Type) bool {
	other, ok := o.(Uplink1Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Uplink1Type) String() string {
	return "Uplink1Type"
}

func (t Uplink1Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	egress5Attribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_5 is missing from object`)

		return nil, diags
	}

	egress5Val, ok := egress5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_5 expected to be basetypes.ObjectValue, was: %T`, egress5Attribute))
	}

	ingress5Attribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_5 is missing from object`)

		return nil, diags
	}

	ingress5Val, ok := ingress5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_5 expected to be basetypes.ObjectValue, was: %T`, ingress5Attribute))
	}

	uplinkSelectorAttribute, ok := attributes["uplink_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_selector is missing from object`)

		return nil, diags
	}

	uplinkSelectorVal, ok := uplinkSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_selector expected to be basetypes.ListValue, was: %T`, uplinkSelectorAttribute))
	}

	uplinkVlanIdAttribute, ok := attributes["uplink_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_vlan_id is missing from object`)

		return nil, diags
	}

	uplinkVlanIdVal, ok := uplinkVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_vlan_id expected to be basetypes.StringValue, was: %T`, uplinkVlanIdAttribute))
	}

	uplinkVlanPoolAttribute, ok := attributes["uplink_vlan_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_vlan_pool is missing from object`)

		return nil, diags
	}

	uplinkVlanPoolVal, ok := uplinkVlanPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_vlan_pool expected to be basetypes.StringValue, was: %T`, uplinkVlanPoolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Uplink1Value{
		Egress5:        egress5Val,
		Ingress5:       ingress5Val,
		UplinkSelector: uplinkSelectorVal,
		UplinkVlanId:   uplinkVlanIdVal,
		UplinkVlanPool: uplinkVlanPoolVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewUplink1ValueNull() Uplink1Value {
	return Uplink1Value{
		state: attr.ValueStateNull,
	}
}

func NewUplink1ValueUnknown() Uplink1Value {
	return Uplink1Value{
		state: attr.ValueStateUnknown,
	}
}

func NewUplink1Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Uplink1Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Uplink1Value Attribute Value",
				"While creating a Uplink1Value value, a missing attribute value was detected. "+
					"A Uplink1Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Uplink1Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Uplink1Value Attribute Type",
				"While creating a Uplink1Value value, an invalid attribute value was detected. "+
					"A Uplink1Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Uplink1Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Uplink1Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Uplink1Value Attribute Value",
				"While creating a Uplink1Value value, an extra attribute value was detected. "+
					"A Uplink1Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Uplink1Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewUplink1ValueUnknown(), diags
	}

	egress5Attribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress_5 is missing from object`)

		return NewUplink1ValueUnknown(), diags
	}

	egress5Val, ok := egress5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress_5 expected to be basetypes.ObjectValue, was: %T`, egress5Attribute))
	}

	ingress5Attribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress_5 is missing from object`)

		return NewUplink1ValueUnknown(), diags
	}

	ingress5Val, ok := ingress5Attribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress_5 expected to be basetypes.ObjectValue, was: %T`, ingress5Attribute))
	}

	uplinkSelectorAttribute, ok := attributes["uplink_selector"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_selector is missing from object`)

		return NewUplink1ValueUnknown(), diags
	}

	uplinkSelectorVal, ok := uplinkSelectorAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_selector expected to be basetypes.ListValue, was: %T`, uplinkSelectorAttribute))
	}

	uplinkVlanIdAttribute, ok := attributes["uplink_vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_vlan_id is missing from object`)

		return NewUplink1ValueUnknown(), diags
	}

	uplinkVlanIdVal, ok := uplinkVlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_vlan_id expected to be basetypes.StringValue, was: %T`, uplinkVlanIdAttribute))
	}

	uplinkVlanPoolAttribute, ok := attributes["uplink_vlan_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`uplink_vlan_pool is missing from object`)

		return NewUplink1ValueUnknown(), diags
	}

	uplinkVlanPoolVal, ok := uplinkVlanPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`uplink_vlan_pool expected to be basetypes.StringValue, was: %T`, uplinkVlanPoolAttribute))
	}

	if diags.HasError() {
		return NewUplink1ValueUnknown(), diags
	}

	return Uplink1Value{
		Egress5:        egress5Val,
		Ingress5:       ingress5Val,
		UplinkSelector: uplinkSelectorVal,
		UplinkVlanId:   uplinkVlanIdVal,
		UplinkVlanPool: uplinkVlanPoolVal,
		state:          attr.ValueStateKnown,
	}, diags
}

func NewUplink1ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Uplink1Value {
	object, diags := NewUplink1Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewUplink1ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Uplink1Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewUplink1ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewUplink1ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewUplink1ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewUplink1ValueMust(Uplink1Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Uplink1Type) ValueType(ctx context.Context) attr.Value {
	return Uplink1Value{}
}

var _ basetypes.ObjectValuable = Uplink1Value{}

type Uplink1Value struct {
	Egress5        basetypes.ObjectValue `tfsdk:"egress"`
	Ingress5       basetypes.ObjectValue `tfsdk:"ingress"`
	UplinkSelector basetypes.ListValue   `tfsdk:"uplink_selector"`
	UplinkVlanId   basetypes.StringValue `tfsdk:"uplink_vlan_id"`
	UplinkVlanPool basetypes.StringValue `tfsdk:"uplink_vlan_pool"`
	state          attr.ValueState
}

func (v Uplink1Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["egress"] = basetypes.ObjectType{
		AttrTypes: Egress5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ingress"] = basetypes.ObjectType{
		AttrTypes: Ingress5Value{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["uplink_selector"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["uplink_vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["uplink_vlan_pool"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Egress5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress"] = val

		val, err = v.Ingress5.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress"] = val

		val, err = v.UplinkSelector.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uplink_selector"] = val

		val, err = v.UplinkVlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uplink_vlan_id"] = val

		val, err = v.UplinkVlanPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["uplink_vlan_pool"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Uplink1Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Uplink1Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Uplink1Value) String() string {
	return "Uplink1Value"
}

func (v Uplink1Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var egress5 basetypes.ObjectValue

	if v.Egress5.IsNull() {
		egress5 = types.ObjectNull(
			Egress5Value{}.AttributeTypes(ctx),
		)
	}

	if v.Egress5.IsUnknown() {
		egress5 = types.ObjectUnknown(
			Egress5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Egress5.IsNull() && !v.Egress5.IsUnknown() {
		egress5 = types.ObjectValueMust(
			Egress5Value{}.AttributeTypes(ctx),
			v.Egress5.Attributes(),
		)
	}

	var ingress5 basetypes.ObjectValue

	if v.Ingress5.IsNull() {
		ingress5 = types.ObjectNull(
			Ingress5Value{}.AttributeTypes(ctx),
		)
	}

	if v.Ingress5.IsUnknown() {
		ingress5 = types.ObjectUnknown(
			Ingress5Value{}.AttributeTypes(ctx),
		)
	}

	if !v.Ingress5.IsNull() && !v.Ingress5.IsUnknown() {
		ingress5 = types.ObjectValueMust(
			Ingress5Value{}.AttributeTypes(ctx),
			v.Ingress5.Attributes(),
		)
	}

	var uplinkSelectorVal basetypes.ListValue
	switch {
	case v.UplinkSelector.IsUnknown():
		uplinkSelectorVal = types.ListUnknown(types.StringType)
	case v.UplinkSelector.IsNull():
		uplinkSelectorVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		uplinkSelectorVal, d = types.ListValue(types.StringType, v.UplinkSelector.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"egress": basetypes.ObjectType{
				AttrTypes: Egress5Value{}.AttributeTypes(ctx),
			},
			"ingress": basetypes.ObjectType{
				AttrTypes: Ingress5Value{}.AttributeTypes(ctx),
			},
			"uplink_selector": basetypes.ListType{
				ElemType: types.StringType,
			},
			"uplink_vlan_id":   basetypes.StringType{},
			"uplink_vlan_pool": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"egress": basetypes.ObjectType{
			AttrTypes: Egress5Value{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: Ingress5Value{}.AttributeTypes(ctx),
		},
		"uplink_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"uplink_vlan_id":   basetypes.StringType{},
		"uplink_vlan_pool": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"egress":           egress5,
			"ingress":          ingress5,
			"uplink_selector":  uplinkSelectorVal,
			"uplink_vlan_id":   v.UplinkVlanId,
			"uplink_vlan_pool": v.UplinkVlanPool,
		})

	return objVal, diags
}

func (v Uplink1Value) Equal(o attr.Value) bool {
	other, ok := o.(Uplink1Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Egress5.Equal(other.Egress5) {
		return false
	}

	if !v.Ingress5.Equal(other.Ingress5) {
		return false
	}

	if !v.UplinkSelector.Equal(other.UplinkSelector) {
		return false
	}

	if !v.UplinkVlanId.Equal(other.UplinkVlanId) {
		return false
	}

	if !v.UplinkVlanPool.Equal(other.UplinkVlanPool) {
		return false
	}

	return true
}

func (v Uplink1Value) Type(ctx context.Context) attr.Type {
	return Uplink1Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Uplink1Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"egress": basetypes.ObjectType{
			AttrTypes: Egress5Value{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: Ingress5Value{}.AttributeTypes(ctx),
		},
		"uplink_selector": basetypes.ListType{
			ElemType: types.StringType,
		},
		"uplink_vlan_id":   basetypes.StringType{},
		"uplink_vlan_pool": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = Egress5Type{}

type Egress5Type struct {
	basetypes.ObjectType
}

func (t Egress5Type) Equal(o attr.Type) bool {
	other, ok := o.(Egress5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Egress5Type) String() string {
	return "Egress5Type"
}

func (t Egress5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Egress5Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgress5ValueNull() Egress5Value {
	return Egress5Value{
		state: attr.ValueStateNull,
	}
}

func NewEgress5ValueUnknown() Egress5Value {
	return Egress5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewEgress5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Egress5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Egress5Value Attribute Value",
				"While creating a Egress5Value value, a missing attribute value was detected. "+
					"A Egress5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Egress5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Egress5Value Attribute Type",
				"While creating a Egress5Value value, an invalid attribute value was detected. "+
					"A Egress5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Egress5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Egress5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Egress5Value Attribute Value",
				"While creating a Egress5Value value, an extra attribute value was detected. "+
					"A Egress5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Egress5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEgress5ValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewEgress5ValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewEgress5ValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewEgress5ValueUnknown(), diags
	}

	return Egress5Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgress5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Egress5Value {
	object, diags := NewEgress5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEgress5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Egress5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEgress5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEgress5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEgress5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEgress5ValueMust(Egress5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Egress5Type) ValueType(ctx context.Context) attr.Value {
	return Egress5Value{}
}

var _ basetypes.ObjectValuable = Egress5Value{}

type Egress5Value struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v Egress5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Egress5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Egress5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Egress5Value) String() string {
	return "Egress5Value"
}

func (v Egress5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v Egress5Value) Equal(o attr.Value) bool {
	other, ok := o.(Egress5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v Egress5Value) Type(ctx context.Context) attr.Type {
	return Egress5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Egress5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Ingress5Type{}

type Ingress5Type struct {
	basetypes.ObjectType
}

func (t Ingress5Type) Equal(o attr.Type) bool {
	other, ok := o.(Ingress5Type)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ingress5Type) String() string {
	return "Ingress5Type"
}

func (t Ingress5Type) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ingress5Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngress5ValueNull() Ingress5Value {
	return Ingress5Value{
		state: attr.ValueStateNull,
	}
}

func NewIngress5ValueUnknown() Ingress5Value {
	return Ingress5Value{
		state: attr.ValueStateUnknown,
	}
}

func NewIngress5Value(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ingress5Value, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ingress5Value Attribute Value",
				"While creating a Ingress5Value value, a missing attribute value was detected. "+
					"A Ingress5Value must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ingress5Value Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ingress5Value Attribute Type",
				"While creating a Ingress5Value value, an invalid attribute value was detected. "+
					"A Ingress5Value must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ingress5Value Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ingress5Value Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ingress5Value Attribute Value",
				"While creating a Ingress5Value value, an extra attribute value was detected. "+
					"A Ingress5Value must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ingress5Value Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIngress5ValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewIngress5ValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewIngress5ValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewIngress5ValueUnknown(), diags
	}

	return Ingress5Value{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngress5ValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ingress5Value {
	object, diags := NewIngress5Value(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIngress5ValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ingress5Type) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIngress5ValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIngress5ValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIngress5ValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIngress5ValueMust(Ingress5Value{}.AttributeTypes(ctx), attributes), nil
}

func (t Ingress5Type) ValueType(ctx context.Context) attr.Value {
	return Ingress5Value{}
}

var _ basetypes.ObjectValuable = Ingress5Value{}

type Ingress5Value struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v Ingress5Value) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ingress5Value) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ingress5Value) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ingress5Value) String() string {
	return "Ingress5Value"
}

func (v Ingress5Value) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v Ingress5Value) Equal(o attr.Value) bool {
	other, ok := o.(Ingress5Value)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v Ingress5Value) Type(ctx context.Context) attr.Type {
	return Ingress5Type{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ingress5Value) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return nil, diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return nil, diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return nil, diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	numBgpPeersAttribute, ok := attributes["num_bgp_peers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_bgp_peers is missing from object`)

		return nil, diags
	}

	numBgpPeersVal, ok := numBgpPeersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_bgp_peers expected to be basetypes.Int64Value, was: %T`, numBgpPeersAttribute))
	}

	numBgpPeersOperDownAttribute, ok := attributes["num_bgp_peers_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_bgp_peers_oper_down is missing from object`)

		return nil, diags
	}

	numBgpPeersOperDownVal, ok := numBgpPeersOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_bgp_peers_oper_down expected to be basetypes.Int64Value, was: %T`, numBgpPeersOperDownAttribute))
	}

	numIrbInterfacesAttribute, ok := attributes["num_irb_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_irb_interfaces is missing from object`)

		return nil, diags
	}

	numIrbInterfacesVal, ok := numIrbInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_irb_interfaces expected to be basetypes.Int64Value, was: %T`, numIrbInterfacesAttribute))
	}

	numIrbInterfacesOperDownAttribute, ok := attributes["num_irb_interfaces_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_irb_interfaces_oper_down is missing from object`)

		return nil, diags
	}

	numIrbInterfacesOperDownVal, ok := numIrbInterfacesOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_irb_interfaces_oper_down expected to be basetypes.Int64Value, was: %T`, numIrbInterfacesOperDownAttribute))
	}

	numNodesAttribute, ok := attributes["num_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_nodes is missing from object`)

		return nil, diags
	}

	numNodesVal, ok := numNodesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_nodes expected to be basetypes.Int64Value, was: %T`, numNodesAttribute))
	}

	numOspfInterfacesAttribute, ok := attributes["num_ospf_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_ospf_interfaces is missing from object`)

		return nil, diags
	}

	numOspfInterfacesVal, ok := numOspfInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_ospf_interfaces expected to be basetypes.Int64Value, was: %T`, numOspfInterfacesAttribute))
	}

	numOspfInterfacesOperDownAttribute, ok := attributes["num_ospf_interfaces_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_ospf_interfaces_oper_down is missing from object`)

		return nil, diags
	}

	numOspfInterfacesOperDownVal, ok := numOspfInterfacesOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_ospf_interfaces_oper_down expected to be basetypes.Int64Value, was: %T`, numOspfInterfacesOperDownAttribute))
	}

	numRoutedInterfacesAttribute, ok := attributes["num_routed_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_routed_interfaces is missing from object`)

		return nil, diags
	}

	numRoutedInterfacesVal, ok := numRoutedInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_routed_interfaces expected to be basetypes.Int64Value, was: %T`, numRoutedInterfacesAttribute))
	}

	numRoutedInterfacesOperDownAttribute, ok := attributes["num_routed_interfaces_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_routed_interfaces_oper_down is missing from object`)

		return nil, diags
	}

	numRoutedInterfacesOperDownVal, ok := numRoutedInterfacesOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_routed_interfaces_oper_down expected to be basetypes.Int64Value, was: %T`, numRoutedInterfacesOperDownAttribute))
	}

	numSubInterfacesAttribute, ok := attributes["num_sub_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_sub_interfaces is missing from object`)

		return nil, diags
	}

	numSubInterfacesVal, ok := numSubInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_sub_interfaces expected to be basetypes.Int64Value, was: %T`, numSubInterfacesAttribute))
	}

	numSubInterfacesOperDownAttribute, ok := attributes["num_sub_interfaces_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_sub_interfaces_oper_down is missing from object`)

		return nil, diags
	}

	numSubInterfacesOperDownVal, ok := numSubInterfacesOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_sub_interfaces_oper_down expected to be basetypes.Int64Value, was: %T`, numSubInterfacesOperDownAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Health:                      healthVal,
		HealthScoreReason:           healthScoreReasonVal,
		LastChange:                  lastChangeVal,
		Nodes:                       nodesVal,
		NumBgpPeers:                 numBgpPeersVal,
		NumBgpPeersOperDown:         numBgpPeersOperDownVal,
		NumIrbInterfaces:            numIrbInterfacesVal,
		NumIrbInterfacesOperDown:    numIrbInterfacesOperDownVal,
		NumNodes:                    numNodesVal,
		NumOspfInterfaces:           numOspfInterfacesVal,
		NumOspfInterfacesOperDown:   numOspfInterfacesOperDownVal,
		NumRoutedInterfaces:         numRoutedInterfacesVal,
		NumRoutedInterfacesOperDown: numRoutedInterfacesOperDownVal,
		NumSubInterfaces:            numSubInterfacesVal,
		NumSubInterfacesOperDown:    numSubInterfacesOperDownVal,
		OperationalState:            operationalStateVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	numBgpPeersAttribute, ok := attributes["num_bgp_peers"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_bgp_peers is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numBgpPeersVal, ok := numBgpPeersAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_bgp_peers expected to be basetypes.Int64Value, was: %T`, numBgpPeersAttribute))
	}

	numBgpPeersOperDownAttribute, ok := attributes["num_bgp_peers_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_bgp_peers_oper_down is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numBgpPeersOperDownVal, ok := numBgpPeersOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_bgp_peers_oper_down expected to be basetypes.Int64Value, was: %T`, numBgpPeersOperDownAttribute))
	}

	numIrbInterfacesAttribute, ok := attributes["num_irb_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_irb_interfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numIrbInterfacesVal, ok := numIrbInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_irb_interfaces expected to be basetypes.Int64Value, was: %T`, numIrbInterfacesAttribute))
	}

	numIrbInterfacesOperDownAttribute, ok := attributes["num_irb_interfaces_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_irb_interfaces_oper_down is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numIrbInterfacesOperDownVal, ok := numIrbInterfacesOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_irb_interfaces_oper_down expected to be basetypes.Int64Value, was: %T`, numIrbInterfacesOperDownAttribute))
	}

	numNodesAttribute, ok := attributes["num_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_nodes is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numNodesVal, ok := numNodesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_nodes expected to be basetypes.Int64Value, was: %T`, numNodesAttribute))
	}

	numOspfInterfacesAttribute, ok := attributes["num_ospf_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_ospf_interfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numOspfInterfacesVal, ok := numOspfInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_ospf_interfaces expected to be basetypes.Int64Value, was: %T`, numOspfInterfacesAttribute))
	}

	numOspfInterfacesOperDownAttribute, ok := attributes["num_ospf_interfaces_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_ospf_interfaces_oper_down is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numOspfInterfacesOperDownVal, ok := numOspfInterfacesOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_ospf_interfaces_oper_down expected to be basetypes.Int64Value, was: %T`, numOspfInterfacesOperDownAttribute))
	}

	numRoutedInterfacesAttribute, ok := attributes["num_routed_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_routed_interfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numRoutedInterfacesVal, ok := numRoutedInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_routed_interfaces expected to be basetypes.Int64Value, was: %T`, numRoutedInterfacesAttribute))
	}

	numRoutedInterfacesOperDownAttribute, ok := attributes["num_routed_interfaces_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_routed_interfaces_oper_down is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numRoutedInterfacesOperDownVal, ok := numRoutedInterfacesOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_routed_interfaces_oper_down expected to be basetypes.Int64Value, was: %T`, numRoutedInterfacesOperDownAttribute))
	}

	numSubInterfacesAttribute, ok := attributes["num_sub_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_sub_interfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numSubInterfacesVal, ok := numSubInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_sub_interfaces expected to be basetypes.Int64Value, was: %T`, numSubInterfacesAttribute))
	}

	numSubInterfacesOperDownAttribute, ok := attributes["num_sub_interfaces_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_sub_interfaces_oper_down is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numSubInterfacesOperDownVal, ok := numSubInterfacesOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_sub_interfaces_oper_down expected to be basetypes.Int64Value, was: %T`, numSubInterfacesOperDownAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Health:                      healthVal,
		HealthScoreReason:           healthScoreReasonVal,
		LastChange:                  lastChangeVal,
		Nodes:                       nodesVal,
		NumBgpPeers:                 numBgpPeersVal,
		NumBgpPeersOperDown:         numBgpPeersOperDownVal,
		NumIrbInterfaces:            numIrbInterfacesVal,
		NumIrbInterfacesOperDown:    numIrbInterfacesOperDownVal,
		NumNodes:                    numNodesVal,
		NumOspfInterfaces:           numOspfInterfacesVal,
		NumOspfInterfacesOperDown:   numOspfInterfacesOperDownVal,
		NumRoutedInterfaces:         numRoutedInterfacesVal,
		NumRoutedInterfacesOperDown: numRoutedInterfacesOperDownVal,
		NumSubInterfaces:            numSubInterfacesVal,
		NumSubInterfacesOperDown:    numSubInterfacesOperDownVal,
		OperationalState:            operationalStateVal,
		state:                       attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Health                      basetypes.Int64Value  `tfsdk:"health"`
	HealthScoreReason           basetypes.StringValue `tfsdk:"health_score_reason"`
	LastChange                  basetypes.StringValue `tfsdk:"last_change"`
	Nodes                       basetypes.ListValue   `tfsdk:"nodes"`
	NumBgpPeers                 basetypes.Int64Value  `tfsdk:"num_bgp_peers"`
	NumBgpPeersOperDown         basetypes.Int64Value  `tfsdk:"num_bgp_peers_oper_down"`
	NumIrbInterfaces            basetypes.Int64Value  `tfsdk:"num_irb_interfaces"`
	NumIrbInterfacesOperDown    basetypes.Int64Value  `tfsdk:"num_irb_interfaces_oper_down"`
	NumNodes                    basetypes.Int64Value  `tfsdk:"num_nodes"`
	NumOspfInterfaces           basetypes.Int64Value  `tfsdk:"num_ospf_interfaces"`
	NumOspfInterfacesOperDown   basetypes.Int64Value  `tfsdk:"num_ospf_interfaces_oper_down"`
	NumRoutedInterfaces         basetypes.Int64Value  `tfsdk:"num_routed_interfaces"`
	NumRoutedInterfacesOperDown basetypes.Int64Value  `tfsdk:"num_routed_interfaces_oper_down"`
	NumSubInterfaces            basetypes.Int64Value  `tfsdk:"num_sub_interfaces"`
	NumSubInterfacesOperDown    basetypes.Int64Value  `tfsdk:"num_sub_interfaces_oper_down"`
	OperationalState            basetypes.StringValue `tfsdk:"operational_state"`
	state                       attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 16)

	var val tftypes.Value
	var err error

	attrTypes["health"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_score_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["nodes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["num_bgp_peers"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_bgp_peers_oper_down"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_irb_interfaces"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_irb_interfaces_oper_down"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_nodes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_ospf_interfaces"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_ospf_interfaces_oper_down"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_routed_interfaces"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_routed_interfaces_oper_down"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_sub_interfaces"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_sub_interfaces_oper_down"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 16)

		val, err = v.Health.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health"] = val

		val, err = v.HealthScoreReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_score_reason"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.Nodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nodes"] = val

		val, err = v.NumBgpPeers.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_bgp_peers"] = val

		val, err = v.NumBgpPeersOperDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_bgp_peers_oper_down"] = val

		val, err = v.NumIrbInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_irb_interfaces"] = val

		val, err = v.NumIrbInterfacesOperDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_irb_interfaces_oper_down"] = val

		val, err = v.NumNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_nodes"] = val

		val, err = v.NumOspfInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_ospf_interfaces"] = val

		val, err = v.NumOspfInterfacesOperDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_ospf_interfaces_oper_down"] = val

		val, err = v.NumRoutedInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_routed_interfaces"] = val

		val, err = v.NumRoutedInterfacesOperDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_routed_interfaces_oper_down"] = val

		val, err = v.NumSubInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_sub_interfaces"] = val

		val, err = v.NumSubInterfacesOperDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_sub_interfaces_oper_down"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var nodesVal basetypes.ListValue
	switch {
	case v.Nodes.IsUnknown():
		nodesVal = types.ListUnknown(types.StringType)
	case v.Nodes.IsNull():
		nodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodesVal, d = types.ListValue(types.StringType, v.Nodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"health":              basetypes.Int64Type{},
			"health_score_reason": basetypes.StringType{},
			"last_change":         basetypes.StringType{},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"num_bgp_peers":                   basetypes.Int64Type{},
			"num_bgp_peers_oper_down":         basetypes.Int64Type{},
			"num_irb_interfaces":              basetypes.Int64Type{},
			"num_irb_interfaces_oper_down":    basetypes.Int64Type{},
			"num_nodes":                       basetypes.Int64Type{},
			"num_ospf_interfaces":             basetypes.Int64Type{},
			"num_ospf_interfaces_oper_down":   basetypes.Int64Type{},
			"num_routed_interfaces":           basetypes.Int64Type{},
			"num_routed_interfaces_oper_down": basetypes.Int64Type{},
			"num_sub_interfaces":              basetypes.Int64Type{},
			"num_sub_interfaces_oper_down":    basetypes.Int64Type{},
			"operational_state":               basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"num_bgp_peers":                   basetypes.Int64Type{},
		"num_bgp_peers_oper_down":         basetypes.Int64Type{},
		"num_irb_interfaces":              basetypes.Int64Type{},
		"num_irb_interfaces_oper_down":    basetypes.Int64Type{},
		"num_nodes":                       basetypes.Int64Type{},
		"num_ospf_interfaces":             basetypes.Int64Type{},
		"num_ospf_interfaces_oper_down":   basetypes.Int64Type{},
		"num_routed_interfaces":           basetypes.Int64Type{},
		"num_routed_interfaces_oper_down": basetypes.Int64Type{},
		"num_sub_interfaces":              basetypes.Int64Type{},
		"num_sub_interfaces_oper_down":    basetypes.Int64Type{},
		"operational_state":               basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"health":                          v.Health,
			"health_score_reason":             v.HealthScoreReason,
			"last_change":                     v.LastChange,
			"nodes":                           nodesVal,
			"num_bgp_peers":                   v.NumBgpPeers,
			"num_bgp_peers_oper_down":         v.NumBgpPeersOperDown,
			"num_irb_interfaces":              v.NumIrbInterfaces,
			"num_irb_interfaces_oper_down":    v.NumIrbInterfacesOperDown,
			"num_nodes":                       v.NumNodes,
			"num_ospf_interfaces":             v.NumOspfInterfaces,
			"num_ospf_interfaces_oper_down":   v.NumOspfInterfacesOperDown,
			"num_routed_interfaces":           v.NumRoutedInterfaces,
			"num_routed_interfaces_oper_down": v.NumRoutedInterfacesOperDown,
			"num_sub_interfaces":              v.NumSubInterfaces,
			"num_sub_interfaces_oper_down":    v.NumSubInterfacesOperDown,
			"operational_state":               v.OperationalState,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Health.Equal(other.Health) {
		return false
	}

	if !v.HealthScoreReason.Equal(other.HealthScoreReason) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.Nodes.Equal(other.Nodes) {
		return false
	}

	if !v.NumBgpPeers.Equal(other.NumBgpPeers) {
		return false
	}

	if !v.NumBgpPeersOperDown.Equal(other.NumBgpPeersOperDown) {
		return false
	}

	if !v.NumIrbInterfaces.Equal(other.NumIrbInterfaces) {
		return false
	}

	if !v.NumIrbInterfacesOperDown.Equal(other.NumIrbInterfacesOperDown) {
		return false
	}

	if !v.NumNodes.Equal(other.NumNodes) {
		return false
	}

	if !v.NumOspfInterfaces.Equal(other.NumOspfInterfaces) {
		return false
	}

	if !v.NumOspfInterfacesOperDown.Equal(other.NumOspfInterfacesOperDown) {
		return false
	}

	if !v.NumRoutedInterfaces.Equal(other.NumRoutedInterfaces) {
		return false
	}

	if !v.NumRoutedInterfacesOperDown.Equal(other.NumRoutedInterfacesOperDown) {
		return false
	}

	if !v.NumSubInterfaces.Equal(other.NumSubInterfaces) {
		return false
	}

	if !v.NumSubInterfacesOperDown.Equal(other.NumSubInterfacesOperDown) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"num_bgp_peers":                   basetypes.Int64Type{},
		"num_bgp_peers_oper_down":         basetypes.Int64Type{},
		"num_irb_interfaces":              basetypes.Int64Type{},
		"num_irb_interfaces_oper_down":    basetypes.Int64Type{},
		"num_nodes":                       basetypes.Int64Type{},
		"num_ospf_interfaces":             basetypes.Int64Type{},
		"num_ospf_interfaces_oper_down":   basetypes.Int64Type{},
		"num_routed_interfaces":           basetypes.Int64Type{},
		"num_routed_interfaces_oper_down": basetypes.Int64Type{},
		"num_sub_interfaces":              basetypes.Int64Type{},
		"num_sub_interfaces_oper_down":    basetypes.Int64Type{},
		"operational_state":               basetypes.StringType{},
	}
}
