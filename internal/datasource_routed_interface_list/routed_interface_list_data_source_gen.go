// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_routed_interface_list

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func RoutedInterfaceListDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"fields": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
				MarkdownDescription: "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
			},
			"filter": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "an EQL \"where\" expression that will be used to filter the set of resources returned.",
				MarkdownDescription: "an EQL \"where\" expression that will be used to filter the set of resources returned.",
			},
			"items": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"api_version": schema.StringAttribute{
							Computed: true,
						},
						"kind": schema.StringAttribute{
							Computed: true,
						},
						"metadata": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"labels": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"namespace": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: MetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: MetadataValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"spec": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"arp_timeout": schema.Int64Attribute{
									Optional:            true,
									Description:         "Duration of time that dynamic ARP entries remain in the ARP cache before they expire.",
									MarkdownDescription: "Duration of time that dynamic ARP entries remain in the ARP cache before they expire.",
								},
								"bfd": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"desired_min_transmit_int": schema.Int64Attribute{
											Optional:            true,
											Description:         "The minimum interval in microseconds between transmission of BFD control packets.",
											MarkdownDescription: "The minimum interval in microseconds between transmission of BFD control packets.",
										},
										"detection_multiplier": schema.Int64Attribute{
											Optional:            true,
											Description:         "The number of packets that must be missed to declare this session as down.",
											MarkdownDescription: "The number of packets that must be missed to declare this session as down.",
										},
										"enabled": schema.BoolAttribute{
											Optional:            true,
											Description:         "Enables Biforward Detection.",
											MarkdownDescription: "Enables Biforward Detection.",
										},
										"min_echo_receive_interval": schema.Int64Attribute{
											Optional:            true,
											Description:         "The minimum interval between echo packets the local node can receive.",
											MarkdownDescription: "The minimum interval between echo packets the local node can receive.",
										},
										"required_min_receive": schema.Int64Attribute{
											Optional:            true,
											Description:         "The minimum interval in microseconds between received BFD control packets that this system should support.",
											MarkdownDescription: "The minimum interval in microseconds between received BFD control packets that this system should support.",
										},
										"ttl": schema.Int64Attribute{
											Optional:            true,
											Description:         "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not appllicable to single-hop BFD sessions.",
											MarkdownDescription: "Sets custom IP TTL or Hop Limit for multi-hop BFD sessions packets. Not appllicable to single-hop BFD sessions.",
										},
									},
									CustomType: BfdType{
										ObjectType: types.ObjectType{
											AttrTypes: BfdValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Enables BFD on the RoutedInterface.",
									MarkdownDescription: "Enables BFD on the RoutedInterface.",
								},
								"description": schema.StringAttribute{
									Optional:            true,
									Description:         "The description of the RoutedInterface.",
									MarkdownDescription: "The description of the RoutedInterface.",
								},
								"egress": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"filters": schema.ListAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Description:         "List of Filter references to use at egress.",
											MarkdownDescription: "List of Filter references to use at egress.",
										},
										"qos_policy": schema.ListAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Description:         "List of QoS Egress policy references to use at egress.",
											MarkdownDescription: "List of QoS Egress policy references to use at egress.",
										},
									},
									CustomType: EgressType{
										ObjectType: types.ObjectType{
											AttrTypes: EgressValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Manages actions on traffic at Egress.",
									MarkdownDescription: "Manages actions on traffic at Egress.",
								},
								"ingress": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"filters": schema.ListAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Description:         "List of Filter references to use at ingress.",
											MarkdownDescription: "List of Filter references to use at ingress.",
										},
										"qos_policy": schema.ListAttribute{
											ElementType:         types.StringType,
											Optional:            true,
											Description:         "List of QoS Ingress policy references to use at ingress.",
											MarkdownDescription: "List of QoS Ingress policy references to use at ingress.",
										},
									},
									CustomType: IngressType{
										ObjectType: types.ObjectType{
											AttrTypes: IngressValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Manages actions on traffic at Ingress.",
									MarkdownDescription: "Manages actions on traffic at Ingress.",
								},
								"interface": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to an Interface to use for attachment.",
									MarkdownDescription: "Reference to an Interface to use for attachment.",
								},
								"ip_mtu": schema.Int64Attribute{
									Optional:            true,
									Description:         "IP MTU for the RoutedInterface.",
									MarkdownDescription: "IP MTU for the RoutedInterface.",
								},
								"ipv4addresses": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"ip_prefix": schema.StringAttribute{
												Optional:            true,
												Description:         "Address and mask to use",
												MarkdownDescription: "Address and mask to use",
											},
											"primary": schema.BoolAttribute{
												Optional:            true,
												Description:         "Indicates which address to use as primary for broadcast",
												MarkdownDescription: "Indicates which address to use as primary for broadcast",
											},
										},
										CustomType: Ipv4addressesType{
											ObjectType: types.ObjectType{
												AttrTypes: Ipv4addressesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "List of IPv4 addresses in IP/mask form, e.g., 192.168.0.1/24.",
									MarkdownDescription: "List of IPv4 addresses in IP/mask form, e.g., 192.168.0.1/24.",
								},
								"ipv4parameters": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"directed_broadcast": schema.BoolAttribute{
											Optional:            true,
											Description:         "Allow receiving and forwarding of directed broadcast packets. Enabled when set to true.",
											MarkdownDescription: "Allow receiving and forwarding of directed broadcast packets. Enabled when set to true.",
										},
									},
									CustomType: Ipv4parametersType{
										ObjectType: types.ObjectType{
											AttrTypes: Ipv4parametersValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
								},
								"ipv6addresses": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"ip_prefix": schema.StringAttribute{
												Optional:            true,
												Description:         "Address and mask to use",
												MarkdownDescription: "Address and mask to use",
											},
											"primary": schema.BoolAttribute{
												Optional:            true,
												Description:         "Indicates which address to use as primary for broadcast",
												MarkdownDescription: "Indicates which address to use as primary for broadcast",
											},
										},
										CustomType: Ipv6addressesType{
											ObjectType: types.ObjectType{
												AttrTypes: Ipv6addressesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Description:         "List of IPv6 addresses in IP/mask form, e.g., fc00::1/120.",
									MarkdownDescription: "List of IPv6 addresses in IP/mask form, e.g., fc00::1/120.",
								},
								"ipv6router_advertisement": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"current_hop_limit": schema.Int64Attribute{
											Optional:            true,
											Description:         "The current hop limit to advertise in the router advertisement messages.",
											MarkdownDescription: "The current hop limit to advertise in the router advertisement messages.",
										},
										"enabled": schema.BoolAttribute{
											Optional:            true,
											Description:         "Enable or disable IPv6 router advertisements.",
											MarkdownDescription: "Enable or disable IPv6 router advertisements.",
										},
										"ip_mtu": schema.Int64Attribute{
											Optional:            true,
											Description:         "The IP MTU to advertise in the router advertisement messages.",
											MarkdownDescription: "The IP MTU to advertise in the router advertisement messages.",
										},
										"managed_configuration_flag": schema.BoolAttribute{
											Optional:            true,
											Description:         "Enable DHCPv6 for address configuration (M-bit).",
											MarkdownDescription: "Enable DHCPv6 for address configuration (M-bit).",
										},
										"max_advertisement_interval": schema.Int64Attribute{
											Optional:            true,
											Description:         "Maximum time between router advertisements (in seconds).",
											MarkdownDescription: "Maximum time between router advertisements (in seconds).",
										},
										"min_advertisement_interval": schema.Int64Attribute{
											Optional:            true,
											Description:         "Minimum time between router advertisements (in seconds).",
											MarkdownDescription: "Minimum time between router advertisements (in seconds).",
										},
										"other_configuration_flag": schema.BoolAttribute{
											Optional:            true,
											Description:         "Enable DHCPv6 for other configuration (O-bit).",
											MarkdownDescription: "Enable DHCPv6 for other configuration (O-bit).",
										},
										"prefixes": schema.ListNestedAttribute{
											NestedObject: schema.NestedAttributeObject{
												Attributes: map[string]schema.Attribute{
													"autonomous_flag": schema.BoolAttribute{
														Optional:            true,
														Description:         "When this is set in the prefix information option hosts can use the prefix for stateless address autoconfiguration (SLAAC).",
														MarkdownDescription: "When this is set in the prefix information option hosts can use the prefix for stateless address autoconfiguration (SLAAC).",
													},
													"on_link_flag": schema.BoolAttribute{
														Optional:            true,
														Description:         "When this is set in the prefix information option hosts can use the prefix for on-link determination.",
														MarkdownDescription: "When this is set in the prefix information option hosts can use the prefix for on-link determination.",
													},
													"preferred_lifetime": schema.Int64Attribute{
														Optional:            true,
														Description:         "The length of time in seconds (relative to the time the packet is sent) that addresses generated from the prefix via stateless address autoconfiguration remain preferred.",
														MarkdownDescription: "The length of time in seconds (relative to the time the packet is sent) that addresses generated from the prefix via stateless address autoconfiguration remain preferred.",
													},
													"prefix": schema.StringAttribute{
														Optional:            true,
														Description:         "An IPv6 global unicast address prefix.",
														MarkdownDescription: "An IPv6 global unicast address prefix.",
													},
													"valid_lifetime": schema.Int64Attribute{
														Optional:            true,
														Description:         "The length of time in seconds (relative to the time the packet is sent) that the prefix is valid for the purpose of on-link determination.",
														MarkdownDescription: "The length of time in seconds (relative to the time the packet is sent) that the prefix is valid for the purpose of on-link determination.",
													},
												},
												CustomType: PrefixesType{
													ObjectType: types.ObjectType{
														AttrTypes: PrefixesValue{}.AttributeTypes(ctx),
													},
												},
											},
											Optional:            true,
											Description:         "IPv6 prefixes to advertise in router advertisements.",
											MarkdownDescription: "IPv6 prefixes to advertise in router advertisements.",
										},
										"reachable_time": schema.Int64Attribute{
											Optional:            true,
											Description:         "Time in milliseconds for Neighbor Unreachability Detection.",
											MarkdownDescription: "Time in milliseconds for Neighbor Unreachability Detection.",
										},
										"retransmit_time": schema.Int64Attribute{
											Optional:            true,
											Description:         "Time in milliseconds between retransmitted NS messages.",
											MarkdownDescription: "Time in milliseconds between retransmitted NS messages.",
										},
										"router_lifetime": schema.Int64Attribute{
											Optional:            true,
											Description:         "Router lifetime in seconds for default gateway.",
											MarkdownDescription: "Router lifetime in seconds for default gateway.",
										},
									},
									CustomType: Ipv6routerAdvertisementType{
										ObjectType: types.ObjectType{
											AttrTypes: Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
										},
									},
									Optional: true,
								},
								"l3proxy_arpnd": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"proxy_arp": schema.BoolAttribute{
											Optional:            true,
											Description:         "Select whether Proxy ARP should be enabled.",
											MarkdownDescription: "Select whether Proxy ARP should be enabled.",
										},
										"proxy_nd": schema.BoolAttribute{
											Optional:            true,
											Description:         "Select whether Proxy ND should be enabled.",
											MarkdownDescription: "Select whether Proxy ND should be enabled.",
										},
									},
									CustomType: L3proxyArpndType{
										ObjectType: types.ObjectType{
											AttrTypes: L3proxyArpndValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "L3 Proxy ARP and ND configuration.",
									MarkdownDescription: "L3 Proxy ARP and ND configuration.",
								},
								"learn_unsolicited": schema.StringAttribute{
									Optional:            true,
									Description:         "Enable or disable learning of unsolicited ARPs.",
									MarkdownDescription: "Enable or disable learning of unsolicited ARPs.",
								},
								"router": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to a Router.",
									MarkdownDescription: "Reference to a Router.",
								},
								"unnumbered": schema.StringAttribute{
									Optional:            true,
									Description:         "Enables the use of unnumbered interfaces on the IRBInterface.  If IPv6 is specified, no IP address are configured on the sub-interface and only the link local address will be used.  If any IP addresses are specified for either IPv4 or IPv6 that will take precedence and IPs will be assigned to the interfaces. (Deprecated, Use IPv6RouterAdvertisement)",
									MarkdownDescription: "Enables the use of unnumbered interfaces on the IRBInterface.  If IPv6 is specified, no IP address are configured on the sub-interface and only the link local address will be used.  If any IP addresses are specified for either IPv4 or IPv6 that will take precedence and IPs will be assigned to the interfaces. (Deprecated, Use IPv6RouterAdvertisement)",
								},
								"vlan_id": schema.StringAttribute{
									Optional:            true,
									Description:         "Single value between 1-4094 support, ranges supported in the format x-y,x-y, or the special keyword null, any, untagged or pool for auto allocation.",
									MarkdownDescription: "Single value between 1-4094 support, ranges supported in the format x-y,x-y, or the special keyword null, any, untagged or pool for auto allocation.",
								},
								"vlan_pool": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to a VLAN pool to use for allocations.",
									MarkdownDescription: "Reference to a VLAN pool to use for allocations.",
								},
							},
							CustomType: SpecType{
								ObjectType: types.ObjectType{
									AttrTypes: SpecValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "The RoutedInterface enables the configuration and management of Layer 3 interfaces for routing traffic between different networks. This resource allows for specifying an underlying Interface and Router, configuring VLAN IDs, and setting the IP MTU. It also supports the learning of unsolicited ARPs, defining both IPv4 and IPv6 addresses, and enabling unnumbered interfaces. Advanced features such as BFD configuration, Proxy ARP/ND, and ARP timeout settings are included to ensure robust and efficient routing.",
							MarkdownDescription: "The RoutedInterface enables the configuration and management of Layer 3 interfaces for routing traffic between different networks. This resource allows for specifying an underlying Interface and Router, configuring VLAN IDs, and setting the IP MTU. It also supports the learning of unsolicited ARPs, defining both IPv4 and IPv6 addresses, and enabling unnumbered interfaces. Advanced features such as BFD configuration, Proxy ARP/ND, and ARP timeout settings are included to ensure robust and efficient routing.",
						},
						"status": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"health": schema.Int64Attribute{
									Computed:            true,
									Description:         "Indicates the health score of the RoutedInterface.",
									MarkdownDescription: "Indicates the health score of the RoutedInterface.",
								},
								"health_score_reason": schema.StringAttribute{
									Computed:            true,
									Description:         "Indicates the reason for the health score.",
									MarkdownDescription: "Indicates the reason for the health score.",
								},
								"interfaces": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"enabled": schema.BoolAttribute{
												Computed:            true,
												Description:         "The administrative status of the SubInterface.",
												MarkdownDescription: "The administrative status of the SubInterface.",
											},
											"interface": schema.StringAttribute{
												Computed:            true,
												Description:         "Normalized interface name.",
												MarkdownDescription: "Normalized interface name.",
											},
											"interface_resource": schema.StringAttribute{
												Computed:            true,
												Description:         "Eda interface resource.",
												MarkdownDescription: "Eda interface resource.",
											},
											"last_change": schema.StringAttribute{
												Computed:            true,
												Description:         "Indicates when this SubInterface last changed state.",
												MarkdownDescription: "Indicates when this SubInterface last changed state.",
											},
											"node": schema.StringAttribute{
												Computed:            true,
												Description:         "Reference to Node object.",
												MarkdownDescription: "Reference to Node object.",
											},
											"node_interface": schema.StringAttribute{
												Computed:            true,
												Description:         "Node specific interface name.",
												MarkdownDescription: "Node specific interface name.",
											},
											"operating_system": schema.StringAttribute{
												Computed:            true,
												Description:         "Operating System of the Node.",
												MarkdownDescription: "Operating System of the Node.",
											},
											"operational_state": schema.StringAttribute{
												Computed:            true,
												Description:         "Indicates the current operational state of the SubInterface.",
												MarkdownDescription: "Indicates the current operational state of the SubInterface.",
											},
											"sub_interface_index": schema.Int64Attribute{
												Computed:            true,
												Description:         "Index allocated to the subinterface on the associated interface for the given VLAN.",
												MarkdownDescription: "Index allocated to the subinterface on the associated interface for the given VLAN.",
											},
											"vlan_id": schema.StringAttribute{
												Computed:            true,
												Description:         "vlan assigned to this subinterface.",
												MarkdownDescription: "vlan assigned to this subinterface.",
											},
										},
										CustomType: InterfacesType{
											ObjectType: types.ObjectType{
												AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
											},
										},
									},
									Computed:            true,
									Description:         "Sub-interface status within the RoutedInterface.",
									MarkdownDescription: "Sub-interface status within the RoutedInterface.",
								},
								"last_change": schema.StringAttribute{
									Computed:            true,
									Description:         "The time when the state of the resource last changed.",
									MarkdownDescription: "The time when the state of the resource last changed.",
								},
								"operational_state": schema.StringAttribute{
									Computed:            true,
									Description:         "Operational state of the RoutedInterface.",
									MarkdownDescription: "Operational state of the RoutedInterface.",
								},
							},
							CustomType: StatusType{
								ObjectType: types.ObjectType{
									AttrTypes: StatusValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "RoutedInterfaceStatus defines the observed state of RoutedInterface",
							MarkdownDescription: "RoutedInterfaceStatus defines the observed state of RoutedInterface",
						},
					},
					CustomType: ItemsType{
						ObjectType: types.ObjectType{
							AttrTypes: ItemsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"labelselector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a label selector string to filter the results based on CR labels",
				MarkdownDescription: "a label selector string to filter the results based on CR labels",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
		},
	}
}

type RoutedInterfaceListModel struct {
	ApiVersion    types.String `tfsdk:"api_version"`
	Fields        types.String `tfsdk:"fields"`
	Filter        types.String `tfsdk:"filter"`
	Items         types.List   `tfsdk:"items"`
	Kind          types.String `tfsdk:"kind"`
	Labelselector types.String `tfsdk:"labelselector"`
	Namespace     types.String `tfsdk:"namespace"`
}

var _ basetypes.ObjectTypable = ItemsType{}

type ItemsType struct {
	basetypes.ObjectType
}

func (t ItemsType) Equal(o attr.Type) bool {
	other, ok := o.(ItemsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ItemsType) String() string {
	return "ItemsType"
}

func (t ItemsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return nil, diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return nil, diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ItemsValue{
		ApiVersion: apiVersionVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueNull() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateNull,
	}
}

func NewItemsValueUnknown() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewItemsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ItemsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ItemsValue Attribute Value",
				"While creating a ItemsValue value, a missing attribute value was detected. "+
					"A ItemsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ItemsValue Attribute Type",
				"While creating a ItemsValue value, an invalid attribute value was detected. "+
					"A ItemsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ItemsValue Attribute Value",
				"While creating a ItemsValue value, an extra attribute value was detected. "+
					"A ItemsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ItemsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	return ItemsValue{
		ApiVersion: apiVersionVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ItemsValue {
	object, diags := NewItemsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewItemsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ItemsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewItemsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewItemsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewItemsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewItemsValueMust(ItemsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ItemsType) ValueType(ctx context.Context) attr.Value {
	return ItemsValue{}
}

var _ basetypes.ObjectValuable = ItemsValue{}

type ItemsValue struct {
	ApiVersion basetypes.StringValue `tfsdk:"api_version"`
	Kind       basetypes.StringValue `tfsdk:"kind"`
	Metadata   basetypes.ObjectValue `tfsdk:"metadata"`
	Spec       basetypes.ObjectValue `tfsdk:"spec"`
	Status     basetypes.ObjectValue `tfsdk:"status"`
	state      attr.ValueState
}

func (v ItemsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["api_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ObjectType{
		AttrTypes: MetadataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: SpecValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.ObjectType{
		AttrTypes: StatusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ApiVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_version"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Spec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ItemsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ItemsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ItemsValue) String() string {
	return "ItemsValue"
}

func (v ItemsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var metadata basetypes.ObjectValue

	if v.Metadata.IsNull() {
		metadata = types.ObjectNull(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ObjectUnknown(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Metadata.IsNull() && !v.Metadata.IsUnknown() {
		metadata = types.ObjectValueMust(
			MetadataValue{}.AttributeTypes(ctx),
			v.Metadata.Attributes(),
		)
	}

	var spec basetypes.ObjectValue

	if v.Spec.IsNull() {
		spec = types.ObjectNull(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if v.Spec.IsUnknown() {
		spec = types.ObjectUnknown(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec.IsNull() && !v.Spec.IsUnknown() {
		spec = types.ObjectValueMust(
			SpecValue{}.AttributeTypes(ctx),
			v.Spec.Attributes(),
		)
	}

	var status basetypes.ObjectValue

	if v.Status.IsNull() {
		status = types.ObjectNull(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if v.Status.IsUnknown() {
		status = types.ObjectUnknown(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Status.IsNull() && !v.Status.IsUnknown() {
		status = types.ObjectValueMust(
			StatusValue{}.AttributeTypes(ctx),
			v.Status.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"api_version": basetypes.StringType{},
		"kind":        basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_version": v.ApiVersion,
			"kind":        v.Kind,
			"metadata":    metadata,
			"spec":        spec,
			"status":      status,
		})

	return objVal, diags
}

func (v ItemsValue) Equal(o attr.Value) bool {
	other, ok := o.(ItemsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiVersion.Equal(other.ApiVersion) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Spec.Equal(other.Spec) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ItemsValue) Type(ctx context.Context) attr.Type {
	return ItemsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ItemsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_version": basetypes.StringType{},
		"kind":        basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	arpTimeoutAttribute, ok := attributes["arp_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_timeout is missing from object`)

		return nil, diags
	}

	arpTimeoutVal, ok := arpTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_timeout expected to be basetypes.Int64Value, was: %T`, arpTimeoutAttribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return nil, diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egressAttribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress is missing from object`)

		return nil, diags
	}

	egressVal, ok := egressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress expected to be basetypes.ObjectValue, was: %T`, egressAttribute))
	}

	ingressAttribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress is missing from object`)

		return nil, diags
	}

	ingressVal, ok := ingressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress expected to be basetypes.ObjectValue, was: %T`, ingressAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return nil, diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	ipv4addressesAttribute, ok := attributes["ipv4addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4addresses is missing from object`)

		return nil, diags
	}

	ipv4addressesVal, ok := ipv4addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4addresses expected to be basetypes.ListValue, was: %T`, ipv4addressesAttribute))
	}

	ipv4parametersAttribute, ok := attributes["ipv4parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4parameters is missing from object`)

		return nil, diags
	}

	ipv4parametersVal, ok := ipv4parametersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4parameters expected to be basetypes.ObjectValue, was: %T`, ipv4parametersAttribute))
	}

	ipv6addressesAttribute, ok := attributes["ipv6addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6addresses is missing from object`)

		return nil, diags
	}

	ipv6addressesVal, ok := ipv6addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6addresses expected to be basetypes.ListValue, was: %T`, ipv6addressesAttribute))
	}

	ipv6routerAdvertisementAttribute, ok := attributes["ipv6router_advertisement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6router_advertisement is missing from object`)

		return nil, diags
	}

	ipv6routerAdvertisementVal, ok := ipv6routerAdvertisementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6router_advertisement expected to be basetypes.ObjectValue, was: %T`, ipv6routerAdvertisementAttribute))
	}

	l3proxyArpndAttribute, ok := attributes["l3proxy_arpnd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3proxy_arpnd is missing from object`)

		return nil, diags
	}

	l3proxyArpndVal, ok := l3proxyArpndAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3proxy_arpnd expected to be basetypes.ObjectValue, was: %T`, l3proxyArpndAttribute))
	}

	learnUnsolicitedAttribute, ok := attributes["learn_unsolicited"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`learn_unsolicited is missing from object`)

		return nil, diags
	}

	learnUnsolicitedVal, ok := learnUnsolicitedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`learn_unsolicited expected to be basetypes.StringValue, was: %T`, learnUnsolicitedAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return nil, diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return nil, diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	vlanPoolAttribute, ok := attributes["vlan_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_pool is missing from object`)

		return nil, diags
	}

	vlanPoolVal, ok := vlanPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_pool expected to be basetypes.StringValue, was: %T`, vlanPoolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		ArpTimeout:              arpTimeoutVal,
		Bfd:                     bfdVal,
		Description:             descriptionVal,
		Egress:                  egressVal,
		Ingress:                 ingressVal,
		Interface:               interfaceVal,
		IpMtu:                   ipMtuVal,
		Ipv4addresses:           ipv4addressesVal,
		Ipv4parameters:          ipv4parametersVal,
		Ipv6addresses:           ipv6addressesVal,
		Ipv6routerAdvertisement: ipv6routerAdvertisementVal,
		L3proxyArpnd:            l3proxyArpndVal,
		LearnUnsolicited:        learnUnsolicitedVal,
		Router:                  routerVal,
		Unnumbered:              unnumberedVal,
		VlanId:                  vlanIdVal,
		VlanPool:                vlanPoolVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	arpTimeoutAttribute, ok := attributes["arp_timeout"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`arp_timeout is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	arpTimeoutVal, ok := arpTimeoutAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`arp_timeout expected to be basetypes.Int64Value, was: %T`, arpTimeoutAttribute))
	}

	bfdAttribute, ok := attributes["bfd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`bfd is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	bfdVal, ok := bfdAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`bfd expected to be basetypes.ObjectValue, was: %T`, bfdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	egressAttribute, ok := attributes["egress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`egress is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	egressVal, ok := egressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`egress expected to be basetypes.ObjectValue, was: %T`, egressAttribute))
	}

	ingressAttribute, ok := attributes["ingress"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ingress is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ingressVal, ok := ingressAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ingress expected to be basetypes.ObjectValue, was: %T`, ingressAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	ipv4addressesAttribute, ok := attributes["ipv4addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4addresses is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipv4addressesVal, ok := ipv4addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4addresses expected to be basetypes.ListValue, was: %T`, ipv4addressesAttribute))
	}

	ipv4parametersAttribute, ok := attributes["ipv4parameters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv4parameters is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipv4parametersVal, ok := ipv4parametersAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv4parameters expected to be basetypes.ObjectValue, was: %T`, ipv4parametersAttribute))
	}

	ipv6addressesAttribute, ok := attributes["ipv6addresses"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6addresses is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipv6addressesVal, ok := ipv6addressesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6addresses expected to be basetypes.ListValue, was: %T`, ipv6addressesAttribute))
	}

	ipv6routerAdvertisementAttribute, ok := attributes["ipv6router_advertisement"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ipv6router_advertisement is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	ipv6routerAdvertisementVal, ok := ipv6routerAdvertisementAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ipv6router_advertisement expected to be basetypes.ObjectValue, was: %T`, ipv6routerAdvertisementAttribute))
	}

	l3proxyArpndAttribute, ok := attributes["l3proxy_arpnd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l3proxy_arpnd is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	l3proxyArpndVal, ok := l3proxyArpndAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l3proxy_arpnd expected to be basetypes.ObjectValue, was: %T`, l3proxyArpndAttribute))
	}

	learnUnsolicitedAttribute, ok := attributes["learn_unsolicited"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`learn_unsolicited is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	learnUnsolicitedVal, ok := learnUnsolicitedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`learn_unsolicited expected to be basetypes.StringValue, was: %T`, learnUnsolicitedAttribute))
	}

	routerAttribute, ok := attributes["router"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	routerVal, ok := routerAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router expected to be basetypes.StringValue, was: %T`, routerAttribute))
	}

	unnumberedAttribute, ok := attributes["unnumbered"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`unnumbered is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	unnumberedVal, ok := unnumberedAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`unnumbered expected to be basetypes.StringValue, was: %T`, unnumberedAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	vlanPoolAttribute, ok := attributes["vlan_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_pool is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	vlanPoolVal, ok := vlanPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_pool expected to be basetypes.StringValue, was: %T`, vlanPoolAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		ArpTimeout:              arpTimeoutVal,
		Bfd:                     bfdVal,
		Description:             descriptionVal,
		Egress:                  egressVal,
		Ingress:                 ingressVal,
		Interface:               interfaceVal,
		IpMtu:                   ipMtuVal,
		Ipv4addresses:           ipv4addressesVal,
		Ipv4parameters:          ipv4parametersVal,
		Ipv6addresses:           ipv6addressesVal,
		Ipv6routerAdvertisement: ipv6routerAdvertisementVal,
		L3proxyArpnd:            l3proxyArpndVal,
		LearnUnsolicited:        learnUnsolicitedVal,
		Router:                  routerVal,
		Unnumbered:              unnumberedVal,
		VlanId:                  vlanIdVal,
		VlanPool:                vlanPoolVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	ArpTimeout              basetypes.Int64Value  `tfsdk:"arp_timeout"`
	Bfd                     basetypes.ObjectValue `tfsdk:"bfd"`
	Description             basetypes.StringValue `tfsdk:"description"`
	Egress                  basetypes.ObjectValue `tfsdk:"egress"`
	Ingress                 basetypes.ObjectValue `tfsdk:"ingress"`
	Interface               basetypes.StringValue `tfsdk:"interface"`
	IpMtu                   basetypes.Int64Value  `tfsdk:"ip_mtu"`
	Ipv4addresses           basetypes.ListValue   `tfsdk:"ipv4addresses"`
	Ipv4parameters          basetypes.ObjectValue `tfsdk:"ipv4parameters"`
	Ipv6addresses           basetypes.ListValue   `tfsdk:"ipv6addresses"`
	Ipv6routerAdvertisement basetypes.ObjectValue `tfsdk:"ipv6router_advertisement"`
	L3proxyArpnd            basetypes.ObjectValue `tfsdk:"l3proxy_arpnd"`
	LearnUnsolicited        basetypes.StringValue `tfsdk:"learn_unsolicited"`
	Router                  basetypes.StringValue `tfsdk:"router"`
	Unnumbered              basetypes.StringValue `tfsdk:"unnumbered"`
	VlanId                  basetypes.StringValue `tfsdk:"vlan_id"`
	VlanPool                basetypes.StringValue `tfsdk:"vlan_pool"`
	state                   attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 17)

	var val tftypes.Value
	var err error

	attrTypes["arp_timeout"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["bfd"] = basetypes.ObjectType{
		AttrTypes: BfdValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["egress"] = basetypes.ObjectType{
		AttrTypes: EgressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ingress"] = basetypes.ObjectType{
		AttrTypes: IngressValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["ip_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ipv4addresses"] = basetypes.ListType{
		ElemType: Ipv4addressesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv4parameters"] = basetypes.ObjectType{
		AttrTypes: Ipv4parametersValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6addresses"] = basetypes.ListType{
		ElemType: Ipv6addressesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["ipv6router_advertisement"] = basetypes.ObjectType{
		AttrTypes: Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["l3proxy_arpnd"] = basetypes.ObjectType{
		AttrTypes: L3proxyArpndValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["learn_unsolicited"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["router"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["unnumbered"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vlan_pool"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 17)

		val, err = v.ArpTimeout.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["arp_timeout"] = val

		val, err = v.Bfd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["bfd"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Egress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["egress"] = val

		val, err = v.Ingress.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ingress"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.IpMtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_mtu"] = val

		val, err = v.Ipv4addresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4addresses"] = val

		val, err = v.Ipv4parameters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv4parameters"] = val

		val, err = v.Ipv6addresses.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6addresses"] = val

		val, err = v.Ipv6routerAdvertisement.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ipv6router_advertisement"] = val

		val, err = v.L3proxyArpnd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l3proxy_arpnd"] = val

		val, err = v.LearnUnsolicited.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["learn_unsolicited"] = val

		val, err = v.Router.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router"] = val

		val, err = v.Unnumbered.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["unnumbered"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		val, err = v.VlanPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_pool"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var bfd basetypes.ObjectValue

	if v.Bfd.IsNull() {
		bfd = types.ObjectNull(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if v.Bfd.IsUnknown() {
		bfd = types.ObjectUnknown(
			BfdValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Bfd.IsNull() && !v.Bfd.IsUnknown() {
		bfd = types.ObjectValueMust(
			BfdValue{}.AttributeTypes(ctx),
			v.Bfd.Attributes(),
		)
	}

	var egress basetypes.ObjectValue

	if v.Egress.IsNull() {
		egress = types.ObjectNull(
			EgressValue{}.AttributeTypes(ctx),
		)
	}

	if v.Egress.IsUnknown() {
		egress = types.ObjectUnknown(
			EgressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Egress.IsNull() && !v.Egress.IsUnknown() {
		egress = types.ObjectValueMust(
			EgressValue{}.AttributeTypes(ctx),
			v.Egress.Attributes(),
		)
	}

	var ingress basetypes.ObjectValue

	if v.Ingress.IsNull() {
		ingress = types.ObjectNull(
			IngressValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ingress.IsUnknown() {
		ingress = types.ObjectUnknown(
			IngressValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ingress.IsNull() && !v.Ingress.IsUnknown() {
		ingress = types.ObjectValueMust(
			IngressValue{}.AttributeTypes(ctx),
			v.Ingress.Attributes(),
		)
	}

	ipv4addresses := types.ListValueMust(
		Ipv4addressesType{
			basetypes.ObjectType{
				AttrTypes: Ipv4addressesValue{}.AttributeTypes(ctx),
			},
		},
		v.Ipv4addresses.Elements(),
	)

	if v.Ipv4addresses.IsNull() {
		ipv4addresses = types.ListNull(
			Ipv4addressesType{
				basetypes.ObjectType{
					AttrTypes: Ipv4addressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ipv4addresses.IsUnknown() {
		ipv4addresses = types.ListUnknown(
			Ipv4addressesType{
				basetypes.ObjectType{
					AttrTypes: Ipv4addressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var ipv4parameters basetypes.ObjectValue

	if v.Ipv4parameters.IsNull() {
		ipv4parameters = types.ObjectNull(
			Ipv4parametersValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv4parameters.IsUnknown() {
		ipv4parameters = types.ObjectUnknown(
			Ipv4parametersValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv4parameters.IsNull() && !v.Ipv4parameters.IsUnknown() {
		ipv4parameters = types.ObjectValueMust(
			Ipv4parametersValue{}.AttributeTypes(ctx),
			v.Ipv4parameters.Attributes(),
		)
	}

	ipv6addresses := types.ListValueMust(
		Ipv6addressesType{
			basetypes.ObjectType{
				AttrTypes: Ipv6addressesValue{}.AttributeTypes(ctx),
			},
		},
		v.Ipv6addresses.Elements(),
	)

	if v.Ipv6addresses.IsNull() {
		ipv6addresses = types.ListNull(
			Ipv6addressesType{
				basetypes.ObjectType{
					AttrTypes: Ipv6addressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Ipv6addresses.IsUnknown() {
		ipv6addresses = types.ListUnknown(
			Ipv6addressesType{
				basetypes.ObjectType{
					AttrTypes: Ipv6addressesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	var ipv6routerAdvertisement basetypes.ObjectValue

	if v.Ipv6routerAdvertisement.IsNull() {
		ipv6routerAdvertisement = types.ObjectNull(
			Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
		)
	}

	if v.Ipv6routerAdvertisement.IsUnknown() {
		ipv6routerAdvertisement = types.ObjectUnknown(
			Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Ipv6routerAdvertisement.IsNull() && !v.Ipv6routerAdvertisement.IsUnknown() {
		ipv6routerAdvertisement = types.ObjectValueMust(
			Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
			v.Ipv6routerAdvertisement.Attributes(),
		)
	}

	var l3proxyArpnd basetypes.ObjectValue

	if v.L3proxyArpnd.IsNull() {
		l3proxyArpnd = types.ObjectNull(
			L3proxyArpndValue{}.AttributeTypes(ctx),
		)
	}

	if v.L3proxyArpnd.IsUnknown() {
		l3proxyArpnd = types.ObjectUnknown(
			L3proxyArpndValue{}.AttributeTypes(ctx),
		)
	}

	if !v.L3proxyArpnd.IsNull() && !v.L3proxyArpnd.IsUnknown() {
		l3proxyArpnd = types.ObjectValueMust(
			L3proxyArpndValue{}.AttributeTypes(ctx),
			v.L3proxyArpnd.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"arp_timeout": basetypes.Int64Type{},
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"description": basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: EgressValue{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: IngressValue{}.AttributeTypes(ctx),
		},
		"interface": basetypes.StringType{},
		"ip_mtu":    basetypes.Int64Type{},
		"ipv4addresses": basetypes.ListType{
			ElemType: Ipv4addressesValue{}.Type(ctx),
		},
		"ipv4parameters": basetypes.ObjectType{
			AttrTypes: Ipv4parametersValue{}.AttributeTypes(ctx),
		},
		"ipv6addresses": basetypes.ListType{
			ElemType: Ipv6addressesValue{}.Type(ctx),
		},
		"ipv6router_advertisement": basetypes.ObjectType{
			AttrTypes: Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
		},
		"l3proxy_arpnd": basetypes.ObjectType{
			AttrTypes: L3proxyArpndValue{}.AttributeTypes(ctx),
		},
		"learn_unsolicited": basetypes.StringType{},
		"router":            basetypes.StringType{},
		"unnumbered":        basetypes.StringType{},
		"vlan_id":           basetypes.StringType{},
		"vlan_pool":         basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"arp_timeout":              v.ArpTimeout,
			"bfd":                      bfd,
			"description":              v.Description,
			"egress":                   egress,
			"ingress":                  ingress,
			"interface":                v.Interface,
			"ip_mtu":                   v.IpMtu,
			"ipv4addresses":            ipv4addresses,
			"ipv4parameters":           ipv4parameters,
			"ipv6addresses":            ipv6addresses,
			"ipv6router_advertisement": ipv6routerAdvertisement,
			"l3proxy_arpnd":            l3proxyArpnd,
			"learn_unsolicited":        v.LearnUnsolicited,
			"router":                   v.Router,
			"unnumbered":               v.Unnumbered,
			"vlan_id":                  v.VlanId,
			"vlan_pool":                v.VlanPool,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ArpTimeout.Equal(other.ArpTimeout) {
		return false
	}

	if !v.Bfd.Equal(other.Bfd) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Egress.Equal(other.Egress) {
		return false
	}

	if !v.Ingress.Equal(other.Ingress) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.IpMtu.Equal(other.IpMtu) {
		return false
	}

	if !v.Ipv4addresses.Equal(other.Ipv4addresses) {
		return false
	}

	if !v.Ipv4parameters.Equal(other.Ipv4parameters) {
		return false
	}

	if !v.Ipv6addresses.Equal(other.Ipv6addresses) {
		return false
	}

	if !v.Ipv6routerAdvertisement.Equal(other.Ipv6routerAdvertisement) {
		return false
	}

	if !v.L3proxyArpnd.Equal(other.L3proxyArpnd) {
		return false
	}

	if !v.LearnUnsolicited.Equal(other.LearnUnsolicited) {
		return false
	}

	if !v.Router.Equal(other.Router) {
		return false
	}

	if !v.Unnumbered.Equal(other.Unnumbered) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	if !v.VlanPool.Equal(other.VlanPool) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"arp_timeout": basetypes.Int64Type{},
		"bfd": basetypes.ObjectType{
			AttrTypes: BfdValue{}.AttributeTypes(ctx),
		},
		"description": basetypes.StringType{},
		"egress": basetypes.ObjectType{
			AttrTypes: EgressValue{}.AttributeTypes(ctx),
		},
		"ingress": basetypes.ObjectType{
			AttrTypes: IngressValue{}.AttributeTypes(ctx),
		},
		"interface": basetypes.StringType{},
		"ip_mtu":    basetypes.Int64Type{},
		"ipv4addresses": basetypes.ListType{
			ElemType: Ipv4addressesValue{}.Type(ctx),
		},
		"ipv4parameters": basetypes.ObjectType{
			AttrTypes: Ipv4parametersValue{}.AttributeTypes(ctx),
		},
		"ipv6addresses": basetypes.ListType{
			ElemType: Ipv6addressesValue{}.Type(ctx),
		},
		"ipv6router_advertisement": basetypes.ObjectType{
			AttrTypes: Ipv6routerAdvertisementValue{}.AttributeTypes(ctx),
		},
		"l3proxy_arpnd": basetypes.ObjectType{
			AttrTypes: L3proxyArpndValue{}.AttributeTypes(ctx),
		},
		"learn_unsolicited": basetypes.StringType{},
		"router":            basetypes.StringType{},
		"unnumbered":        basetypes.StringType{},
		"vlan_id":           basetypes.StringType{},
		"vlan_pool":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = BfdType{}

type BfdType struct {
	basetypes.ObjectType
}

func (t BfdType) Equal(o attr.Type) bool {
	other, ok := o.(BfdType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t BfdType) String() string {
	return "BfdType"
}

func (t BfdType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return nil, diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return nil, diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return nil, diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return nil, diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return nil, diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return BfdValue{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfdValueNull() BfdValue {
	return BfdValue{
		state: attr.ValueStateNull,
	}
}

func NewBfdValueUnknown() BfdValue {
	return BfdValue{
		state: attr.ValueStateUnknown,
	}
}

func NewBfdValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (BfdValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing BfdValue Attribute Value",
				"While creating a BfdValue value, a missing attribute value was detected. "+
					"A BfdValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid BfdValue Attribute Type",
				"While creating a BfdValue value, an invalid attribute value was detected. "+
					"A BfdValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("BfdValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("BfdValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra BfdValue Attribute Value",
				"While creating a BfdValue value, an extra attribute value was detected. "+
					"A BfdValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra BfdValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	desiredMinTransmitIntAttribute, ok := attributes["desired_min_transmit_int"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`desired_min_transmit_int is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	desiredMinTransmitIntVal, ok := desiredMinTransmitIntAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`desired_min_transmit_int expected to be basetypes.Int64Value, was: %T`, desiredMinTransmitIntAttribute))
	}

	detectionMultiplierAttribute, ok := attributes["detection_multiplier"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`detection_multiplier is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	detectionMultiplierVal, ok := detectionMultiplierAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`detection_multiplier expected to be basetypes.Int64Value, was: %T`, detectionMultiplierAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	minEchoReceiveIntervalAttribute, ok := attributes["min_echo_receive_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_echo_receive_interval is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	minEchoReceiveIntervalVal, ok := minEchoReceiveIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_echo_receive_interval expected to be basetypes.Int64Value, was: %T`, minEchoReceiveIntervalAttribute))
	}

	requiredMinReceiveAttribute, ok := attributes["required_min_receive"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`required_min_receive is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	requiredMinReceiveVal, ok := requiredMinReceiveAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`required_min_receive expected to be basetypes.Int64Value, was: %T`, requiredMinReceiveAttribute))
	}

	ttlAttribute, ok := attributes["ttl"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ttl is missing from object`)

		return NewBfdValueUnknown(), diags
	}

	ttlVal, ok := ttlAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ttl expected to be basetypes.Int64Value, was: %T`, ttlAttribute))
	}

	if diags.HasError() {
		return NewBfdValueUnknown(), diags
	}

	return BfdValue{
		DesiredMinTransmitInt:  desiredMinTransmitIntVal,
		DetectionMultiplier:    detectionMultiplierVal,
		Enabled:                enabledVal,
		MinEchoReceiveInterval: minEchoReceiveIntervalVal,
		RequiredMinReceive:     requiredMinReceiveVal,
		Ttl:                    ttlVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewBfdValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) BfdValue {
	object, diags := NewBfdValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewBfdValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t BfdType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewBfdValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewBfdValueUnknown(), nil
	}

	if in.IsNull() {
		return NewBfdValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewBfdValueMust(BfdValue{}.AttributeTypes(ctx), attributes), nil
}

func (t BfdType) ValueType(ctx context.Context) attr.Value {
	return BfdValue{}
}

var _ basetypes.ObjectValuable = BfdValue{}

type BfdValue struct {
	DesiredMinTransmitInt  basetypes.Int64Value `tfsdk:"desired_min_transmit_int"`
	DetectionMultiplier    basetypes.Int64Value `tfsdk:"detection_multiplier"`
	Enabled                basetypes.BoolValue  `tfsdk:"enabled"`
	MinEchoReceiveInterval basetypes.Int64Value `tfsdk:"min_echo_receive_interval"`
	RequiredMinReceive     basetypes.Int64Value `tfsdk:"required_min_receive"`
	Ttl                    basetypes.Int64Value `tfsdk:"ttl"`
	state                  attr.ValueState
}

func (v BfdValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 6)

	var val tftypes.Value
	var err error

	attrTypes["desired_min_transmit_int"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["detection_multiplier"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["min_echo_receive_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["required_min_receive"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["ttl"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 6)

		val, err = v.DesiredMinTransmitInt.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["desired_min_transmit_int"] = val

		val, err = v.DetectionMultiplier.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["detection_multiplier"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.MinEchoReceiveInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_echo_receive_interval"] = val

		val, err = v.RequiredMinReceive.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["required_min_receive"] = val

		val, err = v.Ttl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ttl"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v BfdValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v BfdValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v BfdValue) String() string {
	return "BfdValue"
}

func (v BfdValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"desired_min_transmit_int":  v.DesiredMinTransmitInt,
			"detection_multiplier":      v.DetectionMultiplier,
			"enabled":                   v.Enabled,
			"min_echo_receive_interval": v.MinEchoReceiveInterval,
			"required_min_receive":      v.RequiredMinReceive,
			"ttl":                       v.Ttl,
		})

	return objVal, diags
}

func (v BfdValue) Equal(o attr.Value) bool {
	other, ok := o.(BfdValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DesiredMinTransmitInt.Equal(other.DesiredMinTransmitInt) {
		return false
	}

	if !v.DetectionMultiplier.Equal(other.DetectionMultiplier) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.MinEchoReceiveInterval.Equal(other.MinEchoReceiveInterval) {
		return false
	}

	if !v.RequiredMinReceive.Equal(other.RequiredMinReceive) {
		return false
	}

	if !v.Ttl.Equal(other.Ttl) {
		return false
	}

	return true
}

func (v BfdValue) Type(ctx context.Context) attr.Type {
	return BfdType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v BfdValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"desired_min_transmit_int":  basetypes.Int64Type{},
		"detection_multiplier":      basetypes.Int64Type{},
		"enabled":                   basetypes.BoolType{},
		"min_echo_receive_interval": basetypes.Int64Type{},
		"required_min_receive":      basetypes.Int64Type{},
		"ttl":                       basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = EgressType{}

type EgressType struct {
	basetypes.ObjectType
}

func (t EgressType) Equal(o attr.Type) bool {
	other, ok := o.(EgressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t EgressType) String() string {
	return "EgressType"
}

func (t EgressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return EgressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgressValueNull() EgressValue {
	return EgressValue{
		state: attr.ValueStateNull,
	}
}

func NewEgressValueUnknown() EgressValue {
	return EgressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewEgressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (EgressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing EgressValue Attribute Value",
				"While creating a EgressValue value, a missing attribute value was detected. "+
					"A EgressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EgressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid EgressValue Attribute Type",
				"While creating a EgressValue value, an invalid attribute value was detected. "+
					"A EgressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("EgressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("EgressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra EgressValue Attribute Value",
				"While creating a EgressValue value, an extra attribute value was detected. "+
					"A EgressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra EgressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewEgressValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewEgressValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewEgressValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewEgressValueUnknown(), diags
	}

	return EgressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewEgressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) EgressValue {
	object, diags := NewEgressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewEgressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t EgressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewEgressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewEgressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewEgressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewEgressValueMust(EgressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t EgressType) ValueType(ctx context.Context) attr.Value {
	return EgressValue{}
}

var _ basetypes.ObjectValuable = EgressValue{}

type EgressValue struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v EgressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v EgressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v EgressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v EgressValue) String() string {
	return "EgressValue"
}

func (v EgressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v EgressValue) Equal(o attr.Value) bool {
	other, ok := o.(EgressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v EgressValue) Type(ctx context.Context) attr.Type {
	return EgressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v EgressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = IngressType{}

type IngressType struct {
	basetypes.ObjectType
}

func (t IngressType) Equal(o attr.Type) bool {
	other, ok := o.(IngressType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IngressType) String() string {
	return "IngressType"
}

func (t IngressType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return nil, diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return nil, diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IngressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngressValueNull() IngressValue {
	return IngressValue{
		state: attr.ValueStateNull,
	}
}

func NewIngressValueUnknown() IngressValue {
	return IngressValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIngressValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IngressValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IngressValue Attribute Value",
				"While creating a IngressValue value, a missing attribute value was detected. "+
					"A IngressValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IngressValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IngressValue Attribute Type",
				"While creating a IngressValue value, an invalid attribute value was detected. "+
					"A IngressValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IngressValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IngressValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IngressValue Attribute Value",
				"While creating a IngressValue value, an extra attribute value was detected. "+
					"A IngressValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IngressValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIngressValueUnknown(), diags
	}

	filtersAttribute, ok := attributes["filters"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`filters is missing from object`)

		return NewIngressValueUnknown(), diags
	}

	filtersVal, ok := filtersAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`filters expected to be basetypes.ListValue, was: %T`, filtersAttribute))
	}

	qosPolicyAttribute, ok := attributes["qos_policy"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`qos_policy is missing from object`)

		return NewIngressValueUnknown(), diags
	}

	qosPolicyVal, ok := qosPolicyAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`qos_policy expected to be basetypes.ListValue, was: %T`, qosPolicyAttribute))
	}

	if diags.HasError() {
		return NewIngressValueUnknown(), diags
	}

	return IngressValue{
		Filters:   filtersVal,
		QosPolicy: qosPolicyVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewIngressValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IngressValue {
	object, diags := NewIngressValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIngressValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IngressType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIngressValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIngressValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIngressValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIngressValueMust(IngressValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IngressType) ValueType(ctx context.Context) attr.Value {
	return IngressValue{}
}

var _ basetypes.ObjectValuable = IngressValue{}

type IngressValue struct {
	Filters   basetypes.ListValue `tfsdk:"filters"`
	QosPolicy basetypes.ListValue `tfsdk:"qos_policy"`
	state     attr.ValueState
}

func (v IngressValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["filters"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["qos_policy"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Filters.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["filters"] = val

		val, err = v.QosPolicy.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["qos_policy"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IngressValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IngressValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IngressValue) String() string {
	return "IngressValue"
}

func (v IngressValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var filtersVal basetypes.ListValue
	switch {
	case v.Filters.IsUnknown():
		filtersVal = types.ListUnknown(types.StringType)
	case v.Filters.IsNull():
		filtersVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		filtersVal, d = types.ListValue(types.StringType, v.Filters.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var qosPolicyVal basetypes.ListValue
	switch {
	case v.QosPolicy.IsUnknown():
		qosPolicyVal = types.ListUnknown(types.StringType)
	case v.QosPolicy.IsNull():
		qosPolicyVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		qosPolicyVal, d = types.ListValue(types.StringType, v.QosPolicy.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"filters": basetypes.ListType{
				ElemType: types.StringType,
			},
			"qos_policy": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"filters":    filtersVal,
			"qos_policy": qosPolicyVal,
		})

	return objVal, diags
}

func (v IngressValue) Equal(o attr.Value) bool {
	other, ok := o.(IngressValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Filters.Equal(other.Filters) {
		return false
	}

	if !v.QosPolicy.Equal(other.QosPolicy) {
		return false
	}

	return true
}

func (v IngressValue) Type(ctx context.Context) attr.Type {
	return IngressType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IngressValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"filters": basetypes.ListType{
			ElemType: types.StringType,
		},
		"qos_policy": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = Ipv4addressesType{}

type Ipv4addressesType struct {
	basetypes.ObjectType
}

func (t Ipv4addressesType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4addressesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4addressesType) String() string {
	return "Ipv4addressesType"
}

func (t Ipv4addressesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return nil, diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4addressesValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv4addressesValueNull() Ipv4addressesValue {
	return Ipv4addressesValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv4addressesValueUnknown() Ipv4addressesValue {
	return Ipv4addressesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4addressesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4addressesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4addressesValue Attribute Value",
				"While creating a Ipv4addressesValue value, a missing attribute value was detected. "+
					"A Ipv4addressesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4addressesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4addressesValue Attribute Type",
				"While creating a Ipv4addressesValue value, an invalid attribute value was detected. "+
					"A Ipv4addressesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4addressesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4addressesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4addressesValue Attribute Value",
				"While creating a Ipv4addressesValue value, an extra attribute value was detected. "+
					"A Ipv4addressesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4addressesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4addressesValueUnknown(), diags
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return NewIpv4addressesValueUnknown(), diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewIpv4addressesValueUnknown(), diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return NewIpv4addressesValueUnknown(), diags
	}

	return Ipv4addressesValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv4addressesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4addressesValue {
	object, diags := NewIpv4addressesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4addressesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4addressesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4addressesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4addressesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4addressesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4addressesValueMust(Ipv4addressesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4addressesType) ValueType(ctx context.Context) attr.Value {
	return Ipv4addressesValue{}
}

var _ basetypes.ObjectValuable = Ipv4addressesValue{}

type Ipv4addressesValue struct {
	IpPrefix basetypes.StringValue `tfsdk:"ip_prefix"`
	Primary  basetypes.BoolValue   `tfsdk:"primary"`
	state    attr.ValueState
}

func (v Ipv4addressesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_prefix"] = val

		val, err = v.Primary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4addressesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4addressesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4addressesValue) String() string {
	return "Ipv4addressesValue"
}

func (v Ipv4addressesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_prefix": v.IpPrefix,
			"primary":   v.Primary,
		})

	return objVal, diags
}

func (v Ipv4addressesValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4addressesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpPrefix.Equal(other.IpPrefix) {
		return false
	}

	if !v.Primary.Equal(other.Primary) {
		return false
	}

	return true
}

func (v Ipv4addressesValue) Type(ctx context.Context) attr.Type {
	return Ipv4addressesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4addressesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ipv4parametersType{}

type Ipv4parametersType struct {
	basetypes.ObjectType
}

func (t Ipv4parametersType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv4parametersType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv4parametersType) String() string {
	return "Ipv4parametersType"
}

func (t Ipv4parametersType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	directedBroadcastAttribute, ok := attributes["directed_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`directed_broadcast is missing from object`)

		return nil, diags
	}

	directedBroadcastVal, ok := directedBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`directed_broadcast expected to be basetypes.BoolValue, was: %T`, directedBroadcastAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv4parametersValue{
		DirectedBroadcast: directedBroadcastVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewIpv4parametersValueNull() Ipv4parametersValue {
	return Ipv4parametersValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv4parametersValueUnknown() Ipv4parametersValue {
	return Ipv4parametersValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv4parametersValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv4parametersValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv4parametersValue Attribute Value",
				"While creating a Ipv4parametersValue value, a missing attribute value was detected. "+
					"A Ipv4parametersValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4parametersValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv4parametersValue Attribute Type",
				"While creating a Ipv4parametersValue value, an invalid attribute value was detected. "+
					"A Ipv4parametersValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv4parametersValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv4parametersValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv4parametersValue Attribute Value",
				"While creating a Ipv4parametersValue value, an extra attribute value was detected. "+
					"A Ipv4parametersValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv4parametersValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv4parametersValueUnknown(), diags
	}

	directedBroadcastAttribute, ok := attributes["directed_broadcast"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`directed_broadcast is missing from object`)

		return NewIpv4parametersValueUnknown(), diags
	}

	directedBroadcastVal, ok := directedBroadcastAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`directed_broadcast expected to be basetypes.BoolValue, was: %T`, directedBroadcastAttribute))
	}

	if diags.HasError() {
		return NewIpv4parametersValueUnknown(), diags
	}

	return Ipv4parametersValue{
		DirectedBroadcast: directedBroadcastVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewIpv4parametersValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv4parametersValue {
	object, diags := NewIpv4parametersValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv4parametersValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv4parametersType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv4parametersValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv4parametersValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv4parametersValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv4parametersValueMust(Ipv4parametersValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv4parametersType) ValueType(ctx context.Context) attr.Value {
	return Ipv4parametersValue{}
}

var _ basetypes.ObjectValuable = Ipv4parametersValue{}

type Ipv4parametersValue struct {
	DirectedBroadcast basetypes.BoolValue `tfsdk:"directed_broadcast"`
	state             attr.ValueState
}

func (v Ipv4parametersValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["directed_broadcast"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.DirectedBroadcast.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["directed_broadcast"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv4parametersValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv4parametersValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv4parametersValue) String() string {
	return "Ipv4parametersValue"
}

func (v Ipv4parametersValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"directed_broadcast": basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"directed_broadcast": v.DirectedBroadcast,
		})

	return objVal, diags
}

func (v Ipv4parametersValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv4parametersValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DirectedBroadcast.Equal(other.DirectedBroadcast) {
		return false
	}

	return true
}

func (v Ipv4parametersValue) Type(ctx context.Context) attr.Type {
	return Ipv4parametersType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv4parametersValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"directed_broadcast": basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ipv6addressesType{}

type Ipv6addressesType struct {
	basetypes.ObjectType
}

func (t Ipv6addressesType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6addressesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6addressesType) String() string {
	return "Ipv6addressesType"
}

func (t Ipv6addressesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return nil, diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return nil, diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6addressesValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv6addressesValueNull() Ipv6addressesValue {
	return Ipv6addressesValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv6addressesValueUnknown() Ipv6addressesValue {
	return Ipv6addressesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6addressesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6addressesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6addressesValue Attribute Value",
				"While creating a Ipv6addressesValue value, a missing attribute value was detected. "+
					"A Ipv6addressesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6addressesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6addressesValue Attribute Type",
				"While creating a Ipv6addressesValue value, an invalid attribute value was detected. "+
					"A Ipv6addressesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6addressesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6addressesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6addressesValue Attribute Value",
				"While creating a Ipv6addressesValue value, an extra attribute value was detected. "+
					"A Ipv6addressesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6addressesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6addressesValueUnknown(), diags
	}

	ipPrefixAttribute, ok := attributes["ip_prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_prefix is missing from object`)

		return NewIpv6addressesValueUnknown(), diags
	}

	ipPrefixVal, ok := ipPrefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_prefix expected to be basetypes.StringValue, was: %T`, ipPrefixAttribute))
	}

	primaryAttribute, ok := attributes["primary"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`primary is missing from object`)

		return NewIpv6addressesValueUnknown(), diags
	}

	primaryVal, ok := primaryAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`primary expected to be basetypes.BoolValue, was: %T`, primaryAttribute))
	}

	if diags.HasError() {
		return NewIpv6addressesValueUnknown(), diags
	}

	return Ipv6addressesValue{
		IpPrefix: ipPrefixVal,
		Primary:  primaryVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewIpv6addressesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6addressesValue {
	object, diags := NewIpv6addressesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6addressesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6addressesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6addressesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6addressesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6addressesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6addressesValueMust(Ipv6addressesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6addressesType) ValueType(ctx context.Context) attr.Value {
	return Ipv6addressesValue{}
}

var _ basetypes.ObjectValuable = Ipv6addressesValue{}

type Ipv6addressesValue struct {
	IpPrefix basetypes.StringValue `tfsdk:"ip_prefix"`
	Primary  basetypes.BoolValue   `tfsdk:"primary"`
	state    attr.ValueState
}

func (v Ipv6addressesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["ip_prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["primary"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.IpPrefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_prefix"] = val

		val, err = v.Primary.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["primary"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6addressesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6addressesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6addressesValue) String() string {
	return "Ipv6addressesValue"
}

func (v Ipv6addressesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"ip_prefix": v.IpPrefix,
			"primary":   v.Primary,
		})

	return objVal, diags
}

func (v Ipv6addressesValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6addressesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.IpPrefix.Equal(other.IpPrefix) {
		return false
	}

	if !v.Primary.Equal(other.Primary) {
		return false
	}

	return true
}

func (v Ipv6addressesValue) Type(ctx context.Context) attr.Type {
	return Ipv6addressesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6addressesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"ip_prefix": basetypes.StringType{},
		"primary":   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = Ipv6routerAdvertisementType{}

type Ipv6routerAdvertisementType struct {
	basetypes.ObjectType
}

func (t Ipv6routerAdvertisementType) Equal(o attr.Type) bool {
	other, ok := o.(Ipv6routerAdvertisementType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t Ipv6routerAdvertisementType) String() string {
	return "Ipv6routerAdvertisementType"
}

func (t Ipv6routerAdvertisementType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	currentHopLimitAttribute, ok := attributes["current_hop_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_hop_limit is missing from object`)

		return nil, diags
	}

	currentHopLimitVal, ok := currentHopLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_hop_limit expected to be basetypes.Int64Value, was: %T`, currentHopLimitAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return nil, diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	managedConfigurationFlagAttribute, ok := attributes["managed_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_configuration_flag is missing from object`)

		return nil, diags
	}

	managedConfigurationFlagVal, ok := managedConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_configuration_flag expected to be basetypes.BoolValue, was: %T`, managedConfigurationFlagAttribute))
	}

	maxAdvertisementIntervalAttribute, ok := attributes["max_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_advertisement_interval is missing from object`)

		return nil, diags
	}

	maxAdvertisementIntervalVal, ok := maxAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_advertisement_interval expected to be basetypes.Int64Value, was: %T`, maxAdvertisementIntervalAttribute))
	}

	minAdvertisementIntervalAttribute, ok := attributes["min_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_advertisement_interval is missing from object`)

		return nil, diags
	}

	minAdvertisementIntervalVal, ok := minAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minAdvertisementIntervalAttribute))
	}

	otherConfigurationFlagAttribute, ok := attributes["other_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_configuration_flag is missing from object`)

		return nil, diags
	}

	otherConfigurationFlagVal, ok := otherConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_configuration_flag expected to be basetypes.BoolValue, was: %T`, otherConfigurationFlagAttribute))
	}

	prefixesAttribute, ok := attributes["prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefixes is missing from object`)

		return nil, diags
	}

	prefixesVal, ok := prefixesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefixes expected to be basetypes.ListValue, was: %T`, prefixesAttribute))
	}

	reachableTimeAttribute, ok := attributes["reachable_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reachable_time is missing from object`)

		return nil, diags
	}

	reachableTimeVal, ok := reachableTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reachable_time expected to be basetypes.Int64Value, was: %T`, reachableTimeAttribute))
	}

	retransmitTimeAttribute, ok := attributes["retransmit_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retransmit_time is missing from object`)

		return nil, diags
	}

	retransmitTimeVal, ok := retransmitTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retransmit_time expected to be basetypes.Int64Value, was: %T`, retransmitTimeAttribute))
	}

	routerLifetimeAttribute, ok := attributes["router_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_lifetime is missing from object`)

		return nil, diags
	}

	routerLifetimeVal, ok := routerLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_lifetime expected to be basetypes.Int64Value, was: %T`, routerLifetimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return Ipv6routerAdvertisementValue{
		CurrentHopLimit:          currentHopLimitVal,
		Enabled:                  enabledVal,
		IpMtu:                    ipMtuVal,
		ManagedConfigurationFlag: managedConfigurationFlagVal,
		MaxAdvertisementInterval: maxAdvertisementIntervalVal,
		MinAdvertisementInterval: minAdvertisementIntervalVal,
		OtherConfigurationFlag:   otherConfigurationFlagVal,
		Prefixes:                 prefixesVal,
		ReachableTime:            reachableTimeVal,
		RetransmitTime:           retransmitTimeVal,
		RouterLifetime:           routerLifetimeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewIpv6routerAdvertisementValueNull() Ipv6routerAdvertisementValue {
	return Ipv6routerAdvertisementValue{
		state: attr.ValueStateNull,
	}
}

func NewIpv6routerAdvertisementValueUnknown() Ipv6routerAdvertisementValue {
	return Ipv6routerAdvertisementValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpv6routerAdvertisementValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (Ipv6routerAdvertisementValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing Ipv6routerAdvertisementValue Attribute Value",
				"While creating a Ipv6routerAdvertisementValue value, a missing attribute value was detected. "+
					"A Ipv6routerAdvertisementValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6routerAdvertisementValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid Ipv6routerAdvertisementValue Attribute Type",
				"While creating a Ipv6routerAdvertisementValue value, an invalid attribute value was detected. "+
					"A Ipv6routerAdvertisementValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Ipv6routerAdvertisementValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("Ipv6routerAdvertisementValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra Ipv6routerAdvertisementValue Attribute Value",
				"While creating a Ipv6routerAdvertisementValue value, an extra attribute value was detected. "+
					"A Ipv6routerAdvertisementValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra Ipv6routerAdvertisementValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	currentHopLimitAttribute, ok := attributes["current_hop_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`current_hop_limit is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	currentHopLimitVal, ok := currentHopLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`current_hop_limit expected to be basetypes.Int64Value, was: %T`, currentHopLimitAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	ipMtuAttribute, ok := attributes["ip_mtu"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_mtu is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	ipMtuVal, ok := ipMtuAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_mtu expected to be basetypes.Int64Value, was: %T`, ipMtuAttribute))
	}

	managedConfigurationFlagAttribute, ok := attributes["managed_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`managed_configuration_flag is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	managedConfigurationFlagVal, ok := managedConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`managed_configuration_flag expected to be basetypes.BoolValue, was: %T`, managedConfigurationFlagAttribute))
	}

	maxAdvertisementIntervalAttribute, ok := attributes["max_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`max_advertisement_interval is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	maxAdvertisementIntervalVal, ok := maxAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`max_advertisement_interval expected to be basetypes.Int64Value, was: %T`, maxAdvertisementIntervalAttribute))
	}

	minAdvertisementIntervalAttribute, ok := attributes["min_advertisement_interval"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`min_advertisement_interval is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	minAdvertisementIntervalVal, ok := minAdvertisementIntervalAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`min_advertisement_interval expected to be basetypes.Int64Value, was: %T`, minAdvertisementIntervalAttribute))
	}

	otherConfigurationFlagAttribute, ok := attributes["other_configuration_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`other_configuration_flag is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	otherConfigurationFlagVal, ok := otherConfigurationFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`other_configuration_flag expected to be basetypes.BoolValue, was: %T`, otherConfigurationFlagAttribute))
	}

	prefixesAttribute, ok := attributes["prefixes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefixes is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	prefixesVal, ok := prefixesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefixes expected to be basetypes.ListValue, was: %T`, prefixesAttribute))
	}

	reachableTimeAttribute, ok := attributes["reachable_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`reachable_time is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	reachableTimeVal, ok := reachableTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`reachable_time expected to be basetypes.Int64Value, was: %T`, reachableTimeAttribute))
	}

	retransmitTimeAttribute, ok := attributes["retransmit_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`retransmit_time is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	retransmitTimeVal, ok := retransmitTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`retransmit_time expected to be basetypes.Int64Value, was: %T`, retransmitTimeAttribute))
	}

	routerLifetimeAttribute, ok := attributes["router_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`router_lifetime is missing from object`)

		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	routerLifetimeVal, ok := routerLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`router_lifetime expected to be basetypes.Int64Value, was: %T`, routerLifetimeAttribute))
	}

	if diags.HasError() {
		return NewIpv6routerAdvertisementValueUnknown(), diags
	}

	return Ipv6routerAdvertisementValue{
		CurrentHopLimit:          currentHopLimitVal,
		Enabled:                  enabledVal,
		IpMtu:                    ipMtuVal,
		ManagedConfigurationFlag: managedConfigurationFlagVal,
		MaxAdvertisementInterval: maxAdvertisementIntervalVal,
		MinAdvertisementInterval: minAdvertisementIntervalVal,
		OtherConfigurationFlag:   otherConfigurationFlagVal,
		Prefixes:                 prefixesVal,
		ReachableTime:            reachableTimeVal,
		RetransmitTime:           retransmitTimeVal,
		RouterLifetime:           routerLifetimeVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewIpv6routerAdvertisementValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) Ipv6routerAdvertisementValue {
	object, diags := NewIpv6routerAdvertisementValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpv6routerAdvertisementValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t Ipv6routerAdvertisementType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpv6routerAdvertisementValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpv6routerAdvertisementValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpv6routerAdvertisementValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpv6routerAdvertisementValueMust(Ipv6routerAdvertisementValue{}.AttributeTypes(ctx), attributes), nil
}

func (t Ipv6routerAdvertisementType) ValueType(ctx context.Context) attr.Value {
	return Ipv6routerAdvertisementValue{}
}

var _ basetypes.ObjectValuable = Ipv6routerAdvertisementValue{}

type Ipv6routerAdvertisementValue struct {
	CurrentHopLimit          basetypes.Int64Value `tfsdk:"current_hop_limit"`
	Enabled                  basetypes.BoolValue  `tfsdk:"enabled"`
	IpMtu                    basetypes.Int64Value `tfsdk:"ip_mtu"`
	ManagedConfigurationFlag basetypes.BoolValue  `tfsdk:"managed_configuration_flag"`
	MaxAdvertisementInterval basetypes.Int64Value `tfsdk:"max_advertisement_interval"`
	MinAdvertisementInterval basetypes.Int64Value `tfsdk:"min_advertisement_interval"`
	OtherConfigurationFlag   basetypes.BoolValue  `tfsdk:"other_configuration_flag"`
	Prefixes                 basetypes.ListValue  `tfsdk:"prefixes"`
	ReachableTime            basetypes.Int64Value `tfsdk:"reachable_time"`
	RetransmitTime           basetypes.Int64Value `tfsdk:"retransmit_time"`
	RouterLifetime           basetypes.Int64Value `tfsdk:"router_lifetime"`
	state                    attr.ValueState
}

func (v Ipv6routerAdvertisementValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["current_hop_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["ip_mtu"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["managed_configuration_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["max_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["min_advertisement_interval"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["other_configuration_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["prefixes"] = basetypes.ListType{
		ElemType: PrefixesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["reachable_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["retransmit_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["router_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.CurrentHopLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["current_hop_limit"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.IpMtu.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_mtu"] = val

		val, err = v.ManagedConfigurationFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["managed_configuration_flag"] = val

		val, err = v.MaxAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["max_advertisement_interval"] = val

		val, err = v.MinAdvertisementInterval.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["min_advertisement_interval"] = val

		val, err = v.OtherConfigurationFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["other_configuration_flag"] = val

		val, err = v.Prefixes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefixes"] = val

		val, err = v.ReachableTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["reachable_time"] = val

		val, err = v.RetransmitTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["retransmit_time"] = val

		val, err = v.RouterLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["router_lifetime"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v Ipv6routerAdvertisementValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v Ipv6routerAdvertisementValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v Ipv6routerAdvertisementValue) String() string {
	return "Ipv6routerAdvertisementValue"
}

func (v Ipv6routerAdvertisementValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	prefixes := types.ListValueMust(
		PrefixesType{
			basetypes.ObjectType{
				AttrTypes: PrefixesValue{}.AttributeTypes(ctx),
			},
		},
		v.Prefixes.Elements(),
	)

	if v.Prefixes.IsNull() {
		prefixes = types.ListNull(
			PrefixesType{
				basetypes.ObjectType{
					AttrTypes: PrefixesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Prefixes.IsUnknown() {
		prefixes = types.ListUnknown(
			PrefixesType{
				basetypes.ObjectType{
					AttrTypes: PrefixesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"current_hop_limit":          basetypes.Int64Type{},
		"enabled":                    basetypes.BoolType{},
		"ip_mtu":                     basetypes.Int64Type{},
		"managed_configuration_flag": basetypes.BoolType{},
		"max_advertisement_interval": basetypes.Int64Type{},
		"min_advertisement_interval": basetypes.Int64Type{},
		"other_configuration_flag":   basetypes.BoolType{},
		"prefixes": basetypes.ListType{
			ElemType: PrefixesValue{}.Type(ctx),
		},
		"reachable_time":  basetypes.Int64Type{},
		"retransmit_time": basetypes.Int64Type{},
		"router_lifetime": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"current_hop_limit":          v.CurrentHopLimit,
			"enabled":                    v.Enabled,
			"ip_mtu":                     v.IpMtu,
			"managed_configuration_flag": v.ManagedConfigurationFlag,
			"max_advertisement_interval": v.MaxAdvertisementInterval,
			"min_advertisement_interval": v.MinAdvertisementInterval,
			"other_configuration_flag":   v.OtherConfigurationFlag,
			"prefixes":                   prefixes,
			"reachable_time":             v.ReachableTime,
			"retransmit_time":            v.RetransmitTime,
			"router_lifetime":            v.RouterLifetime,
		})

	return objVal, diags
}

func (v Ipv6routerAdvertisementValue) Equal(o attr.Value) bool {
	other, ok := o.(Ipv6routerAdvertisementValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CurrentHopLimit.Equal(other.CurrentHopLimit) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.IpMtu.Equal(other.IpMtu) {
		return false
	}

	if !v.ManagedConfigurationFlag.Equal(other.ManagedConfigurationFlag) {
		return false
	}

	if !v.MaxAdvertisementInterval.Equal(other.MaxAdvertisementInterval) {
		return false
	}

	if !v.MinAdvertisementInterval.Equal(other.MinAdvertisementInterval) {
		return false
	}

	if !v.OtherConfigurationFlag.Equal(other.OtherConfigurationFlag) {
		return false
	}

	if !v.Prefixes.Equal(other.Prefixes) {
		return false
	}

	if !v.ReachableTime.Equal(other.ReachableTime) {
		return false
	}

	if !v.RetransmitTime.Equal(other.RetransmitTime) {
		return false
	}

	if !v.RouterLifetime.Equal(other.RouterLifetime) {
		return false
	}

	return true
}

func (v Ipv6routerAdvertisementValue) Type(ctx context.Context) attr.Type {
	return Ipv6routerAdvertisementType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v Ipv6routerAdvertisementValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"current_hop_limit":          basetypes.Int64Type{},
		"enabled":                    basetypes.BoolType{},
		"ip_mtu":                     basetypes.Int64Type{},
		"managed_configuration_flag": basetypes.BoolType{},
		"max_advertisement_interval": basetypes.Int64Type{},
		"min_advertisement_interval": basetypes.Int64Type{},
		"other_configuration_flag":   basetypes.BoolType{},
		"prefixes": basetypes.ListType{
			ElemType: PrefixesValue{}.Type(ctx),
		},
		"reachable_time":  basetypes.Int64Type{},
		"retransmit_time": basetypes.Int64Type{},
		"router_lifetime": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = PrefixesType{}

type PrefixesType struct {
	basetypes.ObjectType
}

func (t PrefixesType) Equal(o attr.Type) bool {
	other, ok := o.(PrefixesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PrefixesType) String() string {
	return "PrefixesType"
}

func (t PrefixesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	autonomousFlagAttribute, ok := attributes["autonomous_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_flag is missing from object`)

		return nil, diags
	}

	autonomousFlagVal, ok := autonomousFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_flag expected to be basetypes.BoolValue, was: %T`, autonomousFlagAttribute))
	}

	onLinkFlagAttribute, ok := attributes["on_link_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_link_flag is missing from object`)

		return nil, diags
	}

	onLinkFlagVal, ok := onLinkFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_link_flag expected to be basetypes.BoolValue, was: %T`, onLinkFlagAttribute))
	}

	preferredLifetimeAttribute, ok := attributes["preferred_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_lifetime is missing from object`)

		return nil, diags
	}

	preferredLifetimeVal, ok := preferredLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_lifetime expected to be basetypes.Int64Value, was: %T`, preferredLifetimeAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return nil, diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	validLifetimeAttribute, ok := attributes["valid_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`valid_lifetime is missing from object`)

		return nil, diags
	}

	validLifetimeVal, ok := validLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`valid_lifetime expected to be basetypes.Int64Value, was: %T`, validLifetimeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PrefixesValue{
		AutonomousFlag:    autonomousFlagVal,
		OnLinkFlag:        onLinkFlagVal,
		PreferredLifetime: preferredLifetimeVal,
		Prefix:            prefixVal,
		ValidLifetime:     validLifetimeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixesValueNull() PrefixesValue {
	return PrefixesValue{
		state: attr.ValueStateNull,
	}
}

func NewPrefixesValueUnknown() PrefixesValue {
	return PrefixesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPrefixesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PrefixesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PrefixesValue Attribute Value",
				"While creating a PrefixesValue value, a missing attribute value was detected. "+
					"A PrefixesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PrefixesValue Attribute Type",
				"While creating a PrefixesValue value, an invalid attribute value was detected. "+
					"A PrefixesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PrefixesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PrefixesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PrefixesValue Attribute Value",
				"While creating a PrefixesValue value, an extra attribute value was detected. "+
					"A PrefixesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PrefixesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPrefixesValueUnknown(), diags
	}

	autonomousFlagAttribute, ok := attributes["autonomous_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`autonomous_flag is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	autonomousFlagVal, ok := autonomousFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`autonomous_flag expected to be basetypes.BoolValue, was: %T`, autonomousFlagAttribute))
	}

	onLinkFlagAttribute, ok := attributes["on_link_flag"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`on_link_flag is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	onLinkFlagVal, ok := onLinkFlagAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`on_link_flag expected to be basetypes.BoolValue, was: %T`, onLinkFlagAttribute))
	}

	preferredLifetimeAttribute, ok := attributes["preferred_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`preferred_lifetime is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	preferredLifetimeVal, ok := preferredLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`preferred_lifetime expected to be basetypes.Int64Value, was: %T`, preferredLifetimeAttribute))
	}

	prefixAttribute, ok := attributes["prefix"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prefix is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	prefixVal, ok := prefixAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prefix expected to be basetypes.StringValue, was: %T`, prefixAttribute))
	}

	validLifetimeAttribute, ok := attributes["valid_lifetime"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`valid_lifetime is missing from object`)

		return NewPrefixesValueUnknown(), diags
	}

	validLifetimeVal, ok := validLifetimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`valid_lifetime expected to be basetypes.Int64Value, was: %T`, validLifetimeAttribute))
	}

	if diags.HasError() {
		return NewPrefixesValueUnknown(), diags
	}

	return PrefixesValue{
		AutonomousFlag:    autonomousFlagVal,
		OnLinkFlag:        onLinkFlagVal,
		PreferredLifetime: preferredLifetimeVal,
		Prefix:            prefixVal,
		ValidLifetime:     validLifetimeVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewPrefixesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PrefixesValue {
	object, diags := NewPrefixesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPrefixesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PrefixesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPrefixesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPrefixesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPrefixesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPrefixesValueMust(PrefixesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PrefixesType) ValueType(ctx context.Context) attr.Value {
	return PrefixesValue{}
}

var _ basetypes.ObjectValuable = PrefixesValue{}

type PrefixesValue struct {
	AutonomousFlag    basetypes.BoolValue   `tfsdk:"autonomous_flag"`
	OnLinkFlag        basetypes.BoolValue   `tfsdk:"on_link_flag"`
	PreferredLifetime basetypes.Int64Value  `tfsdk:"preferred_lifetime"`
	Prefix            basetypes.StringValue `tfsdk:"prefix"`
	ValidLifetime     basetypes.Int64Value  `tfsdk:"valid_lifetime"`
	state             attr.ValueState
}

func (v PrefixesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["autonomous_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["on_link_flag"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["preferred_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["prefix"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["valid_lifetime"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.AutonomousFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["autonomous_flag"] = val

		val, err = v.OnLinkFlag.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["on_link_flag"] = val

		val, err = v.PreferredLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["preferred_lifetime"] = val

		val, err = v.Prefix.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prefix"] = val

		val, err = v.ValidLifetime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["valid_lifetime"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PrefixesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PrefixesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PrefixesValue) String() string {
	return "PrefixesValue"
}

func (v PrefixesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"autonomous_flag":    basetypes.BoolType{},
		"on_link_flag":       basetypes.BoolType{},
		"preferred_lifetime": basetypes.Int64Type{},
		"prefix":             basetypes.StringType{},
		"valid_lifetime":     basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"autonomous_flag":    v.AutonomousFlag,
			"on_link_flag":       v.OnLinkFlag,
			"preferred_lifetime": v.PreferredLifetime,
			"prefix":             v.Prefix,
			"valid_lifetime":     v.ValidLifetime,
		})

	return objVal, diags
}

func (v PrefixesValue) Equal(o attr.Value) bool {
	other, ok := o.(PrefixesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AutonomousFlag.Equal(other.AutonomousFlag) {
		return false
	}

	if !v.OnLinkFlag.Equal(other.OnLinkFlag) {
		return false
	}

	if !v.PreferredLifetime.Equal(other.PreferredLifetime) {
		return false
	}

	if !v.Prefix.Equal(other.Prefix) {
		return false
	}

	if !v.ValidLifetime.Equal(other.ValidLifetime) {
		return false
	}

	return true
}

func (v PrefixesValue) Type(ctx context.Context) attr.Type {
	return PrefixesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PrefixesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"autonomous_flag":    basetypes.BoolType{},
		"on_link_flag":       basetypes.BoolType{},
		"preferred_lifetime": basetypes.Int64Type{},
		"prefix":             basetypes.StringType{},
		"valid_lifetime":     basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = L3proxyArpndType{}

type L3proxyArpndType struct {
	basetypes.ObjectType
}

func (t L3proxyArpndType) Equal(o attr.Type) bool {
	other, ok := o.(L3proxyArpndType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t L3proxyArpndType) String() string {
	return "L3proxyArpndType"
}

func (t L3proxyArpndType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return nil, diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.BoolValue, was: %T`, proxyArpAttribute))
	}

	proxyNdAttribute, ok := attributes["proxy_nd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_nd is missing from object`)

		return nil, diags
	}

	proxyNdVal, ok := proxyNdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_nd expected to be basetypes.BoolValue, was: %T`, proxyNdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return L3proxyArpndValue{
		ProxyArp: proxyArpVal,
		ProxyNd:  proxyNdVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewL3proxyArpndValueNull() L3proxyArpndValue {
	return L3proxyArpndValue{
		state: attr.ValueStateNull,
	}
}

func NewL3proxyArpndValueUnknown() L3proxyArpndValue {
	return L3proxyArpndValue{
		state: attr.ValueStateUnknown,
	}
}

func NewL3proxyArpndValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (L3proxyArpndValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing L3proxyArpndValue Attribute Value",
				"While creating a L3proxyArpndValue value, a missing attribute value was detected. "+
					"A L3proxyArpndValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3proxyArpndValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid L3proxyArpndValue Attribute Type",
				"While creating a L3proxyArpndValue value, an invalid attribute value was detected. "+
					"A L3proxyArpndValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L3proxyArpndValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("L3proxyArpndValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra L3proxyArpndValue Attribute Value",
				"While creating a L3proxyArpndValue value, an extra attribute value was detected. "+
					"A L3proxyArpndValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra L3proxyArpndValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewL3proxyArpndValueUnknown(), diags
	}

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return NewL3proxyArpndValueUnknown(), diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.BoolValue, was: %T`, proxyArpAttribute))
	}

	proxyNdAttribute, ok := attributes["proxy_nd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_nd is missing from object`)

		return NewL3proxyArpndValueUnknown(), diags
	}

	proxyNdVal, ok := proxyNdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_nd expected to be basetypes.BoolValue, was: %T`, proxyNdAttribute))
	}

	if diags.HasError() {
		return NewL3proxyArpndValueUnknown(), diags
	}

	return L3proxyArpndValue{
		ProxyArp: proxyArpVal,
		ProxyNd:  proxyNdVal,
		state:    attr.ValueStateKnown,
	}, diags
}

func NewL3proxyArpndValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) L3proxyArpndValue {
	object, diags := NewL3proxyArpndValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewL3proxyArpndValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t L3proxyArpndType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewL3proxyArpndValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewL3proxyArpndValueUnknown(), nil
	}

	if in.IsNull() {
		return NewL3proxyArpndValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewL3proxyArpndValueMust(L3proxyArpndValue{}.AttributeTypes(ctx), attributes), nil
}

func (t L3proxyArpndType) ValueType(ctx context.Context) attr.Value {
	return L3proxyArpndValue{}
}

var _ basetypes.ObjectValuable = L3proxyArpndValue{}

type L3proxyArpndValue struct {
	ProxyArp basetypes.BoolValue `tfsdk:"proxy_arp"`
	ProxyNd  basetypes.BoolValue `tfsdk:"proxy_nd"`
	state    attr.ValueState
}

func (v L3proxyArpndValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["proxy_arp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["proxy_nd"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.ProxyArp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_arp"] = val

		val, err = v.ProxyNd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_nd"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v L3proxyArpndValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v L3proxyArpndValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v L3proxyArpndValue) String() string {
	return "L3proxyArpndValue"
}

func (v L3proxyArpndValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"proxy_arp": basetypes.BoolType{},
		"proxy_nd":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"proxy_arp": v.ProxyArp,
			"proxy_nd":  v.ProxyNd,
		})

	return objVal, diags
}

func (v L3proxyArpndValue) Equal(o attr.Value) bool {
	other, ok := o.(L3proxyArpndValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ProxyArp.Equal(other.ProxyArp) {
		return false
	}

	if !v.ProxyNd.Equal(other.ProxyNd) {
		return false
	}

	return true
}

func (v L3proxyArpndValue) Type(ctx context.Context) attr.Type {
	return L3proxyArpndType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v L3proxyArpndValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"proxy_arp": basetypes.BoolType{},
		"proxy_nd":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return nil, diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return nil, diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	interfacesAttribute, ok := attributes["interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interfaces is missing from object`)

		return nil, diags
	}

	interfacesVal, ok := interfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interfaces expected to be basetypes.ListValue, was: %T`, interfacesAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		Interfaces:        interfacesVal,
		LastChange:        lastChangeVal,
		OperationalState:  operationalStateVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	interfacesAttribute, ok := attributes["interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	interfacesVal, ok := interfacesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interfaces expected to be basetypes.ListValue, was: %T`, interfacesAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Health:            healthVal,
		HealthScoreReason: healthScoreReasonVal,
		Interfaces:        interfacesVal,
		LastChange:        lastChangeVal,
		OperationalState:  operationalStateVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Health            basetypes.Int64Value  `tfsdk:"health"`
	HealthScoreReason basetypes.StringValue `tfsdk:"health_score_reason"`
	Interfaces        basetypes.ListValue   `tfsdk:"interfaces"`
	LastChange        basetypes.StringValue `tfsdk:"last_change"`
	OperationalState  basetypes.StringValue `tfsdk:"operational_state"`
	state             attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["health"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_score_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interfaces"] = basetypes.ListType{
		ElemType: InterfacesValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Health.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health"] = val

		val, err = v.HealthScoreReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_score_reason"] = val

		val, err = v.Interfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interfaces"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	interfaces := types.ListValueMust(
		InterfacesType{
			basetypes.ObjectType{
				AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
			},
		},
		v.Interfaces.Elements(),
	)

	if v.Interfaces.IsNull() {
		interfaces = types.ListNull(
			InterfacesType{
				basetypes.ObjectType{
					AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Interfaces.IsUnknown() {
		interfaces = types.ListUnknown(
			InterfacesType{
				basetypes.ObjectType{
					AttrTypes: InterfacesValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"interfaces": basetypes.ListType{
			ElemType: InterfacesValue{}.Type(ctx),
		},
		"last_change":       basetypes.StringType{},
		"operational_state": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"health":              v.Health,
			"health_score_reason": v.HealthScoreReason,
			"interfaces":          interfaces,
			"last_change":         v.LastChange,
			"operational_state":   v.OperationalState,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Health.Equal(other.Health) {
		return false
	}

	if !v.HealthScoreReason.Equal(other.HealthScoreReason) {
		return false
	}

	if !v.Interfaces.Equal(other.Interfaces) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"interfaces": basetypes.ListType{
			ElemType: InterfacesValue{}.Type(ctx),
		},
		"last_change":       basetypes.StringType{},
		"operational_state": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InterfacesType{}

type InterfacesType struct {
	basetypes.ObjectType
}

func (t InterfacesType) Equal(o attr.Type) bool {
	other, ok := o.(InterfacesType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InterfacesType) String() string {
	return "InterfacesType"
}

func (t InterfacesType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return nil, diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceResourceAttribute, ok := attributes["interface_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_resource is missing from object`)

		return nil, diags
	}

	interfaceResourceVal, ok := interfaceResourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_resource expected to be basetypes.StringValue, was: %T`, interfaceResourceAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return nil, diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	nodeInterfaceAttribute, ok := attributes["node_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_interface is missing from object`)

		return nil, diags
	}

	nodeInterfaceVal, ok := nodeInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_interface expected to be basetypes.StringValue, was: %T`, nodeInterfaceAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return nil, diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	subInterfaceIndexAttribute, ok := attributes["sub_interface_index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_interface_index is missing from object`)

		return nil, diags
	}

	subInterfaceIndexVal, ok := subInterfaceIndexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_interface_index expected to be basetypes.Int64Value, was: %T`, subInterfaceIndexAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return nil, diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InterfacesValue{
		Enabled:           enabledVal,
		Interface:         interfaceVal,
		InterfaceResource: interfaceResourceVal,
		LastChange:        lastChangeVal,
		Node:              nodeVal,
		NodeInterface:     nodeInterfaceVal,
		OperatingSystem:   operatingSystemVal,
		OperationalState:  operationalStateVal,
		SubInterfaceIndex: subInterfaceIndexVal,
		VlanId:            vlanIdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewInterfacesValueNull() InterfacesValue {
	return InterfacesValue{
		state: attr.ValueStateNull,
	}
}

func NewInterfacesValueUnknown() InterfacesValue {
	return InterfacesValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInterfacesValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InterfacesValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InterfacesValue Attribute Value",
				"While creating a InterfacesValue value, a missing attribute value was detected. "+
					"A InterfacesValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfacesValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InterfacesValue Attribute Type",
				"While creating a InterfacesValue value, an invalid attribute value was detected. "+
					"A InterfacesValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InterfacesValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InterfacesValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InterfacesValue Attribute Value",
				"While creating a InterfacesValue value, an extra attribute value was detected. "+
					"A InterfacesValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InterfacesValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInterfacesValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	interfaceAttribute, ok := attributes["interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	interfaceVal, ok := interfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface expected to be basetypes.StringValue, was: %T`, interfaceAttribute))
	}

	interfaceResourceAttribute, ok := attributes["interface_resource"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`interface_resource is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	interfaceResourceVal, ok := interfaceResourceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`interface_resource expected to be basetypes.StringValue, was: %T`, interfaceResourceAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodeAttribute, ok := attributes["node"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	nodeVal, ok := nodeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node expected to be basetypes.StringValue, was: %T`, nodeAttribute))
	}

	nodeInterfaceAttribute, ok := attributes["node_interface"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`node_interface is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	nodeInterfaceVal, ok := nodeInterfaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`node_interface expected to be basetypes.StringValue, was: %T`, nodeInterfaceAttribute))
	}

	operatingSystemAttribute, ok := attributes["operating_system"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operating_system is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	operatingSystemVal, ok := operatingSystemAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operating_system expected to be basetypes.StringValue, was: %T`, operatingSystemAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	subInterfaceIndexAttribute, ok := attributes["sub_interface_index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`sub_interface_index is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	subInterfaceIndexVal, ok := subInterfaceIndexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`sub_interface_index expected to be basetypes.Int64Value, was: %T`, subInterfaceIndexAttribute))
	}

	vlanIdAttribute, ok := attributes["vlan_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vlan_id is missing from object`)

		return NewInterfacesValueUnknown(), diags
	}

	vlanIdVal, ok := vlanIdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vlan_id expected to be basetypes.StringValue, was: %T`, vlanIdAttribute))
	}

	if diags.HasError() {
		return NewInterfacesValueUnknown(), diags
	}

	return InterfacesValue{
		Enabled:           enabledVal,
		Interface:         interfaceVal,
		InterfaceResource: interfaceResourceVal,
		LastChange:        lastChangeVal,
		Node:              nodeVal,
		NodeInterface:     nodeInterfaceVal,
		OperatingSystem:   operatingSystemVal,
		OperationalState:  operationalStateVal,
		SubInterfaceIndex: subInterfaceIndexVal,
		VlanId:            vlanIdVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewInterfacesValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InterfacesValue {
	object, diags := NewInterfacesValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInterfacesValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InterfacesType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInterfacesValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInterfacesValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInterfacesValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInterfacesValueMust(InterfacesValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InterfacesType) ValueType(ctx context.Context) attr.Value {
	return InterfacesValue{}
}

var _ basetypes.ObjectValuable = InterfacesValue{}

type InterfacesValue struct {
	Enabled           basetypes.BoolValue   `tfsdk:"enabled"`
	Interface         basetypes.StringValue `tfsdk:"interface"`
	InterfaceResource basetypes.StringValue `tfsdk:"interface_resource"`
	LastChange        basetypes.StringValue `tfsdk:"last_change"`
	Node              basetypes.StringValue `tfsdk:"node"`
	NodeInterface     basetypes.StringValue `tfsdk:"node_interface"`
	OperatingSystem   basetypes.StringValue `tfsdk:"operating_system"`
	OperationalState  basetypes.StringValue `tfsdk:"operational_state"`
	SubInterfaceIndex basetypes.Int64Value  `tfsdk:"sub_interface_index"`
	VlanId            basetypes.StringValue `tfsdk:"vlan_id"`
	state             attr.ValueState
}

func (v InterfacesValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 10)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["interface_resource"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["node_interface"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operating_system"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["sub_interface_index"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vlan_id"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 10)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.Interface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface"] = val

		val, err = v.InterfaceResource.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["interface_resource"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.Node.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node"] = val

		val, err = v.NodeInterface.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["node_interface"] = val

		val, err = v.OperatingSystem.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operating_system"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		val, err = v.SubInterfaceIndex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["sub_interface_index"] = val

		val, err = v.VlanId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vlan_id"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InterfacesValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InterfacesValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InterfacesValue) String() string {
	return "InterfacesValue"
}

func (v InterfacesValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":             basetypes.BoolType{},
		"interface":           basetypes.StringType{},
		"interface_resource":  basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"node":                basetypes.StringType{},
		"node_interface":      basetypes.StringType{},
		"operating_system":    basetypes.StringType{},
		"operational_state":   basetypes.StringType{},
		"sub_interface_index": basetypes.Int64Type{},
		"vlan_id":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":             v.Enabled,
			"interface":           v.Interface,
			"interface_resource":  v.InterfaceResource,
			"last_change":         v.LastChange,
			"node":                v.Node,
			"node_interface":      v.NodeInterface,
			"operating_system":    v.OperatingSystem,
			"operational_state":   v.OperationalState,
			"sub_interface_index": v.SubInterfaceIndex,
			"vlan_id":             v.VlanId,
		})

	return objVal, diags
}

func (v InterfacesValue) Equal(o attr.Value) bool {
	other, ok := o.(InterfacesValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.Interface.Equal(other.Interface) {
		return false
	}

	if !v.InterfaceResource.Equal(other.InterfaceResource) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.Node.Equal(other.Node) {
		return false
	}

	if !v.NodeInterface.Equal(other.NodeInterface) {
		return false
	}

	if !v.OperatingSystem.Equal(other.OperatingSystem) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	if !v.SubInterfaceIndex.Equal(other.SubInterfaceIndex) {
		return false
	}

	if !v.VlanId.Equal(other.VlanId) {
		return false
	}

	return true
}

func (v InterfacesValue) Type(ctx context.Context) attr.Type {
	return InterfacesType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InterfacesValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":             basetypes.BoolType{},
		"interface":           basetypes.StringType{},
		"interface_resource":  basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"node":                basetypes.StringType{},
		"node_interface":      basetypes.StringType{},
		"operating_system":    basetypes.StringType{},
		"operational_state":   basetypes.StringType{},
		"sub_interface_index": basetypes.Int64Type{},
		"vlan_id":             basetypes.StringType{},
	}
}
