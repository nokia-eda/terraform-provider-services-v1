// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_bridge_domain_list

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func BridgeDomainListDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"api_version": schema.StringAttribute{
				Computed: true,
			},
			"fields": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
				MarkdownDescription: "a comma-separated list of resource fields to fetch/return.  If unspecified, all fields are fetched.  If empty, only key-fields are fetched.",
			},
			"filter": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "an EQL \"where\" expression that will be used to filter the set of resources returned.",
				MarkdownDescription: "an EQL \"where\" expression that will be used to filter the set of resources returned.",
			},
			"items": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"api_version": schema.StringAttribute{
							Computed: true,
						},
						"kind": schema.StringAttribute{
							Computed: true,
						},
						"metadata": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"annotations": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"labels": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"name": schema.StringAttribute{
									Computed: true,
								},
								"namespace": schema.StringAttribute{
									Computed: true,
								},
							},
							CustomType: MetadataType{
								ObjectType: types.ObjectType{
									AttrTypes: MetadataValue{}.AttributeTypes(ctx),
								},
							},
							Computed: true,
						},
						"spec": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"description": schema.StringAttribute{
									Optional:            true,
									Description:         "The description of the BridgeDomain.",
									MarkdownDescription: "The description of the BridgeDomain.",
								},
								"evi": schema.Int64Attribute{
									Optional:            true,
									Description:         "EVI to use for this BridgeDomain, can be optionally left blank to have it automatically allocated using the EVI Pool.",
									MarkdownDescription: "EVI to use for this BridgeDomain, can be optionally left blank to have it automatically allocated using the EVI Pool.",
								},
								"evi_pool": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to an EVI pool to use for allocations if EVI is left blank.",
									MarkdownDescription: "Reference to an EVI pool to use for allocations if EVI is left blank.",
								},
								"export_target": schema.StringAttribute{
									Optional:            true,
									Description:         "Export route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
									MarkdownDescription: "Export route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
								},
								"import_target": schema.StringAttribute{
									Optional:            true,
									Description:         "Import route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
									MarkdownDescription: "Import route target in 'target:N:N' format, if not specified, the default value taken as \"target:1:<evi>\".",
								},
								"l2proxy_arpnd": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"dynamic_learning": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"age_time": schema.Int64Attribute{
													Optional:            true,
													Description:         "Aging timer value for the proxy entries in seconds. If not set, this indicates that the entries are never flushed.",
													MarkdownDescription: "Aging timer value for the proxy entries in seconds. If not set, this indicates that the entries are never flushed.",
												},
												"enabled": schema.BoolAttribute{
													Optional:            true,
													Description:         "Enables or disables Dynamic Learning.",
													MarkdownDescription: "Enables or disables Dynamic Learning.",
												},
												"send_refresh": schema.Int64Attribute{
													Optional:            true,
													Description:         "The interval determines the frequency at which the system generates three ARP Requests or Neighbor Solicitations with the intent to refresh the proxy entry. The refresh is sent within the age-time window.",
													MarkdownDescription: "The interval determines the frequency at which the system generates three ARP Requests or Neighbor Solicitations with the intent to refresh the proxy entry. The refresh is sent within the age-time window.",
												},
											},
											CustomType: DynamicLearningType{
												ObjectType: types.ObjectType{
													AttrTypes: DynamicLearningValue{}.AttributeTypes(ctx),
												},
											},
											Optional: true,
										},
										"ip_duplication": schema.SingleNestedAttribute{
											Attributes: map[string]schema.Attribute{
												"enabled": schema.BoolAttribute{
													Optional:            true,
													Description:         "Enables or disables IP Duplication.",
													MarkdownDescription: "Enables or disables IP Duplication.",
												},
												"hold_down_time": schema.Int64Attribute{
													Optional:            true,
													Description:         "Time to wait in minutes from the moment an IP is declared duplicate to the time the IP is removed from the proxy ARP/ND table.",
													MarkdownDescription: "Time to wait in minutes from the moment an IP is declared duplicate to the time the IP is removed from the proxy ARP/ND table.",
												},
												"monitoring_window": schema.Int64Attribute{
													Optional:            true,
													Description:         "Monitoring window for detecting duplication on a given IP address in the proxy ARP/ND table.",
													MarkdownDescription: "Monitoring window for detecting duplication on a given IP address in the proxy ARP/ND table.",
												},
												"num_moves": schema.Int64Attribute{
													Optional:            true,
													Description:         "Number of moves in the proxy ARP/ND table that an IP is allowed within the monitoring-window.",
													MarkdownDescription: "Number of moves in the proxy ARP/ND table that an IP is allowed within the monitoring-window.",
												},
											},
											CustomType: IpDuplicationType{
												ObjectType: types.ObjectType{
													AttrTypes: IpDuplicationValue{}.AttributeTypes(ctx),
												},
											},
											Optional: true,
										},
										"proxy_arp": schema.BoolAttribute{
											Optional:            true,
											Description:         "Enables proxy ARP.",
											MarkdownDescription: "Enables proxy ARP.",
										},
										"proxy_nd": schema.BoolAttribute{
											Optional:            true,
											Description:         "Enables proxy ND.",
											MarkdownDescription: "Enables proxy ND.",
										},
										"table_size": schema.Int64Attribute{
											Optional:            true,
											Description:         "Maximum number of entries allowed in the proxy table of the bridge domain.",
											MarkdownDescription: "Maximum number of entries allowed in the proxy table of the bridge domain.",
										},
									},
									CustomType: L2proxyArpndType{
										ObjectType: types.ObjectType{
											AttrTypes: L2proxyArpndValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Enables / Disabled Proxy ARP / Proxy ND.",
									MarkdownDescription: "Enables / Disabled Proxy ARP / Proxy ND.",
								},
								"mac_aging": schema.Int64Attribute{
									Optional:            true,
									Description:         "Configurable aging time for dynamically learned mac addresses.",
									MarkdownDescription: "Configurable aging time for dynamically learned mac addresses.",
								},
								"mac_duplication_detection": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"action": schema.StringAttribute{
											Optional:            true,
											Description:         "Action to take on the subinterface upon detecting at least one mac addresses as duplicate on the subinterface.",
											MarkdownDescription: "Action to take on the subinterface upon detecting at least one mac addresses as duplicate on the subinterface.",
										},
										"enabled": schema.BoolAttribute{
											Optional:            true,
											Description:         "Enables or disables Mac Duplication Detection.",
											MarkdownDescription: "Enables or disables Mac Duplication Detection.",
										},
										"hold_down_time": schema.Int64Attribute{
											Optional:            true,
											Description:         "Time to wait in minutes from the moment a mac is declared duplicate to the mac is flushed from the bridge table.",
											MarkdownDescription: "Time to wait in minutes from the moment a mac is declared duplicate to the mac is flushed from the bridge table.",
										},
										"monitoring_window": schema.Int64Attribute{
											Optional:            true,
											Description:         "Monitoring window in minutes for detecting duplication on a given mac address.",
											MarkdownDescription: "Monitoring window in minutes for detecting duplication on a given mac address.",
										},
										"num_moves": schema.Int64Attribute{
											Optional:            true,
											Description:         "Number of moves a mac is allowed within the monitoring-window, before it is declared duplicate.",
											MarkdownDescription: "Number of moves a mac is allowed within the monitoring-window, before it is declared duplicate.",
										},
									},
									CustomType: MacDuplicationDetectionType{
										ObjectType: types.ObjectType{
											AttrTypes: MacDuplicationDetectionValue{}.AttributeTypes(ctx),
										},
									},
									Optional:            true,
									Description:         "Enable or disable MAC duplication detection and resolution mechanisms.",
									MarkdownDescription: "Enable or disable MAC duplication detection and resolution mechanisms.",
								},
								"mac_learning": schema.BoolAttribute{
									Optional:            true,
									Description:         "Enable MAC learning for this BridgeDomain.",
									MarkdownDescription: "Enable MAC learning for this BridgeDomain.",
								},
								"mac_limit": schema.Int64Attribute{
									Optional:            true,
									Description:         "Sets the maximum number of MAC entries accepted in the bridge table.",
									MarkdownDescription: "Sets the maximum number of MAC entries accepted in the bridge table.",
								},
								"tunnel_index_pool": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to a tunnel index pool to use for allocations.",
									MarkdownDescription: "Reference to a tunnel index pool to use for allocations.",
								},
								"type": schema.StringAttribute{
									Optional:            true,
									Description:         "Select the type of BridgeDomain.  Simple doesn't include any overlay control plane or dataplane properties (EVPN/VXLAN). EVPNVXLAN includes the properties needed to provision this BridgeDomain over an IP Fabric.",
									MarkdownDescription: "Select the type of BridgeDomain.  Simple doesn't include any overlay control plane or dataplane properties (EVPN/VXLAN). EVPNVXLAN includes the properties needed to provision this BridgeDomain over an IP Fabric.",
								},
								"vni": schema.Int64Attribute{
									Optional:            true,
									Description:         "VNI to use for this BridgeDomain, can be optionally left blank to have it allocated using the VNI Pool.",
									MarkdownDescription: "VNI to use for this BridgeDomain, can be optionally left blank to have it allocated using the VNI Pool.",
								},
								"vni_pool": schema.StringAttribute{
									Optional:            true,
									Description:         "Reference to a VNI pool to use for allocations if VNI is left blank.",
									MarkdownDescription: "Reference to a VNI pool to use for allocations if VNI is left blank.",
								},
							},
							CustomType: SpecType{
								ObjectType: types.ObjectType{
									AttrTypes: SpecValue{}.AttributeTypes(ctx),
								},
							},
							Optional:            true,
							Description:         "The BridgeDomain enables the configuration and management of Layer 2 virtual networks. It includes settings for VNI, EVI, route targets for import and export, and tunnel index allocation. Additionally, the specification allows for advanced features such as MAC address table limits, aging, Proxy ARP and detection of MAC and IP duplication.",
							MarkdownDescription: "The BridgeDomain enables the configuration and management of Layer 2 virtual networks. It includes settings for VNI, EVI, route targets for import and export, and tunnel index allocation. Additionally, the specification allows for advanced features such as MAC address table limits, aging, Proxy ARP and detection of MAC and IP duplication.",
						},
						"status": schema.SingleNestedAttribute{
							Attributes: map[string]schema.Attribute{
								"evi": schema.Int64Attribute{
									Computed:            true,
									Description:         "EVI in use for this bridge domain.",
									MarkdownDescription: "EVI in use for this bridge domain.",
								},
								"export_target": schema.StringAttribute{
									Computed:            true,
									Description:         "Export route target for this bridge domain.",
									MarkdownDescription: "Export route target for this bridge domain.",
								},
								"health": schema.Int64Attribute{
									Computed:            true,
									Description:         "Indicates the health score of the VNET.",
									MarkdownDescription: "Indicates the health score of the VNET.",
								},
								"health_score_reason": schema.StringAttribute{
									Computed:            true,
									Description:         "Indicates the reason for the health score.",
									MarkdownDescription: "Indicates the reason for the health score.",
								},
								"import_target": schema.StringAttribute{
									Computed:            true,
									Description:         "Import route target for this bridge domain.",
									MarkdownDescription: "Import route target for this bridge domain.",
								},
								"last_change": schema.StringAttribute{
									Computed:            true,
									Description:         "The time when the state of the resource last changed.",
									MarkdownDescription: "The time when the state of the resource last changed.",
								},
								"nodes": schema.ListAttribute{
									ElementType:         types.StringType,
									Computed:            true,
									Description:         "Nodes which have the BridgeDomain configured (min 1 sub-interface).",
									MarkdownDescription: "Nodes which have the BridgeDomain configured (min 1 sub-interface).",
								},
								"num_nodes": schema.Int64Attribute{
									Computed:            true,
									Description:         "Number of nodes which have the BridgeDomain configured (min 1 sub-interface).",
									MarkdownDescription: "Number of nodes which have the BridgeDomain configured (min 1 sub-interface).",
								},
								"num_sub_interfaces": schema.Int64Attribute{
									Computed:            true,
									Description:         "Number of sub-interfaces attached to the BridgeDomain.",
									MarkdownDescription: "Number of sub-interfaces attached to the BridgeDomain.",
								},
								"num_sub_interfaces_oper_down": schema.Int64Attribute{
									Computed:            true,
									Description:         "Number of oper-down sub-interfaces attached to the BridgeDomain.",
									MarkdownDescription: "Number of oper-down sub-interfaces attached to the BridgeDomain.",
								},
								"operational_state": schema.StringAttribute{
									Computed:            true,
									Description:         "Operational state of the VNET.",
									MarkdownDescription: "Operational state of the VNET.",
								},
								"tunnel_index": schema.Int64Attribute{
									Computed:            true,
									Description:         "Vxlan tunnel index in use.",
									MarkdownDescription: "Vxlan tunnel index in use.",
								},
								"vni": schema.Int64Attribute{
									Computed:            true,
									Description:         "VNI in use for this bridge domain.",
									MarkdownDescription: "VNI in use for this bridge domain.",
								},
							},
							CustomType: StatusType{
								ObjectType: types.ObjectType{
									AttrTypes: StatusValue{}.AttributeTypes(ctx),
								},
							},
							Computed:            true,
							Description:         "BridgeDomainStatus defines the observed state of BridgeDomain",
							MarkdownDescription: "BridgeDomainStatus defines the observed state of BridgeDomain",
						},
					},
					CustomType: ItemsType{
						ObjectType: types.ObjectType{
							AttrTypes: ItemsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Computed: true,
			},
			"kind": schema.StringAttribute{
				Computed: true,
			},
			"labelselector": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "a label selector string to filter the results based on CR labels",
				MarkdownDescription: "a label selector string to filter the results based on CR labels",
			},
			"namespace": schema.StringAttribute{
				Required:            true,
				Description:         "the namespace scope in which to operate",
				MarkdownDescription: "the namespace scope in which to operate",
			},
		},
	}
}

type BridgeDomainListModel struct {
	ApiVersion    types.String `tfsdk:"api_version"`
	Fields        types.String `tfsdk:"fields"`
	Filter        types.String `tfsdk:"filter"`
	Items         types.List   `tfsdk:"items"`
	Kind          types.String `tfsdk:"kind"`
	Labelselector types.String `tfsdk:"labelselector"`
	Namespace     types.String `tfsdk:"namespace"`
}

var _ basetypes.ObjectTypable = ItemsType{}

type ItemsType struct {
	basetypes.ObjectType
}

func (t ItemsType) Equal(o attr.Type) bool {
	other, ok := o.(ItemsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ItemsType) String() string {
	return "ItemsType"
}

func (t ItemsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return nil, diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return nil, diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return nil, diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return nil, diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return nil, diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ItemsValue{
		ApiVersion: apiVersionVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueNull() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateNull,
	}
}

func NewItemsValueUnknown() ItemsValue {
	return ItemsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewItemsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ItemsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ItemsValue Attribute Value",
				"While creating a ItemsValue value, a missing attribute value was detected. "+
					"A ItemsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ItemsValue Attribute Type",
				"While creating a ItemsValue value, an invalid attribute value was detected. "+
					"A ItemsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ItemsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ItemsValue Attribute Value",
				"While creating a ItemsValue value, an extra attribute value was detected. "+
					"A ItemsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ItemsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	apiVersionAttribute, ok := attributes["api_version"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`api_version is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	apiVersionVal, ok := apiVersionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`api_version expected to be basetypes.StringValue, was: %T`, apiVersionAttribute))
	}

	kindAttribute, ok := attributes["kind"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`kind is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	kindVal, ok := kindAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`kind expected to be basetypes.StringValue, was: %T`, kindAttribute))
	}

	metadataAttribute, ok := attributes["metadata"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	metadataVal, ok := metadataAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata expected to be basetypes.ObjectValue, was: %T`, metadataAttribute))
	}

	specAttribute, ok := attributes["spec"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`spec is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	specVal, ok := specAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`spec expected to be basetypes.ObjectValue, was: %T`, specAttribute))
	}

	statusAttribute, ok := attributes["status"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`status is missing from object`)

		return NewItemsValueUnknown(), diags
	}

	statusVal, ok := statusAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`status expected to be basetypes.ObjectValue, was: %T`, statusAttribute))
	}

	if diags.HasError() {
		return NewItemsValueUnknown(), diags
	}

	return ItemsValue{
		ApiVersion: apiVersionVal,
		Kind:       kindVal,
		Metadata:   metadataVal,
		Spec:       specVal,
		Status:     statusVal,
		state:      attr.ValueStateKnown,
	}, diags
}

func NewItemsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ItemsValue {
	object, diags := NewItemsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewItemsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ItemsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewItemsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewItemsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewItemsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewItemsValueMust(ItemsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ItemsType) ValueType(ctx context.Context) attr.Value {
	return ItemsValue{}
}

var _ basetypes.ObjectValuable = ItemsValue{}

type ItemsValue struct {
	ApiVersion basetypes.StringValue `tfsdk:"api_version"`
	Kind       basetypes.StringValue `tfsdk:"kind"`
	Metadata   basetypes.ObjectValue `tfsdk:"metadata"`
	Spec       basetypes.ObjectValue `tfsdk:"spec"`
	Status     basetypes.ObjectValue `tfsdk:"status"`
	state      attr.ValueState
}

func (v ItemsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["api_version"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["kind"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metadata"] = basetypes.ObjectType{
		AttrTypes: MetadataValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["spec"] = basetypes.ObjectType{
		AttrTypes: SpecValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["status"] = basetypes.ObjectType{
		AttrTypes: StatusValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.ApiVersion.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["api_version"] = val

		val, err = v.Kind.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["kind"] = val

		val, err = v.Metadata.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata"] = val

		val, err = v.Spec.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["spec"] = val

		val, err = v.Status.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["status"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ItemsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ItemsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ItemsValue) String() string {
	return "ItemsValue"
}

func (v ItemsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var metadata basetypes.ObjectValue

	if v.Metadata.IsNull() {
		metadata = types.ObjectNull(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if v.Metadata.IsUnknown() {
		metadata = types.ObjectUnknown(
			MetadataValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Metadata.IsNull() && !v.Metadata.IsUnknown() {
		metadata = types.ObjectValueMust(
			MetadataValue{}.AttributeTypes(ctx),
			v.Metadata.Attributes(),
		)
	}

	var spec basetypes.ObjectValue

	if v.Spec.IsNull() {
		spec = types.ObjectNull(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if v.Spec.IsUnknown() {
		spec = types.ObjectUnknown(
			SpecValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Spec.IsNull() && !v.Spec.IsUnknown() {
		spec = types.ObjectValueMust(
			SpecValue{}.AttributeTypes(ctx),
			v.Spec.Attributes(),
		)
	}

	var status basetypes.ObjectValue

	if v.Status.IsNull() {
		status = types.ObjectNull(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if v.Status.IsUnknown() {
		status = types.ObjectUnknown(
			StatusValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Status.IsNull() && !v.Status.IsUnknown() {
		status = types.ObjectValueMust(
			StatusValue{}.AttributeTypes(ctx),
			v.Status.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"api_version": basetypes.StringType{},
		"kind":        basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"api_version": v.ApiVersion,
			"kind":        v.Kind,
			"metadata":    metadata,
			"spec":        spec,
			"status":      status,
		})

	return objVal, diags
}

func (v ItemsValue) Equal(o attr.Value) bool {
	other, ok := o.(ItemsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ApiVersion.Equal(other.ApiVersion) {
		return false
	}

	if !v.Kind.Equal(other.Kind) {
		return false
	}

	if !v.Metadata.Equal(other.Metadata) {
		return false
	}

	if !v.Spec.Equal(other.Spec) {
		return false
	}

	if !v.Status.Equal(other.Status) {
		return false
	}

	return true
}

func (v ItemsValue) Type(ctx context.Context) attr.Type {
	return ItemsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ItemsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"api_version": basetypes.StringType{},
		"kind":        basetypes.StringType{},
		"metadata": basetypes.ObjectType{
			AttrTypes: MetadataValue{}.AttributeTypes(ctx),
		},
		"spec": basetypes.ObjectType{
			AttrTypes: SpecValue{}.AttributeTypes(ctx),
		},
		"status": basetypes.ObjectType{
			AttrTypes: StatusValue{}.AttributeTypes(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = MetadataType{}

type MetadataType struct {
	basetypes.ObjectType
}

func (t MetadataType) Equal(o attr.Type) bool {
	other, ok := o.(MetadataType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetadataType) String() string {
	return "MetadataType"
}

func (t MetadataType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return nil, diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return nil, diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return nil, diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueNull() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateNull,
	}
}

func NewMetadataValueUnknown() MetadataValue {
	return MetadataValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetadataValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetadataValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetadataValue Attribute Value",
				"While creating a MetadataValue value, a missing attribute value was detected. "+
					"A MetadataValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetadataValue Attribute Type",
				"While creating a MetadataValue value, an invalid attribute value was detected. "+
					"A MetadataValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetadataValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetadataValue Attribute Value",
				"While creating a MetadataValue value, an extra attribute value was detected. "+
					"A MetadataValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetadataValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	annotationsAttribute, ok := attributes["annotations"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`annotations is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	annotationsVal, ok := annotationsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`annotations expected to be basetypes.MapValue, was: %T`, annotationsAttribute))
	}

	labelsAttribute, ok := attributes["labels"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`labels is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	labelsVal, ok := labelsAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`labels expected to be basetypes.MapValue, was: %T`, labelsAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	namespaceAttribute, ok := attributes["namespace"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`namespace is missing from object`)

		return NewMetadataValueUnknown(), diags
	}

	namespaceVal, ok := namespaceAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`namespace expected to be basetypes.StringValue, was: %T`, namespaceAttribute))
	}

	if diags.HasError() {
		return NewMetadataValueUnknown(), diags
	}

	return MetadataValue{
		Annotations: annotationsVal,
		Labels:      labelsVal,
		Name:        nameVal,
		Namespace:   namespaceVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewMetadataValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetadataValue {
	object, diags := NewMetadataValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetadataValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetadataType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetadataValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetadataValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetadataValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetadataValueMust(MetadataValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetadataType) ValueType(ctx context.Context) attr.Value {
	return MetadataValue{}
}

var _ basetypes.ObjectValuable = MetadataValue{}

type MetadataValue struct {
	Annotations basetypes.MapValue    `tfsdk:"annotations"`
	Labels      basetypes.MapValue    `tfsdk:"labels"`
	Name        basetypes.StringValue `tfsdk:"name"`
	Namespace   basetypes.StringValue `tfsdk:"namespace"`
	state       attr.ValueState
}

func (v MetadataValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["annotations"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["labels"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["namespace"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Annotations.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["annotations"] = val

		val, err = v.Labels.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["labels"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Namespace.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["namespace"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetadataValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetadataValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetadataValue) String() string {
	return "MetadataValue"
}

func (v MetadataValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var annotationsVal basetypes.MapValue
	switch {
	case v.Annotations.IsUnknown():
		annotationsVal = types.MapUnknown(types.StringType)
	case v.Annotations.IsNull():
		annotationsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		annotationsVal, d = types.MapValue(types.StringType, v.Annotations.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	var labelsVal basetypes.MapValue
	switch {
	case v.Labels.IsUnknown():
		labelsVal = types.MapUnknown(types.StringType)
	case v.Labels.IsNull():
		labelsVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		labelsVal, d = types.MapValue(types.StringType, v.Labels.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"annotations": basetypes.MapType{
				ElemType: types.StringType,
			},
			"labels": basetypes.MapType{
				ElemType: types.StringType,
			},
			"name":      basetypes.StringType{},
			"namespace": basetypes.StringType{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"annotations": annotationsVal,
			"labels":      labelsVal,
			"name":        v.Name,
			"namespace":   v.Namespace,
		})

	return objVal, diags
}

func (v MetadataValue) Equal(o attr.Value) bool {
	other, ok := o.(MetadataValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Annotations.Equal(other.Annotations) {
		return false
	}

	if !v.Labels.Equal(other.Labels) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Namespace.Equal(other.Namespace) {
		return false
	}

	return true
}

func (v MetadataValue) Type(ctx context.Context) attr.Type {
	return MetadataType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetadataValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"annotations": basetypes.MapType{
			ElemType: types.StringType,
		},
		"labels": basetypes.MapType{
			ElemType: types.StringType,
		},
		"name":      basetypes.StringType{},
		"namespace": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = SpecType{}

type SpecType struct {
	basetypes.ObjectType
}

func (t SpecType) Equal(o attr.Type) bool {
	other, ok := o.(SpecType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t SpecType) String() string {
	return "SpecType"
}

func (t SpecType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	eviAttribute, ok := attributes["evi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi is missing from object`)

		return nil, diags
	}

	eviVal, ok := eviAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi expected to be basetypes.Int64Value, was: %T`, eviAttribute))
	}

	eviPoolAttribute, ok := attributes["evi_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi_pool is missing from object`)

		return nil, diags
	}

	eviPoolVal, ok := eviPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi_pool expected to be basetypes.StringValue, was: %T`, eviPoolAttribute))
	}

	exportTargetAttribute, ok := attributes["export_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_target is missing from object`)

		return nil, diags
	}

	exportTargetVal, ok := exportTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_target expected to be basetypes.StringValue, was: %T`, exportTargetAttribute))
	}

	importTargetAttribute, ok := attributes["import_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_target is missing from object`)

		return nil, diags
	}

	importTargetVal, ok := importTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_target expected to be basetypes.StringValue, was: %T`, importTargetAttribute))
	}

	l2proxyArpndAttribute, ok := attributes["l2proxy_arpnd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2proxy_arpnd is missing from object`)

		return nil, diags
	}

	l2proxyArpndVal, ok := l2proxyArpndAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2proxy_arpnd expected to be basetypes.ObjectValue, was: %T`, l2proxyArpndAttribute))
	}

	macAgingAttribute, ok := attributes["mac_aging"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_aging is missing from object`)

		return nil, diags
	}

	macAgingVal, ok := macAgingAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_aging expected to be basetypes.Int64Value, was: %T`, macAgingAttribute))
	}

	macDuplicationDetectionAttribute, ok := attributes["mac_duplication_detection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_duplication_detection is missing from object`)

		return nil, diags
	}

	macDuplicationDetectionVal, ok := macDuplicationDetectionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_duplication_detection expected to be basetypes.ObjectValue, was: %T`, macDuplicationDetectionAttribute))
	}

	macLearningAttribute, ok := attributes["mac_learning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_learning is missing from object`)

		return nil, diags
	}

	macLearningVal, ok := macLearningAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_learning expected to be basetypes.BoolValue, was: %T`, macLearningAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return nil, diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	tunnelIndexPoolAttribute, ok := attributes["tunnel_index_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_index_pool is missing from object`)

		return nil, diags
	}

	tunnelIndexPoolVal, ok := tunnelIndexPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_index_pool expected to be basetypes.StringValue, was: %T`, tunnelIndexPoolAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vniAttribute, ok := attributes["vni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni is missing from object`)

		return nil, diags
	}

	vniVal, ok := vniAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni expected to be basetypes.Int64Value, was: %T`, vniAttribute))
	}

	vniPoolAttribute, ok := attributes["vni_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni_pool is missing from object`)

		return nil, diags
	}

	vniPoolVal, ok := vniPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni_pool expected to be basetypes.StringValue, was: %T`, vniPoolAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return SpecValue{
		Description:             descriptionVal,
		Evi:                     eviVal,
		EviPool:                 eviPoolVal,
		ExportTarget:            exportTargetVal,
		ImportTarget:            importTargetVal,
		L2proxyArpnd:            l2proxyArpndVal,
		MacAging:                macAgingVal,
		MacDuplicationDetection: macDuplicationDetectionVal,
		MacLearning:             macLearningVal,
		MacLimit:                macLimitVal,
		TunnelIndexPool:         tunnelIndexPoolVal,
		SpecType:                typeVal,
		Vni:                     vniVal,
		VniPool:                 vniPoolVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewSpecValueNull() SpecValue {
	return SpecValue{
		state: attr.ValueStateNull,
	}
}

func NewSpecValueUnknown() SpecValue {
	return SpecValue{
		state: attr.ValueStateUnknown,
	}
}

func NewSpecValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (SpecValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing SpecValue Attribute Value",
				"While creating a SpecValue value, a missing attribute value was detected. "+
					"A SpecValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid SpecValue Attribute Type",
				"While creating a SpecValue value, an invalid attribute value was detected. "+
					"A SpecValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("SpecValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("SpecValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra SpecValue Attribute Value",
				"While creating a SpecValue value, an extra attribute value was detected. "+
					"A SpecValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra SpecValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	eviAttribute, ok := attributes["evi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	eviVal, ok := eviAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi expected to be basetypes.Int64Value, was: %T`, eviAttribute))
	}

	eviPoolAttribute, ok := attributes["evi_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi_pool is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	eviPoolVal, ok := eviPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi_pool expected to be basetypes.StringValue, was: %T`, eviPoolAttribute))
	}

	exportTargetAttribute, ok := attributes["export_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_target is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	exportTargetVal, ok := exportTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_target expected to be basetypes.StringValue, was: %T`, exportTargetAttribute))
	}

	importTargetAttribute, ok := attributes["import_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_target is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	importTargetVal, ok := importTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_target expected to be basetypes.StringValue, was: %T`, importTargetAttribute))
	}

	l2proxyArpndAttribute, ok := attributes["l2proxy_arpnd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`l2proxy_arpnd is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	l2proxyArpndVal, ok := l2proxyArpndAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`l2proxy_arpnd expected to be basetypes.ObjectValue, was: %T`, l2proxyArpndAttribute))
	}

	macAgingAttribute, ok := attributes["mac_aging"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_aging is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	macAgingVal, ok := macAgingAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_aging expected to be basetypes.Int64Value, was: %T`, macAgingAttribute))
	}

	macDuplicationDetectionAttribute, ok := attributes["mac_duplication_detection"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_duplication_detection is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	macDuplicationDetectionVal, ok := macDuplicationDetectionAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_duplication_detection expected to be basetypes.ObjectValue, was: %T`, macDuplicationDetectionAttribute))
	}

	macLearningAttribute, ok := attributes["mac_learning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_learning is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	macLearningVal, ok := macLearningAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_learning expected to be basetypes.BoolValue, was: %T`, macLearningAttribute))
	}

	macLimitAttribute, ok := attributes["mac_limit"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`mac_limit is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	macLimitVal, ok := macLimitAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`mac_limit expected to be basetypes.Int64Value, was: %T`, macLimitAttribute))
	}

	tunnelIndexPoolAttribute, ok := attributes["tunnel_index_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_index_pool is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	tunnelIndexPoolVal, ok := tunnelIndexPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_index_pool expected to be basetypes.StringValue, was: %T`, tunnelIndexPoolAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	vniAttribute, ok := attributes["vni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	vniVal, ok := vniAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni expected to be basetypes.Int64Value, was: %T`, vniAttribute))
	}

	vniPoolAttribute, ok := attributes["vni_pool"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni_pool is missing from object`)

		return NewSpecValueUnknown(), diags
	}

	vniPoolVal, ok := vniPoolAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni_pool expected to be basetypes.StringValue, was: %T`, vniPoolAttribute))
	}

	if diags.HasError() {
		return NewSpecValueUnknown(), diags
	}

	return SpecValue{
		Description:             descriptionVal,
		Evi:                     eviVal,
		EviPool:                 eviPoolVal,
		ExportTarget:            exportTargetVal,
		ImportTarget:            importTargetVal,
		L2proxyArpnd:            l2proxyArpndVal,
		MacAging:                macAgingVal,
		MacDuplicationDetection: macDuplicationDetectionVal,
		MacLearning:             macLearningVal,
		MacLimit:                macLimitVal,
		TunnelIndexPool:         tunnelIndexPoolVal,
		SpecType:                typeVal,
		Vni:                     vniVal,
		VniPool:                 vniPoolVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewSpecValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) SpecValue {
	object, diags := NewSpecValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewSpecValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t SpecType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewSpecValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewSpecValueUnknown(), nil
	}

	if in.IsNull() {
		return NewSpecValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewSpecValueMust(SpecValue{}.AttributeTypes(ctx), attributes), nil
}

func (t SpecType) ValueType(ctx context.Context) attr.Value {
	return SpecValue{}
}

var _ basetypes.ObjectValuable = SpecValue{}

type SpecValue struct {
	Description             basetypes.StringValue `tfsdk:"description"`
	Evi                     basetypes.Int64Value  `tfsdk:"evi"`
	EviPool                 basetypes.StringValue `tfsdk:"evi_pool"`
	ExportTarget            basetypes.StringValue `tfsdk:"export_target"`
	ImportTarget            basetypes.StringValue `tfsdk:"import_target"`
	L2proxyArpnd            basetypes.ObjectValue `tfsdk:"l2proxy_arpnd"`
	MacAging                basetypes.Int64Value  `tfsdk:"mac_aging"`
	MacDuplicationDetection basetypes.ObjectValue `tfsdk:"mac_duplication_detection"`
	MacLearning             basetypes.BoolValue   `tfsdk:"mac_learning"`
	MacLimit                basetypes.Int64Value  `tfsdk:"mac_limit"`
	TunnelIndexPool         basetypes.StringValue `tfsdk:"tunnel_index_pool"`
	SpecType                basetypes.StringValue `tfsdk:"type"`
	Vni                     basetypes.Int64Value  `tfsdk:"vni"`
	VniPool                 basetypes.StringValue `tfsdk:"vni_pool"`
	state                   attr.ValueState
}

func (v SpecValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 14)

	var val tftypes.Value
	var err error

	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["evi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["evi_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["export_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["l2proxy_arpnd"] = basetypes.ObjectType{
		AttrTypes: L2proxyArpndValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["mac_aging"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["mac_duplication_detection"] = basetypes.ObjectType{
		AttrTypes: MacDuplicationDetectionValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["mac_learning"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["mac_limit"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["tunnel_index_pool"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["vni"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vni_pool"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 14)

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Evi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evi"] = val

		val, err = v.EviPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evi_pool"] = val

		val, err = v.ExportTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_target"] = val

		val, err = v.ImportTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_target"] = val

		val, err = v.L2proxyArpnd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["l2proxy_arpnd"] = val

		val, err = v.MacAging.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_aging"] = val

		val, err = v.MacDuplicationDetection.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_duplication_detection"] = val

		val, err = v.MacLearning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_learning"] = val

		val, err = v.MacLimit.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["mac_limit"] = val

		val, err = v.TunnelIndexPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tunnel_index_pool"] = val

		val, err = v.SpecType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Vni.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vni"] = val

		val, err = v.VniPool.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vni_pool"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v SpecValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v SpecValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v SpecValue) String() string {
	return "SpecValue"
}

func (v SpecValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var l2proxyArpnd basetypes.ObjectValue

	if v.L2proxyArpnd.IsNull() {
		l2proxyArpnd = types.ObjectNull(
			L2proxyArpndValue{}.AttributeTypes(ctx),
		)
	}

	if v.L2proxyArpnd.IsUnknown() {
		l2proxyArpnd = types.ObjectUnknown(
			L2proxyArpndValue{}.AttributeTypes(ctx),
		)
	}

	if !v.L2proxyArpnd.IsNull() && !v.L2proxyArpnd.IsUnknown() {
		l2proxyArpnd = types.ObjectValueMust(
			L2proxyArpndValue{}.AttributeTypes(ctx),
			v.L2proxyArpnd.Attributes(),
		)
	}

	var macDuplicationDetection basetypes.ObjectValue

	if v.MacDuplicationDetection.IsNull() {
		macDuplicationDetection = types.ObjectNull(
			MacDuplicationDetectionValue{}.AttributeTypes(ctx),
		)
	}

	if v.MacDuplicationDetection.IsUnknown() {
		macDuplicationDetection = types.ObjectUnknown(
			MacDuplicationDetectionValue{}.AttributeTypes(ctx),
		)
	}

	if !v.MacDuplicationDetection.IsNull() && !v.MacDuplicationDetection.IsUnknown() {
		macDuplicationDetection = types.ObjectValueMust(
			MacDuplicationDetectionValue{}.AttributeTypes(ctx),
			v.MacDuplicationDetection.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"description":   basetypes.StringType{},
		"evi":           basetypes.Int64Type{},
		"evi_pool":      basetypes.StringType{},
		"export_target": basetypes.StringType{},
		"import_target": basetypes.StringType{},
		"l2proxy_arpnd": basetypes.ObjectType{
			AttrTypes: L2proxyArpndValue{}.AttributeTypes(ctx),
		},
		"mac_aging": basetypes.Int64Type{},
		"mac_duplication_detection": basetypes.ObjectType{
			AttrTypes: MacDuplicationDetectionValue{}.AttributeTypes(ctx),
		},
		"mac_learning":      basetypes.BoolType{},
		"mac_limit":         basetypes.Int64Type{},
		"tunnel_index_pool": basetypes.StringType{},
		"type":              basetypes.StringType{},
		"vni":               basetypes.Int64Type{},
		"vni_pool":          basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"description":               v.Description,
			"evi":                       v.Evi,
			"evi_pool":                  v.EviPool,
			"export_target":             v.ExportTarget,
			"import_target":             v.ImportTarget,
			"l2proxy_arpnd":             l2proxyArpnd,
			"mac_aging":                 v.MacAging,
			"mac_duplication_detection": macDuplicationDetection,
			"mac_learning":              v.MacLearning,
			"mac_limit":                 v.MacLimit,
			"tunnel_index_pool":         v.TunnelIndexPool,
			"type":                      v.SpecType,
			"vni":                       v.Vni,
			"vni_pool":                  v.VniPool,
		})

	return objVal, diags
}

func (v SpecValue) Equal(o attr.Value) bool {
	other, ok := o.(SpecValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Evi.Equal(other.Evi) {
		return false
	}

	if !v.EviPool.Equal(other.EviPool) {
		return false
	}

	if !v.ExportTarget.Equal(other.ExportTarget) {
		return false
	}

	if !v.ImportTarget.Equal(other.ImportTarget) {
		return false
	}

	if !v.L2proxyArpnd.Equal(other.L2proxyArpnd) {
		return false
	}

	if !v.MacAging.Equal(other.MacAging) {
		return false
	}

	if !v.MacDuplicationDetection.Equal(other.MacDuplicationDetection) {
		return false
	}

	if !v.MacLearning.Equal(other.MacLearning) {
		return false
	}

	if !v.MacLimit.Equal(other.MacLimit) {
		return false
	}

	if !v.TunnelIndexPool.Equal(other.TunnelIndexPool) {
		return false
	}

	if !v.SpecType.Equal(other.SpecType) {
		return false
	}

	if !v.Vni.Equal(other.Vni) {
		return false
	}

	if !v.VniPool.Equal(other.VniPool) {
		return false
	}

	return true
}

func (v SpecValue) Type(ctx context.Context) attr.Type {
	return SpecType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v SpecValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"description":   basetypes.StringType{},
		"evi":           basetypes.Int64Type{},
		"evi_pool":      basetypes.StringType{},
		"export_target": basetypes.StringType{},
		"import_target": basetypes.StringType{},
		"l2proxy_arpnd": basetypes.ObjectType{
			AttrTypes: L2proxyArpndValue{}.AttributeTypes(ctx),
		},
		"mac_aging": basetypes.Int64Type{},
		"mac_duplication_detection": basetypes.ObjectType{
			AttrTypes: MacDuplicationDetectionValue{}.AttributeTypes(ctx),
		},
		"mac_learning":      basetypes.BoolType{},
		"mac_limit":         basetypes.Int64Type{},
		"tunnel_index_pool": basetypes.StringType{},
		"type":              basetypes.StringType{},
		"vni":               basetypes.Int64Type{},
		"vni_pool":          basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = L2proxyArpndType{}

type L2proxyArpndType struct {
	basetypes.ObjectType
}

func (t L2proxyArpndType) Equal(o attr.Type) bool {
	other, ok := o.(L2proxyArpndType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t L2proxyArpndType) String() string {
	return "L2proxyArpndType"
}

func (t L2proxyArpndType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	dynamicLearningAttribute, ok := attributes["dynamic_learning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_learning is missing from object`)

		return nil, diags
	}

	dynamicLearningVal, ok := dynamicLearningAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_learning expected to be basetypes.ObjectValue, was: %T`, dynamicLearningAttribute))
	}

	ipDuplicationAttribute, ok := attributes["ip_duplication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_duplication is missing from object`)

		return nil, diags
	}

	ipDuplicationVal, ok := ipDuplicationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_duplication expected to be basetypes.ObjectValue, was: %T`, ipDuplicationAttribute))
	}

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return nil, diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.BoolValue, was: %T`, proxyArpAttribute))
	}

	proxyNdAttribute, ok := attributes["proxy_nd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_nd is missing from object`)

		return nil, diags
	}

	proxyNdVal, ok := proxyNdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_nd expected to be basetypes.BoolValue, was: %T`, proxyNdAttribute))
	}

	tableSizeAttribute, ok := attributes["table_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_size is missing from object`)

		return nil, diags
	}

	tableSizeVal, ok := tableSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_size expected to be basetypes.Int64Value, was: %T`, tableSizeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return L2proxyArpndValue{
		DynamicLearning: dynamicLearningVal,
		IpDuplication:   ipDuplicationVal,
		ProxyArp:        proxyArpVal,
		ProxyNd:         proxyNdVal,
		TableSize:       tableSizeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewL2proxyArpndValueNull() L2proxyArpndValue {
	return L2proxyArpndValue{
		state: attr.ValueStateNull,
	}
}

func NewL2proxyArpndValueUnknown() L2proxyArpndValue {
	return L2proxyArpndValue{
		state: attr.ValueStateUnknown,
	}
}

func NewL2proxyArpndValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (L2proxyArpndValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing L2proxyArpndValue Attribute Value",
				"While creating a L2proxyArpndValue value, a missing attribute value was detected. "+
					"A L2proxyArpndValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L2proxyArpndValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid L2proxyArpndValue Attribute Type",
				"While creating a L2proxyArpndValue value, an invalid attribute value was detected. "+
					"A L2proxyArpndValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("L2proxyArpndValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("L2proxyArpndValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra L2proxyArpndValue Attribute Value",
				"While creating a L2proxyArpndValue value, an extra attribute value was detected. "+
					"A L2proxyArpndValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra L2proxyArpndValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewL2proxyArpndValueUnknown(), diags
	}

	dynamicLearningAttribute, ok := attributes["dynamic_learning"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`dynamic_learning is missing from object`)

		return NewL2proxyArpndValueUnknown(), diags
	}

	dynamicLearningVal, ok := dynamicLearningAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`dynamic_learning expected to be basetypes.ObjectValue, was: %T`, dynamicLearningAttribute))
	}

	ipDuplicationAttribute, ok := attributes["ip_duplication"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`ip_duplication is missing from object`)

		return NewL2proxyArpndValueUnknown(), diags
	}

	ipDuplicationVal, ok := ipDuplicationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`ip_duplication expected to be basetypes.ObjectValue, was: %T`, ipDuplicationAttribute))
	}

	proxyArpAttribute, ok := attributes["proxy_arp"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_arp is missing from object`)

		return NewL2proxyArpndValueUnknown(), diags
	}

	proxyArpVal, ok := proxyArpAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_arp expected to be basetypes.BoolValue, was: %T`, proxyArpAttribute))
	}

	proxyNdAttribute, ok := attributes["proxy_nd"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`proxy_nd is missing from object`)

		return NewL2proxyArpndValueUnknown(), diags
	}

	proxyNdVal, ok := proxyNdAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`proxy_nd expected to be basetypes.BoolValue, was: %T`, proxyNdAttribute))
	}

	tableSizeAttribute, ok := attributes["table_size"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`table_size is missing from object`)

		return NewL2proxyArpndValueUnknown(), diags
	}

	tableSizeVal, ok := tableSizeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`table_size expected to be basetypes.Int64Value, was: %T`, tableSizeAttribute))
	}

	if diags.HasError() {
		return NewL2proxyArpndValueUnknown(), diags
	}

	return L2proxyArpndValue{
		DynamicLearning: dynamicLearningVal,
		IpDuplication:   ipDuplicationVal,
		ProxyArp:        proxyArpVal,
		ProxyNd:         proxyNdVal,
		TableSize:       tableSizeVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewL2proxyArpndValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) L2proxyArpndValue {
	object, diags := NewL2proxyArpndValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewL2proxyArpndValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t L2proxyArpndType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewL2proxyArpndValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewL2proxyArpndValueUnknown(), nil
	}

	if in.IsNull() {
		return NewL2proxyArpndValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewL2proxyArpndValueMust(L2proxyArpndValue{}.AttributeTypes(ctx), attributes), nil
}

func (t L2proxyArpndType) ValueType(ctx context.Context) attr.Value {
	return L2proxyArpndValue{}
}

var _ basetypes.ObjectValuable = L2proxyArpndValue{}

type L2proxyArpndValue struct {
	DynamicLearning basetypes.ObjectValue `tfsdk:"dynamic_learning"`
	IpDuplication   basetypes.ObjectValue `tfsdk:"ip_duplication"`
	ProxyArp        basetypes.BoolValue   `tfsdk:"proxy_arp"`
	ProxyNd         basetypes.BoolValue   `tfsdk:"proxy_nd"`
	TableSize       basetypes.Int64Value  `tfsdk:"table_size"`
	state           attr.ValueState
}

func (v L2proxyArpndValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["dynamic_learning"] = basetypes.ObjectType{
		AttrTypes: DynamicLearningValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["ip_duplication"] = basetypes.ObjectType{
		AttrTypes: IpDuplicationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["proxy_arp"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["proxy_nd"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["table_size"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.DynamicLearning.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["dynamic_learning"] = val

		val, err = v.IpDuplication.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["ip_duplication"] = val

		val, err = v.ProxyArp.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_arp"] = val

		val, err = v.ProxyNd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["proxy_nd"] = val

		val, err = v.TableSize.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["table_size"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v L2proxyArpndValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v L2proxyArpndValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v L2proxyArpndValue) String() string {
	return "L2proxyArpndValue"
}

func (v L2proxyArpndValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var dynamicLearning basetypes.ObjectValue

	if v.DynamicLearning.IsNull() {
		dynamicLearning = types.ObjectNull(
			DynamicLearningValue{}.AttributeTypes(ctx),
		)
	}

	if v.DynamicLearning.IsUnknown() {
		dynamicLearning = types.ObjectUnknown(
			DynamicLearningValue{}.AttributeTypes(ctx),
		)
	}

	if !v.DynamicLearning.IsNull() && !v.DynamicLearning.IsUnknown() {
		dynamicLearning = types.ObjectValueMust(
			DynamicLearningValue{}.AttributeTypes(ctx),
			v.DynamicLearning.Attributes(),
		)
	}

	var ipDuplication basetypes.ObjectValue

	if v.IpDuplication.IsNull() {
		ipDuplication = types.ObjectNull(
			IpDuplicationValue{}.AttributeTypes(ctx),
		)
	}

	if v.IpDuplication.IsUnknown() {
		ipDuplication = types.ObjectUnknown(
			IpDuplicationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.IpDuplication.IsNull() && !v.IpDuplication.IsUnknown() {
		ipDuplication = types.ObjectValueMust(
			IpDuplicationValue{}.AttributeTypes(ctx),
			v.IpDuplication.Attributes(),
		)
	}

	attributeTypes := map[string]attr.Type{
		"dynamic_learning": basetypes.ObjectType{
			AttrTypes: DynamicLearningValue{}.AttributeTypes(ctx),
		},
		"ip_duplication": basetypes.ObjectType{
			AttrTypes: IpDuplicationValue{}.AttributeTypes(ctx),
		},
		"proxy_arp":  basetypes.BoolType{},
		"proxy_nd":   basetypes.BoolType{},
		"table_size": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"dynamic_learning": dynamicLearning,
			"ip_duplication":   ipDuplication,
			"proxy_arp":        v.ProxyArp,
			"proxy_nd":         v.ProxyNd,
			"table_size":       v.TableSize,
		})

	return objVal, diags
}

func (v L2proxyArpndValue) Equal(o attr.Value) bool {
	other, ok := o.(L2proxyArpndValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.DynamicLearning.Equal(other.DynamicLearning) {
		return false
	}

	if !v.IpDuplication.Equal(other.IpDuplication) {
		return false
	}

	if !v.ProxyArp.Equal(other.ProxyArp) {
		return false
	}

	if !v.ProxyNd.Equal(other.ProxyNd) {
		return false
	}

	if !v.TableSize.Equal(other.TableSize) {
		return false
	}

	return true
}

func (v L2proxyArpndValue) Type(ctx context.Context) attr.Type {
	return L2proxyArpndType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v L2proxyArpndValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"dynamic_learning": basetypes.ObjectType{
			AttrTypes: DynamicLearningValue{}.AttributeTypes(ctx),
		},
		"ip_duplication": basetypes.ObjectType{
			AttrTypes: IpDuplicationValue{}.AttributeTypes(ctx),
		},
		"proxy_arp":  basetypes.BoolType{},
		"proxy_nd":   basetypes.BoolType{},
		"table_size": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = DynamicLearningType{}

type DynamicLearningType struct {
	basetypes.ObjectType
}

func (t DynamicLearningType) Equal(o attr.Type) bool {
	other, ok := o.(DynamicLearningType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DynamicLearningType) String() string {
	return "DynamicLearningType"
}

func (t DynamicLearningType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	ageTimeAttribute, ok := attributes["age_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`age_time is missing from object`)

		return nil, diags
	}

	ageTimeVal, ok := ageTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`age_time expected to be basetypes.Int64Value, was: %T`, ageTimeAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	sendRefreshAttribute, ok := attributes["send_refresh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_refresh is missing from object`)

		return nil, diags
	}

	sendRefreshVal, ok := sendRefreshAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_refresh expected to be basetypes.Int64Value, was: %T`, sendRefreshAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DynamicLearningValue{
		AgeTime:     ageTimeVal,
		Enabled:     enabledVal,
		SendRefresh: sendRefreshVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDynamicLearningValueNull() DynamicLearningValue {
	return DynamicLearningValue{
		state: attr.ValueStateNull,
	}
}

func NewDynamicLearningValueUnknown() DynamicLearningValue {
	return DynamicLearningValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDynamicLearningValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DynamicLearningValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DynamicLearningValue Attribute Value",
				"While creating a DynamicLearningValue value, a missing attribute value was detected. "+
					"A DynamicLearningValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicLearningValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DynamicLearningValue Attribute Type",
				"While creating a DynamicLearningValue value, an invalid attribute value was detected. "+
					"A DynamicLearningValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DynamicLearningValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DynamicLearningValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DynamicLearningValue Attribute Value",
				"While creating a DynamicLearningValue value, an extra attribute value was detected. "+
					"A DynamicLearningValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DynamicLearningValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDynamicLearningValueUnknown(), diags
	}

	ageTimeAttribute, ok := attributes["age_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`age_time is missing from object`)

		return NewDynamicLearningValueUnknown(), diags
	}

	ageTimeVal, ok := ageTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`age_time expected to be basetypes.Int64Value, was: %T`, ageTimeAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewDynamicLearningValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	sendRefreshAttribute, ok := attributes["send_refresh"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`send_refresh is missing from object`)

		return NewDynamicLearningValueUnknown(), diags
	}

	sendRefreshVal, ok := sendRefreshAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`send_refresh expected to be basetypes.Int64Value, was: %T`, sendRefreshAttribute))
	}

	if diags.HasError() {
		return NewDynamicLearningValueUnknown(), diags
	}

	return DynamicLearningValue{
		AgeTime:     ageTimeVal,
		Enabled:     enabledVal,
		SendRefresh: sendRefreshVal,
		state:       attr.ValueStateKnown,
	}, diags
}

func NewDynamicLearningValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DynamicLearningValue {
	object, diags := NewDynamicLearningValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDynamicLearningValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DynamicLearningType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDynamicLearningValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDynamicLearningValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDynamicLearningValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDynamicLearningValueMust(DynamicLearningValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DynamicLearningType) ValueType(ctx context.Context) attr.Value {
	return DynamicLearningValue{}
}

var _ basetypes.ObjectValuable = DynamicLearningValue{}

type DynamicLearningValue struct {
	AgeTime     basetypes.Int64Value `tfsdk:"age_time"`
	Enabled     basetypes.BoolValue  `tfsdk:"enabled"`
	SendRefresh basetypes.Int64Value `tfsdk:"send_refresh"`
	state       attr.ValueState
}

func (v DynamicLearningValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["age_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["send_refresh"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AgeTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["age_time"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.SendRefresh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["send_refresh"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DynamicLearningValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DynamicLearningValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DynamicLearningValue) String() string {
	return "DynamicLearningValue"
}

func (v DynamicLearningValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"age_time":     basetypes.Int64Type{},
		"enabled":      basetypes.BoolType{},
		"send_refresh": basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"age_time":     v.AgeTime,
			"enabled":      v.Enabled,
			"send_refresh": v.SendRefresh,
		})

	return objVal, diags
}

func (v DynamicLearningValue) Equal(o attr.Value) bool {
	other, ok := o.(DynamicLearningValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AgeTime.Equal(other.AgeTime) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.SendRefresh.Equal(other.SendRefresh) {
		return false
	}

	return true
}

func (v DynamicLearningValue) Type(ctx context.Context) attr.Type {
	return DynamicLearningType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DynamicLearningValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"age_time":     basetypes.Int64Type{},
		"enabled":      basetypes.BoolType{},
		"send_refresh": basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = IpDuplicationType{}

type IpDuplicationType struct {
	basetypes.ObjectType
}

func (t IpDuplicationType) Equal(o attr.Type) bool {
	other, ok := o.(IpDuplicationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t IpDuplicationType) String() string {
	return "IpDuplicationType"
}

func (t IpDuplicationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	holdDownTimeAttribute, ok := attributes["hold_down_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_down_time is missing from object`)

		return nil, diags
	}

	holdDownTimeVal, ok := holdDownTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_down_time expected to be basetypes.Int64Value, was: %T`, holdDownTimeAttribute))
	}

	monitoringWindowAttribute, ok := attributes["monitoring_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_window is missing from object`)

		return nil, diags
	}

	monitoringWindowVal, ok := monitoringWindowAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_window expected to be basetypes.Int64Value, was: %T`, monitoringWindowAttribute))
	}

	numMovesAttribute, ok := attributes["num_moves"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_moves is missing from object`)

		return nil, diags
	}

	numMovesVal, ok := numMovesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_moves expected to be basetypes.Int64Value, was: %T`, numMovesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return IpDuplicationValue{
		Enabled:          enabledVal,
		HoldDownTime:     holdDownTimeVal,
		MonitoringWindow: monitoringWindowVal,
		NumMoves:         numMovesVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewIpDuplicationValueNull() IpDuplicationValue {
	return IpDuplicationValue{
		state: attr.ValueStateNull,
	}
}

func NewIpDuplicationValueUnknown() IpDuplicationValue {
	return IpDuplicationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewIpDuplicationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (IpDuplicationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing IpDuplicationValue Attribute Value",
				"While creating a IpDuplicationValue value, a missing attribute value was detected. "+
					"A IpDuplicationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpDuplicationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid IpDuplicationValue Attribute Type",
				"While creating a IpDuplicationValue value, an invalid attribute value was detected. "+
					"A IpDuplicationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("IpDuplicationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("IpDuplicationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra IpDuplicationValue Attribute Value",
				"While creating a IpDuplicationValue value, an extra attribute value was detected. "+
					"A IpDuplicationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra IpDuplicationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewIpDuplicationValueUnknown(), diags
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewIpDuplicationValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	holdDownTimeAttribute, ok := attributes["hold_down_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_down_time is missing from object`)

		return NewIpDuplicationValueUnknown(), diags
	}

	holdDownTimeVal, ok := holdDownTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_down_time expected to be basetypes.Int64Value, was: %T`, holdDownTimeAttribute))
	}

	monitoringWindowAttribute, ok := attributes["monitoring_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_window is missing from object`)

		return NewIpDuplicationValueUnknown(), diags
	}

	monitoringWindowVal, ok := monitoringWindowAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_window expected to be basetypes.Int64Value, was: %T`, monitoringWindowAttribute))
	}

	numMovesAttribute, ok := attributes["num_moves"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_moves is missing from object`)

		return NewIpDuplicationValueUnknown(), diags
	}

	numMovesVal, ok := numMovesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_moves expected to be basetypes.Int64Value, was: %T`, numMovesAttribute))
	}

	if diags.HasError() {
		return NewIpDuplicationValueUnknown(), diags
	}

	return IpDuplicationValue{
		Enabled:          enabledVal,
		HoldDownTime:     holdDownTimeVal,
		MonitoringWindow: monitoringWindowVal,
		NumMoves:         numMovesVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewIpDuplicationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) IpDuplicationValue {
	object, diags := NewIpDuplicationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewIpDuplicationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t IpDuplicationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewIpDuplicationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewIpDuplicationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewIpDuplicationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewIpDuplicationValueMust(IpDuplicationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t IpDuplicationType) ValueType(ctx context.Context) attr.Value {
	return IpDuplicationValue{}
}

var _ basetypes.ObjectValuable = IpDuplicationValue{}

type IpDuplicationValue struct {
	Enabled          basetypes.BoolValue  `tfsdk:"enabled"`
	HoldDownTime     basetypes.Int64Value `tfsdk:"hold_down_time"`
	MonitoringWindow basetypes.Int64Value `tfsdk:"monitoring_window"`
	NumMoves         basetypes.Int64Value `tfsdk:"num_moves"`
	state            attr.ValueState
}

func (v IpDuplicationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hold_down_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["monitoring_window"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_moves"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.HoldDownTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_down_time"] = val

		val, err = v.MonitoringWindow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monitoring_window"] = val

		val, err = v.NumMoves.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_moves"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v IpDuplicationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v IpDuplicationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v IpDuplicationValue) String() string {
	return "IpDuplicationValue"
}

func (v IpDuplicationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"enabled":           basetypes.BoolType{},
		"hold_down_time":    basetypes.Int64Type{},
		"monitoring_window": basetypes.Int64Type{},
		"num_moves":         basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"enabled":           v.Enabled,
			"hold_down_time":    v.HoldDownTime,
			"monitoring_window": v.MonitoringWindow,
			"num_moves":         v.NumMoves,
		})

	return objVal, diags
}

func (v IpDuplicationValue) Equal(o attr.Value) bool {
	other, ok := o.(IpDuplicationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.HoldDownTime.Equal(other.HoldDownTime) {
		return false
	}

	if !v.MonitoringWindow.Equal(other.MonitoringWindow) {
		return false
	}

	if !v.NumMoves.Equal(other.NumMoves) {
		return false
	}

	return true
}

func (v IpDuplicationValue) Type(ctx context.Context) attr.Type {
	return IpDuplicationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v IpDuplicationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"enabled":           basetypes.BoolType{},
		"hold_down_time":    basetypes.Int64Type{},
		"monitoring_window": basetypes.Int64Type{},
		"num_moves":         basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = MacDuplicationDetectionType{}

type MacDuplicationDetectionType struct {
	basetypes.ObjectType
}

func (t MacDuplicationDetectionType) Equal(o attr.Type) bool {
	other, ok := o.(MacDuplicationDetectionType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MacDuplicationDetectionType) String() string {
	return "MacDuplicationDetectionType"
}

func (t MacDuplicationDetectionType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return nil, diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return nil, diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	holdDownTimeAttribute, ok := attributes["hold_down_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_down_time is missing from object`)

		return nil, diags
	}

	holdDownTimeVal, ok := holdDownTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_down_time expected to be basetypes.Int64Value, was: %T`, holdDownTimeAttribute))
	}

	monitoringWindowAttribute, ok := attributes["monitoring_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_window is missing from object`)

		return nil, diags
	}

	monitoringWindowVal, ok := monitoringWindowAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_window expected to be basetypes.Int64Value, was: %T`, monitoringWindowAttribute))
	}

	numMovesAttribute, ok := attributes["num_moves"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_moves is missing from object`)

		return nil, diags
	}

	numMovesVal, ok := numMovesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_moves expected to be basetypes.Int64Value, was: %T`, numMovesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MacDuplicationDetectionValue{
		Action:           actionVal,
		Enabled:          enabledVal,
		HoldDownTime:     holdDownTimeVal,
		MonitoringWindow: monitoringWindowVal,
		NumMoves:         numMovesVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMacDuplicationDetectionValueNull() MacDuplicationDetectionValue {
	return MacDuplicationDetectionValue{
		state: attr.ValueStateNull,
	}
}

func NewMacDuplicationDetectionValueUnknown() MacDuplicationDetectionValue {
	return MacDuplicationDetectionValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMacDuplicationDetectionValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MacDuplicationDetectionValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MacDuplicationDetectionValue Attribute Value",
				"While creating a MacDuplicationDetectionValue value, a missing attribute value was detected. "+
					"A MacDuplicationDetectionValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MacDuplicationDetectionValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MacDuplicationDetectionValue Attribute Type",
				"While creating a MacDuplicationDetectionValue value, an invalid attribute value was detected. "+
					"A MacDuplicationDetectionValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MacDuplicationDetectionValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MacDuplicationDetectionValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MacDuplicationDetectionValue Attribute Value",
				"While creating a MacDuplicationDetectionValue value, an extra attribute value was detected. "+
					"A MacDuplicationDetectionValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MacDuplicationDetectionValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	actionAttribute, ok := attributes["action"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`action is missing from object`)

		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	actionVal, ok := actionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`action expected to be basetypes.StringValue, was: %T`, actionAttribute))
	}

	enabledAttribute, ok := attributes["enabled"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enabled is missing from object`)

		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	enabledVal, ok := enabledAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enabled expected to be basetypes.BoolValue, was: %T`, enabledAttribute))
	}

	holdDownTimeAttribute, ok := attributes["hold_down_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`hold_down_time is missing from object`)

		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	holdDownTimeVal, ok := holdDownTimeAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`hold_down_time expected to be basetypes.Int64Value, was: %T`, holdDownTimeAttribute))
	}

	monitoringWindowAttribute, ok := attributes["monitoring_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`monitoring_window is missing from object`)

		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	monitoringWindowVal, ok := monitoringWindowAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`monitoring_window expected to be basetypes.Int64Value, was: %T`, monitoringWindowAttribute))
	}

	numMovesAttribute, ok := attributes["num_moves"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_moves is missing from object`)

		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	numMovesVal, ok := numMovesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_moves expected to be basetypes.Int64Value, was: %T`, numMovesAttribute))
	}

	if diags.HasError() {
		return NewMacDuplicationDetectionValueUnknown(), diags
	}

	return MacDuplicationDetectionValue{
		Action:           actionVal,
		Enabled:          enabledVal,
		HoldDownTime:     holdDownTimeVal,
		MonitoringWindow: monitoringWindowVal,
		NumMoves:         numMovesVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMacDuplicationDetectionValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MacDuplicationDetectionValue {
	object, diags := NewMacDuplicationDetectionValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMacDuplicationDetectionValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MacDuplicationDetectionType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMacDuplicationDetectionValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMacDuplicationDetectionValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMacDuplicationDetectionValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMacDuplicationDetectionValueMust(MacDuplicationDetectionValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MacDuplicationDetectionType) ValueType(ctx context.Context) attr.Value {
	return MacDuplicationDetectionValue{}
}

var _ basetypes.ObjectValuable = MacDuplicationDetectionValue{}

type MacDuplicationDetectionValue struct {
	Action           basetypes.StringValue `tfsdk:"action"`
	Enabled          basetypes.BoolValue   `tfsdk:"enabled"`
	HoldDownTime     basetypes.Int64Value  `tfsdk:"hold_down_time"`
	MonitoringWindow basetypes.Int64Value  `tfsdk:"monitoring_window"`
	NumMoves         basetypes.Int64Value  `tfsdk:"num_moves"`
	state            attr.ValueState
}

func (v MacDuplicationDetectionValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["action"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["enabled"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["hold_down_time"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["monitoring_window"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_moves"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Action.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["action"] = val

		val, err = v.Enabled.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enabled"] = val

		val, err = v.HoldDownTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["hold_down_time"] = val

		val, err = v.MonitoringWindow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["monitoring_window"] = val

		val, err = v.NumMoves.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_moves"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MacDuplicationDetectionValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MacDuplicationDetectionValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MacDuplicationDetectionValue) String() string {
	return "MacDuplicationDetectionValue"
}

func (v MacDuplicationDetectionValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"action":            basetypes.StringType{},
		"enabled":           basetypes.BoolType{},
		"hold_down_time":    basetypes.Int64Type{},
		"monitoring_window": basetypes.Int64Type{},
		"num_moves":         basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"action":            v.Action,
			"enabled":           v.Enabled,
			"hold_down_time":    v.HoldDownTime,
			"monitoring_window": v.MonitoringWindow,
			"num_moves":         v.NumMoves,
		})

	return objVal, diags
}

func (v MacDuplicationDetectionValue) Equal(o attr.Value) bool {
	other, ok := o.(MacDuplicationDetectionValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Action.Equal(other.Action) {
		return false
	}

	if !v.Enabled.Equal(other.Enabled) {
		return false
	}

	if !v.HoldDownTime.Equal(other.HoldDownTime) {
		return false
	}

	if !v.MonitoringWindow.Equal(other.MonitoringWindow) {
		return false
	}

	if !v.NumMoves.Equal(other.NumMoves) {
		return false
	}

	return true
}

func (v MacDuplicationDetectionValue) Type(ctx context.Context) attr.Type {
	return MacDuplicationDetectionType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MacDuplicationDetectionValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"action":            basetypes.StringType{},
		"enabled":           basetypes.BoolType{},
		"hold_down_time":    basetypes.Int64Type{},
		"monitoring_window": basetypes.Int64Type{},
		"num_moves":         basetypes.Int64Type{},
	}
}

var _ basetypes.ObjectTypable = StatusType{}

type StatusType struct {
	basetypes.ObjectType
}

func (t StatusType) Equal(o attr.Type) bool {
	other, ok := o.(StatusType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t StatusType) String() string {
	return "StatusType"
}

func (t StatusType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	eviAttribute, ok := attributes["evi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi is missing from object`)

		return nil, diags
	}

	eviVal, ok := eviAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi expected to be basetypes.Int64Value, was: %T`, eviAttribute))
	}

	exportTargetAttribute, ok := attributes["export_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_target is missing from object`)

		return nil, diags
	}

	exportTargetVal, ok := exportTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_target expected to be basetypes.StringValue, was: %T`, exportTargetAttribute))
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return nil, diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return nil, diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	importTargetAttribute, ok := attributes["import_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_target is missing from object`)

		return nil, diags
	}

	importTargetVal, ok := importTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_target expected to be basetypes.StringValue, was: %T`, importTargetAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return nil, diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return nil, diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	numNodesAttribute, ok := attributes["num_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_nodes is missing from object`)

		return nil, diags
	}

	numNodesVal, ok := numNodesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_nodes expected to be basetypes.Int64Value, was: %T`, numNodesAttribute))
	}

	numSubInterfacesAttribute, ok := attributes["num_sub_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_sub_interfaces is missing from object`)

		return nil, diags
	}

	numSubInterfacesVal, ok := numSubInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_sub_interfaces expected to be basetypes.Int64Value, was: %T`, numSubInterfacesAttribute))
	}

	numSubInterfacesOperDownAttribute, ok := attributes["num_sub_interfaces_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_sub_interfaces_oper_down is missing from object`)

		return nil, diags
	}

	numSubInterfacesOperDownVal, ok := numSubInterfacesOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_sub_interfaces_oper_down expected to be basetypes.Int64Value, was: %T`, numSubInterfacesOperDownAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return nil, diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	tunnelIndexAttribute, ok := attributes["tunnel_index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_index is missing from object`)

		return nil, diags
	}

	tunnelIndexVal, ok := tunnelIndexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_index expected to be basetypes.Int64Value, was: %T`, tunnelIndexAttribute))
	}

	vniAttribute, ok := attributes["vni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni is missing from object`)

		return nil, diags
	}

	vniVal, ok := vniAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni expected to be basetypes.Int64Value, was: %T`, vniAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return StatusValue{
		Evi:                      eviVal,
		ExportTarget:             exportTargetVal,
		Health:                   healthVal,
		HealthScoreReason:        healthScoreReasonVal,
		ImportTarget:             importTargetVal,
		LastChange:               lastChangeVal,
		Nodes:                    nodesVal,
		NumNodes:                 numNodesVal,
		NumSubInterfaces:         numSubInterfacesVal,
		NumSubInterfacesOperDown: numSubInterfacesOperDownVal,
		OperationalState:         operationalStateVal,
		TunnelIndex:              tunnelIndexVal,
		Vni:                      vniVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewStatusValueNull() StatusValue {
	return StatusValue{
		state: attr.ValueStateNull,
	}
}

func NewStatusValueUnknown() StatusValue {
	return StatusValue{
		state: attr.ValueStateUnknown,
	}
}

func NewStatusValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (StatusValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing StatusValue Attribute Value",
				"While creating a StatusValue value, a missing attribute value was detected. "+
					"A StatusValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid StatusValue Attribute Type",
				"While creating a StatusValue value, an invalid attribute value was detected. "+
					"A StatusValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("StatusValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("StatusValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra StatusValue Attribute Value",
				"While creating a StatusValue value, an extra attribute value was detected. "+
					"A StatusValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra StatusValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	eviAttribute, ok := attributes["evi"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`evi is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	eviVal, ok := eviAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`evi expected to be basetypes.Int64Value, was: %T`, eviAttribute))
	}

	exportTargetAttribute, ok := attributes["export_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`export_target is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	exportTargetVal, ok := exportTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`export_target expected to be basetypes.StringValue, was: %T`, exportTargetAttribute))
	}

	healthAttribute, ok := attributes["health"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthVal, ok := healthAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health expected to be basetypes.Int64Value, was: %T`, healthAttribute))
	}

	healthScoreReasonAttribute, ok := attributes["health_score_reason"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`health_score_reason is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	healthScoreReasonVal, ok := healthScoreReasonAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`health_score_reason expected to be basetypes.StringValue, was: %T`, healthScoreReasonAttribute))
	}

	importTargetAttribute, ok := attributes["import_target"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`import_target is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	importTargetVal, ok := importTargetAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`import_target expected to be basetypes.StringValue, was: %T`, importTargetAttribute))
	}

	lastChangeAttribute, ok := attributes["last_change"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_change is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	lastChangeVal, ok := lastChangeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_change expected to be basetypes.StringValue, was: %T`, lastChangeAttribute))
	}

	nodesAttribute, ok := attributes["nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`nodes is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	nodesVal, ok := nodesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`nodes expected to be basetypes.ListValue, was: %T`, nodesAttribute))
	}

	numNodesAttribute, ok := attributes["num_nodes"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_nodes is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numNodesVal, ok := numNodesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_nodes expected to be basetypes.Int64Value, was: %T`, numNodesAttribute))
	}

	numSubInterfacesAttribute, ok := attributes["num_sub_interfaces"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_sub_interfaces is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numSubInterfacesVal, ok := numSubInterfacesAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_sub_interfaces expected to be basetypes.Int64Value, was: %T`, numSubInterfacesAttribute))
	}

	numSubInterfacesOperDownAttribute, ok := attributes["num_sub_interfaces_oper_down"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`num_sub_interfaces_oper_down is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	numSubInterfacesOperDownVal, ok := numSubInterfacesOperDownAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`num_sub_interfaces_oper_down expected to be basetypes.Int64Value, was: %T`, numSubInterfacesOperDownAttribute))
	}

	operationalStateAttribute, ok := attributes["operational_state"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`operational_state is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	operationalStateVal, ok := operationalStateAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`operational_state expected to be basetypes.StringValue, was: %T`, operationalStateAttribute))
	}

	tunnelIndexAttribute, ok := attributes["tunnel_index"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`tunnel_index is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	tunnelIndexVal, ok := tunnelIndexAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`tunnel_index expected to be basetypes.Int64Value, was: %T`, tunnelIndexAttribute))
	}

	vniAttribute, ok := attributes["vni"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`vni is missing from object`)

		return NewStatusValueUnknown(), diags
	}

	vniVal, ok := vniAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`vni expected to be basetypes.Int64Value, was: %T`, vniAttribute))
	}

	if diags.HasError() {
		return NewStatusValueUnknown(), diags
	}

	return StatusValue{
		Evi:                      eviVal,
		ExportTarget:             exportTargetVal,
		Health:                   healthVal,
		HealthScoreReason:        healthScoreReasonVal,
		ImportTarget:             importTargetVal,
		LastChange:               lastChangeVal,
		Nodes:                    nodesVal,
		NumNodes:                 numNodesVal,
		NumSubInterfaces:         numSubInterfacesVal,
		NumSubInterfacesOperDown: numSubInterfacesOperDownVal,
		OperationalState:         operationalStateVal,
		TunnelIndex:              tunnelIndexVal,
		Vni:                      vniVal,
		state:                    attr.ValueStateKnown,
	}, diags
}

func NewStatusValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) StatusValue {
	object, diags := NewStatusValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewStatusValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t StatusType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewStatusValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewStatusValueUnknown(), nil
	}

	if in.IsNull() {
		return NewStatusValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewStatusValueMust(StatusValue{}.AttributeTypes(ctx), attributes), nil
}

func (t StatusType) ValueType(ctx context.Context) attr.Value {
	return StatusValue{}
}

var _ basetypes.ObjectValuable = StatusValue{}

type StatusValue struct {
	Evi                      basetypes.Int64Value  `tfsdk:"evi"`
	ExportTarget             basetypes.StringValue `tfsdk:"export_target"`
	Health                   basetypes.Int64Value  `tfsdk:"health"`
	HealthScoreReason        basetypes.StringValue `tfsdk:"health_score_reason"`
	ImportTarget             basetypes.StringValue `tfsdk:"import_target"`
	LastChange               basetypes.StringValue `tfsdk:"last_change"`
	Nodes                    basetypes.ListValue   `tfsdk:"nodes"`
	NumNodes                 basetypes.Int64Value  `tfsdk:"num_nodes"`
	NumSubInterfaces         basetypes.Int64Value  `tfsdk:"num_sub_interfaces"`
	NumSubInterfacesOperDown basetypes.Int64Value  `tfsdk:"num_sub_interfaces_oper_down"`
	OperationalState         basetypes.StringValue `tfsdk:"operational_state"`
	TunnelIndex              basetypes.Int64Value  `tfsdk:"tunnel_index"`
	Vni                      basetypes.Int64Value  `tfsdk:"vni"`
	state                    attr.ValueState
}

func (v StatusValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 13)

	var val tftypes.Value
	var err error

	attrTypes["evi"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["export_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["health"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["health_score_reason"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["import_target"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_change"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["nodes"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["num_nodes"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_sub_interfaces"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["num_sub_interfaces_oper_down"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["operational_state"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["tunnel_index"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["vni"] = basetypes.Int64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 13)

		val, err = v.Evi.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["evi"] = val

		val, err = v.ExportTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["export_target"] = val

		val, err = v.Health.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health"] = val

		val, err = v.HealthScoreReason.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["health_score_reason"] = val

		val, err = v.ImportTarget.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["import_target"] = val

		val, err = v.LastChange.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_change"] = val

		val, err = v.Nodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["nodes"] = val

		val, err = v.NumNodes.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_nodes"] = val

		val, err = v.NumSubInterfaces.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_sub_interfaces"] = val

		val, err = v.NumSubInterfacesOperDown.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["num_sub_interfaces_oper_down"] = val

		val, err = v.OperationalState.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["operational_state"] = val

		val, err = v.TunnelIndex.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["tunnel_index"] = val

		val, err = v.Vni.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["vni"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v StatusValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v StatusValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v StatusValue) String() string {
	return "StatusValue"
}

func (v StatusValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var nodesVal basetypes.ListValue
	switch {
	case v.Nodes.IsUnknown():
		nodesVal = types.ListUnknown(types.StringType)
	case v.Nodes.IsNull():
		nodesVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		nodesVal, d = types.ListValue(types.StringType, v.Nodes.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"evi":                 basetypes.Int64Type{},
			"export_target":       basetypes.StringType{},
			"health":              basetypes.Int64Type{},
			"health_score_reason": basetypes.StringType{},
			"import_target":       basetypes.StringType{},
			"last_change":         basetypes.StringType{},
			"nodes": basetypes.ListType{
				ElemType: types.StringType,
			},
			"num_nodes":                    basetypes.Int64Type{},
			"num_sub_interfaces":           basetypes.Int64Type{},
			"num_sub_interfaces_oper_down": basetypes.Int64Type{},
			"operational_state":            basetypes.StringType{},
			"tunnel_index":                 basetypes.Int64Type{},
			"vni":                          basetypes.Int64Type{},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"evi":                 basetypes.Int64Type{},
		"export_target":       basetypes.StringType{},
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"import_target":       basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"num_nodes":                    basetypes.Int64Type{},
		"num_sub_interfaces":           basetypes.Int64Type{},
		"num_sub_interfaces_oper_down": basetypes.Int64Type{},
		"operational_state":            basetypes.StringType{},
		"tunnel_index":                 basetypes.Int64Type{},
		"vni":                          basetypes.Int64Type{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"evi":                          v.Evi,
			"export_target":                v.ExportTarget,
			"health":                       v.Health,
			"health_score_reason":          v.HealthScoreReason,
			"import_target":                v.ImportTarget,
			"last_change":                  v.LastChange,
			"nodes":                        nodesVal,
			"num_nodes":                    v.NumNodes,
			"num_sub_interfaces":           v.NumSubInterfaces,
			"num_sub_interfaces_oper_down": v.NumSubInterfacesOperDown,
			"operational_state":            v.OperationalState,
			"tunnel_index":                 v.TunnelIndex,
			"vni":                          v.Vni,
		})

	return objVal, diags
}

func (v StatusValue) Equal(o attr.Value) bool {
	other, ok := o.(StatusValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Evi.Equal(other.Evi) {
		return false
	}

	if !v.ExportTarget.Equal(other.ExportTarget) {
		return false
	}

	if !v.Health.Equal(other.Health) {
		return false
	}

	if !v.HealthScoreReason.Equal(other.HealthScoreReason) {
		return false
	}

	if !v.ImportTarget.Equal(other.ImportTarget) {
		return false
	}

	if !v.LastChange.Equal(other.LastChange) {
		return false
	}

	if !v.Nodes.Equal(other.Nodes) {
		return false
	}

	if !v.NumNodes.Equal(other.NumNodes) {
		return false
	}

	if !v.NumSubInterfaces.Equal(other.NumSubInterfaces) {
		return false
	}

	if !v.NumSubInterfacesOperDown.Equal(other.NumSubInterfacesOperDown) {
		return false
	}

	if !v.OperationalState.Equal(other.OperationalState) {
		return false
	}

	if !v.TunnelIndex.Equal(other.TunnelIndex) {
		return false
	}

	if !v.Vni.Equal(other.Vni) {
		return false
	}

	return true
}

func (v StatusValue) Type(ctx context.Context) attr.Type {
	return StatusType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v StatusValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"evi":                 basetypes.Int64Type{},
		"export_target":       basetypes.StringType{},
		"health":              basetypes.Int64Type{},
		"health_score_reason": basetypes.StringType{},
		"import_target":       basetypes.StringType{},
		"last_change":         basetypes.StringType{},
		"nodes": basetypes.ListType{
			ElemType: types.StringType,
		},
		"num_nodes":                    basetypes.Int64Type{},
		"num_sub_interfaces":           basetypes.Int64Type{},
		"num_sub_interfaces_oper_down": basetypes.Int64Type{},
		"operational_state":            basetypes.StringType{},
		"tunnel_index":                 basetypes.Int64Type{},
		"vni":                          basetypes.Int64Type{},
	}
}
